RFCトランス
個人情報保護方針
連絡先
イチジク
@ tex2e
https://tools.ietf.org/html/draft-ietf-rtcweb-rtp-usage-26
draft-ietf-rtcweb-rtp-usage-26-Webリアルタイム通信（WebRTC）：メディアトランスポートとRTPの使用
URL：https://tools.ietf.org/html/rfchttps://tools.ietf.org/html/draft-ietf-rtcweb-rtp-usage-26
タイトル：draft-ietf-rtcweb-rtp-usage-26-Web Real-Time Communication（WebRTC）：Media Transport and Use of RTP
翻訳編集：自動生成
RTCWEBワーキンググループC.パーキンス
グラスゴー大学インターネットドラフト
対象ステータス：Standards Track M. Westerlund
有効期限：2016年9月18日エリクソン
                                                                  J.オット
                                                        アールト大学
                                                          2016年3月17日
        
Web Real-Time Communication（WebRTC）：Media Transport and Use of RTP draft-ietf-rtcweb-rtp-usage-26

概要

Webリアルタイム通信（WebRTC）フレームワークは、2つのピアのWebブラウザー間でオーディオ、ビデオ、テキスト、コラボレーション、ゲームなどを使用した、インタラクティブでリッチな直接通信をサポートします. このメモは、WebRTCフレームワークのメディアトランスポートの側面について説明しています. WebRTCコンテキストでのリアルタイムトランスポートプロトコル（RTP）の使用方法を指定し、どのRTP機能、プロファイル、および拡張機能をサポートする必要があるかについての要件を示します. 

このメモのステータス

このインターネットドラフトは、BCP 78およびBCP 79の規定に完全に準拠して提出されます. 

Internet-Draftsは、Internet Engineering Task Force（IETF）の作業文書です. 他のグループも作業文書をインターネットドラフトとして配布する場合があることに注意してください. 現在のインターネットドラフトのリストは、http：//datatracker.ietf.org/drafts/current/にあります. 

Internet-Draftは、最長6か月間有効な草案文書であり、いつでも他の文書によって更新、置き換え、または廃止される可能性があります. インターネットドラフトを参考資料として使用したり、「進行中の作業」以外の方法で引用することは不適切です. 

このインターネットドラフトは2016年9月18日に期限が切れます. 

著作権表示

Copyright（c）2016 IETF Trustおよびドキュメントの作成者として識別された人物. 全著作権所有. 

この文書は、BCP 78およびこの文書の発行日に有効なIETF文書に関するIETFトラストの法的規定（http://trustee.ietf.org/license-info）の対象となります. これらのドキュメントは、このドキュメントに関するあなたの権利と制限について説明しているため、注意深く確認してください. このドキュメントから抽出されたコードコンポーネントには、Trust Legal Provisionsのセクション4.eに記載されているSimplified BSD Licenseのテキストが含まれている必要があり、Simplified BSD Licenseに記載されているように保証なしで提供されます. 

目次

   1.はじめに. . . . . . . . . . . . . . . . . . . . . . . . ３
   2.根拠. . . . . . . . . . . . . . . . . . . . . . . . . . 4
   3.用語. . . . . . . . . . . . . . . . . . . . . . . . . 4
   4. RTPのWebRTCの使用：コアプロトコル. . . . . . . . . . . . . . 5
     4.1. RTPおよびRTCP. . . . . . . . . . . . . . . . . . . . . . 5
     4.2. RTPプロファイルの選択. . . . . . . . . . . . . . . . 7
     4.3. RTPペイロード形式の選択. . . . . . . . . . . . . . 8
     4.4. RTPセッションの使用. . . . . . . . . . . . . . . . . . . 10
     4.5. RTPおよびRTCP多重化. . . . . . . . . . . . . . . . 10
     4.6. 縮小サイズRTCP. . . . . . . . . . . . . . . . . . . . 11
     4.7. 対称RTP / RTCP. . . . . . . . . . . . . . . . . . . 11
     4.8. RTP同期ソース（SSRC）の選択. . . . . . . 12
     4.9. RTCP正規名（CNAME）の生成. . . . . . 12
     4.10. うるう秒の扱い . . . . . . . . . . . . . . . 13
   5. RTPのWebRTCの使用：拡張機能. . . . . . . . . . . . . . . . 13
     5.1. 会議拡張機能とトポロジ. . . . . . . . . 14
       5.1.1. フルイントラリクエスト（FIR）. . . . . . . . . . . . . . 15
       5.1.2. 画像損失表示（PLI）. . . . . . . . . . . . 15
       5.1.3. スライス損失表示（SLI）. . . . . . . . . . . . . 16
       5.1.4. 参照画像選択表示（RPSI）. . . . 16
       5.1.5. 時間的空間的トレードオフリクエスト（TSTR）. . . . . . 16
       5.1.6. 一時的な最大メディアストリームビットレート要求
               （TMMBR）. . . . . . . . . . . . . . . . . . . . . . . 16
     5.2. ヘッダー拡張. . . . . . . . . . . . . . . . . . . . 17
       5.2.1. 迅速な同期. . . . . . . . . . . . . . . . 17
       5.2.2. クライアントからミキサーへのオーディオレベル. . . . . . . . . . . . . 17
       5.2.3. ミキサーからクライアントへのオーディオレベル. . . . . . . . . . . . . 18
       5.2.4. メディアストリーム識別. . . . . . . . . . . . . 18
       5.2.5. ビデオオリエンテーションの調整. . . . . . . . . . 18
   6. WebRTCでのRTPの使用：トランスポートの堅牢性の向上. . . . . . 19
     6.1. 否定的な確認とRTP再送信. . . . 19
     6.2. 前方誤り訂正（FEC）. . . . . . . . . . . . . 20
   7. WebRTCでのRTPの使用：レート制御とメディア適応. . . . 20
     7.1. 境界条件と回路ブレーカー. . . . . . . . 21
     7.2. 輻輳制御の相互運用性とレガシーシステム. 22
   8. WebRTCによるRTPの使用：パフォーマンスの監視. . . . . . . . . . 22
   9. RTPのWebRTCの使用：将来の拡張機能. . . . . . . . . . . . 23
   10.シグナリングに関する考慮事項. . . . . . . . . . . . . . . . . . 23
   11. WebRTC APIに関する考慮事項. . . . . . . . . . . . . . . . . . 25
   12. RTP実装に関する考慮事項. . . . . . . . . . . . . . 27日
     12.1. RTPセッションの構成と使用 . . . . . . . . 27日
       12.1.1. RTPセッション内での複数のメディアソースの使用27
       12.1.2. 複数のRTPセッションの使用. . . . . . . . . . . . 28
       12.1.3. RTPストリームの差別化された処理. . . . . . 33
     12.2. メディアソース、RTPストリーム、および参加者
            識別. . . . . . . . . . . . . . . . . . . . . 35
       12.2.1. メディアソースID. . . . . . . . . . . . 35
       12.2.2. SSRC衝突検出. . . . . . . . . . . . . . 36
       12.2.3. メディア同期コンテキスト. . . . . . . . . . . 37
   13.セキュリティに関する考慮事項. . . . . . . . . . . . . . . . . . . 37
   14. IANAの考慮事項. . . . . . . . . . . . . . . . . . . . . 39
   15.謝辞. . . . . . . . . . . . . . . . . . . . . . 39
   16.参考資料. . . . . . . . . . . . . . . . . . . . . . . . . 39
     16.1. 規範的な参照. . . . . . . . . . . . . . . . . . 39
     16.2. 有益な参照. . . . . . . . . . . . . . . . . 44
   著者のアドレス. . . . . . . . . . . . . . . . . . . . . . . 46
        
1.はじめに
リアルタイムトランスポートプロトコル（RTP）[RFC3550]は、オーディオおよびビデオの電話会議データやその他のリアルタイムメディアアプリケーションを配信するためのフレームワークを提供します. 以前の研究では、RTPプロトコルを定義し、多数のプロファイル、ペイロード形式、およびその他の拡張機能を備えています. 適切なシグナリングと組み合わせると、これらは多くのテレビ会議システムの基礎を形成します. 

Webリアルタイム通信（WebRTC）フレームワークは、2つのピアのWebブラウザー間でオーディオ、ビデオ、コラボレーション、ゲームなどを使用した直接のインタラクティブなリアルタイム通信をサポートするプロトコルビルディングブロックを提供します. このメモは、RTPフレームワークがWebRTCコンテキストでどのように使用されるかを説明しています. すべてのWebRTCエンドポイントによって実装されるRTP機能のベースラインセットと、拡張機能の推奨拡張機能を提案します. 

このメモは、WebRTCフレームワーク内での使用を目的としたプロトコルを指定していますが、そのコンテキストに限定されません. WebRTCフレームワークの概要は、[ID.ietf-rtcweb-overview]に記載されています. 

このメモの構造は次のとおりです. セクション2では、このメモを準備し、これらのRTP機能を選択する根拠を概説します. セクション3では、用語を定義します. コアRTPプロトコルの要件についてはセクション4で説明し、推奨されるRTP拡張についてはセクション5で説明します. セクション6ではネットワーク問題の堅牢性を高めるメカニズムの概要を示し、セクション7では輻輳制御とレート適応メカニズムについて説明します. 必須のRTPメカニズムの説明は、セクション8で、パフォーマンス監視とネットワーク管理ツールのレビューで終わります. セクション9では、他のRTPおよびRTP制御プロトコル（RTCP）拡張機能をこのフレームワークに将来組み込むためのガイドラインを示します. セクション10では、シグナリングチャネルに課せられる要件について説明します. セクション11では、RTPフレームワークの機能とWebRTCアプリケーションプログラミングインターフェイス（API）の関係について説明し、セクション12では、RTP実装の考慮事項について説明します. メモは、セキュリティの考慮事項（セクション13）およびIANAの考慮事項（セクション14）で終わります. 

2.根拠
RTPフレームワークは、RTPデータ転送プロトコル、RTP制御プロトコル、および多数のRTPペイロード形式、プロファイル、および拡張機能で構成されています. このアドオンの範囲により、RTPは元のプロトコル設計者が想定していなかったさまざまなニーズを満たし、多くの新しいメディアエンコーディングをサポートできるようになりましたが、新しい実装でサポートされる拡張機能について疑問を投げかけています. WebRTCフレームワークの開発により、利用可能なRTP機能と拡張機能を確認し、すべてのWebRTCエンドポイントに共通のベースラインRTP機能セットを定義する機会が提供されます. これは、過去20年間のRTP開発に基づいて構築されており、広範なユーティリティを示す拡張機能の使用を義務付けながら、可能な場合はRTP実装の幅広いインストールベースとの互換性を維持しています. 

このドキュメントで説明されていないRTPおよびRTCP拡張機能は、新しいユースケースに有益であれば、WebRTCエンドポイントで実装できます. ただし、[RFC7478]で特定されているWebRTCの使用例と要件に対処する必要はありません. 

このメモで定義されているRTP機能と拡張機能のベースラインセットは、WebRTCフレームワークの要件を対象としていますが、RTPの他の会議関連の用途に広く役立つことが期待されています. 特に、このRTP機能と拡張機能のセットは、他のデスクトップまたはモバイルビデオ会議システム、または部屋ベースの高品質テレプレゼンスアプリケーションに適している可能性があります. 

3.用語
このドキュメントのキーワード「MUST」、「MUST NOT」、「REQUIRED」、「SHALL」、「SHALL NOT」、「SHOULD」、「SHOULD NOT」、「RECOMMENDED」、「MAY」、および「OPTIONAL」は、 [RFC2119]で説明されているように解釈されます. これらのキーワードのRFC 2119解釈は、すべて大文字で記述されている場合にのみ適用されます. これらのキーワードの小文字または大/小文字混合の使用は、このメモで特別な意味を持つと解釈されるべきではありません. 

次の追加の用語を定義します. WebRTC MediaStream：WebRTC API [W3C.WD-mediacapture-streams-20130903]でW3Cによって定義されたMediaStreamの概念. MediaStreamは0個以上のMediaStreamTracksで構成されます. 

MediaStreamTrack：WebRTC API [W3C.WD-mediacapture-streams-20130903]でW3Cによって定義されたMediaStreamコンセプトの一部. MediaStreamTrackは、マイクやカメラなどのあらゆるタイプのメディアソースからの個別のメディアストリームですが、オーディオミックスやビデオコンポジションなどの概念的なソースも可能です. 

トランスポート層フロー：送信元IPアドレス、送信元ポート、宛先IPアドレス、宛先ポート、および使用されるトランスポートプロトコルの特定の5タプルを持つことによって識別されるトランスポートパケットの単方向フロー. 

双方向トランスポート層フロー：双方向トランスポート層フローは、対称的なトランスポート層フローです. つまり、逆方向のトランスポート層フローには5つのタプルがあり、フォワードパスのトランスポート層フローと比較して、送信元アドレスと宛先アドレスおよびポートがスワップされ、トランスポートプロトコルは同じです. 

このドキュメントでは、[ID.ietf-avtext-rtp-grouping-taxonomy]と[ID.ietf-rtcweb-overview]の用語を使用しています. その他の用語は、RTP仕様[RFC3550]の定義に従って使用されています. 特に、頻繁に使用される次の用語に注意してください. RTPストリーム、RTPセッション、エンドポイント. 

4. WebRTCによるRTPの使用：コアプロトコル
以下のセクションでは、必須のRTPプロファイルとともに、実装する必要があるRTPおよびRTCPのコア機能について説明します. また、今日のネットワークで効果的に機能するためにすべてのWebRTCエンドポイントが実装する必要のある重要な機能を提供するコア拡張についても説明します. 

4.1. RTPおよびRTCP
リアルタイム転送プロトコル（RTP）[RFC3550]は、WebRTCのメディア転送プロトコルとして実装する必要があります. RTP自体は、RTPデータ転送プロトコルとRTP制御プロトコル（RTCP）の2つの部分で構成されています. RTCPはRTPの基本的かつ不可欠な部分であり、すべてのWebRTCエンドポイントで実装および使用する必要があります. 

以下のRTPおよびRTCP機能は、RTPの限られた機能の実装では省略されることがありますが、すべてのWebRTCエンドポイントで必要です.  、[RFC3550]および[ID.ietf-avtcore-rtp-multi-stream]に続きます. [ID.ietf-avtcore-rtp-multi-stream-optimization]で定義されているマルチSSRCセッションのRTCP最適化がサポートされる場合があります. サポートされている場合は、使用方法を通知する必要があります. 

oセッションへの参加時にSSRCをランダムに選択. SSRC値の衝突検出と解決（セクション4.8も参照）

o RTPミキサーによって生成されたCSRCリストを含むRTPデータパケット、およびCSRCに関連するRTCPパケットの受信のサポート. 

o RTCP送信者レポートで正しい同期情報を送信して、受信者がリップ同期を実装できるようにします. 高速RTP同期拡張のサポートについては、セクション5.2.1を参照してください. 

o複数の同期コンテキストのサポート. 複数の同時RTPパケットストリームを送信する参加者は、すべてのストリームに対して単一のRTCP CNAMEを使用し、受信者がストリームを同期して再生できるようにして、単一の同期コンテキストの一部として送信する必要があります（SHOULD）. この仕様の潜在的な将来のバージョンとの互換性、またはゲートウェイを介した非WebRTCデバイスとの相互運用性のために、受信者は、RTPセッションで複数のRTCP CNAMEを使用することで示される複数の同期コンテキストをサポートする必要があります. この仕様では、状況によってはRTPストリームを送信するときに単一のCNAMEの使用を義務付けています. セクション4.9を参照してください. 

o RTCP SR、RR、SDES、およびBYEパケットタイプの送受信のサポート. この仕様の他の部分で義務付けられていない限り、他のRTCPパケットタイプのサポートはオプションであることに注意してください. 追加のRTCPパケットタイプは、RTP / SAVPFプロファイル（セクション4.2）およびその他のRTCP拡張（セクション5）によって使用されることに注意してください. SDPバンドルネゴシエーション拡張機能を実装するWebRTCエンドポイントは、SDPグループ化フレームワークの「mid」属性を使用して、メディアストリームを識別します. このようなエンドポイントは、[ID.ietf-mmusic-sdp-bundle-negotiation]で説明されているRTCP SDES MIDアイテムを実装する必要があります. 

o単一のRTPセッションでの複数のエンドポイントのサポート、およびセッションの参加者数に応じたRTCP送信間隔のスケーリング. RTCPレポートの同期を回避するためのランダムなRTCP送信間隔のサポート. RTCPタイマーの再検討のサポート（セクション6.3.6の

[RFC3550]）および逆再検討（[RFC3550]のセクション6.3.4）. 

o RTCP帯域幅をメディア帯域幅の一部として構成し、送信者に割り当てられたRTCP帯域幅の一部を構成するためのサポート（SDP "b ="行[RFC4566] [RFC3556]など）. 

o [RFC3550]のセクション6.2で説明されている短縮された最小RTCPレポート間隔のサポート. 短縮された最小RTCPレポート間隔を使用する場合は、参加者のタイムアウト間隔を計算するときに、固定（短縮されていない）最小間隔を使用する必要があります（[RFC3550]のセクション6.2および6.3.5を参照）. 最初の複合RTCPパケットを送信する前の遅延はゼロに設定できます（[ID.ietf-avtcore-rtp-multi-stream]によって更新される[RFC3550]のセクション6.2を参照）. 

o不連続送信のサポート. RTPにより、エンドポイントはいつでも送信を一時停止および再開できます. 再開すると、RTPシーケンス番号は通常どおり1ずつ増加しますが、RTPタイムスタンプ値の増加は一時停止の期間に依存します. 不連続伝送は、一部のオーディオペイロード形式で最も一般的に使用されますが、オーディオ固有ではなく、任意のRTPペイロード形式で使用できます. 

o不明なRTCPパケットタイプとRTPヘッダー拡張を無視します. これは、将来の拡張、ミドルボックスの動作などの堅牢な処理を確実にするためであり、信号が出されないRTCPパケットタイプまたはRTPヘッダー拡張が受信されない可能性があります. 既知のRTCPパケットタイプと不明なRTCPパケットタイプが混在する複合RTCPパケットを受信した場合、既知のパケットタイプは通常どおり処理する必要があり、不明なパケットタイプのみが破棄されます. 

多くのレガシーRTP実装、特にVoIPのみのシステムを対象とするものは、上記の機能のすべてをサポートしておらず、場合によってはRTCPをまったくサポートしていないことがわかっています. 実装者は、レガシー実装と相互運用する際に、適切なデグラデーションの要件を検討することをお勧めします. 

その他の実装に関する考慮事項については、セクション12で説明します. 

4.2. RTPプロファイルの選択
特定のアプリケーションドメインのRTPを完全に指定するには、RTPプロファイルを選択する必要があります. WebRTCを使用するには、[RFC7007]によって拡張された、RTCPベースのフィードバック用の拡張セキュアRTPプロファイル（RTP / SAVPF）[RFC5124]を実装する必要があります. RTP / SAVPFプロファイルは、基本的なRTP / AVPプロファイル[RFC3551]、RTPプロファイルの組み合わせです. 

RTCPベースのフィードバック（RTP / AVPF）[RFC4585]、およびセキュアなRTPプロファイル（RTP / SAVP）[RFC3711]. 

RTCPベースのフィードバック拡張[RFC4585]は、改善されたRTCPタイマーモデルに必要です. これにより、帯域幅に厳密に従うのではなく、イベントに応答してRTCPパケットをより柔軟に送信できるようになり、輻輳信号やメディアイベントを報告できるようになります. これらの拡張機能により、RTCP帯域幅を節約することもできます. エンドポイントは、フィードバックが必要なイベントが多数ある場合にのみ、通常、RTCP帯域幅の全割り当てを使用します. タイマールールは、セクション5.1で説明したRTP会議拡張機能を利用するためにも必要です. 

注：RTP / AVPFプロファイルで定義された拡張RTCPタイマーモデルは、RTP帯域幅の値や「trr-int」などのパラメーター構成にいくつかの制約がある場合、RTP / AVPまたはRTP / SAVPプロファイルのみを実装するレガシーシステムと下位互換性があります"（ゲートウェイを介してRTP /（S）AVPエンドポイントと相互作用するための最も重要な要素は、trr-intパラメーターを4秒を表す値に設定することです. [ID.ietf-avtcore-rtp-multi-streamのセクション6.1を参照してください]）. 

セキュアRTP（SRTP）プロファイル拡張[RFC3711]は、メディアの暗号化、整合性保護、再生保護、およびソース認証の制限された形式を提供するために必要です. WebRTCエンドポイントは、基本的なRTP / AVPプロファイルまたはRTP / AVPFプロファイルを使用してパケットを送信してはなりません（MUST NOT）. 生成されるすべてのRTPおよびRTCPパケットを保護するために、完全なRTP / SAVPFプロファイルを使用する必要があります（つまり、実装ではSRTPおよびSRTCPを使用する必要があります）. RTP / SAVPFプロファイルは、暗号スイート、DTLS-SRTP保護プロファイル、キーイングメカニズム、および[ID.ietf-rtcweb-security-arch]で説明されているその他のパラメーターを使用して構成する必要があります. 

4.3. RTPペイロード形式の選択
WebRTCエンドポイントのオーディオコーデックとRTPペイロード形式を実装することは必須です[ID.ietf-rtcweb-audio]で定義されています. WebRTCエンドポイントのビデオコーデックとRTPペイロード形式を実装することは必須です. [ID.ietf-rtcweb-video]で定義されています. WebRTCエンドポイントは、RTPペイロード形式および関連するシグナリングが定義されている他のコーデックをさらに実装する場合があります. 

WebRTCエンドポイントは、RTPセッションの他の参加者が、どんなに一般的であっても、RTPペイロード形式を理解しているとは想定できません. RTPペイロードタイプ番号と特定のRTPペイロードフォーマットの特定の構成との間のマッピングは、それらのペイロードタイプ/フォーマットを使用する前に合意する必要があります. SDPコンテキストでは、これは、「m =」行に関連付けられた「a = rtpmap：」属性と「a = fmtp：」属性、およびRTPペイロード形式の構成に必要なその他のSDP属性を使用して実行できます. 

固有の各RTPペイロードフォーマット構成が異なるRTPペイロードタイプ番号を使用している限り、エンドポイントは、複数のRTPペイロードフォーマット、または単一のRTPペイロードフォーマットの複数の構成のサポートを通知できます. セクション4.8で概説されているように、RTPペイロードタイプ番号は、RTPパケットストリームをシグナリングコンテキストに関連付けるために使用されることがあります. この関連付けは、各コンテキストで一意のRTPペイロードタイプ番号が使用されている場合にのみ可能です. たとえば、RTPパケットストリームは、RTPパケットストリームで使用されるRTPペイロードタイプ番号と、メディアセクションの「a = rtpmap：」行でシグナリングされるペイロードタイプを比較することにより、SDPの「m =」行に関連付けることができます.  SDP. これは、次の考慮事項につながります. 

RTPパケットストリームがRTPペイロードタイプに基づいてシグナリングコンテキストに関連付けられている場合、RTPペイロードタイプ番号の割り当ては、シグナリングコンテキスト全体で一意である必要があります. 

同じRTPペイロードフォーマット設定が複数のコンテキストで使用されている場合、一意性を確保するために、各コンテキストで異なるRTPペイロードタイプ番号を割り当てる必要があります. 

RTPペイロードタイプ番号がRTPパケットストリームをシグナリングコンテキストに関連付けるために使用されていない場合、同じRTPペイロードタイプ番号を使用して、複数のコンテキストでまったく同じRTPペイロードフォーマット設定を示すことができます. 

単一のRTPペイロードタイプ番号は、単一のRTPセッション内の異なるRTPペイロードフォーマット、または同じRTPペイロードフォーマットの異なる設定に割り当ててはなりません（SDPバンドルグループの "m ="行に注意してください[ID.ietf- mmusic-sdp-bundle-negotiation]は、単一のRTPセッションを形成します）. 

複数のRTPペイロード形式のサポートを通知したエンドポイントは、以前にデコード機能の制限を通知していない限り、いつでもこれらのペイロード形式のデータを受け入れることができる必要があります. この要件は、複数のタイプのメディア（オーディオやビデオなど）が同じRTPセッションで送信される場合に制限されます. そのような場合、ソース（SSRC）は、そのソースによって送信されているメディアのタイプに対してシグナリングされたRTPペイロードフォーマット間の切り替えのみに制限されます. セクション4.4を参照してください. コーデックを変更することによる高速レート適応をサポートするために、RTPは、セッションのセットアップ中に通知された単一のSSRCによって使用されるRTPペイロード形式間の変更に対して事前の通知を必要としません. 

異なるRTPクロックレートを使用する2つのRTPペイロードタイプ間で変更を実行する場合、RTP送信者は[RFC7160]のセクション4.1の推奨事項に従う必要があります. RTPレシーバーは、RTPセッションでクロックレートを切り替えるソースをサポートするために、[RFC7160]のセクション4.3の推奨事項に従う必要があります（レシーバーに対するこれらの推奨事項は、送信者が単一のクロックレートのみを使用する場合と下位互換性があります）. 

4.4. RTPセッションの使用
RTPを使用して通信する一連のエンドポイント間の関連付けは、RTPセッション[RFC3550]と呼ばれます. エンドポイントは、同時に複数のRTPセッションに関与できます. マルチメディアセッションでは、通常、各タイプのメディアが個別のRTPセッションで運ばれます（たとえば、オーディオに1つのRTPセッションを使用し、ビデオに異なるトランスポートレイヤーフローを使用する個別のRTPセッションを使用します）. WebRTCエンドポイントは、この方法でマルチメディアセッションのサポートを実装し、レガシーシステムとの互換性のために異なるトランスポートレイヤーフローを使用して各RTPセッションを分離する必要があります（これはセッションの多重化と呼ばれることもあります）. 

ただし、今日のネットワークでは、ネットワークアドレス/ポートトランスレータ（NAT / NAPT）とファイアウォールが広く使用されているため、RTPアプリケーションで使用されるトランスポート層フローの数を減らすことが望まれます. これは、単一のトランスポート層フローを構成する単一のRTPセッションですべてのRTPパケットストリームを送信することで実行できます（これにより、セクション12.1.3で説明されているように、一部のサービス品質メカニズムの使用が妨げられます）. したがって、[ID.ietf-avtcore-multi-media-rtp-session]に従って、単一のトランスポートレイヤーフローを使用する単一のRTPセッションで、メディアタイプに関係なく、すべてのRTPパケットストリームのトランスポートをサポートする実装も必要です.  SSRC多重化と呼ばれることもあります）. 単一のRTPセッションで複数のタイプのメディアを使用する場合、そのRTPセッションのすべての参加者は、この使用法に同意する必要があります. 

さまざまなRTPセッション構造とさまざまなシナリオへの多重化方法の適合性についての詳細は、[ID.ietf-avtcore-multiplex-guidelines]を参照してください. 

4.5. RTPおよびRTCP多重化
歴史的に、RTPとRTCPは別々のトランスポート層フローで実行されていました（たとえば、RTPセッションごとに2つのUDPポート、RTP用に1つのポート、RTCP用に1つのポート）. 複数のNATバインディングを維持するとコストがかかるため、ネットワークアドレス/ポート変換（NAT / NAPT）の使用が増えると、問題が発生します. また、RTPトラフィックを許可するには複数のポートを開く必要があるため、ファイアウォールの管理も複雑になります. これらのコストとセッションのセットアップ時間を削減するために、単一のトランスポート層フローでのRTPデータパケットとRTCP制御パケットの多重化をサポートする実装が必要です[RFC5761]. このようなRTPおよびRTCP多重化は、使用前にシグナリングチャネルでネゴシエートする必要があります. SDPがシグナリングに使用される場合、このネゴシエーションは[RFC5761]で定義されたメカニズムを使用する必要があります. 実装は、RTPとRTCPの送信を個別のトランスポート層フローでサポートすることもできますが、これは実装のオプションです. 実装が個別のトランスポート層フローで送信されるRTPとRTCPをサポートしない場合、それは[ID.ietf-mmusic-mux-exclusive]で定義されたメカニズムを使用することを示さなければなりません（MUST）. 

単一のトランスポート層フローに多重化されたRTPおよびRTCPを使用すると、アクティブなメディアトラフィックがなくても、そのポートで送信されるトラフィックが時々発生することが保証されます. これは、NATバインディングを存続させるのに役立ちます[RFC6263]. 

4.6 縮小サイズRTCP
RTCPパケットは通常、複合RTCPパケットとして送信され、[RFC3550]では、これらの複合パケットが送信者レポート（SR）または受信者レポート（RR）パケットで始まる必要があります. RTP / AVPFプロファイル[RFC4585]で頻繁にRTCPフィードバックメッセージを使用する場合、これらの統計はすべてのパケットで必要とされるわけではなく、平均RTCPパケットサイズを不必要に増やします. これにより、RTCP帯域幅共有内でRTCPパケットを送信できる頻度を制限できます. 

この問題を回避するために、[RFC5506]は、平均RTCPメッセージサイズを削減し、より頻繁なフィードバックを可能にする方法を指定しています. 頻繁なフィードバックは、リアルタイムのアプリケーションに変化するネットワークの状態をすばやく認識させ、伝送とエンコードの動作を適応させるために不可欠です. 実装は、非複合RTCPフィードバックパケットの送受信をサポートする必要があります[RFC5506]. 非複合RTCPパケットの使用は、シグナリングチャネルを使用してネゴシエートする必要があります. SDPがシグナリングに使用される場合、このネゴシエーションは[RFC5506]で定義された属性を使用する必要があります. 下位互換性のために、リモートエンドポイントがシグナリング交換での非複合RTCPの使用に同意しない場合、複合RTCPフィードバックパケットの使用をサポートするための実装も必要です. 

4.7. 対称RTP / RTCP
NATおよびファイアウォールデバイスの通過を容易にするために、実装は対称RTP [RFC4961]を実装して使用する必要があります. 対称RTPを使用する理由は、主に、送受信RTPパケットストリームとRTCPが実際に双方向のトランスポート層フローであることを保証することにより、NATとファイアウォールの問題を回避するためです. これにより、NATとファイアウォールのピンホールが維持され、受信方向が、目的の受信者が実際に必要とするトランスポート層フローであることを示すのに役立ちます. さらに、NATマッピングやファイアウォールの状態が不必要に肥大化されないため、リソース、特にエンドポイントのポートだけでなくネットワークも節約できます. ネットワークに保持されるフローごとのQoS状態の量も削減されます. 

4.8. RTP同期ソース（SSRC）の選択
信号によるRTP同期ソース（SSRC）識別子をサポートするには、実装が必要です. SDPを使用する場合、これは[RFC5576]のセクション4.1およびセクション5で定義された「a = ssrc：」SDP属性と、[RFC5576]のセクション6.2で定義された「previous-ssrc」ソース属性を使用して行う必要があります. [RFC5576]で定義されている他のSSRCごとの属性がサポートされる場合があります. 

通知されたSSRC識別子のサポートは必須ですが、RTPセッションでのそれらの使用はオプションです. 実装は、事前に明示的に通知されていないSSRCを使用してRTPおよびRTCPパケットを受け入れる準備ができていなければなりません. [RFC3550]によると、実装はランダムなSSRC割り当てをサポートする必要があり、SSRC衝突の検出と解決をサポートする必要があります. 通知されたSSRC値を使用する場合、[RFC5576]のセクション5で説明されているように、衝突検出を実行する必要があります. 

RTPパケットストリームを非RTPコンテキストに関連付けることが望ましい場合がよくあります. WebRTC APIのユーザーのために、SSRCとMediaStreamTracksの間のマッピングがセクション11に従って提供されています. ゲートウェイまたはその他の使用法については、RTPパケットストリームをSDPを使用してフォーマットされたセッション記述の「m =」行に関連付けることが可能です. SSRCが通知される場合、これは簡単です（SDPでは、「a = ssrc：」行はメディアレベルにあり、「m =」行との直接の関連付けが可能です）. SSRCが通知されない場合、RTPパケットストリームで使用されるRTPペイロードタイプ番号は、そのパケットストリームをシグナリングコンテキストに関連付けるのに十分なことがよくあります（たとえば、RTPペイロードタイプ番号がこのメモのセクション4.3で説明されているように割り当てられている場合、RTP RTPパケットストリームで使用されるペイロードタイプは、SDPの値と比較できます. 

4.9. RTCP正規名（CNAME）の生成
RTCP正規名（CNAME）は、RTPエンドポイントに永続的なトランスポートレベルの識別子を提供します. 衝突が検出された場合、またはRTPアプリケーションが再起動された場合、RTPエンドポイントの同期ソース（SSRC）識別子は変更される可能性がありますが、RTCP CNAMEは、RTCPeerConnection [W3C.WD-webrtc-20130910 ]、RTPエンドポイントを一意に識別し、関連するRTPセッションのセット内のRTPパケットストリームに関連付けることができます. 

各RTPエンドポイントには少なくとも1つのRTCP CNAMEが必要であり、そのRTCP CNAMEはRTCPeerConnection内で一意である必要があります. RTCP CNAMEは特定の同期コンテキストを識別します. つまり、単一のRTCP CNAMEに関連付けられたすべてのSSRCは、共通の基準クロックを共有します. エンドポイントに複数の非同期の基準クロックに関連付けられているSSRCがあるため、異なる同期コンテキストがある場合、同期コンテキストごとに1つずつ、複数のRTCP CNAMEを使用する必要があります. 

セクション11の説明を考慮に入れると、WebRTCエンドポイントは、単一のRTCPeerConnectionに属するRTPセッションで複数のRTCP CNAMEを使用してはなりません（つまり、RTCPeerConnectionが同期コンテキストを形成します）. RTPミドルボックスは、複数のRTCP CNAMEに関連付けられたRTPパケットストリームを生成して、マルチパーティRTPセッションの複数の異なるエンドポイントからのメディアを再同期する必要がないようにすることができます. 

RTP仕様[RFC3550]には、一意のRTP CNAMEを選択するためのガイドラインが含まれていますが、NATデバイスが存在する場合は十分ではありません. さらに、長期的な永続的な識別子は、プライバシーの観点から問題になることがあります（セクション13）. したがって、WebRTCエンドポイントは、[RFC7022]に続いて、各RTCPeerConnectionに対して、1つの例外を除いて、新しい一意の短期永続RTCP CNAMEを生成する必要があります. 作成時に明示的に要求された場合、RTCPeerConnectionは、共通の同一生成元コンテキスト内の既存のRTCPeerConnectionと同じCNAMEを使用できます（MAY）. 

WebRTCエンドポイントは、RTP仕様[RFC3550]で指定された構文制限に一致するCNAMEの受信をサポートする必要があり、上記の形式に従ってCNAMEが選択されるとは想定できません. 

4.10. うるう秒の扱い
[RFC7164]で規定されているRTPメディアの再生と同期への影響を制限するためのうるう秒の処理に関するガイドラインに従う必要があります（SHOULD）. 

5. RTPのWebRTCでの使用：拡張機能
WebRTCのコンテキストでは、完全な機能を取得するために必要な、またはベースラインパフォーマンスを向上させるために非常に役立つRTP拡張機能がいくつかあります. これらの拡張機能の1つのセットは会議に関連していますが、他の拡張機能はより一般的なものです. 以下のサブセクションでは、WebRTC内での使用が義務付けられている、または提案されているさまざまなRTP拡張機能について説明します. 

5.1. 会議拡張機能とトポロジ
RTPは、本質的にグループ通信をサポートするプロトコルです. グループを実装するには、各エンドポイントがRTPパケットストリームをRTPミドルボックスに送信してトラフィックを再分配するか、エンドポイント間でユニキャストRTPパケットストリームのメッシュを使用するか、またはIPマルチキャストグループを使用してRTPパケットストリームを配布します. これらのトポロジーは、[ID.ietf-avtcore-rtp-topologies-update]で説明されているように、いくつかの方法で実装できます. 

IPTVシステムではIPマルチキャストグループの使用が一般的ですが、インタラクティブビデオ会議環境では、RTPミドルボックスに基づくトポロジが主流です. 共通のRTPセッションを作成するためのユニキャストトランスポートレイヤーフローのメッシュに基づくトポロジでは、これまでの広範な展開は見られません. したがって、WebRTCエンドポイントは、IPマルチキャストグループに基づくトポロジをサポートすることや、単一のRTPセッションとして構成されたポイントツーマルチポイントメッシュ（[ID.ietf -avtcore-rtp-topologies-update]）. ただし、複数のRTPセッションを使用して構築され、独立したRTCPeerConnections [W3C.WD-webrtc-20130910]を使用してWebRTCで実装されたポイントツーマルチポイントメッシュは、WebRTCでの使用が予想され、サポートする必要があります. 

このメモに従って実装されたWebRTCエンドポイントは、[ID.ietf-avtcore-rtp-topologies-update]で説明されているすべてのトポロジをサポートすることが期待されています. ここで、RTPエンドポイントは、ピアがピアであれば、ピアデバイスとの間でユニキャストRTPパケットストリームを送受信します.  RTPパケットストリームの輻輳制御の実行に参加できます. ピアデバイスは、別のRTPエンドポイントであるか、またはRTPパケットストリームを他のRTPエンドポイントに再配布するRTPミドルボックスである可能性があります. この制限は、RTPミドルボックスベースのトポロジの一部がWebRTCでの使用に適していないことを意味します. 具体的には：

oビデオスイッチングMCU（Topo-Video-switch-MCU）は、輻輳制御およびサービス品質レポートにRTCPの使用を問題にするため、使用しないでください（[ID.ietf-avtcore-rtp-topologies-更新]）. 

oリレー-トランスポートトランスレーター（Topo-PtM-Trn-Translator）トポロジは使用しないでください. 安全に使用するには、まだ標準化されていない、ポイントツーマルチポイントを処理する輻輳制御アルゴリズムまたはRTP回路ブレーカーが必要です. 

以下のトポロジーを使用できますが、注目に値するいくつかの問題があります. o RTCPターミネーションを備えたコンテンツ変更MCU（Topo-RTCP-terminating-MCU）を使用できます. このRTPトポロジでは、RTPループの検出とアクティブな送信者の識別はWebRTCアプリケーションの責任であることに注意してください. クライアントはRTP層で互いに分離されているため、RTPはこれらの機能を支援できません（[ID.ietf-avtcore-rtp-topologies-update]のセクション3.9を参照）. 

セクション5.1.1からセクション5.1.6で説明されているRTP拡張機能は、RTPミドルボックス（会議ブリッジなど）が参加者のRTPパケットストリームを受信して​​他の参加者に配信する集中会議で使用するように設計されています. これらの拡張は相互運用性のために必要ではありません. これらの拡張機能を実装していないRTPエンドポイントは正しく機能しますが、パフォーマンスが低下する可能性があります. リストされている拡張機能のサポートにより、エクスペリエンスの品質が大幅に向上し、合理的なベースライン品質を提供するために、これらの拡張機能の一部はWebRTCエンドポイントでサポートされることが必須です. 

RTCP会議の拡張機能は、リアルタイムトランスポートコントロールプロトコル（RTCP）ベースのフィードバック用の拡張RTPプロファイル（RTP / AVPF）[RFC4585]およびRTP / AVPFのコーデックコントロールメッセージ（CCM）に関するメモ[RFC5104]で定義されています. これらは、このプロファイルのセキュアバリアント（RTP / SAVPF）[RFC5124]で完全に使用できます. 

5.1.1. 完全なイントラリクエスト（FIR）
Full Intra Requestメッセージは、コーデック制御メッセージ[RFC5104]のセクション3.5.1および4.3.1で定義されています. これは、セッションの参加者からミキサーに新しいイントラ画像を要求させるために使用されます. これは、ソースを切り替えるときに使用され、レシーバーがビデオまたは他の予測メディアエンコーディングを長い予測チェーンで確実にデコードできるようにします. メディアを送信するWebRTCエンドポイントは、受信するFIRフィードバックメッセージを理解して対応する必要があります. これにより、集中型ミキサーベースの会議を使用する場合のユーザーエクスペリエンスが大幅に向上します. FIRメッセージの送信のサポートはオプションです. 

5.1.2. 画像損失表示（PLI）
Picture Loss Indicationメッセージは、RTP / AVPFプロファイル[RFC4585]のセクション6.3.1で定義されています. これは、受信側が送信側のエンコーダーにデコーダーのコンテキストを失ったことを通知し、何らかの方法で修復してもらいたい場合に使用されます. これは、要求を満たすための複数の方法が存在する可能性があるため、上記の完全な内部要求とは意味的に異なります. メディアを送信しているWebRTCエンドポイントは、PLIフィードバックメッセージをロストレランスメカニズムとして理解して対応する必要があります. 受信者はPLIメッセージを送信してもよい（MAY）. 

5.1.3. スライス損失表示（SLI）
Slice Loss Indicationメッセージは、RTP / AVPFプロファイル[RFC4585]のセクション6.3.2で定義されています. これは、1つ以上の連続したマクロブロックの損失または破損を検出したことをエンコーダーに伝えるためにレシーバーによって使用され、これらを何らかの方法で修復したいと考えています. マクロブロックの概念をサポートするコーデックを使用しているときにスライスが失われた場合、レシーバーがSLIフィードバックメッセージを生成することをお勧めします. SLIフィードバックメッセージを受信する送信者は、失われたスライスを修復する必要があります（SHOULD）. 

5.1.4. 参照画像選択表示（RPSI）
参照画像選択表示（RPSI）メッセージは、RTP / AVPFプロファイル[RFC4585]のセクション6.3.3で定義されています. 一部のビデオエンコーディング規格では、最新のものよりも古い参照ピクチャを予測コーディングに使用できます. そのようなコーデックが使用されていて、エンコーダがエンコーダとデコーダの同期が失われたことを学習した場合、正しい参照ピクチャとして知られているものを、将来のコーディングのベースとして使用できます. RPSIメッセージにより、これを通知できます. 使用されているコーデックが参照画像の選択をサポートしている場合、エンコーダーとデコーダーの同期が失われたことを検出する受信機は、RPSIフィードバックメッセージを生成する必要があります. このようなRPSIメッセージを受信するRTPパケットストリーム送信者は、利用可能な帯域幅の制限内で変更できる場合、そのメッセージに基づいて参照画像を変更する必要があります（SHOULD）. 

5.1.5. 時間と空間のトレードオフリクエスト（TSTR）
時間と空間のトレードオフ要求と通知は、[RFC5104]のセクション3.5.2と4.3.2で定義されています. この要求を使用して、ビデオエンコーダーに時間的解像度と空間的解像度の間のトレードオフを変更するように要求できます. TSTRリクエストと通知のサポートはオプションです. 

5.1.6. 一時最大メディアストリームビットレートリクエスト（TMMBR）
TMMBRフィードバックメッセージは、コーデック制御メッセージ[RFC5104]のセクション3.5.4および4.2.1で定義されています. この要求とその通知メッセージは、メディアレシーバーがこのレシーバーで使用できる帯域幅の量に現在制限があることを送信側に通知するために使用されます. これにはさまざまな理由が考えられます. たとえば、RTPミキサーはこのメッセージを使用して、（メディアトランスコーディングを行わずに）ミキサーによって転送される送信者のメディアレートを制限して、他のセッション参加者に存在するボトルネックに合わせることができます. メディアを送信しているWebRTCエンドポイントは、TMMBRメッセージのサポートを実装する必要があり、SSRCに対して受信したTMMBRメッセージによって設定された帯域幅制限に従う必要があります. TMMBR要求の送信はオプションです. 

5.2. ヘッダー拡張
RTP仕様[RFC3550]は、帯域内データを含むRTPヘッダー拡張を含める機能を提供しますが、拡張の形式とセマンティクスは十分に指定されていません. ヘッダー拡張の使用はWebRTCではオプションですが、使用する場合は、[RFC5285]で定義されているRTPヘッダー拡張の一般的なメカニズムに従ってフォーマットおよびシグナリングする必要があります. これにより、RTPヘッダー拡張に明確なセマンティクスが提供されます. 

[RFC5285]で述べられているように、RTP仕様のヘッダー拡張は「ヘッダー拡張が無視されるように設計されている」という要件が存在します[RFC3550]. 具体的には、ヘッダー拡張は、相互運用性に影響を与えずに受信者が安全に無視できるデータにのみ使用する必要があり、拡張の存在がパケットの残りの部分の形式または性質を変更した場合は使用しないでくださいこれは、ストリームのシグナリング方法と互換性がありません（たとえば、ペイロードタイプによって定義されている）. RTPヘッダー拡張の有効な例には、通常のRTP情報に追加されたメタデータが含まれる場合がありますが、相互運用性を損なうことなく無視できます. 

5.2.1. 迅速な同期
多くのRTPセッションでは、オーディオ、ビデオ、およびその他のコンテンツ間の同期が必要です. この同期は、RTP仕様[RFC3550]で説明されているように、RTCP SRパケットに含まれている情報を使用して、受信者によって実行されます. ただし、この基本的なメカニズムは遅くなる可能性があるため、[RFC6051]で説明されている高速RTP同期拡張をRTCP SRベースの同期に加えて実装することをお勧めします. 

このヘッダー拡張は[RFC5285]汎用ヘッダー拡張フレームワークを使用するため、使用する前に交渉する必要があります. 

5.2.2. クライアントからミキサーへのオーディオレベル
クライアントからミキサーへのオーディオレベル拡張[RFC6464]は、ヘッダーが添付されているパケットのオーディオアクティビティのレベルについてミキサーに通知するためにエンドポイントで使用されるRTPヘッダー拡張です. これにより、RTPミドルボックスは、ペイロードをデコードしたり詳細に検査したりせずにミキシングまたは選択の決定を行うことができ、一部のタイプのミキサーの複雑さが軽減されます. また、オーディオアクティビティレベルに基づいて最も関連性の高いRTPパケットストリームのみをデコードすることを選択できるレシーバーのデコードリソースを節約することもできます. 

Client-to-Mixerオーディオレベル[RFC6464]ヘッダー拡張を実装する必要があります. これらのヘッダー拡張に含まれる情報は機密情報と見なすことができるため、実装は[RFC6904]に従ってヘッダー拡張を暗号化できることが必要です. この暗号化の使用は推奨されていますが、暗号化の使用は、APIまたはシグナリングを通じて明示的に無効にすることができます. 

このヘッダー拡張は[RFC5285]汎用ヘッダー拡張フレームワークを使用するため、使用する前に交渉する必要があります. 

5.2.3. ミキサーからクライアントへのオーディオレベル
Mixer to Client Audio Levelヘッダー拡張[RFC6465]は、RTPミキサーによって共通ソースストリームに混合されたさまざまなソースのオーディオレベルをエンドポイントに提供します. これにより、ユーザーインターフェイスは、CSRCフィールドに基づいて含まれるだけではなく、含まれるのではなく、各セッション参加者の相対的なアクティビティレベルを示すことができます. これは重要ではない関数の純粋な最適化であり、したがって実装はオプションです. このヘッダー拡張が実装されている場合、これらのヘッダー拡張に含まれる情報は機密情報と見なすことができるため、実装は[RFC6904]に従ってヘッダー拡張を暗号化できることが必要です. 暗号化がAPIまたはシグナリングを介して明示的に無効にされていない限り、この暗号化を使用することをさらにお勧めします. 

このヘッダー拡張は[RFC5285]汎用ヘッダー拡張フレームワークを使用するため、使用する前に交渉する必要があります. 

5.2.4. メディアストリームの識別
SDPバンドルネゴシエーション拡張機能を実装するWebRTCエンドポイントは、SDPグループ化フレームワークの「mid」属性を使用して、メディアストリームを識別します. このようなエンドポイントは、[ID.ietf-mmusic-sdp-bundle-negotiation]で説明されているRTP MIDヘッダー拡張を実装する必要があります. 

このヘッダー拡張は[RFC5285]汎用ヘッダー拡張フレームワークを使用するため、使用する前に交渉する必要があります. 

5.2.5. ビデオオリエンテーションの調整
ビデオを送信または受信するWebRTCエンドポイントは、[ID.ietf-rtcweb-video]のセクション4で説明されているように、ビデオオリエンテーション（CVO）RTPヘッダー拡張の調整を実装する必要があります. 

このヘッダー拡張は[RFC5285]汎用ヘッダー拡張フレームワークを使用するため、使用する前に交渉する必要があります. 

6. RTPのWebRTCの使用：トランスポートの堅牢性の向上
RTPパケットストリームをパケット損失に対して堅牢にし、損失がメディア品質に与える影響を軽減できるツールがあります. ただし、一般的に、非堅牢なストリームと比較してオーバーヘッドが追加されます. オーバーヘッドを考慮する必要があり、ネットワークの輻輳の発生を回避するために、総ビットレートをレート制御する必要があります（セクション7を参照）. その結果、ロバスト性を向上させるには低いベースエンコーディング品質が必要になる場合がありますが、エラーを少なくしてその品質を実現できる可能性があります. 次のサブセクションで説明するメカニズムは、パケット損失に対する耐性を向上させるために使用できます. 

6.1. 否定応答とRTP再送信
RTP / SAVPFプロファイルをサポートする結果として、実装はRTPデータパケットに対して否定応答（NACK）を送信できます[RFC4585]. このフィードバックは、RTCPフィードバックチャネルの容量制限に従って、特定のRTPパケットの損失を送信者に通知するために使用できます. 送信者はこの情報を使用して、既知の失われたパケットを補償するようにメディアエンコーディングを調整することにより、ユーザーエクスペリエンスを最適化できます. 

RTPパケットストリームの送信者は、[RFC4585]のセクション6.2.1で定義されているGeneric NACKメッセージを理解する必要がありますが、このフィードバックの一部またはすべてを無視することを選択できます（[RFC4585]のセクション4.2に従います）. レシーバーは、欠落しているRTPパケットに対してNACKを送信してもよい（MAY）. NACKを送信するタイミングに関するガイドラインは、[RFC4585]で提供されています. 受信者が失われたすべてのRTPパケットに対してNACKを送信することは想定されていません. 送信者に伝える価値があるかどうかを判断するために、NACKフィードバックの送信コストと失われたパケットの重要性を考慮する必要があります. パケット損失イベントについて. 

RTP Retransmission Payload Format [RFC4588]は、NACKフィードバックに基づいて失われたパケットを再送信する機能を提供します. 再送信は、インタラクティブなリアルタイムアプリケーションで注意深く使用して、再送信されたパケットが時間内に到着して有用であることを確認する必要がありますが、ネットワークRTTが比較的低い環境では効果的です（RTP送信者は、 [RFC3550]のセクション6.4.1の最後に説明されているように、RTCP SRおよびRRパケット内の情報. 再送信を使用すると、転送RTP帯域幅も増加する可能性があり、元のパケット損失がネットワークの輻輳によって引き起こされた場合、パケット損失が増加する可能性があります. ただし、デコーダの状態を修復するための重要な失われたパケットの再送信は、完全なイントラフレームを送信するよりもコストが低くなる可能性があることに注意してください. NACKに応答してRTPパケットを盲目的に再送信することは適切ではありません. RTP再送信を使用する前に、失われたパケットの重要性と、パケットが時間内に到着して有用になる可能性を考慮する必要があります. 

受信者は、SSRC多重化を使用して送信されるRTP再送信パケット[RFC4588]のサポートを実装する必要があります. また、セッション多重化を使用して送信されるRTP再送信パケットもサポートする場合があります. 送信者は、RTP再送信ペイロード形式のサポートがネゴシエートされ、送信者がNACKで参照されるパケットの再送信を送信すると便利であると確信している場合、NACKに応答してRTP再送信パケットを送信できます. 送信者はすべてのNACKされたパケットを再送信する必要はありません. 

6.2. 前方誤り訂正（FEC）
Forward Error Correction（FEC）を使用すると、一定の帯域幅のオーバーヘッドを犠牲にして、ある程度のパケット損失から効果的に保護できます. RTPで使用するために定義されているいくつかのFECスキームがあります. これらのスキームには、特定のRTPペイロード形式に固有のものもあれば、RTPパケット全体で動作し、任意のペイロード形式で使用できるものもあります. 冗長エンコーディングまたはFECを使用すると、再生遅延が増加することに注意してください. FECスキームとそのパラメーターを選択する際には、この遅延を考慮する必要があります. 

WebRTCエンドポイントは、[ID.ietf-rtcweb-fec]で提供されるFECの使用に関する推奨事項に従う必要があります. WebRTCエンドポイントは他のタイプのFECをサポートする場合がありますが、これらは使用する前にネゴシエートする必要があります. 

7. RTPのWebRTCでの使用：レート制御とメディア適応
WebRTCは、有線リンクと無線リンクの両方を含むさまざまなリンクテクノロジーを使用する異種ネットワーク環境で使用され、世界中の潜在的に大規模なユーザーグループを相互接続します. その結果、ユーザー間のネットワークパスには、一方向の遅延、利用可能なビットレート、負荷レベル、およびトラフィックの混合が大きく変動する可能性があります. 個々のエンドポイントは1つ以上のRTPパケットストリームを各参加者に送信でき、複数の参加者が存在する可能性があります. これらの各RTPパケットストリームには、さまざまなタイプのメディアを含めることができ、メディアのタイプ、ビットレート、RTPパケットストリームの数、およびトランスポート層フローは、非常に非対称にすることができます. 非RTPトラフィックは、RTPトランスポート層フローとネットワークパスを共有できます. ネットワーク環境は予測可能または安定していないため、

WebRTCのユーザーのエクスペリエンスの品質は、ネットワークの制限に対するメディアの効果的な適応に大きく依存しています. エンドポイントは、非常に短い時間を除いて、ネットワークパスがサポートできるよりもはるかに多くのデータを送信しないように設計する必要があります. そうしないと、高レベルのネットワークパケット損失または遅延スパイクが発生し、メディア品質が低下します. ネットワークパスの容量を制限する要素は、リンクの帯域幅であるか、リンク上の他のトラフィックとの競合である可能性があります（これは、非WebRTCトラフィック、他のWebRTCフローによるトラフィック、または他のWebRTCフローとの競合である可能性があります）同じセッションで）. 

したがって、効果的なメディア輻輳制御アルゴリズムは、WebRTCフレームワークの重要な部分です. ただし、この記事の執筆時点では、WebRTCのフローなどのインタラクティブメディアアプリケーションに使用できる標準的な輻輳制御アルゴリズムはありません. RTCPeerConnectionsの輻輳制御アルゴリズムのいくつかの要件は、[ID.ietf-rmcat-cc-requirements]で説明されています. これらの要件を満たす標準化された輻輳制御アルゴリズムが将来開発される場合、このメモはその使用を義務付けるように更新する必要があります. 

7.1. 境界条件と回路ブレーカー
WebRTCエンドポイントは、[ID.ietf-avtcore-rtp-circuit-breakers]で説明されているRTP回路ブレーカーアルゴリズムを実装する必要があります. RTP回路ブレーカーは、アプリケーションが極端なネットワーク輻輳の状況を認識してそれに対応できるように設計されています. ただし、RTPサーキットブレーカーは、輻輳が極度に大きくなるまでトリガーされない可能性があるため、輻輳制御の代替と見なすことはできません. また、アプリケーションは輻輳制御を実装して、ネットワーク容量の変化に適応できるようにする必要があります. 標準化された輻輳制御アルゴリズムが利用可能になるまで、輻輳制御アルゴリズムは独自のものでなければなりません. 将来のRTP輻輳制御アルゴリズムは、回路ブレーカーによって許可されたエンベロープ内で動作することが期待されています. 

セッション確立シグナリングは、メディアビットレートが準拠する境界も必ず確立します. メディアコーデックの選択により、アプリケーションが有用な品質を提供するために利用できるサポートされているビットレートの上限と下限、および存在するパケット化の選択肢が提供されます. さらに、シグナリングチャネルは、たとえば、SDP "b = AS："または "b = CT："行とRTP / AVPF一時最大メディアストリームビットレート（TMMBR）要求を使用して、最大メディアビットレート境界を確立できます.  （このメモのセクション5.1.6を参照）. RTPパケットストリームを送信するときは、ピアから受信したSDP "b = AS："または "b = CT："回線などの信号帯域幅制限に従う必要があります. メディアを受信するWebRTCエンドポイントは、帯域幅の制限を通知する必要があります. 

7.2. 輻輳制御の相互運用性とレガシーシステム
WebRTCと相互作用するすべてのエンドポイントは、RTCPを実装し、定義されたRTCPレポートメカニズムを介して輻輳フィードバックを提供する必要があります. 

RTP / AVPプロファイル[RFC3551]を使用してRTCPをサポートする従来の実装と相互作用する場合、RTCP RRパケットで数秒ごとに輻輳フィードバックが提供されます. そのようなエンドポイントと相互作用する必要がある実装は、RTPサーキットブレーカー[ID.ietf-avtcore-rtp-circuit-breakers]制約内に維持して、発生する可能性のある輻輳を制限する必要があります. 

レガシーエンドポイントがRTP / AVPFをサポートしている場合、これにより、「trr-int」パラメーターなどの頻繁なレポートのための重要なパラメーターのネゴシエーションが可能になり、エンドポイントがTMMBR [RFC5104]などの輻輳制御目的でいくつかの有用なフィードバック形式をサポートする可能性があります.  . そのようなエンドポイントと相互作用する必要がある実装は、RTPサーキットブレーカー[ID.ietf-avtcore-rtp-circuit-breakers]制約内に留まり、発生する可能性のある輻輳を制限する必要がありますが、より良い輻輳応答を実現できる場合があります. 利用可能なフィードバックの量に応じて. 

独自の輻輳制御アルゴリズムでは、通信セッションでさまざまなアルゴリズムと実装が相互作用すると、問題が発生する可能性があります. たとえば、1つの送信者ベースと1つの受信者ベースのように、異なる実装が適応のタイプに関して異なる選択をした場合、一方の方向が二重制御され、もう一方の方向が制御されない状況になる可能性があります. このメモは独自の輻輳制御アルゴリズムの動作を義務付けることはできませんが、そのようなアルゴリズムを使用する実装はこの問題を認識し、双方向に流れるメディアに対して効果的な輻輳制御が確実にネゴシエートされるようにする必要があります. IETFがWebRTCトラフィックの送信者ベースと受信者ベースの両方の輻輳制御アルゴリズムを将来的に標準化する場合、相互運用性、制御、

8. RTPのWebRTC使用：パフォーマンス監視
セクション4.1で説明したように、RTPパケットストリームが送受信するRTCP送信者レポート（SR）パケットと受信レポート（RR）パケットを生成する実装が必要です. これらのRTCPレポートには、基本的なパケット損失とジッターの統計情報が含まれているため、パフォーマンスの監視に使用できます. 

RTCP拡張レポート（XR）フレームワークでは、多数の追加のパフォーマンスメトリックがサポートされています. [RFC3611] [RFC6792]を参照してください. この記事の執筆時点では、どの拡張メトリックがWebRTCでの使用に適しているかは明確ではないため、実装でRTCP XRパケットを生成する必要はありません. ただし、詳細なパフォーマンスモニタリングデータを使用できる実装は、必要に応じてRTCP XRパケットを生成する場合があります. RTCP XRパケットの使用は通知されるべきです. 実装は、予期しない、または理解できないRTCP XRパケットを無視する必要があります. 

9. RTPのWebRTC使用：将来の拡張
このメモで指定されたRTPプロトコルとRTP拡張機能のコアセットは、WebRTCの将来のニーズに対して不十分であることが判明する可能性があります. この場合、RTPペイロード形式仕様の作成者向けガイドライン[RFC2736]、RTPペイロード形式の記述方法[ID.ietf-payload-rtp-howto]および拡張に関するガイドラインに従って、このメモの将来の更新を行う必要があります.  RTP制御プロトコル[RFC5968]、およびSHOULDは、RTPおよび開発された関連プロトコルを拡張するための将来のガイドラインを考慮に入れる必要があります. 

将来の拡張機能の作成者は、拡張機能を推奨するときにRTPが使用されるさまざまな環境を検討することをお勧めします. 可能な場合、WebRTCフレームワークは、特定のWebRTCユースケースを対象としたメカニズムを採用するのではなく、一般的なユーティリティであるRTP拡張を採用して、RTPを使用する他のアプリケーションへのゲートウェイを簡単に実装できるようにします. 

10.シグナリングに関する考慮事項
RTPは、外部シグナリングチャネルが存在することを前提に構築されており、RTPセッションとその機能を構成するために使用できます. RTPセッションの基本設定は、次のパラメータで構成されています. 

RTPプロファイル：セッションで使用されるRTPプロファイルの名前. RTP / AVP [RFC3551]およびRTP / AVPF [RFC4585]プロファイルは、安全なバリアントRTP / SAVP [RFC3711]およびRTP / SAVPF [RFC5124]と同様に、基本レベルで相互運用できます. SRTPパケットの認証用の追加ヘッダーフィールドが存在し、ペイロードの暗号化変換が行われるため、プロファイルのセキュアバリアントは非セキュアバリアントと直接相互運用しません. WebRTCはRTP / SAVPFプロファイルを使用する必要があり、これを通知する必要があります. インターワーキング機能は、RTP / SAVPFが使用されていることをWebRTCエンドポイントに示し、4秒のtrr-int値を設定することにより、これをレガシーユースケースのRTP / SAVPプロファイルに変換する場合があります. 

トランスポート情報：RTPおよびRTCPの送信元および宛先IPアドレスとポートは、RTPセッションごとに通知される必要があります. WebRTCでは、これらのトランスポートアドレスはICE [RFC5245]によって提供され、候補を知らせ、指定された候補アドレスのペアに到達します. RTPおよびRTCP多重化[RFC5761]を使用する場合、RTPおよびRTCPフローに単一のポート、つまりトランスポート層フローを使用する場合は、これを通知する必要があります（セクション4.5を参照）. 

RTPペイロードタイプ、メディアフォーマット、およびフォーマットパラメータ：メディアタイプ名（したがって、使用されるRTPペイロードフォーマット）とRTPペイロードタイプ番号の間のマッピングを通知する必要があります. 各メディアタイプには、コーデックとRTPペイロード形式（SDPからの "a = fmtp："行）を構成するために通知する必要があるいくつかのメディアタイプパラメータもある場合があります（MAY）. このメモのセクション4.3では、ペイロードタイプの一意性の要件について説明します. 

RTP拡張：必要なパラメーターを含む、追加のRTPヘッダー拡張とRTCPパケットタイプの使用を通知する必要があります. このシグナリングは、拡張機能のWebRTCエンドポイントの動作、特に送信時の動作が予測可能で一貫していることを確認するためのものです. 堅牢性、およびゲートウェイを介してWebRTCセッションに接続される可能性のある非WebRTCシステムとの互換性のために、不明なRTCPパケットとRTPヘッダー拡張を無視する実装が必要です（セクション4.1も参照）. 

RTCP帯域幅：RTCP帯域幅値をエンドポイントと交換するためのサポートが必要になります. これは、SDPまたは意味的に同等なものを使用する場合は、「RTP制御プロトコル（RTCP）帯域幅のセッション記述プロトコル（SDP）帯域幅修飾子」[RFC3556]の説明に従って行う必要があります. これにより、エンドポイントがRTCP帯域幅の共通のビューを持つことも保証されます. 相互運用性の問題の原因となるRTCPパケットタイミングとタイムアウト間隔の違いを防ぐために、異なるエンドポイント間でのRTCP帯域幅の共通のビューは重要です. 

これらのパラメータは、オファー/アンサー交換で伝えられるSDPメッセージで表現されることがよくあります. RTPはSDPやオファー/アンサーモデルに依存しませんが、必要なすべてのパラメーターについて合意し、RTP実装に提供する必要があります. WebRTCでは、これらのパラメーターの構成方法はシグナリングモデルとAPIによって異なりますが、APIで設定するか、ピア間で明示的にシグナリングする必要があります. 

11. WebRTC APIに関する考慮事項
WebRTC API [W3C.WD-webrtc-20130910]およびMedia Capture and Streams API [W3C.WD-mediacapture-streams-20130903]は、0個以上のMediaStreamTracksで構成されるMediaStreamの概念を定義および使用します. MediaStreamTrackは、マイクやカメラなどのあらゆるタイプのメディアソースからの個別のメディアストリームですが、オーディオミックスやビデオコンポジションなどの概念的なソースも可能です. MediaStream内のMediaStreamTracksは、再生中に同期する必要がある場合があります. 

MediaStreamTrackのRTCPeerConnectionのコンテキストでのRTPでの実現は、RTCPeerConnectionのRTPセッション部分内のSSRCで識別されるソースパケットストリームで構成されます. MediaStreamTrackは、同じRTPセッションで追加のパケットストリーム、つまりSSRCをもたらすこともあります. これらは、MediaStreamTrackに関連付けられたソースストリームのスケーラブルなエンコーディングからの依存パケットストリームである可能性があります（そのようなメディアエンコーダーが使用されている場合）. これらは冗長パケットストリームにすることもできます. これらは、転送エラー訂正（セクション6.2）またはRTP再送信（セクション6.1）をソースパケットストリームに適用するときに作成されます. 

同じメディアソースが複数のMediaStreamTracksにフィードできることに注意することが重要です. MediaStreamTrackにはさまざまな制約やその他のパラメーターのセットを適用できるため、RTCPeerConnectionに追加された各MediaStreamTrackインスタンスは、独自の関連するパケットストリームのセットを備えた独立したソースパケットストリームを生成し、異なるSSRCを生成します. 同じメディアソースを共有する異なるMediaStreamTracks間でソースストリームとエンコーディング構成が同一である場合、適用される制約とパラメーターに依存します. エンコーディングパラメータと制約が同じ場合、実装は1つのエンコードされたストリームのみを使用して異なるRTPパケットストリームを作成することを選択できます. 

同じMediaStreamTrackを複数のMediaStreamsに含めることもできるため、複数のMediaStreamsセットが暗黙的に同じ同期ベースを使用する必要がある場合があります. すべてのケースでこれが機能し、進行中のパケットストリームの配信中に同期ベースとCNAMEを変更してエンドポイントにメディアを中断させないようにするには、同じエンドポイントから発信されたすべてのMediaStreamTracksおよび関連するSSRCを、 1つのRTCPeerConnection内の同じCNAME. これは、セクション4.9で単一のCNAMEの使用を動機付けています. 

同じエンドポイントから発信されるすべてのSSRCに同じCNAMEを使用するという要件では、複数のエンドポイントからのトラフィックを転送するミドルボックスが1つのCNAMEのみを使用する必要はありません. 

セクション4.9で指定されているように、通常は異なるRTCPeerConnectionインスタンスに異なるCNAMEを使用する必要があります. 同じCNAMEで2つの通信セッションを使用すると、異なるサービス全体でユーザーまたはデバイスを追跡できるようになります（詳細については、[ID.ietf-rtcweb-security]のセクション4.4.1を参照してください）. Webアプリケーションは、（同じorignコンテキスト内の）異なるRTCPeerConnectionsで使用されるCNAMEが同じであることを要求できます. これにより、異なるRTCPeerConnections間でエンドポイントのRTPパケットストリームを同期できます. 

注：一致するCNAMEの作成は単一のオリジン内の既存の追跡に依存するため、これは追跡の問題にはなりません. 

上記は現在、1つのRTCPeerConnectionでMediaStreamTrackを受信するWebRTCエンドポイントを強制し、任意のRTCPeerConnectionで発信として追加して、ストリームの再同期を実行します. 送信側はCNAMEを使用するものに変更する必要があるため、同期のタイムベースとしてローカルシステムクロックを使用する必要があることを意味します. したがって、着信ストリームのタイムベースと送出システムの相対的な関係を定義する必要があります. この関係には、クロックドリフトの監視と、同期の調整の可能性もあります. 送信エンティティは、送信されたストリームの輻輳制御も行います. パケット損失の場合、着信データの損失も処理する必要があります. これは、メタが発信ソースパケットストリームで問題または中断を引き起こす可能性が最も低いodは、修復などを含む完全なデコードのモデルであり、続いてメディアを再び発信パケットストリームにエンコードします. この方法の最適化は明らかに可能であり、実装に固有です. 

WebRTCエンドポイントは複数のMediaStreamTracksの受信をサポートする必要があります. 異なるMediaStreamTracks（および関連するパケットストリームのセット）のそれぞれは異なるCNAMEを使用します. ただし、異なるCNAMEで受信されるMediaStreamTracksには、同期が定義されていません. 

注：複数のCNAMEの受信をサポートする動機は、エンドポイントがストリームをリレー/転送するときに、より効率的なストリーム処理を可能にする将来の変更との上位互換性を可能にすることです. また、エンドポイントがWebRTCではない特定のタイプのマルチストリームミドルボックスまたはエンドポイントと相互運用できることも保証します. 

JavaScriptセッション確立プロトコル[ID.ietf-rtcweb-jsep]は、WebRTC MediaStreams、MediaStreamTracks、およびSSRC間のバインディングが「セッション記述プロトコルのクロスセッションストリーム識別」[ID.ietf-mmusic-msid ]. MSIDドキュメント[ID.ietf-mmusic-msid]もセクション4.1で、未知のソースパケットストリームSSRCをMediaStreamTracksおよびMediaStreamsにマッピングする方法を定義しています. これは、レガシー相互運用性のいくつかのケースを処理するために後で関連します. 一般に、着信パケットのRTPペイロードタイプは、パケットストリームがソースストリームであるか、冗長または依存パケットストリームであるかを明らかにします. 正しいソースパケットストリームへの関連付けは、パケットストリームに使用されているペイロード形式によって異なります. 

最後に、この仕様では、WebRTC APIに要件を課して、CSRCリスト（セクション4.1）とミキサーからクライアントへのオーディオレベル（セクション5.2.3）（サポートされている場合）およびこの基本要件を決定する方法を実現しています. セクション12.2.1でさらに議論されます. 

12. RTP実装に関する考慮事項
次の説明は、このメモに記載されているRTP機能の実装に関するガイダンスです. 焦点はWebRTCエンドポイント実装のパースペクティブにあり、ミドルボックスの動作についていくつか言及されていますが、それはこのメモの焦点では​​ありません. 

12.1. RTPセッションの構成と使用
WebRTCエンドポイントは、1つ以上のRTPセッションに同時に参加します. 各RTPセッションは複数のメディアソースを伝達でき、複数のエンドポイントからのメディアデータを含めることができます. 以下では、WebRTCエンドポイントがRTPセッションを構成および使用できるいくつかの方法について概説します. 

12.1.1. RTPセッション内での複数のメディアソースの使用
RTPはグループ通信プロトコルであり、すべてのRTPセッションには複数のRTPパケットストリームが含まれる可能性があります. これが望ましい理由はいくつかあります. 

複数のメディアタイプ：WebRTCの外では、メディアソースのタイプごとに1つのRTPセッションを使用するのが一般的です（たとえば、オーディオソース用に1つ、ビデオソース用に1つ、それぞれ異なるトランスポートレイヤーフローで送信される）. ただし、使用されるUDPポートの数を減らすために、WebRTCのデフォルトでは、セクション4.4で説明されているように、RTPおよびRTCP多重化（セクション4.5）を使用してすべてのタイプのメディアを単一のRTPセッションで送信し、UDPの数をさらに減らします. ポートが必要です. このRTPセッションは、1つの双方向トランスポート層フローのみを使用しますが、それぞれが異なるタイプのメディアを含む複数のRTPパケットストリームを含みます. 一般的な例として、1つのビデオと1つのオーディオの2つのRTPパケットストリームを1つのRTPセッションに送信するカメラとマイクを備えたエンドポイントがあります. 

複数のキャプチャデバイス：WebRTCエンドポイントには複数のカメラ、マイク、またはその他のメディアキャプチャデバイスがあり、同じメディアタイプの複数のRTPパケットストリームを生成する場合があります. または、単一のキャプチャデバイスから複数の異なる形式または品質設定でメディアを一度に送信することもできます. どちらの場合も、1つのエンドポイントが同じメディアタイプの複数のRTPパケットストリームを1つのRTPセッションに同時に送信する可能性があります. 

関連する修復データ：エンドポイントは、別のストリームに何らかの形で関連付けられているRTPパケットストリームを送信する場合があります. たとえば、別のストリームに関連するFECまたは再送信データを含むRTPパケットストリームを送信する場合があります. 一部のRTPペイロード形式は、この種の関連する修復データをソースパケットストリームの一部として送信しますが、別の形式では、個別のパケットストリームとして送信します. 

階層化または複数の記述コーディング：エンドポイントは、H.264 SVCなどの階層化メディアコーデック、または複数のRTPパケットストリームを生成する複数の記述コーデックを使用できます. それぞれが1つのRTPセッション内で異なるRTP SSRCを使用します. 

RTPミキサー、トランスレーター、およびその他のミドルボックス：WebRTCコンテキストでのRTPセッションは、エンドポイントと他のピアデバイス間のポイントツーポイントの関連付けであり、これらのデバイスは共通のSSRCスペースを共有します. ピアデバイスは、別のWebRTCエンドポイントの場合もあれば、RTPミキサー、トランスレータ、その他のメディア処理ミドルボックスの形式の場合もあります. 後者の場合、ミドルボックスは、WebRTCエンドポイントがレンダリングする必要のある混合またはリレーされたRTPストリームを複数の参加者から送信する可能性があります. したがって、WebRTCエンドポイントが単一のRTPセッションのメンバーにすぎない場合でも、ピアデバイスはそのRTPセッションを拡張して他のエンドポイントを組み込む可能性があります. WebRTCはグループ通信環境であり、エンドポイントは、単一のRTPセッションでも、複数のRTPパケットストリームを一度に受信、デコード、および再生できる必要があります. 

12.1.2. 複数のRTPセッションの使用
単一のRTPセッション内で複数のRTPパケットストリームを送受信することに加えて、WebRTCエンドポイントは複数のRTPセッションに参加する場合があります. WebRTCエンドポイントがこれを選択する理由はいくつかあります. 

レガシーデバイスと相互運用するには：非WebRTCの世界での一般的な慣行は、異なるタイプのメディアを別々のRTPセッションで送信することです. たとえば、1つのRTPセッションをオーディオ用に、別のRTPセッションを別のトランスポートレイヤーフローで、ビデオ用に使用します. すべてのWebRTCエンドポイントは、異なるタイプのメディアを異なるRTPセッションで送信するオプションをサポートする必要があるため、そのようなレガシーデバイスと相互運用できます. これについては、セクション4.4で詳しく説明します. 

拡張されたサービス品質を提供するには：一部のネットワークベースのサービス品質メカニズムは、トランスポート層フローの粒度で動作します. これらのメカニズムを使用して一部のRTPパケットストリームに差別化されたサービス品質を提供する必要がある場合、それらのRTPパケットストリームは、適切なサービス品質マーキングを使用して、異なるトランスポート層フローを使用する個別のRTPセッションで送信する必要があります. これについては、セクション12.1.3で詳しく説明します. 

目的の異なるメディアを分離するには：エンドポイントは、ピアデバイスがそれらを簡単に区別できるように、異なるRTPセッションで異なる目的を持つRTPパケットストリームを送信する場合があります. たとえば、一部の集中型マルチパーティ会議システムでは、アクティブスピーカーは高解像度で表示されますが、他の参加者の低解像度の「サムネイル」が表示されます. このようなシステムでは、RTPミドルボックスの操作を簡素化するために、個別のRTPセッションを使用してビデオの高解像度と低解像度の同時放送バージョンを送信するようにエンドポイントを構成する場合があります. WebRTCコンテキストでは、これは現在、1つ（または複数）のRTCPeerConnectionに同じメディアソースを持つ複数のWebRTC MediaStreamTracksを確立することで可能です. 各MediaStreamTrackは、特定のメディア品質、つまりメディアビットレートを提供するように構成されます. そして、そのRTCPeerConnectionのコンテキストで具体的に合意されたコーデックパラメータを使用して、独立してエンコードされたバージョンを生成します. RTPミドルボックスは、SSRC、RTPペイロードタイプ、またはRTPペイロード、RTPヘッダー拡張、またはRTCPパケットに含まれるその他の情報を検査することにより、低解像度ストリームと高解像度ストリームに対応するパケットを区別できますが、RTPを区別する方が簡単です. 個別のトランスポート層フローの個別のRTPセッションに到着した場合のパケットストリーム. 

複数のピアと直接接続するには：マルチパーティの会議でRTPミドルボックスを使用する必要はありません. むしろ、図1に示すように、複数の個別のRTPセッションで構成されるマルチユニキャストメッシュを作成でき、各参加者は個別のRTPセッションを介して（つまり、独立したRTCPeerConnectionオブジェクトを使用して）RTPトラフィックを他のすべての参加者に送信します. トポロジには、メディアデータにアクセスして操作するために信頼されているRTPミドルボックスノードを必要としないという利点があります. 欠点は、送信者自体を超えて同じセッションの一部である各参加者に対してRTPパケットストリームの1つのコピーを要求することにより、各送信者で使用される帯域幅を増やすことです. 

   + --- + + --- +
   | A | <---> | B |
   + --- + + --- +
     ^ ^
      \ /
       \ /
        vv
        + --- +
        | C |
        + --- +
        
図1：複数のRTPセッションを使用したマルチユニキャスト

マルチユニキャストトポロジは、複数のピアツーピアトランスポート層接続にまたがる単一のRTPセッションとして実装することも、ピアの各ペア間に1つずつ存在する複数のペアワイズRTPセッションとして実装することもできます. RTPセッションとRTCPeerConnectionオブジェクト間の関係の整合性のあるマッピングを維持するには、これを複数の個別のRTPセッションとして実装することをお勧めします. 唯一の欠点は、BとCの間のRTPセッションのRTCPレポートが表示されないため、エンドポイントAがBとCの間で発生する伝送の品質を認識しないことです.  RTPセッション. Mboneツール（1990年代後半の実験的なRTPベースのマルチキャスト会議ツール）の経験から、サードパーティのRTCP受信品質レポートは、非対称ネットワークの問題と、個別のネットワークを使用するアプローチを理解するのに役立つ方法でユーザーに提示できることが示されていますRTPセッションはこれを防ぎます. ただし、個別のRTPセッションを使用する利点は、異なるピア間で異なるメディアビットレートとRTPセッション構成を使用できるため、AからCへの転送に制限がある場合、Bに同じ品質の低下に耐えさせないことです.  Cします. これらの利点は、デバッグ能力の制限を上回ると考えられています. 個別のRTPセッションを使用する利点は、異なるピア間で異なるメディアビットレートとRTPセッション構成を使用できるため、AからCへの転送に制限がある場合、Cが行うようにBに同じ品質の低下に耐えさせないことです.  . これらの利点は、デバッグ能力の制限を上回ると考えられています. 個別のRTPセッションを使用する利点は、異なるピア間で異なるメディアビットレートとRTPセッション構成を使用できるため、AからCへの転送に制限がある場合、Cが行うようにBに同じ品質の低下に耐えさせないことです.  . これらの利点は、デバッグ能力の制限を上回ると考えられています. 

複数のピアと間接的に接続するには：マルチパーティ会議の一般的なシナリオは、RTPミキサー、トランスレータ、またはその他のタイプのRTPミドルボックスを使用して、複数のピアへの間接的な接続を作成することです. 図2は、4人集中会議で使用される可能性のある単純なトポロジの概要を示しています. ミドルボックスは、受信したRTPパケットストリームの一部のみを特定のレシーバーに送信するか、関連する一連のストリームから組み合わされたRTPパケットストリームを提供することにより、RTPパケットストリームの送信を特定の観点から最適化するように機能します. 

   + --- + + ------------- + + --- +
   | A | <----> | | <----> | B |
   + --- + | RTPミキサー| + --- +
              | 翻訳者|
              | またはその他|
   + --- + | ミドルボックス| + --- +
   | C | <----> | | <----> | D |
   + --- + + ------------- + + --- +
        
図2：ユニキャストパスのみのRTPミキサー

ミドルボックスの実装にはさまざまな方法があります. 標準のRTPミキサーまたはトランスレーターとして実装されている場合、単一のRTPセッションがミドルボックス全体に拡張され、すべてのエンドポイントが1つのマルチパーティセッションに含まれます. 他のタイプのミドルボックスは、各エンドポイントとミドルボックスの間で個別のRTPセッションを使用する場合があります. 共通の側面は、これらのRTPミドルボックスがいくつかのツールを使用して、WebRTCエンドポイントによって提供されるメディアエンコーディングを制御できることです. これには、エンコードチェーンの解除を要求する機能や、エンコーダーにいわゆるイントラフレームを生成させる機能が含まれます. 別の方法は、特定のストリームのビットレートを制限して、複数のダウンストリームのミキサービューに適するようにします. その他は、最も適切なフレームレート、画像解像度、フレームレートと空間品質のトレードオフを制御しています. ミドルボックスは、アプリケーションに適切なメディア最適化を提供しながら、輻輳制御、ソース識別、同期管理を正しく実行する責任があります. ミドルボックスは、セキュリティに関しては信頼できるノードである必要があります. これは、エンドポイントに送信する前に、1つのエンドポイントから受信したRTPヘッダーまたはメディア自体（または両方）を操作するため、 RTPパケットストリームを送信する前に、復号化してから再暗号化できます. 

RTPミキサーは、エンドポイントが2つだけのセッションと複数のRTPセッションの間にセッションが発生する状況を作成できます. ミキサーは、RTPパケットストリームに関するRTCPレポートを転送しないことが期待されます. これは、さまざまなエンドポイントに提供されるRTPパケットストリームの違いによるものです. 元のメディアソースには、さまざまなレシーバーに送信する前のミキサーの操作に関する情報がありません. このシナリオでは、エンドポイントのフィードバックまたはリクエストがミキサーに送られることにもなります. ミキサー自体がこれに対応できない場合は、レシーバーの要求を満たすために、元のメディアソースに移動する必要があります. これは必ずしもすべてのRTPおよびRTCPトラフィックに明示的に表示されるわけではありませんが、相互作用とそれらを完了する時間はそのような依存関係を示します. 

マルチパーティのシナリオでソース認証を提供することは困難です. ミキサーベースのトポロジでは、エンドポイントのソース認証は、最初にメディアが暗号化検証によってミキサーからのものであることの検証に基づいており、次にミキサーを信頼して、エンドポイントに向かうソースを正しく識別します. 複数のエンドポイントがエンドポイントに直接表示されるRTPセッションでは、すべてのエンドポイントが互いのマスターキーについて認識しているため、セッション内の別のエンドポイントから送信されたと主張するパケットを注入できます. リレーを実行するすべてのノードは、以前に他のエンドポイントから送信されたSSRCフィールドを持つパケットの転送を防ぐことにより、非暗号化の軽減を実行できます. ソースの暗号検証では、SRTPは追加のセキュリティメカニズムを必要とします. たとえば、SRTPのTESLA [RFC4383]、

複数のピア間でメディアを転送するには：RTPパケットストリームを受信するエンドポイントがそのRTPパケットストリームをサードパーティに転送できることが望ましい場合があります. これは、これをサポートする上でのいくつかの明らかなセキュリティとプライバシーの影響ですが、潜在的な用途もあります. これは、受信およびデコードされたメディアを取得し、新しいストリームとして再エンコードおよび送信されるメディアソースとして使用することにより、W3C APIでサポートされています. 

RTP層では、メディア転送はバックツーバックRTPレシーバーおよびRTPセンダーとして機能します. 受信側はRTPセッションを終了してメディアをデコードし、送信側は完全に別のRTPセッションを使用してメディアを再エンコードして送信します. 転送されたメディアの送信に使用されるRTPセッションがRTPセッションに接続されていないため、元の送信者はメディアの単一の受信者のみを参照し、RTPレイヤー情報に基づいて転送が行われていることを通知できませんメディアは、転送を実行するノードによって受信されました. 

転送を実行しているエンドポイントは、以降の送信に適したRTPパケットストリームを生成する責任があります. 転送されたメディアの送信に使用される発信RTPセッションは、メディアが受信されたRTPセッションとは完全に別のものです. これには、輻輳制御の目的でメディアトランスコーディングが必要です. これにより、発信RTPセッションに適切なビットレートが生成され、メディア品質が低下し、転送エンドポイントがリソースをトランスコーディングに費やすようになります. メディアトランスコーディングにより、2つの異なるレッグが分離され、ほぼすべての依存関係が削除され、転送エンドポイントがメディアトランスコーディング操作を最適化できるようになります. コストは、転送ノードの計算の複雑さを大幅に増加させます. 

12.1.3. RTPストリームの差別化された処理
RTPパケットストリームの差別化された処理の使用例があります. このような区別は、システムのいくつかの場所で発生する可能性があります. まず第一に、メディアを送信するエンドポイント内の優先順位付けです. メディアは、送信するRTPパケットストリームと、輻輳制御によって決定された現在利用可能な集約からのビットレートの割り当ての両方を制御します. 

WebRTC API [W3C.WD-webrtc-20130910]により、アプリケーションが異なるMediaStreamTracksの相対的な優先順位を示すことができるようになることが期待されています. これらの優先順位は、RTPパケットストリーム間で利用可能な帯域幅を分割する方法で特に輻輳制御応答に関して、ローカルRTP処理に影響を与えるために使用できます. RTP再送信やFECの冗長ストリームなど、メインRTPパケットストリームに関連付けられているRTPパケットストリームについても、相対的な優先度の変更を考慮する必要があります. そのような冗長なRTPパケットストリームの重要性は、コーデックがパケット損失に対してどの程度堅牢であるかに関して、使用されるメディアタイプとコーデックに依存します. ただし、デフォルトのポリシーでは、冗長RTPパケットストリームに対して、ソースRTPパケットストリームと同じ優先順位を使用する場合があります. 

次に、ネットワークは、RTPパケットストリームを含むトランスポートレイヤーフローとサブフローを優先できます. 通常、差分処理には2つのステップが含まれます. 最初のステップは、IPパケットが別の方法で処理する必要があるクラスに属しているかどうかを識別することです. IPパケットを分類する3つの一般的な方法は次のとおりです. 

DiffServ：エンドポイントは、パケットがDiffServコードポイントでマークされ、パケットが特定のクラスに属していることをネットワークに示します. 

フローベース：特定の処理を行う必要があるパケットは、IPとポートアドレスの組み合わせを使用して識別されます. 

ディープパケットインスペクション：ネットワーク分類（DPI）はパケットを検査し、パケットが特定のアプリケーションと優先されるタイプであるかどうかを判断しようとします. 

フローベースの差別化は、トランスポート層フロー内のすべてのパケットに同じ処理を提供します. つまり、相対的な優先順位付けは不可能です. さらに、リソースが限られている場合、WebRTCセッションで使用されるすべてのRTPパケットストリームのベストエフォートと比較して、差別的な扱いを提供することができない場合があります. フローベースの差別化の使用は、WebRTCシステムとネットワークの間で調整する必要があります. WebRTCエンドポイントは、フローベースの差別化を使用して、RTPパケットストリームをさまざまなUDPフローに分離し、フローベースの差別化をより細かく使用できるようにする必要があることを認識する必要があります. 使用されたフロー、それらの5タプル、および優先順位付けは、優先順位付けを有効にするためにフローを正しく識別できるように、ネットワークに伝達される必要があります. 

DiffServは、エンドポイントまたは分類子のいずれかがパケットを適切なDSCPでマークできるため、パケットがそのマーキングに従って処理されると想定しています. エンドポイントがトラフィックにマークを付ける場合、WebRTCコンテキストで2つの要件が発生します. 1）WebRTCエンドポイントは、使用するDSCPと、RTPパケットストリームのセットでそれらを使用できることを知っている必要があります. 2）パケットを送信するときに、情報をオペレーティングシステムに伝達する必要があります. このプロセスの詳細はこのメモの範囲外であり、「RTCWeb QoSのDSCPおよびその他のパケットマーキング」[ID.ietf-tsvwg-rtcweb-qos]でさらに説明されています. 

ディープパケットインスペクターは、SRTPメディア暗号化にもかかわらず、RTPストリームを分類するのにかなりの能力があります. その理由は、SRTPがRTPヘッダーの最初の12バイトを暗号化しないままにするためです. これにより、SSRCを使用してRTPストリームを簡単に識別できるようになり、たとえばストリームのメディアタイプを判別するために関連付けることができる有用な情報が分類子に提供されます. パケットサイズ、受信時間、パケットの間隔、RTPタイムスタンプの増分、およびシーケンス番号を使用して、かなり信頼できる分類が実現されます. 

パケットベースのマーキングスキームの場合、RTPペイロードの相対的な優先度に基づいて、個別のRTPパケットに異なるマークを付けることが可能です. たとえば、I、P、およびBピクチャを含むビデオコーデックは、Bフレームのみを運ぶペイロードを優先することができます. ただし、QoSメカニズムと適用されるマーキングによっては、これによりパケットドロップの確率が異なるだけでなく、パケットの順序も変わる可能性があります. [ID.ietf-tsvwg-rtcweb-qos]および[ID.ietf-dart-dscp -rtp]詳細については. デフォルトのポリシーとして、RTPパケットストリームに関連するすべてのRTPパケットに同じ優先順位を付ける必要があります. 

パケットごとの優先順位付けはこのメモの範囲外ですが、将来、他の場所で指定される可能性があります. 

特定のRTPパケットストリームに関連付けられたRTCPパケットをどのようにマークする必要があるかを考慮することも重要です. 送信者レポート（SR）を含むRTCP複合パケットは、RTPパケットストリーム自体と同じ優先度でマークする必要があります. そのため、RTCPベースのラウンドトリップ時間（RTT）測定は、同じトランスポートレイヤーフロー優先度を使用して行われます.  RTPパケットストリームエクスペリエンス. RRパケットを含むRTCP複合パケットは、報告されたRTPパケットストリームの大部分が使用する優先順位で送信する必要があります. タイムクリティカルなフィードバックパケットを含むRTCPパケットは、より高い優先度を使用して、そのようなフィードバックの配信の適時性と可能性を向上させることができます. 

12.2. メディアソース、RTPストリーム、および参加者の識別
12.2.1. メディアソースの識別
各RTPパケットストリームは、一意の同期ソース（SSRC）識別子によって識別されます. SSRC識別子は、RTPパケットストリームを構成する各RTPパケットで伝送され、対応するRTCPレポートでそのストリームを識別するためにも使用されます. SSRCは、セクション4.8で説明されているように選択されます. WebRTCエンドポイントで単一のトランスポート層フローで受信されたRTPおよびRTCPパケットを逆多重化する最初の段階は、SSRC値に基づいてRTPパケットストリームを分離することです. それが完了すると、追加の逆多重化手順で、メディアをレンダリングする方法と場所を決定できます. 

RTPを使用すると、ミキサーまたはその他のRTPレイヤーミドルボックスで、複数のメディアソースからのエンコードされたストリームを組み合わせて、新しいメディアソース（ミキサー）からの新しいエンコードされたストリームを形成できます. その新しいRTPパケットストリームのRTPパケットには、元のSSRCが結合されたソースストリームに寄与したことを示す寄与元（CSRC）リストを含めることができます. セクション4.1で説明したように、実装では、CSRCリストを含むRTPデータパケットと、CSRCリストに存在するソースに関連するRTCPパケットの受信をサポートする必要があります. CSRCリストは、実行されるミキシング操作に応じて、パケットごとに変更できます. ユーザーインターフェイスがセッションでアクティブな参加者を示している場合、特定のRTPパケットの原因となったメディアソースを知ることは重要です. アプリケーションがセッション参加の変更を追跡できるようにする場合は、パケットに含まれるCSRCリストの変更を、何らかのAPIを使用してWebRTCアプリケーションに公開する必要があります. SSRC / CSRC名前空間がWebRTCアプリケーションに公開されないようにするには、CSRC値をこのAPIを通過するときにWebRTC MediaStreamアイデンティティにマッピングすることが望ましいです. 

ミキサーからクライアントへのオーディオレベル拡張[RFC6465]がセッションで使用されている場合（セクション5.2.3を参照）、CSRCリストの情報

貢献している各ソースの音声レベル情報が追加されます. CSRC値をWebRTC MediaStream IDにマッピングした後、APIを使用してこの情報をWebRTCアプリケーションに公開し、ユーザーインターフェイスで公開できるようにすることが望ましいです. 

12.2.2. SSRC衝突検出
RTP標準では、RTP実装がSSRC衝突の検出と処理をサポートする必要があります. つまり、2つの異なるエンドポイントが同じSSRC値を使用する場合の競合を解決します（[RFC3550]のセクション8.2を参照）. この要件は、WebRTCエンドポイントにも適用されます. SSRCの衝突が発生する可能性のあるシナリオがいくつかあります. 

o各SSRCが2つのエンドポイントのいずれかに関連付けられ、SSRC識別子を伝えるメインメディアがシグナリングチャネルでアナウンスされるポイントツーポイントセッションでは、使用されたSSRCに関する情報が原因で衝突が発生する可能性が低くなります.  . SDPが使用される場合、この情報はソース固有のSDP属性[RFC5576]によって提供されます. それでも、ピアにそれをシグナリングし、シグナリングメッセージで確認応答を受信する前に、両方のエンドポイントが新しいSSRC識別子の使用を開始すると、衝突が発生する可能性があります. ソース固有のSDP属性[RFC5576]には、エンドポイントがどのようにSSRC衝突を解決したかを通知するメカニズムが含まれています. 

o通知されていないSSRC値は、RTPセッションにも表示される可能性があります. 一部のRTP機能は追加のSSRCを使用して機能を提供するため、これは見かけよりも可能性が高くなります. たとえば、再送信データは、ソースRTPパケットストリームの[SSRC]とは別に、独自のSSRCを必要とする別のRTPパケットストリームを使用して送信される場合があります[RFC4588]. これらの場合、エンドポイントは、RTPレベルとRTCPeerConnectionレベルの両方で正しく機能するために、シグナリングチャネルを介して厳密にアナウンスされる必要がない新しいSSRCを作成できます. 

oマルチパーティ会議の複数のエンドポイントは、新しいソースを作成し、RTPミドルボックスに向けて信号を送ることができます. SSRC / CSRCがRTPミドルボックスの衝突から異なるエンドポイント間で伝搬される場合、衝突が発生する可能性があります. 

o RTPミドルボックスは、エンドポイントのRTCPeerConnectionを同じエンドポイントから別のRTCPeerConnectionに接続し、エンドポイントが独自のトラフィックを受信するループを形成します. 明らかにバグと見なされますが、エンドポイントが発生時にケースを認識して処理できることが重要です. このケースは、受信されたストリームが別のストリームであるにもかかわらず、このクライアントの入力がまだ含まれているメディアミキサーなどが関係している場合、さらに問題になります. 

これらのSSRC / CSRC衝突は、RTPミドルボックスによって同じRTPセッションが複数のRTCPeerConnectionsに拡張されている限り、RTPレベルでのみ処理できます. 複数のRTCPeerConnectionsが相互接続されているより一般的なケースを解決するには、相互接続された複数のRTCPeerConnection間で伝達されるMediaStreamTrackのメディアソース部分の識別を、これらの相互接続間で保持する必要があります. 

12.2.3. メディア同期コンテキスト
エンドポイントが複数のメディアソースからメディアを送信する場合、これらのメディアソースを同期するかどうか（およびそのどれを同期するか）を検討する必要があります. RTP / RTCPでは、RTPパケットストリームのセットを、同じRTCP CNAME識別子を使用して同じ同期コンテキストと論理エンドポイントから送信されるものとして示すことで、同期が提供されます. 

次の規定は、すべてのメディアソースの内部クロック、つまり、RTPタイムスタンプを駆動するものを、NTP形式でエンコードされたRTCP送信者レポートで提供されるシステムクロックに関連付けることができることです. すべてのRTPタイムスタンプをすべてのソースの共通のシステムクロックに関連付けることにより、さまざまなRTPパケットストリームのタイミング関係を複数のRTPセッションにわたって受信側で導出でき、必要に応じてストリームを同期できます. 要件は、メディア送信者が相関情報を提供することです. それを使用するかどうかは受信機次第です. 

13.セキュリティに関する考慮事項
WebRTCの全体的なセキュリティアーキテクチャは[ID.ietf-rtcweb-security-arch]で説明されており、WebRTCフレームワークのセキュリティに関する考慮事項は[ID.ietf-rtcweb-security]で説明されています. これらの考慮事項は、このメモにも適用されます. 

RTP仕様、RTP / SAVPFプロファイル、およびこのメモで説明されている完全なプロトコルスイートを形成するさまざまなRTP / RTCP拡張機能とRTPペイロード形式のセキュリティに関する考慮事項が適用されます. これらのさまざまなプロトコル拡張の組み合わせから生じる新しいセキュリティの考慮事項があるとは考えられていません. 

リアルタイムトランスポートコントロールプロトコル（RTCP）ベースのフィードバックの拡張セキュアRTPプロファイル[RFC5124]（RTP / SAVPF）は、機密性、整合性、および部分的なソース認証を提供することにより、基本的な問題の処理を提供します. [ID.ietf-rtcweb-security-arch]のセクション5.5で定義されているように、このセキュリティで保護されたRTPプロファイルとDTLS-SRTPキーイング[RFC5764]を組み合わせることにより、メディアセキュリティソリューションを実装および使用するために必須です. 

RTCPパケットは、関連するRTPセッション間で同期する必要があるRTPパケットストリームを関連付けるために使用される正規名（CNAME）識別子を伝達します. 複数のWebRTC呼び出しにわたってユーザーを追跡するために長期間の永続的なCNAME識別子を使用できるため、CNAME値の不適切な選択はプライバシーの問題になる可能性があります. このメモのセクション4.9は、RFC7022で指定されているように、短期の永続的なRTCP CNAMESの生成を義務付けており、このリスクを軽減する追跡不可能なCNAME値をもたらします. 

RTCPレポート間隔が不適切な値に設定されている場合、サービス拒否攻撃の可能性があります. これは、SDP "b = RR："または "b = RS："行[RFC3556]または同様のメカニズムを使用して、RTCP帯域幅の割合を過度に大きいまたは小さい値に構成するか、過度に大きいまたはRTP / AVPF最小受信者レポート間隔の小さな値（SDPを使用している場合、これは「a = rtcp-fb：... trr-int」パラメーターです）[RFC4585]. リスクは次のとおりです. 

1. RTCP帯域幅を設定して、定期的なレポート間隔を非常に大きくして、効果的な輻輳制御を維持できず、メディアトラフィックによる輻輳が原因でサービス拒否を引き起こす可能性があります. 

2. RTCP間隔を非常に小さい値に設定すると、エンドポイントで高レートのRTCPトラフィックが生成され、非輻輳制御のRTCPトラフィックが原因でサービス拒否が発生する可能性があります. そして

3. RTCPパラメータは、エンドポイントごとに異なるように設定できます. 一部のエンドポイントは大きなレポート間隔を使用し、一部は短い間隔を使用するため、レポートに基づくタイムアウト期間の不一致が原因で、早期の参加者タイムアウトによりサービス拒否が発生します.  [ID.ietf-avtcore-rtp-のセクション6.1で説明されているように、これはエンドポイントがRTP / AVPF最小レシーバーレポート間隔（trr-int）[RFC4585]に小さいがゼロ以外の値を使用する場合に特に問題になります. マルチストリーム]）. 

参加者のタイムアウトを計算するときに固定（非短縮）の最小間隔を使用することで、早期の参加者のタイムアウトを回避できます（このメモのセクション4.1および[ID.ietf-avtcore-rtp-multi-stream]のセクション6.1を参照）. 他の懸念に対処するために、エンドポイントは、RTCPレポート間隔を[RFC3550]で指定されているデフォルトの5秒間隔よりも大幅に長く設定するパラメーターを無視する必要があります（メディアデータレートが非常に低く、長いレポート間隔がおおよそ5％に対応する場合を除く）メディアデータレートの）、またはRTCP帯域幅がメディア帯域幅を超えるほど小さいRTCPレポート間隔を設定します. 

[RFC6562]のガイドラインは、Opusなどの可変ビットレート（VBR）オーディオコーデックを使用する場合に適用されます（必須のオーディオコーデックについては、セクション4.3を参照）. [RFC6562]のガイドラインも適用されますが、クライアントからミキサーへのオーディオレベルヘッダー拡張（セクション5.2.2）またはミキサーからクライアントへのオーディオレベルヘッダー拡張（セクション5.2.3）を使用する場合は、それほど重要ではありません.  . RTPミドルボックスが音声アクティビティベースのソース選択を実行する、または情報から大きなメリットを得るサードパーティのモニタリングを実行するなどの既知の理由がない限り、ヘッダー拡張の暗号化の使用は推奨され、これはAPIまたはシグナリングを使用して表現されています. オーディオレベルの表示からの情報漏えいが重大であることを示すさらなる証拠が生成される場合は、その時点で暗号化の使用を義務付ける必要があります. 

RTPミドルボックスを使用するマルチパーティ通信シナリオでは、セッションのセキュリティを維持するために、これらのミドルボックスに多くの信頼が置かれます. ミドルボックスは、機密性と整合性を維持し、ソース認証を実行する必要があります. セクション12.1.1で説明したように、ミドルボックスは、会議に参加しているエンドポイントが他のユーザーになりすますことを防ぐチェックを実行できます. マルチパーティトポロジに関するセキュリティに関するその他の考慮事項は、[ID.ietf-avtcore-rtp-topologies-update]にあります. 

14. IANAに関する考慮事項
このメモはIANAに要求するものではありません. 

RFCエディタへの注意：このセクションは、RFCとしての公開時に削除されます. 

15.謝辞
著者は、バーナードアボバ、ハラルドアルヴェストランド、キャリーブラン、ベンキャンベル、アリッサクーパー、スペンサードーキンス、チャールズエケル、アレックスエレフテリアディス、クリスチャングローブス、クリスイナシオ、カレンジェニングス、オルレヨハンソン、スハスナンダクマール、ダンローマスカヌ、ジムスプリングに感謝します、Martin Thomson、およびIETF RTCWEBワーキンググループの他のメンバーから貴重なフィードバックをいただきました. 

16.参考文献
16.1. 規範的な参考文献
[ID.ietf-avtcore-multi-media-rtp-session] Westerlund、M.、Perkins、C. 、およびJ. Lennox、「単一のRTPセッションでの複数のタイプのメディアの送信」、draft-ietf-avtcore-multi -media-rtp-session-13（作業中）、2015年12月. 

[ID.ietf-avtcore-rtp-circuit-breakers] Perkins、C. およびV. Varun、「Multimedia Congestion Control：Circuit Breakers for Unicast RTP Sessions」、draft-ietf-avtcore-rtp-circuit-breakers-13（work進行中）、2016年2月. 

[ID.ietf-avtcore-rtp-multi-stream] Lennox、J.、Westerlund、M.、Wu、Q. 、およびC. Perkins、「単一のRTPセッションでの複数のRTPストリームの送信」、draft-ietf-avtcore -rtp-multi-stream-11（作業中）、2015年12月. 

[ID.ietf-avtcore-rtp-multi-stream-optimization] Lennox、J.、Westerlund、M.、Wu、Q. 、およびC. Perkins、「単一のRTPセッションでの複数のRTPストリームの送信：RTCP受信統計のグループ化およびその他のフィードバック」、draft-ietf-avtcore-rtp-multi-stream-optimization-12（作業中）、2016年3月. 

[ID.ietf-avtcore-rtp-topologies-update] Westerlund、M. およびS. Wenger、「RTPトポロジ」、draft-ietf-avtcore-rtp-topologies-update-10（作業中）、2015年7月. 

[ID.ietf-mmusic-mux-exclusive] Holmberg、C. 、「SDPを使用したRTP / RTCP多重化の排他的サポートを示す」、draft-ietf-mmusic-mux-exclusive-03（作業中）、2016年2月. 

[ID.ietf-mmusic-sdp-bundle-negotiation] Holmberg、C.、Alvestrand、H. 、およびC. Jennings、「Session Description Protocol（SDP）を使用したメディア多重化のネゴシエーション」、draft-ietf-mmusic-sdp- bundle-negotiation-27（進行中の作業）、2016年2月. 

[ID.ietf-rtcweb-audio] Valin、J. およびC. Bran、「WebRTCオーディオコーデックおよび処理要件」、draft-ietf-rtcweb-audio-10（作業中）、2016年2月. 

[ID.ietf-rtcweb-fec] Uberti、J. 、「WebRTC Forward Error Correction Requirements」、draft-ietf-rtcweb-fec-02（作業中）、2015年10月. 

[ID.ietf-rtcweb-overview] Alvestrand、H. 、「Overview：Real Time Protocols for Browser-based Applications」、draft-ietf-rtcweb-overview-15（作業中）、2016年1月. 

[ID.ietf-rtcweb-security] Rescorla、E. 、「WebRTCのセキュリティに関する考慮事項」、draft-ietf-rtcweb-security-08（作業中）、2015年2月. 

[ID.ietf-rtcweb-security-arch] Rescorla、E. 、「WebRTC Security Architecture」、draft-ietf-rtcweb-security-arch-11（作業中）、2015年3月. 

[ID.ietf-rtcweb-video] Roach、A. 、「WebRTCビデオ処理およびコーデックの要件」、draft-ietf-rtcweb-video-06（作業中）、2015年6月. 

[RFC2119] Bradner、S. 、「要件レベルを示すためにRFCで使用するキーワード」、BCP 14、RFC 2119、DOI 10.17487 / RFC2119、1997年3月、<http://www.rfc-editor.org/info/ rfc2119>. 

[RFC2736] Handley、M. およびC. Perkins、「RTPペイロード形式仕様の作成者向けガイドライン」、BCP 36、RFC 2736、DOI 10.17487 / RFC2736、1999年12月、<http://www.rfc-editor.org/ info / rfc2736>. 

[RFC3550] Schulzrinne、H.、Casner、S.、Frederick、R. 、およびV. Jacobson、「RTP：A Transport Protocol for Real-Time Applications」、STD 64、RFC 3550、DOI 10.17487 / RFC3550、2003年7月、 <http://www.rfc-editor.org/info/rfc3550>. 

[RFC3551] Schulzrinne、H. およびS. Casner、「Minimal Controlを使用したオーディオおよびビデオ会議のRTPプロファイル」、STD 65、RFC 3551、DOI 10.17487 / RFC3551、2003年7月、<http：//www.rfc-editor.  org / info / rfc3551>. 

[RFC3556] Casner、S. 、「RTP制御プロトコル（RTCP）帯域幅のセッション記述プロトコル（SDP）帯域幅修飾子」、RFC 3556、DOI 10.17487 / RFC3556、2003年7月、<http://www.rfc-editor.org / info / rfc3556>. 

[RFC3711]バウアー、M. 、マクルー、D. 、ナスルンド、M. 、カララ、E. 、およびK.ノーマン、「Secure Real-time Transport Protocol（SRTP）」、RFC 3711、DOI 10.17487 / RFC3711、3月2004、<http://www.rfc-editor.org/info/rfc3711>. 

[RFC4566] Handley、M.、Jacobson、V. 、およびC. Perkins、「SDP：Session Description Protocol」、RFC 4566、DOI 10.17487 / RFC4566、2006年7月、<http://www.rfc-editor.org/ info / rfc4566>. 

[RFC4585] Ott、J.、Wenger、S.、Sato、N.、Burmeister、C. 、およびJ. Rey、「​​リアルタイム転送制御プロトコル（RTCP）ベースのフィードバック用の拡張RTPプロファイル（RTP / AVPF） "、RFC 4585、DOI 10.17487 / RFC4585、2006年7月、<http://www.rfc-editor.org/info/rfc4585>. 

[RFC4588]レイ、J. 、レオン、D. 、宮崎、A. 、ヴァルサ、V. 、およびR.ハケンバーグ、「RTP Retransmission Payload Format」、RFC 4588、DOI 10.17487 / RFC4588、2006年7月、<http：/ /www.rfc-editor.org/info/rfc4588>. 

[RFC4961] Wing、D. 、「Symmetric RTP / RTP Control Protocol（RTCP）」、BCP 131、RFC 4961、DOI 10.17487 / RFC4961、2007年7月、<http://www.rfc-editor.org/info/rfc4961 >. 

[RFC5104] Wenger、S.、Chandra、U.、Westerlund、M. 、およびB. Burman、「フィードバック付きのRTPオーディオビジュアルプロファイルのコーデック制御メッセージ（AVPF）」、RFC 5104、DOI 10.17487 / RFC5104、2月2008、<http://www.rfc-editor.org/info/rfc5104>. 

[RFC5124] Ott、J. およびE. Carrara、「リアルタイム転送制御プロトコル（RTCP）ベースのフィードバック用の拡張セキュアRTPプロファイル（RTP / SAVPF）」、RFC 5124、DOI 10.17487 / RFC5124、2008年2月、<http ：//www.rfc-editor.org/info/rfc5124>. 

[RFC5285] Singer、D. およびH. Desineni、「一般的なRTPヘッダー拡張メカニズム」、RFC 5285、DOI 10.17487 / RFC5285、2008年7月、<http://www.rfc-editor.org/info/rfc5285> . 

[RFC5506] Johansson、I. およびM. Westerlund、「Reduced-Size Real-Time Transport Control Protocol（RTCP）：Opportunities and Consequences」、RFC 5506、DOI 10.17487 / RFC5506、2009年4月、<http：// www .rfc-editor.org / info / rfc5506>. 

[RFC5761] Perkins、C. およびM. Westerlund、「Multiplexing RTP Data and Control Packets on a Single Port」、RFC 5761、DOI 10.17487 / RFC5761、2010年4月、<http://www.rfc-editor.org/info / rfc5761>. 

[RFC5764] McGrew、D. およびE. Rescorla、「Secure Real-time Transport Protocol（SRTP）のキーを確立するためのデータグラムトランスポート層セキュリティ（DTLS）拡張」、RFC 5764、DOI 10.17487 / RFC5764、2010年5月、<http ：//www.rfc-editor.org/info/rfc5764>. 

[RFC6051] Perkins、C. およびT. Schierl、「RTPフローの迅速な同期」、RFC 6051、DOI 10.17487 / RFC6051、2010年11月、<http://www.rfc-editor.org/info/rfc6051>. 

[RFC6464] Lennox、J.、Ed. 、Ivov、E. 、およびE. Marocco、「クライアントからミキサーへのオーディオレベル表示のた​​めのリアルタイム転送プロトコル（RTP）ヘッダー拡張」、RFC 6464、DOI 10.17487 / RFC6464、2011年12月、<http://www.rfc-editor.org/info/rfc6464>. 

[RFC6465] Ivov、E.、Ed. 、Marocco、E.、Ed. 、およびJ. Lennox、「ミキサーからクライアントへのオーディオレベル表示のた​​めのリアルタイムトランスポートプロトコル（RTP）ヘッダー拡張」、RFC 6465、 DOI 10.17487 / RFC6465、2011年12月、<http://www.rfc-editor.org/info/rfc6465>. 

[RFC6562]パーキンス、C. およびJM. Valin、「Secure RTPでの可変ビットレートオーディオの使用に関するガイドライン」、RFC 6562、DOI 10.17487 / RFC6562、2012年3月、<http://www.rfc-editor.org/info/rfc6562>. 

[RFC6904] Lennox、J. 、「Secure Real-time Transport Protocol（SRTP）のヘッダー拡張の暗号化」、RFC 6904、DOI 10.17487 / RFC6904、2013年4月、<http://www.rfc-editor.org/ info / rfc6904>. 

[RFC7007] Terriberry、T. 、「Minimal Control（RTP / AVP）を使用したオーディオおよびビデオ会議のRTPプロファイルの推奨コーデックからDVI4を削除するための更新」、RFC 7007、DOI 10.17487 / RFC7007、2013年8月、<http： //www.rfc-editor.org/info/rfc7007>. 

[RFC7022] Begen、A.、Perkins、C.、Wing、D. 、およびE. Rescorla、「RTP制御プロトコル（RTCP）正規名（CNAME）を選択するためのガイドライン」、RFC 7022、DOI 10.17487 / RFC7022、2013年9月、<http://www.rfc-editor.org/info/rfc7022>. 

[RFC7160] Petit-Huguenin、M. およびG. Zorn、編、「RTPセッションでの複数のクロックレートのサポート」、RFC 7160、DOI 10.17487 / RFC7160、2014年4月、<http：//www.rfc-editor .org / info / rfc7160>. 

[RFC7164] Gross、K. およびR. Brandenburg、「RTP and Leap Seconds」、RFC 7164、DOI 10.17487 / RFC7164、2014年3月、<http://www.rfc-editor.org/info/rfc7164>. 

[W3C.WD-mediacapture-streams-20130903]バーネット、D. 、バーグビスト、A. 、ジェニングス、C. 、およびA.ナラヤナン、「メディアキャプチャおよびストリーム」、ワールドワイドウェブコンソーシアムWD WD-mediacapture-streams-20130903 、2013年9月、<http://www.w3.org/TR/2013/ WD-mediacapture-streams-20130903>. 

[W3C.WD-webrtc-20130910] Bergkvist、A.、Burnett、D.、Jennings、C. 、およびA. Narayanan、「WebRTC 1.0：ブラウザー間のリアルタイム通信」、World Wide Web Consortium WD WD-webrtc- 20130910、2013年9月、<http://www.w3.org/TR/2013/WD-webrtc-20130910>. 

16.2. 参考情報
[ID.ietf-avtcore-multiplex-guidelines] Westerlund、M.、Perkins、C. 、およびH. Alvestrand、「RTPの多重化機能を使用して複数のメディアストリームをサポートするためのガイドライン」、draft-ietf-avtcore-multiplex-ガイドライン-03（作業中）、2014年10月. 

[ID.ietf-avtext-rtp-grouping-taxonomy] Lennox、J.、Gross、K.、Nandakumar、S.、Salgueiro、G.、and B. Burman、 "A Taxonomy of Semantics and Mechanisms for Real-Time Transportプロトコル（RTP）ソース」、draft-ietf-avtext-rtp-grouping-taxonomy-08（作業中）、2015年7月. 

[ID.ietf-dart-dscp-rtp] Black、D. 、およびP. Jones、「Differentiated Services（DiffServ）and Real-time Communication」、draft-ietf-dart-dscp-rtp-10（作業中）、 2014年11月. 

[ID.ietf-mmusic-msid] Alvestrand、H. 、「Session Description ProtocolでのWebRTC MediaStream Identification」、draft-ietf-mmusic-msid-11（作業中）、2015年10月. 

[ID.ietf-payload-rtp-howto] Westerlund、M. 、「RTPペイロード形式の記述方法」、draft-ietf-payload-rtp-howto-14（進行中）、2015年5月. 

[ID.ietf-rmcat-cc-requirements] Jesup、R. およびZ. Sarker、「インタラクティブリアルタイムメディアの輻輳制御要件」、draft-ietf-rmcat-cc-requirements-09（作業中）、12月2014. 

[ID.ietf-rtcweb-jsep] Uberti、J.、Jennings、C. 、およびE. Rescorla、「Javascriptセッション確立プロトコル」、draft-ietf-rtcweb-jsep-13（進行中）、2016年3月. 

[ID.ietf-tsvwg-rtcweb-qos] Jones、P.、Dhesikan、S.、Jennings、C. 、およびD. Druta、「WebRTC QoSのDSCPおよびその他のパケットマーキング」、draft-ietf-tsvwg-rtcweb- qos-14（作業中）、2016年3月. 

[RFC3611]フリードマン、T. 、編、カセレス、R、編、A. クラーク、編、「RTP制御プロトコル拡張レポート（RTCP XR）」、RFC 3611、DOI 10.17487 / RFC3611、2003年11月、 <http://www.rfc-editor.org/info/rfc3611>. 

[RFC4383]バウアー、M. 、およびE.カララ、「Secure Real-time Transport Protocol（SRTP）での時間指定の効率的なストリームのロストレラント認証（TESLA）の使用」、RFC 4383、DOI 10.17487 / RFC4383、2006年2月、 <http://www.rfc-editor.org/info/rfc4383>. 

[RFC5245] Rosenberg、J. 、「Interactive Connectivity Establishment（ICE）：A Protocol for Network Address Translator（NAT）Traversal for Offer / Answer Protocols」、RFC 5245、DOI 10.17487 / RFC5245、2010年4月、<http：// www .rfc-editor.org / info / rfc5245>. 

[RFC5576] Lennox、J.、Ott、J. 、およびT. Schierl、「Session Description Protocol（SDP）のソース固有のメディア属性」、RFC 5576、DOI 10.17487 / RFC5576、2009年6月、<http：// www.rfc-editor.org/info/rfc5576>. 

[RFC5968] Ott、J. およびC. Perkins、「RTP Control Protocol（RTCP）の拡張に関するガイドライン」、RFC 5968、DOI 10.17487 / RFC5968、2010年9月、<http://www.rfc-editor.org/info / rfc5968>. 

[RFC6263] Marjou、X. およびA. Sollaud、「RTP / RTP制御プロトコル（RTCP）フローに関連するNATマッピングを維持するためのアプリケーションメカニズム」、RFC 6263、DOI 10.17487 / RFC6263、2011年6月、<http：// www.rfc-editor.org/info/rfc6263>. 

[RFC6792] Wu、Q.、Ed. 、Hunt、G. 、およびP. Arden、「RTPモニタリングフレームワークの使用に関するガイドライン」、RFC 6792、DOI 10.17487 / RFC6792、2012年11月、<http：// www.  rfc-editor.org/info/rfc6792>. 

[RFC7478] Holmberg、C.、Hakansson、S. 、およびG. Eriksson、「Web Real-Time Communication Use Cases and Requirements」、RFC 7478、DOI 10.17487 / RFC7478、2015年3月、<http：//www.rfc- editor.org/info/rfc7478>. 

著者のアドレス

コリンパーキンスグラスゴー大学コンピューティングサイエンススクールグラスゴーG12 8QQイギリス

   メール：csp@csperkins.org
   URI：https://csperkins.org/
        
Magnus Westerlund Ericsson Farogatan 6 SE-164 80 Kistaスウェーデン

   電話：+46 10 714 82 87
   メール：magnus.westerlund@ericsson.com
        
Joerg Ott Aalto University School of Electrical Engineering Espoo 02150フィンランド

   メール：jorg.ott@aalto.fi
        