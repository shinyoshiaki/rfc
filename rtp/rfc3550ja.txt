RFCトランス
個人情報保護方針
連絡先
イチジク
@ tex2e
3550
RFC 3550-RTP：リアルタイムアプリケーション用のトランスポートプロトコル
URL：https://tools.ietf.org/html/rfc3550
タイトル：RFC 3550-RTP：リアルタイムアプリケーション用のトランスポートプロトコル
翻訳編集：自動生成
ネットワークワーキンググループH.シュルツリンネ
コメントの要求：3550コロンビア大学
廃止：1889 S. Casner
カテゴリ：標準トラックパケットデザイン
                                                            R.フレデリック
                                                  ブルーコートシステムズ株式会社
                                                             ジェイコブソン
                                                           パケット設計
                                                               2003年7月
        
RTP：リアルタイムアプリケーション用のトランスポートプロトコル

このメモのステータス

このドキュメントは、インターネットコミュニティのためのインターネット標準トラックプロトコルを指定し、改善のための議論と提案を要求します. このプロトコルの標準化状態とステータスについては、「インターネット公式プロトコル標準」（STD 1）の最新版を参照してください. このメモの配布は無制限です. 

著作権表示

Copyright（C）The Internet Society（2003）. 全著作権所有. 

概要

この覚書では、リアルタイム転送プロトコルであるRTPについて説明します. RTPは、マルチキャスト、ユニキャストネットワークサービスを介して、オーディオ、ビデオ、シミュレーションデータなどのリアルタイムデータを送信するアプリケーションに適したエンドツーエンドのネットワーク転送機能を提供します. RTPはリソース予約に対応しておらず、リアルタイムサービスのサービス品質を保証していません. データトランスポートは、制御プロトコル（RTCP）によって拡張され、大規模なマルチキャストネットワークに拡張可能な方法でデータ配信の監視を可能にし、最小限の制御および識別機能を提供します. RTPとRTCPは、基になるトランスポート層とネットワーク層から独立するように設計されています. このプロトコルは、RTPレベルのトランスレータとミキサーの使用をサポートしています. 

このメモのテキストのほとんどは、廃止されたRFC 1889と同一です. 回線上のパケット形式に変更はなく、プロトコルの使用方法を管理するルールとアルゴリズムに変更が加えられます. 最大の変更点は、RTCPパケットを送信するタイミングを計算するスケーラブルタイマーアルゴリズムの拡張で、多数の参加者が同時にセッションに参加する場合に、意図したレートを超える送信を最小限に抑えることができます. 

目次

   1.はじめに............................................... . 4
       1.1用語................................................................ 5
   2. RTP使用シナリオ........................................... 5
       2.1簡単なマルチキャスト音声会議...................... 6
       2.2音声およびビデオ会議............................. 7
       2.3ミキサーと翻訳................................. 7
       2.4階層化エンコーディング................................................ 8
   3.定義......................................................... .. 8
   4.バイトオーダー、アラインメント、時間フォーマット...................... 12
   5. RTPデータ転送プロトコル.................................. 13
       5.1 RTP固定ヘッダーフィールド................................ 13
       5.2 RTPセッションの多重化.............................. 16
       5.3 RTPヘッダーへのプロファイル固有の変更....... 18
            5.3.1 RTPヘッダー拡張機能................................................ 18
   6. RTP制御プロトコル-RTCP ................................ 19
       6.1 RTCPパケット形式..................................... 21
       6.2 RTCP送信間隔............................. 24
            6.2.1セッションメンバー数の維持....... 28
       6.3 RTCPパケット送受信ルール..................... 28
            6.3.1 RTCP送信間隔の計算........ 29
            6.3.2初期化.................................. 30
            6.3.3 RTPまたはBYE以外のRTCPパケットの受信......... 31
            6.3.4 RTCP BYEパケットの受信.................... 31
            6.3.5 SSRCのタイムアウト.............................. 32
            6.3.6送信タイマーの期限切れ................ 32
            6.3.7 BYEパケットの送信....................... 33
            6.3.8 we_sentの更新................................ 34
            6.3.9ソース記述帯域幅の割り当て...... 34
       6.4送信者および受信者レポート............................ 35
            6.4.1 SR：送信者レポートRTCPパケット................... 36
            6.4.2 RR：受信者レポートRTCPパケット................. 42
            6.4.3送信者および受信者レポートの拡張....... 42
            6.4.4送信者および受信者レポートの分析........... 43
       6.5 SDES：ソース説明RTCPパケット................... 45
            6.5.1 CNAME：Canonical End-Point Identifier SDES Item. 46
            6.5.2 NAME：ユーザー名SDESアイテム....................... 48
            6.5.3電子メール：電子メールアドレスSDESアイテム........ 48
            6.5.4電話：電話番号SDESアイテム................... 49
            6.5.5 LOC：地理的ユーザーの場所SDESアイテム......... 49
            6.5.6ツール：アプリケーションまたはツール名SDESアイテム........ 49
            6.5.7注：通知/ステータスSDESアイテム................... 50
            6.5.8 PRIV：Private Extensions SDESアイテム.............. 50
       6.6 BYE：さようならRTCPパケット............................... 51
       6.7 APP：アプリケーション定義のRTCPパケット................... 52
   7. RTPトランスレータとミキサー.................................. 53
       7.1概要.................................... 53
        
       7.2トランスレータでのRTCP処理......................... 55
       7.3ミキサーでのRTCP処理.............................. 57
       7.4カスケードミキサー........................................ 58
   8. SSRC識別子の割り当てと使用.......................... 59
       8.1衝突の確率............................... 59
       8.2衝突解決とループ検出................ 60
       8.3階層化エンコーディングでの使用............................. 64
   9.セキュリティ................................................................... ..... 65
       9.1機密性........................................ 65
       9.2認証とメッセージの整合性................... 67
   10.輻輳制御.......................................... 67
   11. RTP over NetworkおよびTransport Protocols ................................. 68
   12.プロトコル定数の概要............................... 69
       12.1 RTCPパケットタイプ...................................... 70
       12.2 SDESタイプ................................................................. 70
   13. RTPプロファイルとペイロード形式の仕様.............. 71
   14.セキュリティに関する考慮事項..................................... 73
   15. IANAの考慮事項......................................... 73
   16.知的財産権に関する声明................................ 74
   17.謝辞............................................. 74
   付録A.アルゴリズム.................................................. 75
   付録A.1 RTPデータヘッダーの有効性チェック................... 78
   付録A.2 RTCPヘッダーの有効性チェック....................... 82
   付録A.3予想されるパケット数と失われるパケット数の決定...
   付録A.4 RTCP SDESパケットの生成...................... 84
   付録A.5 RTCP SDESパケットの解析......................... 85
   付録A.6ランダム32ビット識別子の生成............. 85
   付録A.7 RTCP送信間隔の計算.......... 87
   付録A.8到着間ジッターの推定................ 94
   付録B. RFC 1889からの変更点............................. 95
   参考資料................................................................ ..... 100
   規範的な参照...................................................... 100
   参考資料.......................................... 100
   著者のアドレス.............................................. 103
   完全な著作権表示........................................ 104
        
1.はじめに
このメモは、リアルタイムトランスポートプロトコル（RTP）を指定します. RTPは、インタラクティブなオーディオやビデオなどのリアルタイムの特性を持つデータにエンドツーエンドの配信サービスを提供します. これらのサービスには、ペイロードタイプの識別、シーケンス番号付け、タイムスタンプ、および配信監視が含まれます. アプリケーションは通常、UDPの上でRTPを実行して、その多重化およびチェックサムサービスを利用します. どちらのプロトコルも、トランスポートプロトコル機能の一部を提供します. ただし、RTPは他の適切な基盤となるネットワークまたはトランスポートプロトコルで使用できます（セクション11を参照）. RTPは、基盤となるネットワークによって提供されている場合、マルチキャスト配信を使用して複数の宛先へのデータ転送をサポートします. 

RTP自体は、タイムリーな配信を保証するメカニズムやその他のサービス品質保証を提供するものではありませんが、下位層のサービスに依存していることに注意してください. 配信を保証したり、順序どおりの配信を防止したりすることはありません. また、基盤となるネットワークが信頼性があり、パケットを順番に配信するとは限りません. RTPに含まれるシーケンス番号を使用すると、受信者は送信者のパケットシーケンスを再構築できますが、シーケンス番号は、たとえばビデオをデコードする場合に、パケットを順番にデコードする必要はなく、パケットの適切な場所を決定するためにも使用できます. 

RTPは主に複数参加者のマルチメディア会議のニーズを満たすように設計されていますが、特定のアプリケーションに限定されません. 連続データ、インタラクティブな分散シミュレーション、アクティブバッジ、制御および測定アプリケーションのストレージも、RTPが適用できる場合があります. 

このドキュメントは、2つの密接にリンクされた部分で構成されるRTPを定義します. 

oリアルタイム転送プロトコル（RTP）. リアルタイムプロパティを持つデータを伝送します. 

o RTP制御プロトコル（RTCP）. サービスの品質を監視し、進行中のセッションの参加者に関する情報を伝達します. RTCPの後者の側面は、「緩やかに制御された」セッション、つまり明示的なメンバーシップ制御とセットアップがない場合には十分ですが、アプリケーションの制御通信要件のすべてをサポートすることを必ずしも意図していません. この機能は、このドキュメントの範囲を超える個別のセッション制御プロトコルによって完全にまたは部分的に包含される場合があります. 

RTPは、クラークとテネンハウスによって提案されたアプリケーションレベルのフレーミングと統合されたレイヤー処理の原則に従う新しいプロトコルのスタイルを表します[10]. つまり、RTPは柔軟であることを目的としています

特定のアプリケーションが必要とする情報を提供し、多くの場合、個別のレイヤーとして実装されるのではなく、アプリケーション処理に統合されます. RTPは、意図的に完全ではないプロトコルフレームワークです. このドキュメントでは、RTPが適切であるすべてのアプリケーションで共通であると予想される機能を指定します. プロトコルをより一般的にしたり、解析を必要とするオプションメカニズムを追加したりすることで追加機能に対応できる従来のプロトコルとは異なり、RTPは、必要に応じてヘッダーの変更や追加を通じて調整することを目的としています. 例は、セクション5.3および6.4.3に記載されています. 

したがって、このドキュメントに加えて、特定のアプリケーションのRTPの完全な仕様には、1つ以上の関連ドキュメントが必要です（セクション13を参照）. 

o一連のペイロードタイプコードとそれらのペイロードフォーマット（メディアエンコーディングなど）へのマッピングを定義するプロファイル仕様書. プロファイルは、特定のクラスのアプリケーションに固有のRTPの拡張または変更を定義することもできます. 通常、アプリケーションは1つのプロファイルでのみ動作します. オーディオおよびビデオデータのプロファイルは、関連するRFC 3551 [1]にあります. 

oペイロード形式の仕様ドキュメント. オーディオやビデオのエンコーディングなどの特定のペイロードがRTPでどのように伝送されるかを定義します. 

リアルタイムサービスとその実装のためのアルゴリズムの議論、およびRTP設計の決定のいくつかに関する背景の議論は、[11]にあります. 

1.1用語

このドキュメントのキーワード「MUST」、「MUST NOT」、「REQUIRED」、「SHALL」、「SHALL NOT」、「SHOULD」、「SHOULD NOT」、「RECOMMENDED」、「MAY」、および「OPTIONAL」は、 BCP 14、RFC 2119 [2]で説明されているように解釈され、準拠するRTP実装の要件レベルを示します. 

2. RTP使用シナリオ
次のセクションでは、RTPの使用のいくつかの側面について説明します. これらの例は、RTPの用途を制限するためではなく、RTPを使用するアプリケーションの基本的な操作を説明するために選択されました. これらの例では、RTPはIPおよびUDPの上で実行され、関連するRFC 3551で指定されたオーディオおよびビデオのプロファイルによって確立された規則に従います. 

2.1シンプルなマルチキャスト音声会議

IETFのワーキンググループは、最新のプロトコルドキュメントについて話し合うために会合し、音声通信にインターネットのIPマルチキャストサービスを使用します. いくつかの割り当てメカニズムによって、ワーキンググループの議長はマルチキャストグループアドレスとポートのペアを取得します. 1つのポートはオーディオデータに使用され、もう1つのポートは制御（RTCP）パケットに使用されます. このアドレスとポート情報は、対象となる参加者に配布されます. プライバシーが必要な場合は、セクション9.1で指定されているようにデータと制御パケットを暗号化できます. その場合、暗号化キーも生成して配布する必要があります. これらの割り当ておよび配布メカニズムの正確な詳細は、RTPの範囲を超えています. 

各会議参加者が使用する音声会議アプリケーションは、音声データを、たとえば20ミリ秒の小さなチャンクで送信します. オーディオデータの各チャンクの前には、RTPヘッダーが付いています. RTPヘッダーとデータは、UDPパケットに含まれています. RTPヘッダーは、各パケットに含まれているオーディオエンコーディングのタイプ（PCM、ADPCM、LPCなど）を示します. これにより、送信者は会議中にエンコーディングを変更して、低帯域幅で接続されている新しい参加者に対応できます. ネットワークの輻輳の兆候にリンクまたは対応します. 

インターネットは、他のパケットネットワークと同様に、パケットを失ったり、並べ替えたり、さまざまな時間だけパケットを遅延させたりすることがあります. これらの障害に対処するために、RTPヘッダーにはタイミング情報とシーケンス番号が含まれており、レシーバーがソースによって生成されたタイミングを再構築できるため、この例では、オーディオのチャンクが20 msごとにスピーカーから連続して再生されます. このタイミングの再構築は、会議のRTPパケットのソースごとに個別に実行されます. シーケンス番号は、失われたパケットの数を推定するために受信者が使用することもできます. 

ワーキンググループのメンバーは会議中に参加したり退会したりするので、いつ誰が参加しているか、また彼らが音声データをどれだけうまく受信しているかを知ることは役に立ちます. そのために、会議のオーディオアプリケーションの各インスタンスは、受信レポートとRTCP（制御）ポート上のユーザーの名前を定期的にマルチキャストします. 受信レポートは、現在の話者がどれだけうまく受信されているかを示し、適応エンコーディングの制御に使用できます. ユーザー名に加えて、制御帯域幅の制限に従って、他の識別情報も含めることができます. サイトは、会議を離れるときにRTCP BYEパケット（セクション6.6）を送信します. 

2.2オーディオおよびビデオ会議

オーディオメディアとビデオメディアの両方が会議で使用される場合、それらは個別のRTPセッションとして送信されます. つまり、2つの異なるUDPポートペアまたはマルチキャストアドレス、あるいはその両方を使用して、メディアごとに個別のRTPおよびRTCPパケットが送信されます. オーディオセッションとビデオセッションの間にRTPレベルで直接結合することはありません. ただし、両方のセッションに参加しているユーザーは、両方のRTCPパケットで同じ識別（正規）名を使用して、セッションを関連付けることができます. 

この分離の1つの動機は、会議の一部の参加者が選択した場合に1つのメディアのみを受信できるようにすることです. 詳細については、セクション5.2を参照してください. 分離にもかかわらず、ソースのオーディオとビデオの同期再生は、両方のセッションのRTCPパケットで運ばれるタイミング情報を使用して実現できます. 

2.3ミキサーとトランスレータ

これまでのところ、すべてのサイトが同じ形式のメディアデータを受信することを望んでいると想定しています. ただし、これが常に適切であるとは限りません. 1つのエリアの参加者が、高速ネットワークアクセスを楽しむ会議参加者の大半に低速リンクを介して接続されている場合を考えます. 低帯域幅で低品質のオーディオエンコーディングを使用するように全員を強制する代わりに、ミキサーと呼ばれるRTPレベルのリレーを低帯域幅領域の近くに配置することができます. このミキサーは、着信オーディオパケットを再同期して、送信者によって生成された一定の20 ms間隔を再構築し、これらの再構築されたオーディオストリームを単一のストリームに混合し、オーディオエンコーディングを低帯域幅のものに変換し、低帯域幅パケットストリームを低帯域幅に転送します. スピードリンク. これらのパケットは、単一の受信者へのユニキャスト、または複数の受信者への異なるアドレスでのマルチキャストの場合があります. RTPヘッダーには、ミキサーが混合パケットに寄与したソースを識別して、正しいトーカー表示をレシーバーで提供できるようにする手段が含まれています. 

オーディオ会議の参加者の一部は、高帯域幅リンクに接続されている可能性がありますが、IPマルチキャストを介して直接到達できない場合があります. たとえば、IPパケットを通過させないアプリケーションレベルのファイアウォールの背後にある可能性があります. これらのサイトでは、ミキシングは必要ない場合があります. その場合、トランスレータと呼ばれる別のタイプのRTPレベルのリレーを使用できます. 2つのトランスレータがインストールされており、1つはファイアウォールの両側にあり、1つはファイアウォールの内側のトランスレータへの安全な接続を通じて受信されたすべてのマルチキャストパケットを外部に転送します. ファイアウォール内のトランスレータは、サイトの内部ネットワークに制限されたマルチキャストグループにマルチキャストパケットとしてそれらを再度送信します. 

ミキサとトランスレータは、さまざまな目的で設計できます. 一例は、個別のビデオストリームで個々の人の画像をスケーリングし、それらを1つのビデオストリームに合成してグループシーンをシミュレートするビデオミキサーです. その他の変換の例には、IP / UDPのみを話すホストのグループと、ST-IIのみを理解するホストのグループとの接続、または再同期やミキシングを行わない、個々のソースからのビデオストリームのパケットごとのエンコード変換が含まれます. ミキサーとトランスレータの操作の詳細については、セクション7で説明します. 

2.4階層化エンコーディング

マルチメディアアプリケーションは、受信機の容量に一致するように、またはネットワークの輻輳に適応するように伝送速度を調整できる必要があります. 多くの実装では、レート適応性の責任はソースにあります. 異種受信機の帯域幅要件が競合するため、これはマルチキャスト送信ではうまく機能しません. 結果は、ネットワークメッシュの最小のパイプがライブマルチメディア「ブロードキャスト」全体の品質と忠実度を決定する、最も一般的でない分母シナリオです. 

代わりに、階層化されたエンコーディングと階層化された伝送システムを組み合わせることによって、レート適応の責任をレシーバーに課すことができます. RTP over IPマルチキャストのコンテキストでは、ソースは、それぞれ独自のマルチキャストグループで実行される複数のRTPセッションに階層的に表された信号のプログレッシブレイヤーをストライプ化できます. 受信者は、マルチキャストグループの適切なサブセットのみに参加することで、ネットワークの異質性に適応し、受信帯域幅を制御できます. 

レイヤードエンコーディングでのRTPの使用の詳細については、セクション6.3.9、8.3、11を参照してください. 

3.定義
RTPペイロード：オーディオサンプルや圧縮ビデオデータなど、RTPによってパケットで転送されるデータ. ペイロードの形式と解釈は、このドキュメントの範囲外です. 

RTPパケット：固定RTPヘッダー、おそらく空のソースのリスト（以下を参照）、およびペイロードデータで構成されるデータパケット. 一部の基本的なプロトコルでは、RTPパケットのカプセル化を定義する必要がある場合があります. 通常、基礎となるプロトコルの1つのパケットには1つのRTPパケットが含まれますが、カプセル化方法で許可されている場合は、複数のRTPパケットが含まれる場合があります（セクション11を参照）. 

RTCPパケット：RTPデータパケットと同様の固定ヘッダー部分と、それに続くRTCPパケットタイプによって異なる構造化要素で構成される制御パケット. 形式はセクション6で定義されています. 通常、複数のRTCPパケットは、基になるプロトコルの単一のパケットで複合RTCPパケットとして一緒に送信されます. これは、各RTCPパケットの固定ヘッダーの長さフィールドによって有効になります. 

ポート：「トランスポートプロトコルが特定のホストコンピュータ内の複数の宛先を区別するために使用する抽象化. TCP/ IPプロトコルは、小さな正の整数を使用してポートを識別します. 」[12] OSIトランスポート層で使用されるトランスポートセレクター（TSEL）はポートに相当します. RTPは、セッションのRTPおよびRTCPパケットを多重化するポートなどのメカニズムを提供するために、下位層プロトコルに依存しています. 

トランスポートアドレス：トランスポートレベルのエンドポイントを識別するネットワークアドレスとポートの組み合わせ（IPアドレスやUDPポートなど）. パケットは、ソーストランスポートアドレスから宛先トランスポートアドレスに送信されます. 

RTPメディアタイプ：RTPメディアタイプは、単一のRTPセッション内で伝送できるペイロードタイプのコレクションです. RTPプロファイルは、RTPメディアタイプをRTPペイロードタイプに割り当てます. 

マルチメディアセッション：参加者の一般的なグループ間の同時RTPセッションのセット. たとえば、ビデオ会議（マルチメディアセッション）には、オーディオRTPセッションとビデオRTPセッションが含まれる場合があります. 

RTPセッション：RTPと通信する一連の参加者間の関連付け. 参加者は、複数のRTPセッションに同時に関与する場合があります. マルチメディアセッションでは、エンコーディング自体が複数のメディアを単一のデータストリームに多重化しない限り、通常、各メディアは独自のRTCPパケットを使用して個別のRTPセッションで伝送されます. 参加者は、宛先トランスポートアドレスの異なるペアを使用して異なるセッションを受信することにより、複数のRTPセッションを区別します. トランスポートアドレスのペアは、1つのネットワークアドレスとRTPおよびRTCPのポートのペアで構成されます. RTPセッションのすべての参加者は、IPマルチキャストの場合のように、共通の宛先トランスポートアドレスのペアを共有するか、個々のユニキャストネットワークアドレスとポートのペアの場合のように、参加者ごとにペアが異なる場合があります. 

RTPセッションの際立った機能は、それぞれがSSRC識別子の完全な個別のスペースを維持することです（次に定義）. 1つのRTPセッションに含まれる参加者のセットは、参加者のいずれかによって送信されたSSRC識別子を、SSRCまたはCSRC（以下でも定義）またはRTCPとしてRTPで送信できる参加者で構成されます. たとえば、各参加者が別のポートペアで他の2つから受信するユニキャストUDPを使用して実装された3者間会議について考えてみます. 各参加者が他の1人の参加者から受信したデータに関するRTCPフィードバックをその参加者にのみ送信する場合、会議は3つの個別のポイントツーポイントRTPセッションで構成されます. 各参加者が他の1人の参加者の受信に関するRTCPフィードバックを他の参加者の両方に提供する場合、その後、会議は1つのマルチパーティRTPセッションで構成されます. 後者のケースは、3人の参加者間のIPマルチキャスト通信で発生する動作をシミュレートします. 

RTPフレームワークはここで定義されたバリエーションを許可しますが、特定の制御プロトコルまたはアプリケーション設計は通常これらのバリエーションに制約を課します. 

同期ソース（SSRC）：RTPパケットのストリームのソース. ネットワークアドレスに依存しないように、RTPヘッダーで運ばれる32ビットの数値SSRC識別子によって識別されます. 同期ソースからのすべてのパケットは、同じタイミングとシーケンス番号空間の一部を形成するため、レシーバーは再生のために同期ソースによってパケットをグループ化します. 同期ソースの例には、マイクやカメラなどの信号ソースから派生したパケットストリームの送信者、またはRTPミキサーが含まれます（以下を参照）. 同期ソースは、時間の経過とともに、オーディオエンコーディングなどのデータ形式を変更する場合があります. SSRC識別子はランダムに選択された値であり、特定のRTPセッション内でグローバルに一意であることを意味します（セクション8を参照）. 参加者は、マルチメディアセッションのすべてのRTPセッションに同じSSRC識別子を使用する必要はありません. SSRC識別子のバインディングは、RTCPを介して提供されます（6.5.1を参照）. 参加者が1つのRTPセッションで、たとえば別々のビデオカメラから複数のストリームを生成する場合、それぞれを異なるSSRCとして識別する必要があります. 

Contributing source（CSRC）：RTPミキサーによって生成された結合ストリームに寄与したRTPパケットのストリームのソース（以下を参照）. ミキサーは、特定のパケットの生成に貢献したソースのSSRC識別子のリストを、そのパケットのRTPヘッダーに挿入します. このリストはCSRCリストと呼ばれます. アプリケーションの例としては、オーディオ会議が挙げられます. ミキサーは、スピーチが組み合わされて発信パケットを生成したすべてのトーカーを示し、すべてのオーディオパケットに同じSSRC識別子（ミキサーのもの）が含まれていても、レシーバーは現在のトーカーを示すことができます. 

エンドシステム：RTPパケットで送信されるコンテンツを生成したり、受信したRTPパケットのコンテンツを消費したりするアプリケーション. エンドシステムは、特定のRTPセッションで1つ以上の同期ソースとして機能できますが、通常は1つだけです. 

ミキサー：1つ以上のソースからRTPパケットを受信し、おそらくデータ形式を変更し、何らかの方法でパケットを結合してから新しいRTPパケットを転送する中間システム. 複数の入力ソース間のタイミングは一般に同期されないため、ミキサーはストリーム間でタイミングを調整し、結合されたストリームに対して独自のタイミングを生成します. したがって、ミキサーから発信されたすべてのデータパケットは、同期ソースとしてミキサーを持っていると識別されます. 

トランスレータ：同期ソース識別子をそのままにしてRTPパケットを転送する中間システム. トランスレータの例には、ミキシングせずにエンコーディングを変換するデバイス、マルチキャストからユニキャストへのレプリケータ、ファイアウォールのアプリケーションレベルのフィルタなどがあります. 

モニター：RTPセッションの参加者によって送信されたRTCPパケット、特に受信レポートを受信し、配信監視、障害診断、および長期統計のために現在のサービス品質を推定するアプリケーション. モニター機能は、セッションに参加しているアプリケーションに組み込まれている可能性がありますが、別の方法では参加せず、RTPデータパケットを送信または受信しない別のアプリケーションである可能性があります（これらは別のポートにあるため） . これらはサードパーティのモニターと呼ばれます. サードパーティのモニターがRTPデータパケットを受信して​​も、RTCPパケットを送信したり、セッションでカウントされないようにすることもできます. 

非RTPとは、RTPに加えて、使用可能なサービスを提供するために必要となる可能性のあるプロトコルとメカニズムを意味します. 特に、マルチメディア会議の場合、制御プロトコルは、暗号化のためにマルチキャストアドレスとキーを配布し、使用する暗号化アルゴリズムをネゴシエートし、RTPペイロードタイプの値と、事前定義されていない形式に対してそれらが表すペイロード形式の間の動的マッピングを定義します. ペイロードタイプの値. このようなプロトコルの例には、セッション開始プロトコル（SIP）（RFC 3261 [13]）、ITU勧告H.323 [14]、およびRTSP（RFC 2326 [16]）などのSDP（RFC 2327 [15]）を使用するアプリケーションが含まれます.  . 単純な

アプリケーション、電子メール、または会議データベースも使用できます. このようなプロトコルとメカニズムの仕様は、このドキュメントの範囲外です. 

4.バイトオーダー、アラインメント、および時間フォーマット
すべての整数フィールドは、ネットワークバイトオーダーで運ばれます. つまり、最上位バイト（オクテット）が最初です. このバイトオーダーは、一般にビッグエンディアンと呼ばれます. 送信順序については、[3]で詳しく説明しています. 特に明記しない限り、数値定数は10進数（基数10）です. 

すべてのヘッダーデータは自然長に揃えられます. つまり、16ビットフィールドは偶数オフセットに揃えられ、32ビットフィールドは4で割り切れるオフセットに揃えられます. パディングとして指定されたオクテットの値はゼロです. 

ウォールクロック時間（絶対日時）は、Network Time Protocol（NTP）のタイムスタンプ形式を使用して表されます. これは、1900年1月1日の0h UTCを基準とした秒単位です[4]. フル解像度のNTPタイムスタンプは、64ビットの符号なし固定小数点数で、最初の32ビットに整数部分があり、最後の32ビットに小数部分があります. よりコンパクトな表現が適切な一部のフィールドでは、中央の32ビットのみが使用されます. つまり、整数部の下位16ビットと小数部の上位16ビットです. 整数部分の上位16ビットは個別に決定する必要があります. 

RTPを使用するために、ネットワークタイムプロトコルを実行するための実装は必要ありません. 他の時刻源を使用することも、まったく使用しないこともできます（セクション6.4.1のNTPタイムスタンプフィールドの説明を参照）. ただし、NTPの実行は、別のホストから送信されたストリームの同期に役立つ場合があります. 

NTPタイムスタンプは2036年のある時点で循環してゼロになりますが、RTPの目的では、NTPタイムスタンプのペア間の違いのみが使用されます. タイムスタンプのペアが互いに68年以内であると想定できる限り、減算と比較にモジュラー算術を使用すると、ラップアラウンドは無関係になります. 

5. RTPデータ転送プロトコル
5.1 RTP固定ヘッダーフィールド

RTPヘッダーの形式は次のとおりです. 


    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |V=2|P|X|  CC   |M|     PT      |       sequence number         |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                           timestamp                           |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |           synchronization source (SSRC) identifier            |
   +=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+
   |            contributing source (CSRC) identifiers             |
   |                             ....                              |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        
最初の12オクテットはすべてのRTPパケットに存在しますが、CSRC識別子のリストはミキサーによって挿入された場合にのみ存在します. フィールドには次の意味があります. 

バージョン（V）：2ビットこのフィールドは、RTPのバージョンを識別します. この仕様で定義されているバージョンは2です. （値1はRTPの最初のドラフトバージョンで使用され、値0は「バット」オーディオツールで最初に実装されたプロトコルで使用されます. 

パディング（P）：1ビットパディングビットが設定されている場合、パケットには、ペイロードの一部ではない1つ以上の追加のパディングオクテットが最後に含まれます. パディングの最後のオクテットには、無視されるパディングオクテットの数が含まれます. 固定ブロックサイズの一部の暗号化アルゴリズム、または下位層のプロトコルデータユニットで複数のRTPパケットを伝送するために、パディングが必要になる場合があります. 

拡張（X）：1ビット拡張ビットが設定されている場合、固定ヘッダーの後には、セクション5.3.1で定義されているフォーマットのヘッダー拡張が1つだけ続く必要があります. 

CSRCカウント（CC）：4ビットCSRCカウントには、固定ヘッダーに続くCSRC識別子の数が含まれます. 

マーカー（M）：1ビットマーカーの解釈はプロファイルによって定義されます. これは、フレーム境界などの重要なイベントをパケットストリームでマークできるようにすることを目的としています. プロファイルは、ペイロードタイプフィールドのビット数を変更することにより、追加のマーカービットを定義するか、マーカービットがないことを指定できます（セクション5.3を参照）. 

ペイロードタイプ（PT）：7ビットこのフィールドは、RTPペイロードのフォーマットを識別し、アプリケーションによる解釈を決定します. プロファイルは、ペイロードタイプコードのペイロード形式へのデフォルトの静的マッピングを指定する場合があります. 追加のペイロードタイプコードは、RTP以外の方法で動的に定義できます（セクション3を参照）. オーディオとビデオのデフォルトのマッピングのセットは、関連するRFC 3551 [1]で指定されています. RTPソースは、セッション中にペイロードタイプを変更する場合がありますが、このフィールドは、個別のメディアストリームの多重化には使用しないでください（セクション5.2を参照）. 

レシーバーは、理解できないペイロードタイプのパケットを無視する必要があります. 

シーケンス番号：16ビットシーケンス番号は、送信されるRTPデータパケットごとに1ずつ増加し、パケット損失を検出してパケットシーケンスを復元するために受信者が使用できます. シーケンス番号の初期値はランダム（予測不可能）である必要があり（SHOULD）、ソース自体がセクション9.1の方法に従って暗号化しない場合でも、暗号化に対する既知の平文攻撃をより困難にします.  . 予測できない数値を選択する手法は、[17]で説明されています. 

タイムスタンプ：32ビットタイムスタンプは、RTPデータパケットの最初のオクテットのサンプリングの瞬間を反映しています. サンプリングインスタントは、同期とジッターの計算を可能にするために、時間内で単調かつ線形に増加するクロックから派生する必要があります（セクション6.4.1を参照）. クロックの分解能は、望ましい同期精度とパケット到着ジッターの測定に十分でなければなりません（ビデオフレームごとに1ティックでは通常十分ではありません）. クロック周波数は、ペイロードとして伝送されるデータのフォーマットに依存し、フォーマットを定義するプロファイルまたはペイロードフォーマット仕様で静的に指定されるか、非RTP手段を通じて定義されるペイロードフォーマットに対して動的に指定される場合があります. RTPパケットが定期的に生成される場合、サンプリングクロックから決定された公称サンプリングインスタントが使用されます. システムクロックの読み取りではありません. 例として、固定レートのオーディオの場合、タイムスタンプクロックは、サンプリング期間ごとに1ずつ増加する可能性があります. オーディオアプリケーションが160のサンプリング期間をカバーするブロックを入力デバイスから読み取る場合、ブロックがパケットで送信されるかサイレントとしてドロップされるかに関係なく、そのようなブロックごとにタイムスタンプが160ずつ増加します. 

シーケンス番号と同様に、タイムスタンプの初期値はランダムである必要があります（SHOULD）. いくつかの連続したRTPパケットは、それらが（論理的に）一度に生成される場合、たとえば同じビデオフレームに属する場合、タイムスタンプが等しくなります. 連続したRTPパケットには、MPEG補間ビデオフレームの場合のように、データがサンプリングされた順序で送信されない場合、単調でないタイムスタンプが含まれる場合があります. （送信されたパケットのシーケンス番号は単調です. ）

異なるメディアストリームからのRTPタイムスタンプは異なる速度で進む可能性があり、通常、独立したランダムオフセットがあります. したがって、これらのタイムスタンプは単一のストリームのタイミングを再構築するのに十分ですが、異なるメディアからのRTPタイムスタンプを直接比較しても同期には効果的ではありません. 代わりに、各メディアのRTPタイムスタンプは、RTPタイムスタンプに対応するデータがサンプリングされた時刻を表す参照クロック（ウォールクロック）からのタイムスタンプとペアにすることで、サンプリングインスタントに関連付けられます. 基準クロックは、同期されるすべてのメディアで共有されます. タイムスタンプペアは、すべてのデータパケットで送信されるわけではありませんが、セクション6.4で説明されているように、RTCP SRパケットでは低いレートで送信されます. 

サンプリングインスタントは、RTPタイムスタンプの参照ポイントとして選択されます. これは、RTPタイムスタンプが送信エンドポイントに認識され、エンコーディング遅延やその他の処理とは無関係に、すべてのメディアに共通の定義があるためです. 目的は、同時にサンプリングされたすべてのメディアの同期プレゼンテーションを可能にすることです. 

リアルタイムでサンプリングされたデータではなく、保存されたデータを送信するアプリケーションは、通常、実時間から導出された仮想プレゼンテーションタイムラインを使用して、保存されたデータ内の各メディアの次のフレームまたは他のユニットをいつ表示するかを決定します. この場合、RTPタイムスタンプは各ユニットのプレゼンテーション時間を反映します. つまり、各ユニットのRTPタイムスタンプは、ユニットが仮想プレゼンテーションタイムライン上で最新になる実時間に関連しています. 実際のプレゼンテーションは、受信者の判断により、しばらくして行われます. 

事前に記録されたビデオのライブオーディオナレーションを説明する例は、基準点としてサンプリングの瞬間を選択することの重要性を示しています. このシナリオでは、ナレーターが見るためにビデオがローカルに提示され、RTPを使用して同時に送信されます. RTPで送信されたビデオフレームの「サンプリングインスタント」は、そのタイムスタンプをナレーターに提示されたウォールクロック時間に参照することによって確立されます. ナレーターのスピーチを含むオーディオRTPパケットのサンプリングインスタントは、オーディオがサンプリングされたときと同じ壁時計時間を参照することによって確立されます. 2つのホストの基準クロックがNTPなどの手段によって同期されている場合、オーディオとビデオは異なるホストによって送信されることもあります. 

SSRC：32ビットSSRCフィールドは同期ソースを識別します. この識別子は、同じRTPセッション内の2つの同期ソースが同じSSRC識別子を持たないように、ランダムに選択する必要があります（SHOULD）. ランダムな識別子を生成するためのアルゴリズムの例を付録A.6に示します. 複数のソースが同じ識別子を選択する可能性は低いですが、衝突を検出して解決するためにすべてのRTP実装を準備する必要があります. セクション8では、SSRC識別子の一意性に基づいて、衝突を解決し、RTPレベルの転送ループを検出するメカニズムとともに、衝突の確率について説明します. ソースがそのソーストランスポートアドレスを変更する場合、ループしたソースとして解釈されないように、新しいSSRC識別子も選択する必要があります（セクション8.2を参照）. 

CSRCリスト：0〜15項目、各32ビットCSRCリストは、このパケットに含まれるペイロードの原因となっているソースを識別します. 識別子の数はCCフィールドで指定されます. 15を超えるソースがある場合、特定できるのは15のみです. CSRC識別子は、提供元のSSRC識別子を使用して、ミキサー（セクション7.1を参照）によって挿入されます. たとえば、オーディオパケットの場合、パケットを作成するために混合されたすべてのソースのSSRC識別子が一覧表示され、受信側で正しいトーカーを示すことができます. 

5.2 RTPセッションの多重化

効率的なプロトコル処理のために、統合層処理の設計原理[10]で説明されているように、多重化ポイントの数を最小限に抑える必要があります. RTPでは、多重化は、RTPセッションごとに異なる宛先トランスポートアドレス（ネットワークアドレスとポート番号）によって提供されます. たとえば、別々にエンコードされたオーディオおよびビデオメディアで構成される電話会議では、各メディアは独自の宛先トランスポートアドレスを持つ個別のRTPセッションで伝送される必要があります（SHOULD）. 

個別のオーディオストリームとビデオストリームは、単一のRTPセッションで伝送して、ペイロードタイプまたはSSRCフィールドに基づいて逆多重化するべきではありません（SHOULD NOT）. RTPメディアタイプが異なるが同じSSRCを使用してパケットをインターリーブすると、いくつかの問題が発生します. 

1.たとえば、2つのオーディオストリームが同じRTPセッションと同じSSRC値を共有し、1つがエンコーディングを変更して異なるRTPペイロードタイプを取得する場合、どのストリームがエンコーディングを変更したかを識別する一般的な方法はありません. 

2. SSRCは、単一のタイミングおよびシーケンス番号スペースを識別するために定義されています. メディアクロックレートが異なる場合、複数のペイロードタイプをインターリーブするには異なるタイミングスペースが必要であり、パケット損失が発生したペイロードタイプを通知するために異なるシーケンス番号スペースが必要になります. 

3. RTCP送信者および受信者レポート（セクション6.4を参照）は、SSRCごとに1つのタイミングおよびシーケンス番号スペースのみを記述でき、ペイロードタイプフィールドを伝送しません. 

4. RTPミキサーは、互換性のないメディアのインターリーブストリームを1つのストリームに結合できません. 

5. 1つのRTPセッションで複数のメディアを運ぶことは、以下を排除します. 適切な場合、異なるネットワークパスまたはネットワークリソース割り当ての使用. 必要に応じてメディアのサブセットを受信します. たとえば、ビデオが使用可能な帯域幅を超える場合はオーディオのみ. 異なるメディアに対して個別のプロセスを使用するレシーバーの実装. 個別のRTPセッションを使用すると、単一プロセスまたは複数プロセスの実装が可能になります. 

メディアごとに異なるSSRCを使用し、同じRTPセッションでそれらを送信すると、最初の3つの問題は回避できますが、最後の2つの問題は回避できません. 

一方、異なるSSRC値を使用して1つのRTPセッションで同じメディアの複数の関連ソースを多重化することは、マルチキャストセッションの標準です. 上記の問題は当てはまりません. たとえば、RTPミキサーは複数のオーディオソースを組み合わせることができ、同じ処理をそれらすべてに適用できます. 最後の2つの問題が当てはまらない他のシナリオでは、異なるSSRC値を使用して同じメディアのストリームを多重化することも適切な場合があります. 

5.3 RTPヘッダーに対するプロファイル固有の変更

既存のRTPデータパケットヘッダーは、RTPがサポートする可能性のあるすべてのアプリケーションクラスに共通して必要な一連の機能に対して完全であると考えられています. ただし、ALFの設計原則に従って、プロファイルに依存しない監視および記録ツールを機能させながら、プロファイル仕様で定義された変更または追加によってヘッダーを調整できます（MAY）. 

oマーカービットとペイロードタイプフィールドにはプロファイル固有の情報が含まれますが、多くのアプリケーションではそれらが必要であり、保持するためだけに別の32ビットワードを追加する必要があるため、固定ヘッダーに割り当てられます. これらのフィールドを含むオクテットは、たとえばマーカービットの増減など、さまざまな要件に適合するようにプロファイルによって再定義される場合があります. マーカービットがある場合は、プロファイルに依存しないモニターがパケット損失パターンとマーカービット間の相関を観察できる可能性があるため、オクテットの最上位ビットに1つを配置する必要があります. 

oビデオエンコーディングなど、特定のペイロード形式に必要な追加情報は、パケットのペイロードセクションで伝送する必要があります（SHOULD）. これは、ペイロードセクションの先頭に常に存在するヘッダーに含まれている場合と、データパターンの予約値で示されている場合があります. 

o特定のクラスのアプリケーションがペイロード形式とは関係なく追加の機能を必要とする場合、それらのアプリケーションが動作するプロファイルは、既存の固定ヘッダーのSSRCフィールドの直後に続く追加の固定フィールドを定義する必要があります. これらのアプリケーションは、追加のフィールドに迅速かつ直接アクセスできますが、プロファイルに依存しないモニターまたはレコーダーは、最初の12オクテットのみを解釈してRTPパケットを処理できます. 

すべてのプロファイルに共通の追加機能が必要であることが判明した場合は、新しいバージョンのRTPを定義して、固定ヘッダーに永続的な変更を加える必要があります. 

5.3.1 RTPヘッダー拡張

RTPデータパケットヘッダーで追加情報を伝達する必要がある新しいペイロード形式に依存しない関数を個々の実装で実験できるように、拡張メカニズムが提供されています. このメカニズムは、ヘッダー拡張が、拡張されていない他の相互運用実装によって無視されるように設計されています. 

このヘッダー拡張は、限られた使用のみを目的としています. このメカニズムを使用する可能性が最も高いのは、前のセクションで説明した方法を使用する別の方法のほうが適しています. たとえば、固定ヘッダーに対するプロファイル固有の拡張は、条件付きでも可変位置でもないため、処理コストが低くなります. 特定のペイロード形式に必要な追加情報は、このヘッダー拡張を使用してはいけません（SHOULD NOT）. ただし、パケットのペイロードセクションで運ぶ必要があります（SHOULD）. 

    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |      defined by profile       |           length              |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                        header extension                       |
   |                             ....                              |
        
RTPヘッダーのXビットが1の場合、可変長ヘッダー拡張を、存在する場合はCSRCリストに従って、RTPヘッダーに追加する必要があります. ヘッダー拡張には、拡張内の32ビットワードの数をカウントする16ビットの長さフィールドが含まれます（4オクテット拡張ヘッダーを除く）（したがって、ゼロは有効な長さです）. RTPデータヘッダーに追加できる拡張子は1つだけです. 複数の相互運用実装が異なるヘッダー拡張を使用して個別に実験できるようにするか、特定の実装が複数のタイプのヘッダー拡張を実験できるようにするには、ヘッダー拡張の最初の16ビットを識別子またはパラメーターを区別するために開いたままにします. これらの16ビットのフォーマットは、実装が動作しているプロファイル仕様によって定義されます. 

6. RTP制御プロトコル-RTCP
RTP制御プロトコル（RTCP）は、データパケットと同じ配布メカニズムを使用して、セッションのすべての参加者への制御パケットの定期的な送信に基づいています. 基になるプロトコルは、データと制御パケットの多重化を提供する必要があります. たとえば、UDPで個別のポート番号を使用します. RTCPは4つの機能を実行します. 

1.主な機能は、データ配信の品質に関するフィードバックを提供することです. これは、トランスポートプロトコルとしてのRTPの役割の不可欠な部分であり、他のトランスポートプロトコルのフローおよび輻輳制御機能に関連しています（輻輳制御の要件については、セクション10を参照）. フィードバックはアダプティブエンコーディングの制御に直接役立つ場合がありますが[18、19]、IPマルチキャストの実験では、配信の障害を診断するためにレシーバーからフィードバックを取得することも重要であることが示されています. 受信フィードバックレポートをすべての参加者に送信することで、問題を観察している人は、それらの問題がローカルかグローバルかを評価できます. IPマルチキャストのような配信メカニズムにより、また、セッションに関与していないネットワークサービスプロバイダーなどのエンティティがフィードバック情報を受け取り、サードパーティのモニターとして機能してネットワークの問題を診断することもできます. このフィードバック機能は、RTCPの送信者と受信者のレポートによって実行されます（セクション6.4を参照）. 

2. RTCPは、正規名またはCNAMEと呼ばれるRTPソースの永続的なトランスポートレベル識別子を保持します（セクション6.5.1）. 競合が発見された場合、またはプログラムが再起動された場合、SSRC識別子は変更される可能性があるため、受信者は各参加者を追跡するためにCNAMEを必要とします. 受信者は、CNAMEに、たとえばオーディオとビデオを同期するために、関連するRTPセッションのセットの特定の参加者からの複数のデータストリームを関連付けることを要求する場合もあります. メディア間の同期には、データ送信者がRTCPパケットに含めるNTPおよびRTPタイムスタンプも必要です. 

3.最初の2つの機能では、すべての参加者がRTCPパケットを送信する必要があるため、RTPを多数の参加者にスケールアップするには、レートを制御する必要があります. 各参加者に制御パケットを他のすべての参加者に送信させることにより、各参加者は参加者の数を個別に監視できます. この数値は、セクション6.2で説明されているように、パケットが送信される速度を計算するために使用されます. 

4. 4番目のOPTIONAL機能は、最小限のセッション制御情報、たとえばユーザーインターフェースに表示される参加者IDを伝えることです. これは、メンバーシップの制御やパラメーターのネゴシエーションなしで参加者が出入りする「緩やかに制御された」セッションで役立つ可能性が最も高いです. RTCPは、すべての参加者に到達するための便利なチャネルとして機能しますが、アプリケーションのすべての制御通信要件をサポートするとは限りません. このドキュメントの範囲を超える、より高レベルのセッション制御プロトコルが必要になる場合があります. 

機能1〜3はすべての環境で使用する必要がありますが、特にIPマルチキャスト環境で使用してください. RTPアプリケーション設計者は、ユニキャストモードでのみ機能し、より大きな数にスケーリングしないメカニズムを回避する必要があります（SHOULD）. RTCPの送信は、セクション6.2で説明されているように、レシーバーからのフィードバックが不可能な単一方向リンクの場合など、センダーとレシーバーに対して別々に制御される場合があります. 

非規範的な注記：Source-Specific Multicast（SSM）と呼ばれるマルチキャストルーティングアプローチでは、「チャネル」ごとに1つの送信者（送信元アドレス、グループアドレスのペア）のみがあり、受信者（チャネル送信元を除く）はマルチキャストを使用できません. 他のチャネルメンバーと直接通信する. ここでの推奨事項は、レシーバーのRTCPを完全にオフにするセクション6.2のオプションを通じてのみSSMに対応します. 今後の作業では、受信者からのフィードバックを維持できるように、SSMに対するRTCPの適応を指定します. 

6.1 RTCPパケット形式

この仕様では、さまざまな制御情報を伝送するためにいくつかのRTCPパケットタイプを定義しています. 

SR：送信者レポート、アクティブな送信者である参加者からの送受信統計

RR：受信者レポート、アクティブな送信者ではない参加者からの受信統計、および31を超えるソースでレポートするアクティブな送信者のSRとの組み合わせ

SDES：CNAMEを含むソース記述アイテム

BYE：参加の終了を示します

APP：アプリケーション固有の機能

各RTCPパケットは、RTPデータパケットの固定部分と同様の固定部分で始まり、パケットタイプに応じて可変長である可能性がありますが、32ビット境界で終了する必要があります. 各パケットの固定部分のアライメント要件と長さフィールドは、RTCPパケットを「スタック可能」にするために含まれています. 複数のRTCPパケットをセパレータを介さずに連結して、UDPなどの下位層プロトコルの単一パケットで送信される複合RTCPパケットを形成できます. 下位層プロトコルは、複合パケットの終わりを決定するために全体の長さを提供することが期待されるため、複合パケット内の個々のRTCPパケットの明示的なカウントはありません. 

複合パケット内の個々のRTCPパケットは、パケットの順序や組み合わせを必要とせずに独立して処理できます. ただし、プロトコルの機能を実行するために、次の制約が課されます. o受信統計（SRまたはRR）は、帯域幅の制約により統計の解像度を最大化できるのと同じ頻度で送信する必要があるため、定期的に送信される複合RTCPパケットには、レポートパケットを含める必要があります. 

o新しいレシーバーは、ソースを識別し、リップシンクなどの目的でメディアの関連付けを開始するために、できるだけ早くソースのCNAMEを受信する必要があるため、各複合RTCPパケットには、複合RTCPパケットが含まれる場合を除き、SDES CNAMEも含める必要があります. セクション9.1で説明されているように、部分的な暗号化のために分割します. 

o複合パケットの最初に出現する可能性のあるパケットタイプの数は、最初のワードの定数ビットの数と、誤ってアドレス指定されたRTPデータパケットまたは他の無関係なパケットに対してRTCPパケットを正常に検証する確率を高めるために制限する必要があります. 

したがって、すべてのRTCPパケットは、次の形式で、少なくとも2つの個別パケットの複合パケットで送信する必要があります. 

暗号化プレフィックス：複合パケットがセクション9.1の方法に従って暗号化される場合に限り、送信されるすべての複合パケットに対して再描画されるランダムな32ビットの数量をプレフィックスとして付加する必要があります. 暗号化にパディングが必要な場合は、複合パケットの最後のパケットに追加する必要があります. 

SRまたはRR：付録A.2で説明されているように、ヘッダー検証を容易にするために、複合パケットの最初のRTCPパケットは常にレポートパケットである必要があります. これは、データが送受信されていない場合でも当てはまります. その場合、空のRRを送信する必要があり、複合パケット内の他のRTCPパケットがBYEである場合でも同様です. 

追加のRR：受信統計が報告されているソースの数が31を超える場合、1つのSRまたはRRパケットに収まる数の場合、追加のRRパケットは最初のレポートパケットに従う必要があります（SHOULD）. 

SDES：セクション9.1に記載されている場合を除き、CNAMEアイテムを含むSDESパケットは、各複合RTCPパケットに含まれている必要があります. 帯域幅の制約に従い、特定のアプリケーションで必要な場合、他のソース記述アイテムをオプションで含めることができます（セクション6.3.9を参照）. 

BYEまたはAPP：まだ定義されていないものを含む他のRTCPパケットタイプは、BYEが特定のSSRC / CSRCで送信された最後のパケットであることを除いて、任意の順序で続くことができます. パケットタイプは複数回表示される場合があります. 

個々のRTP参加者は、参加者ごとのRTCP帯域幅を正しく見積もるために（セクション6.2を参照）、レポート間隔ごとに1つの複合RTCPパケットのみを送信する必要があります（セクション6.2を参照）. ソースが多すぎて、ネットワークパスの最大伝送単位（MTU）を超えずに、必要なすべてのRRパケットを1つの複合RTCPパケットに収めるには、1つのMTUに適合するサブセットのみを各間隔に含める必要があります（SHOULD）. すべてのソースが報告されるように、サブセットは複数の間隔でラウンドロビンで選択する必要があります（SHOULD）. 

トランスレーターとミキサーは、転送する複数のソースからの個々のRTCPパケットを、可能な場合は常に1つの複合パケットに結合して、パケットのオーバーヘッドを償却することをお勧めします（セクション7を参照）. ミキサーによって生成されるRTCP複合パケットの例を図1に示します. 複合パケットの全長がネットワークパスのMTUを超える場合は、複数の短い複合パケットに分割して、別々に送信する必要があります（SHOULD）. 基礎となるプロトコルのパケット. 各複合パケットは少なくとも1つの異なる参加者を表すため、これはRTCP帯域幅の推定を損なうことはありません. 複合パケットのそれぞれは、SRまたはRRパケットで始まる必要があることに注意してください. 

実装は、タイプが不明な着信RTCPパケットを無視する必要があります（SHOULD）. セクション15で説明されているように、追加のRTCPパケットタイプをInternet Assigned Numbers Authority（IANA）に登録できます. 

   if encrypted: random 32-bit integer
   |
   |[--------- packet --------][---------- packet ----------][-packet-]
   |
   |                receiver            chunk        chunk
   V                reports           item  item   item  item
   --------------------------------------------------------------------
   R[SR #sendinfo #site1#site2][SDES #CNAME PHONE #CNAME LOC][BYE##why]
   --------------------------------------------------------------------
   |                                                                  |
   |<-----------------------  compound packet ----------------------->|
   |<--------------------------  UDP packet ------------------------->|

   #: SSRC/CSRC identifier

              Figure 1: Example of an RTCP compound packet

6.2 RTCP送信間隔

RTPは、参加者が数人から数千人までの範囲のセッションサイズでアプリケーションを自動的に拡張できるように設計されています. たとえば、音声会議では、一度に1人または2人しか話せないため、データトラフィックは本質的に自己制限的であり、マルチキャスト配信では、特定のリンクのデータレートは参加者の数に関係なく比較的一定のままです. ただし、制御トラフィックは自己制限的ではありません. 各参加者からの受信レポートが一定のレートで送信された場合、制御トラフィックは参加者の数に比例して増加します. したがって、RTCPパケット送信間の間隔を動的に計算することにより、レートを縮小する必要があります. 

セッションごとに、データトラフィックは、「セッション帯域幅」と呼ばれる総制限の影響を受け、参加者間で分割されると想定されています. この帯域幅は予約されている場合があり、ネットワークによって制限が適用されます. 予約がない場合、環境に応じて、使用するセッションの「妥当な」最大値を確立する他の制約があり、それがセッションの帯域幅になります. セッションの帯域幅は、セッションに使用可能なネットワーク帯域幅のコストまたはアプリオリな知識に基づいて選択できます. メディアエンコーディングとは多少独立していますが、エンコーディングの選択はセッションの帯域幅によって制限される場合があります. 多くの場合、セッション帯域幅は、同時にアクティブになると予想される送信者の公称帯域幅の合計です. 電話会議の音声の場合、通常、この数は1つの送信者の帯域幅です. レイヤードエンコーディングの場合、各レイヤーは、独自のセッション帯域幅パラメーターを持つ個別のRTPセッションです. 

セッション帯域幅パラメーターは、メディアアプリケーションを呼び出すときにセッション管理アプリケーションによって提供されることが期待されますが、メディアアプリケーションは、セッション用に選択されたエンコーディングの単一送信者データ帯域幅に基づいてデフォルトを設定できます（MAY）. アプリケーションは、マルチキャストスコープルールまたは他の基準に基づいて帯域幅制限を実施することもできます（MAY）. すべての参加者は、同じRTCP間隔が計算されるように、セッション帯域幅に同じ値を使用する必要があります. 

制御トラフィックとデータトラフィックの帯域幅の計算には、下位層のトランスポートとネットワークプロトコル（UDPやIPなど）が含まれます. これは、リソース予約システムが知る必要があることだからです. アプリケーションは、これらのプロトコルのどれが使用されているかを知ることも期待できます. パケットは移動するときに異なるリンクレベルヘッダーでカプセル化されるため、リンクレベルヘッダーは計算に含まれません. 

制御トラフィックは、セッション帯域幅の小さい既知の部分に制限する必要があります. データを伝送するためのトランスポートプロトコルの主要な機能が損なわれないように、小さい必要があります. 制御トラフィックをリソース予約プロトコルに指定された帯域幅仕様に含めることができ、各参加者が独自にシェアを計算できることが知られています. 制御トラフィック帯域幅は、データトラフィックのセッション帯域幅に追加されます. RTCPに追加されるセッション帯域幅の割合を5％に固定することをお勧めします. また、RTCP帯域幅の1/4をデータを送信する参加者専用にすることをお勧めします. これにより、多数の受信者と少数の送信者とのセッションでは、新しく参加する参加者は送信サイトのCNAMEをより迅速に受信できます.  . 送信者の比率が参加者の1/4より大きい場合、送信者はRTCP帯域幅全体の比率を取得します. 間隔の計算におけるこれらの定数およびその他の定数の値は重要ではありませんが、同じ間隔が計算されるように、セッションのすべての参加者が同じ値を使用する必要があります. したがって、これらの定数は特定のプロファイル用に修正する必要があります. 

プロファイルは、制御トラフィック帯域幅が、セッション帯域幅の厳密なパーセンテージではなく、セッションの個別のパラメータである可能性があることを指定する場合があります. 別のパラメーターを使用すると、レート適応型アプリケーションが、セッション帯域幅パラメーターで指定された最大帯域幅よりも低い「通常の」データ帯域幅と一致するRTCP帯域幅を設定できます. 

プロファイルはさらに、制御トラフィックの帯域幅が、アクティブなデータ送信者である参加者とそうでない参加者の2つの別々のセッションパラメータに分割される場合があることを指定する場合があります. パラメータSとRを呼び出します. RTCP帯域幅の1/4をデータ送信者専用にするという推奨に従って、これら2つのパラメータの推奨されるデフォルト値は、それぞれ1.25％と3.75％になります. 送信者の比率が参加者のS /（S + R）より大きい場合、送信者はこれらのパラメーターの合計の比率を取得します. 2つのパラメーターを使用すると、データ送信者のRTCP帯域幅をゼロ以外に維持しながら、非データ送信者のRTCP帯域幅をゼロに設定することにより、特定のセッションでRTCP受信レポートを完全にオフにできるため、送信者レポートを引き続き送信できます.  -メディア同期. RTCP受信レポートをオフにすることは、セクション6の冒頭に記載されている機能、特に受信品質のフィードバックと輻輳制御に必要であるため、推奨されません. ただし、そうすることは、単一方向リンクで動作するシステムや、受信品質や受信機の活性度に関するフィードバックを必要とせず、輻輳を回避する他の手段があるセッションに適している場合があります. 

複合RTCPパケットの送信間の計算された間隔には、参加者の数が少なく、トラフィックが多数の法則に従って平滑化されていない場合に、パケットのバーストが許容帯域幅を超えないようにするための下限もあります. また、ネットワークパーティションのような一時的な停止中にレポートの間隔が短くなりすぎないようにし、パーティションが回復したときに適応が遅れるようにします. アプリケーションの起動時に、最初の複合RTCPパケットが送信される前に遅延が課されるべきであり（SHOULD）、RTCPパケットが他の参加者から受信される時間を確保して、レポート間隔がより迅速に正しい値に収束するようにします. この遅延は最小間隔の半分に設定して、新しい参加者が存在することをすばやく通知できます. 

実装は、最小RTCP間隔を、以下の制限付きでセッション帯域幅パラメーターに反比例してより小さい値にスケーリングできます（MAY）. 

oマルチキャストセッションの場合、アクティブなデータ送信者のみが最小値を使用して、複合RTCPパケットの送信間隔を計算できます. 

oユニキャストセッションの場合、削減された値は、アクティブなデータ送信者ではない参加者も使用できます. また、最初の複合RTCPパケットを送信する前の遅延はゼロになる場合があります. 

oすべてのセッションについて、参加者のタイムアウト間隔（セクション6.3.5を参照）を計算するときに固定最小値を使用して（SHOULD）、RTCPパケットの送信に削減された値を使用しない実装が他の参加者によって時期尚早にタイムアウトしないようにします. 

o削減された最小値（秒単位）の推奨値は、360をセッション帯域幅（キロビット/秒）で割った値です. この最小値は、72 kb / sを超える帯域幅では5秒未満です. 

セクション6.3および付録A.7で説明されているアルゴリズムは、このセクションで概説されている目標を満たすように設計されています. 参加者間で許可された制御トラフィック帯域幅を分割するために、複合RTCPパケットを送信する間隔を計算します. これにより、アプリケーションは、たとえば、すべての参加者の識別が重要でありながら、大きなセッションに自動的に適応するような小さなセッションに対して高速な応答を提供できます. アルゴリズムには次の特性が組み込まれています. o RTCPパケット間の計算された間隔は、グループ内のメンバーの数に比例します. すべてのメンバーにわたって合計されたときに一定量の制御トラフィックを可能にするのは、この線形係数です. 

o RTCPパケット間の間隔は、すべての参加者の意図しない同期を回避するために、計算された間隔の[0.5,1.5]倍の範囲でランダムに変化します[20]. セッションに参加した後に送信された最初のRTCPパケットも、最小RTCP間隔の半分のランダムな変動によって遅延されます. 

o送受信されるすべてのパケットを含む、平均の複合RTCPパケットサイズの動的な見積もりが計算され、運ばれる制御情報の量の変化に自動的に適応します. 

o計算された間隔は観測されたグループメンバーの数に依存するため、新しいユーザーが既存のセッションに参加したり、多数のユーザーが同時に新しいセッションに参加したりすると、望ましくない起動効果が生じる可能性があります. これらの新しいユーザーは、最初はグループメンバーシップの推定が正しくないため、RTCP送信間隔が短すぎます. 多くのユーザーが同時にセッションに参加している場合、この問題は重大になる可能性があります. これに対処するために、「タイマー再考」と呼ばれるアルゴリズムが採用されています. このアルゴリズムは単純なバックオフメカニズムを実装しており、グループサイズが増加している場合、ユーザーはRTCPパケットの送信を保留します. 

o BYEまたはタイムアウトにより、ユーザーがセッションを終了すると、グループメンバーシップが減少するため、計算される間隔が短くなります. 「逆再検討」アルゴリズムは、メンバーがグループメンバーシップの減少に応じて、間隔をより迅速に短縮できるようにするために使用されます. 

o BYEパケットには、他のRTCPパケットとは異なる処理が行われます. ユーザーがグループを離れ、BYEパケットを送信したい場合は、次にスケジュールされているRTCPパケットの前に送信する場合があります. ただし、BYEの送信は、多数のメンバーが同時にセッションを離れた場合にBYEパケットのフラッドを回避するバックオフアルゴリズムに従います. 

このアルゴリズムは、すべての参加者が送信を許可されているセッションに使用できます. その場合、セッション帯域幅パラメーターは、個々の送信者の帯域幅に参加者の数を掛けた積であり、RTCP帯域幅はその5％です. 

アルゴリズムの動作の詳細については、以下のセクションで説明します. 付録A.7に実装例を示します. 

6.2.1セッションメンバーの数の維持

RTCPパケット間隔の計算は、セッションに参加しているサイトの推定数に依存します. 新しいサイトが聞こえるとカウントに追加され、SSRCまたはCSRC識別子（セクション8.2を参照）でインデックス付けされたテーブルに各サイトのエントリを作成して、それらを追跡する必要があります（SHOULD）. 新しいSSRCを運ぶ複数のパケットが受信されるまで（付録A.1を参照）、またはそのSSRCのCNAMEを含むSDES RTCPパケットが受信されるまで、新しいエントリは無効と見なされる場合があります. 対応するSSRC識別子を持つRTCP BYEパケットを受信すると、エントリがテーブルから削除される場合があります. ただし、一部のストラグラーデータパケットがBYEの後に到着し、エントリが再作成される場合があります. 代わりに、エントリはBYEを受信したものとしてマークし、適切な遅延の後に削除する必要があります（SHOULD）. 

少数のRTCPレポートインターバルでRTPまたはRTCPパケットが受信されなかった場合（5が推奨）、参加者は別のサイトを非アクティブとしてマークするか、まだ有効でない場合は削除することができます（MAY）. これにより、パケット損失に対する堅牢性が提供されます. このタイムアウトが適切に機能するためには、すべてのサイトでこの乗数に同じ値を設定し、RTCPレポート間隔にほぼ同じ値を計算する必要があります. したがって、この乗数は特定のプロファイルに対して固定する必要があります. 

非常に多数の参加者がいるセッションの場合、SSRC識別子とそのすべての状態情報を格納するテーブルを維持することは非現実的です. [21]で説明されているように、実装はSSRCサンプリングを使用して、ストレージ要件を減らすことができます. 実装は、同様のパフォーマンスを持つ他のアルゴリズムを使用してもよい（MAY）. 重要な要件は、考慮されるアルゴリズムは、グループのサイズを大幅に過小評価してはいけません（SHOULD NOT）. 

6.3 RTCPパケット送受信ルール

ここでは、RTCPパケットの送信方法と受信時のルールについて説明します. マルチキャスト環境またはマルチポイントユニキャスト環境での操作を可能にする実装は、セクション6.2の要件を満たしている必要があります. そのような実装は、これらの要件を満たすためにこのセクションで定義されたアルゴリズムを使用してもよいし、同等またはより優れたパフォーマンスを提供する限り、他のアルゴリズムを使用してもよい（MAY）. 2パーティのユニキャスト操作に制限されている実装では、RTCP送信間隔のランダム化を引き続き使用して、同じ環境で動作している複数のインスタンスの意図しない同期を回避する必要がありますが、セクション6.3の「タイマー再検討」および「逆再検討」アルゴリズムを省略してもかまいません（MAY）.  .3、6.3.6、および6.3.7. 

これらのルールを実行するには、セッション参加者はいくつかの状態を維持する必要があります. 

tp：RTCPパケットが最後に送信された時間. 

tc：現在の時刻. 

tn：RTCPパケットの次のスケジュールされた送信時間. 

pmembers：tnが最後に再計算された時点でのセッションメンバーの推定数. 

メンバー：セッションメンバー数の最新の見積もり. 

送信者：セッションの送信者数の最新の見積もり. 

rtcp_bw：ターゲットRTCP帯域幅、つまり、このセッションのすべてのメンバーがRTCPパケットに使用する合計帯域幅（オクテット/秒）. これは、起動時にアプリケーションに提供される「セッション帯域幅」パラメータの指定された部分になります. 

we_sent：2つ前のRTCPレポートが送信されてからアプリケーションがデータを送信した場合にtrueになるフラグ. 

avg_rtcp_size：この参加者が送受信したすべてのRTCPパケットの平均複合RTCPパケットサイズ（オクテット単位）. セクション6.2で説明したように、サイズには下位層のトランスポートとネットワークプロトコルヘッダー（UDPやIPなど）が含まれます. 

initial：アプリケーションがまだRTCPパケットを送信していない場合にtrueになるフラグ. 

これらのルールの多くは、パケット送信間の「計算された間隔」を利用しています. この間隔については、次のセクションで説明します. 

6.3.1 RTCP送信間隔の計算

スケーラビリティを維持するには、セッション参加者からのパケット間の平均間隔をグループサイズに合わせて調整する必要があります. この間隔は、計算された間隔と呼ばれます. 上記の状態をいくつか組み合わせて得られます. 次に、計算された間隔Tは次のように決定されます. 1.送信者の数がメンバーシップ（メンバー）の25％以下の場合、間隔は、参加者が送信者であるかどうかに依存します（ we_sent）. 参加者が送信者である場合（we_sent true）、定数Cは平均RTCPパケットサイズ（avg_rtcp_size）をRTCP帯域幅（rtcp_bw）の25％で割った値に設定され、定数nは送信者の数に設定されます. we_sentがtrueでない場合、定数Cは、RTCP帯域幅の75％で割った平均RTCPパケットサイズに設定されます. 定数nは、受信者（メンバー-送信者）の数に設定されます. 送信者の数が25％を超える場合、送信者と受信者は一緒に扱われます. 定数Cは、平均RTCPパケットサイズを合計RTCP帯域幅で割った値に設定され、nはメンバーの総数に設定されます. セクション6.2で述べたように、RTPプロファイルは、RTCP帯域幅が、送信者である参加者とそうでない参加者の2つの別々のパラメーター（SおよびRと呼ぶ）によって明示的に定義されることを指定できます（MAY）. その場合、25％の割合はS /（S + R）になり、75％の割合はR /（S + R）になります. Rがゼロの場合、送信者のパーセンテージがS /（S + R）を超えることはなく、実装ではゼロによる除算を回避する必要があることに注意してください. 定数Cは、平均RTCPパケットサイズを合計RTCP帯域幅で割った値に設定され、nはメンバーの総数に設定されます. セクション6.2で述べたように、RTPプロファイルは、RTCP帯域幅が、送信者である参加者とそうでない参加者の2つの別々のパラメーター（SおよびRと呼ぶ）によって明示的に定義されることを指定できます（MAY）. その場合、25％の割合はS /（S + R）になり、75％の割合はR /（S + R）になります. Rがゼロの場合、送信者のパーセンテージがS /（S + R）を超えることはなく、実装ではゼロによる除算を回避する必要があることに注意してください. 定数Cは、平均RTCPパケットサイズを合計RTCP帯域幅で割った値に設定され、nはメンバーの総数に設定されます. セクション6.2で述べたように、RTPプロファイルは、RTCP帯域幅が、送信者である参加者とそうでない参加者の2つの別々のパラメーター（SおよびRと呼ぶ）によって明示的に定義されることを指定できます（MAY）. その場合、25％の割合はS /（S + R）になり、75％の割合はR /（S + R）になります. Rがゼロの場合、送信者のパーセンテージがS /（S + R）を超えることはなく、実装ではゼロによる除算を回避する必要があることに注意してください. RTPプロファイルは、RTCP帯域幅が、送信者である参加者とそうでない参加者の2つの別々のパラメーター（SおよびRと呼ぶ）によって明示的に定義されることを指定する場合があります. その場合、25％の割合はS /（S + R）になり、75％の割合はR /（S + R）になります. Rがゼロの場合、送信者のパーセンテージがS /（S + R）を超えることはなく、実装ではゼロによる除算を回避する必要があることに注意してください. RTPプロファイルは、RTCP帯域幅が、送信者である参加者とそうでない参加者の2つの別々のパラメーター（SおよびRと呼ぶ）によって明示的に定義されることを指定する場合があります. その場合、25％の割合はS /（S + R）になり、75％の割合はR /（S + R）になります. Rがゼロの場合、送信者のパーセンテージがS /（S + R）を超えることはなく、実装ではゼロによる除算を回避する必要があることに注意してください. 

2.参加者がまだRTCPパケットを送信していない場合（変数の初期値はtrue）、定数Tminは2.5秒に設定され、それ以外の場合は5秒に設定されます. 

3.決定論的に計算された間隔Tdはmax（Tmin、n * C）に設定されます. 

4.計算された間隔Tは、決定論的に計算された間隔の0.5倍から1.5倍の間に均一に分布する数に設定されます. 

5. Tの結果の値はe-3 / 2 = 1.21828で除算され、タイマー再検討アルゴリズムがRTCP帯域幅の値に意図された平均を下回る値に収束するという事実を補正します. 

この手順により、ランダムな間隔になりますが、平均して、RTCP帯域幅の少なくとも25％が送信側に、残りが受信側に割り当てられます. 送信者がメンバーシップの4分の1を超える場合、この手順では、平均してすべての参加者間で帯域幅を均等に分割します. 

6.3.2初期化

セッションに参加すると、参加者はtpを0に、tcを0に、sendersを0に、pmembersを1に、membersを1に、we_sentをfalseに、rtcp_bwをセッション帯域幅の指定された割合に、initialをtrueに、avg_rtcp_sizeをアプリケーションが後で構築する最初のRTCPパケットの推定サイズ. 次に、計算された間隔Tが計算され、最初のパケットが時間tn = Tにスケジュールされます. これは、時間Tで期限切れになる送信タイマーが設定されることを意味します. アプリケーションは、このタイマーを実装するために任意の望ましいアプローチを使用できます. 

参加者は、独自のSSRCをメンバーテーブルに追加します. 

6.3.3 RTPまたはBYE以外のRTCPパケットの受信

メンバーテーブルにSSRCがない参加者からRTPまたはRTCPパケットを受信すると、SSRCがテーブルに追加され、セクション6.2.1で説明されているように参加者が検証されると、メンバーの値が更新されます. 検証されたRTPパケットの各CSRCに対して同じ処理が行われます. 

SSRCが送信者テーブルにない参加者からRTPパケットを受信すると、SSRCがテーブルに追加され、送信者の値が更新されます. 

受信した複合RTCPパケットごとに、avg_rtcp_sizeの値が更新されます. 

      avg_rtcp_size =（1/16）* packet_size +（15/16）* avg_rtcp_size
        
ここで、packet_sizeは受信したRTCPパケットのサイズです. 

6.3.4 RTCP BYEパケットの受信

RTCP BYEを送信する場合のセクション6.3.7で説明されている場合を除き、受信パケットがRTCP BYEパケットの場合、SSRCはメンバーテーブルと照合されます. 存在する場合、エントリはテーブルから削除され、メンバーの値が更新されます. 次に、SSRCが送信者テーブルに対してチェックされます. 存在する場合、エントリはテーブルから削除され、送信者の値が更新されます. 

さらに、RTCPパケットの伝送速度をグループメンバーシップの変化に適応させるために、BYEパケットを受信したときに、メンバーをpmembers未満の値に減らす次の「逆再検討」アルゴリズムを実行する必要があります. 

o tnの値は、次の式に従って更新されます. 

         tn = tc +（メンバー/ pメンバー）*（tn-tc）
        
o tpの値は、次の式に従って更新されます. 

tp = tc-（メンバー/ pmembers）*（tc-tp）. 

o次のRTCPパケットは、現在より早い時刻tnでの送信用に再スケジュールされます. 

o pmembersの値は、membersと等しく設定されます. 

このアルゴリズムは、大規模なセッションのほとんどの参加者が一度に離れたが一部が残った場合の早期タイムアウトにより、グループサイズの見積もりが短時間で誤ってゼロに落ちることを防ぎません. アルゴリズムは、推定をより迅速に正しい値に戻します. この状況は非常に異常であり、結果は十分に無害なので、この問題は二次的な懸念にすぎないと見なされます. 

6.3.5 SSRCのタイムアウト

時折、参加者は他の参加者のいずれかがタイムアウトするかどうかを確認する必要があります. これを行うために、参加者は、レシーバーの決定論的（ランダム化係数なし）の計算された間隔Td、つまりwe_sent falseを計算します. 時間tc-MTd（Mはタイムアウト乗数で、デフォルトは5）からRTPまたはRTCPパケットを送信していない他のセッションメンバーはタイムアウトします. これは、そのSSRCがメンバーリストから削除され、メンバーが更新されることを意味します. 同様のチェックが送信者リストで実行されます. 時間tc-2T（最後の2つのRTCPレポート間隔内）以降にRTPパケットを送信していない送信者リストのメンバーは送信者リストから削除され、送信者が更新されます. 

いずれかのメンバーがタイムアウトした場合は、6.3.4項で説明されている逆再検討アルゴリズムを実行する必要があります. 

参加者は、RTCP送信間隔ごとに少なくとも1回このチェックを実行する必要があります. 

6.3.6送信タイマーの期限切れ

パケット送信タイマーが切れると、参加者は次の操作を実行します. 

o送信間隔Tは、ランダム化係数を含め、セクション6.3.1で説明されているように計算されます. 

o tp + Tがtc以下の場合、RTCPパケットが送信されます. tpがtcに設定され、前の手順と同様にTの別の値が計算され、tnがtc + Tに設定されます. 送信タイマーは、時刻tnに再び期限切れになるように設定されます. tp + Tがtcより大きい場合、tnはtp + Tに設定されます. RTCPパケットは送信されません. 送信タイマーは、時刻tnに満了するように設定されています. 

o pmembersはメンバーに設定されます. 

RTCPパケットが送信される場合、initialの値はFALSEに設定されます. さらに、avg_rtcp_sizeの値が更新されます. 

      avg_rtcp_size =（1/16）* packet_size +（15/16）* avg_rtcp_size
        
ここで、packet_sizeは送信されたばかりのRTCPパケットのサイズです. 

6.3.7 BYEパケットの送信

参加者がセッションを離れたい場合、BYEパケットが送信され、他の参加者にイベントを通知します. 多くの参加者がシステムを離れるときにBYEパケットのフラッドを回避するために、参加者が離れることを選択したときにメンバー数が50を超える場合、参加者は次のアルゴリズムを実行する必要があります. このアルゴリズムは、代わりにメンバー変数の通常の役割を使用してBYEパケットをカウントします. 

o参加者がシステムを離れることを決定すると、tpはtcにリセットされ、現在の時刻、メンバーおよびpmembersは1に初期化され、initialは1に設定され、we_sentはfalseに設定され、sendersは0に設定され、avg_rtcp_sizeが設定されます複合BYEパケットのサイズに. 計算された間隔Tが計算されます. 次にBYEパケットは、時間tn = tc + Tにスケジュールされます. 

o別の参加者からのBYEパケットを受信するたびに、その参加者がメンバーテーブルに存在するかどうかに関係なく、メンバーは1ずつ増加し、SSRCサンプリングが使用されている場合は、BYE SSRCが含まれるかどうかに関係なく標本、見本. 他のRTCPパケットまたはRTPパケットが受信された場合、メンバーは増加しませんが、BYEパケットの場合のみです. 同様に、avg_rtcp_sizeは、受信したBYEパケットに対してのみ更新されます. RTPパケットが到着しても送信者は更新されません. 0のままです. 

o BYEパケットの送信は、上記のように通常のRTCPパケットを送信するためのルールに従います. 

これにより、BYEパケットをすぐに送信しながら、それらの総帯域幅使用量を制御できます. 最悪の場合、これによりRTCP制御パケットが通常の2倍の帯域幅（10％）を使用する可能性があります-非BYE RTCPパケットの場合は5％、BYEの場合は5％. 

上記のメカニズムがBYEパケットの送信を許可するのを待たない参加者は、BYEをまったく送信せずにグループを去ることができます. その参加者は、最終的に他のグループメンバーによってタイムアウトになります. 

参加者が脱退することを決定したときにグループサイズの推定メンバーが50未満である場合、参加者はBYEパケットをすぐに送信できます（MAY）. あるいは、参加者は上記のBYEバックオフアルゴリズムを実行することを選択できます. 

どちらの場合も、RTPまたはRTCPパケットを送信したことがない参加者は、グループを離れるときにBYEパケットを送信してはなりません（MUST NOT）. 

6.3.8 we_sentの更新

変数we_sentには、参加者が最近RTPパケットを送信した場合はtrue、それ以外の場合はfalseが含まれます. この決定は、送信者テーブルにリストされている他の参加者のセットを管理する場合と同じメカニズムを使用して行われます. 参加者がwe_sentがfalseのときにRTPパケットを送信すると、それ自体が送信者テーブルに追加され、we_sentがtrueに設定されます. SRパケットを送信する前に、セクション6.3.4で説明されている逆再検討アルゴリズムを実行して、遅延をおそらく減らす必要があります. 別のRTPパケットが送信されるたびに、そのパケットの送信時刻がテーブルに保持されます. 次に、通常の送信者タイムアウトアルゴリズムが参加者に適用されます. RTCパケットが時間tc-2T以降送信されていない場合、参加者は送信者テーブルから自身を削除し、送信者カウントをデクリメントして、we_sentをfalseに設定します. 

6.3.9ソース記述帯域幅の割り当て

この仕様では、必須のCNAMEアイテムに加えて、NAME（個人名）やEMAIL（電子メールアドレス）など、いくつかのソース記述（SDES）アイテムが定義されています. また、新しいアプリケーション固有のRTCPパケットタイプを定義する手段も提供します. 受信レポートとCNAMEが送信される速度が遅くなり、プロトコルのパフォーマンスが低下するため、アプリケーションはこの追加情報に制御帯域幅を割り当てる際には注意が必要です. 1人の参加者に割り当てられたRTCP帯域幅の20％以下が追加情報の伝達に使用されることが推奨されます. さらに、すべてのSDESアイテムがすべてのアプリケーションに含まれることは意図されていません. 含まれているものは、それらのユーティリティに従って帯域幅の一部を割り当てる必要があります. これらの割合を動的に推定するのではなく、

たとえば、アプリケーションはCNAME、NAME、およびEMAILのみを送信し、その他は送信しないように設計されている場合があります. NAMEはアプリケーションのユーザーインターフェイスに継続的に表示されるため、EMAILよりもはるかに高い優先度が与えられる可能性がありますが、EMAILは要求された場合にのみ表示されます. すべてのRTCP間隔で、CNAMEアイテムを含むRRパケットとSDESパケットが送信されます. 最小間隔で動作する小さなセッションの場合、平均して5秒ごとになります. 3番目の間隔（15秒）ごとに、1つの追加アイテムがSDESパケットに含まれます. 8回のうち7回はNAMEアイテムで、8回（2分）ごとにEMAILアイテムになります. 

各メディアのRTPセッションで構成されるマルチメディア会議など、各参加者の共通のCNAMEを介したクロスアプリケーションバインディングを使用して複数のアプリケーションが協調して動作する場合、追加のSDES情報は1つのRTPセッションでのみ送信される場合があります. 他のセッションはCNAMEアイテムのみを扱います. 特に、このアプローチは、階層化されたエンコーディングスキームの複数のセッションに適用する必要があります（セクション2.4を参照）. 

6.4送信者および受信者レポート

RTPレシーバーは、RTCPレポートパケットを使用して受信品質フィードバックを提供します. これは、レシーバーが送信者でもあるかどうかに応じて、2つの形式のいずれかになります. パケットタイプコード以外の送信者レポート（SR）フォームと受信者レポート（RR）フォームの唯一の違いは、送信者レポートにアクティブな送信者が使用する20バイトの送信者情報セクションが含まれていることです. 最後のレポートまたは前回のレポートを発行してから、インターバル中にサイトがデータパケットを送信した場合、SRが発行されます. それ以外の場合、RRが発行されます. 

SRフォームとRRフォームの両方に、0個以上の受信レポートブロックが含まれます. 最後のレポート以降、このレシーバーがRTPデータパケットを受信した同期ソースごとに1つずつあります. CSRCリストにリストされている貢献元についてのレポートは発行されません. 各受信レポートブロックは、そのブロックに示されている特定のソースから受信したデータに関する統計を提供します. 最大31の受信レポートブロックがSRまたはRRパケットに収まるので、最後のレポート以降のインターバル中に聞こえたすべてのソースの受信レポートを含めるために、必要に応じて追加のRRパケットを最初のSRまたはRRパケットの後にスタックする必要があります. ネットワークパスのMTUを超えずに必要なすべてのRRパケットを1つの複合RTCPパケットに収めるにはソースが多すぎる場合、次に、1つのMTUに収まるサブセットのみを各間隔に含める必要があります. すべてのソースが報告されるように、サブセットは複数の間隔でラウンドロビンで選択する必要があります（SHOULD）. 

次のセクションでは、2つのレポートの形式、アプリケーションが追加のフィードバック情報を必要とする場合にプロファイル固有の方法で拡張する方法、およびレポートの使用方法を定義します. 翻訳者とミキサーによるレセプションレポートの詳細については、セクション7を参照してください. 

6.4.1 SR：送信者レポートRTCPパケット

        0                   1                   2                   3
        0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
header |V=2|P|    RC   |   PT=SR=200   |             length            |
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       |                         SSRC of sender                        |
       +=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+
sender |              NTP timestamp, most significant word             |
info   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       |             NTP timestamp, least significant word             |
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       |                         RTP timestamp                         |
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       |                     sender's packet count                     |
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       |                      sender's octet count                     |
       +=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+
report |                 SSRC_1 (SSRC of first source)                 |
block  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  1    | fraction lost |       cumulative number of packets lost       |
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       |           extended highest sequence number received           |
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       |                      interarrival jitter                      |
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       |                         last SR (LSR)                         |
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       |                   delay since last SR (DLSR)                  |
       +=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+
report |                 SSRC_2 (SSRC of second source)                |
block  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  2    :                               ...                             :
       +=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+
       |                  profile-specific extensions                  |
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

送信者レポートパケットは3つのセクションで構成され、定義されている場合は、4番目のプロファイル固有の拡張セクションが後に続く場合があります. 最初のセクションであるヘッダーは、8オクテットの長さです. フィールドには次の意味があります. 

バージョン（V）：2ビットRTPのバージョンを識別します. これは、RTCPパケットでもRTPデータパケットと同じです. この仕様で定義されているバージョンは2です. 

パディング（P）：1ビットパディングビットが設定されている場合、この個別のRTCPパケットには、制御情報の一部ではないが長さフィールドに含まれる追加のパディングオクテットが最後に含まれます. パディングの最後のオクテットは、無視されるパディングオクテットの数であり、それ自体を含みます（4の倍数になります）. 固定ブロックサイズの一部の暗号化アルゴリズムでは、パディングが必要になる場合があります. 複合RTCPパケットでは、複合パケットはセクション9.1の方法で全体として暗号化されるため、パディングは1つの個別のパケットでのみ必要です. したがって、パディングは最後の個々のパケットにのみ追加する必要があり、パディングがそのパケットに追加される場合、パディングビットはそのパケットにのみ設定する必要があります. この規則は、付録Aで説明されているヘッダーの有効性チェックに役立ちます. 

受信レポートカウント（RC）：5ビットこのパケットに含まれる受信レポートブロックの数. ゼロの値が有効です. 

パケットタイプ（PT）：8ビットこれをRTCP SRパケットとして識別する定数200が含まれています. 

length：16 bitsこのRTCPパケットの長さ（32ビットワードから1を引いたもの）（ヘッダーとパディングを含む）. （1のオフセットはゼロを有効な長さにし、複合RTCPパケットのスキャンで起こり得る無限ループを回避し、32ビットのワードをカウントすると4の倍数の有効性チェックが回避されます. ）

SSRC：32ビットこのSRパケットの発信元の同期ソース識別子. 

2番目のセクションである送信者情報は、20オクテット長であり、すべての送信者レポートパケットに存在します. この送信者からのデータ送信を要約します. フィールドには次の意味があります. 

NTPタイムスタンプ：64ビットこのレポートが送信されたときの実時間（セクション4を参照）を示し、他の受信者からの受信レポートで返されたタイムスタンプと組み合わせて、それらの受信者への往復伝搬を測定できるようにします. 受信者は、タイムスタンプの測定精度がNTPタイムスタンプの解像度よりもはるかに低く制限される可能性があることを期待する必要があります. タイムスタンプの測定の不確実性は不明な場合があるため、示されていません. ウォールクロック時間の概念はないが、「システム稼働時間」などのシステム固有のクロックがあるシステムでは、送信者はそのクロックを参照として使用して、相対NTPタイムスタンプを計算できます. マルチメディアセッションの個々のストリームを生成するために個別の実装を使用する場合、一般的に使用されるクロックを選択することが重要です. すべての実装で同じクロックを使用します. 2036年までは、相対タイムスタンプと絶対タイムスタンプの上位ビットが異なるため、（無効な）比較では大きな違いが示されます. それまでに、相対タイムスタンプが不要になることを期待しています. ウォールクロックや経過時間の概念を持たない送信者は、NTPタイムスタンプをゼロに設定してもよい（MAY）. 

RTPタイムスタンプ：32ビットNTPタイムスタンプ（上記）と同じ時刻に対応しますが、データパケットのRTPタイムスタンプと同じ単位で同じランダムオフセットを使用します. この対応は、NTPタイムスタンプが同期されるソースのメディア内およびメディア間同期に使用でき、メディアに依存しない受信者が公称RTPクロック周波数を推定するために使用できます. ほとんどの場合、このタイムスタンプは隣接するデータパケットのRTPタイムスタンプと等しくないことに注意してください. むしろ、RTPタイムスタンプカウンターとリアルタイムの関係を使用して、対応するNTPタイムスタンプから計算されなければなりません. サンプリングの瞬間にウォールクロック時間を定期的にチェックすることにより維持されます. 

送信者のパケット数：32ビット送信を開始してからこのSRパケットが生成されるまでに送信者が送信したRTPデータパケットの総数. 送信者がSSRC識別子を変更した場合は、カウントをリセットする必要があります（SHOULD）. 

送信者のオクテットカウント：32ビットこのSRパケットが生成されるまで送信を開始してから、送信者がRTPデータパケットで送信したペイロードオクテット（ヘッダーまたはパディングを含まない）の総数. 送信者がSSRC識別子を変更した場合は、カウントをリセットする必要があります（SHOULD）. このフィールドは、平均ペイロードデータレートを推定するために使用できます. 

3番目のセクションには、最後のレポート以降にこの送信者が聞いた他のソースの数に応じて、0個以上の受信レポートブロックが含まれます. 各受信レポートブロックは、単一の同期ソースからのRTPパケットの受信に関する統計を伝えます. 衝突が原因でソースがSSRC識別子を変更した場合、受信者は統計を引き継がないでください. これらの統計は次のとおりです. SSRC_n（ソース識別子）：32ビットこの受信レポートブロックの情報が関係するソースのSSRC識別子. 

失われた割合：8ビット前のSRまたはRRパケットが送信されてからソースSSRC_nから失われたRTPデータパケットの割合. フィールドの左端に2進小数点がある固定小数点数として表されます. （これは、損失部分に256を掛けた後の整数部分を取ることと同じです. ）この部分は、次の段落で定義するように、失われたパケット数を予期されるパケット数で割ったものとして定義されます. 実装は付録A.3に示されています. 重複により損失が負の場合、損失率はゼロに設定されます. 受信側は、最後のパケットを受信した後にパケットが失われたかどうかを判断できず、最後のレポート間隔中に送信元から送信されたすべてのパケットが失われた場合、ソースに対して発行された受信レポートブロックはないことに注意してください. 

失われたパケットの累積数：24ビット受信の開始以降に失われた、ソースSSRC_nからのRTPデータパケットの総数. この数は、予想されるパケット数から実際に受信されたパケット数を差し引いた数として定義されます. 受信されたパケット数には、遅延または重複したパケットが含まれます. したがって、遅れて到着するパケットは損失としてカウントされず、重複がある場合、損失は負になる可能性があります. 予期されるパケット数は、次に定義されるように、受信された拡張された最後のシーケンス番号から、受信された最初のシーケンス番号を差し引いたものとして定義されます. これは、付録A.3に示すように計算できます. 

受信した拡張最大シーケンス番号：32ビット下位16ビットには、ソースSSRC_nからRTPデータパケットで受信した最大シーケンス番号が含まれ、最上位16ビットは、シーケンス番号サイクルの対応するカウントでそのシーケンス番号を拡張します. 付録A.1のアルゴリズムに従って. 同じセッション内の異なるレシーバーは、開始時刻が大幅に異なる場合、シーケンス番号に異なる拡張子を生成することに注意してください. 

到着間ジッター：32ビットタイムスタンプ単位で測定され、符号なし整数として表される、RTPデータパケットの到着間時間の統計的変動の推定値. 到着間ジッタJは、パケットのペアの送信側と比較した受信側のパケット間隔の差Dの平均偏差（平滑化された絶対値）として定義されます. 次の式に示すように、これは2つのパケットの「相対通過時間」の差に相当します. 

相対通過時間は、パケットのRTPタイムスタンプと到着時のレシーバーのクロックとの差であり、同じ単位で測定されます. 

SiがパケットiからのRTPタイムスタンプであり、RiがパケットiのRTPタイムスタンプ単位での到着時間である場合、2つのパケットiおよびjの場合、Dは次のように表されます. 

         D（i、j）=（Rj-Ri）-（Sj-Si）=（Rj-Sj）-（Ri-Si）
        
次の式に従って、各データパケットiがソースSSRC_nから受信されたときに、到着間ジッターを連続的に計算する必要があります. 

         J（i）= J（i-1）+（| D（i-1、i）|-J（i-1））/ 16
        
受信レポートが発行されるたびに、Jの現在の値がサンプリングされます. 

ジッターの計算は、プロファイルに依存しないモニターが異なる実装からのレポートを有効に解釈できるようにするために、ここで指定された式に準拠する必要があります. このアルゴリズムは最適な1次推定量であり、ゲインパラメーター1/16は、妥当な収束率を維持しながら、良好なノイズ低減率を提供します[22]. 実装例を付録A.8に示します. 送信前のさまざまなパケット持続時間と遅延の影響については、セクション6.4.4を参照してください. 

最後のSRタイムスタンプ（LSR）：32ビットソースSSRC_nからの最新のRTCP送信者レポート（SR）パケットの一部として受信されたNTPタイムスタンプ（セクション4で説明）の64の中間の32ビット. SRがまだ受信されていない場合、フィールドはゼロに設定されます. 

最後のSRからの遅延（DLSR）：32ビットソースSSRC_nから最後のSRパケットを受信して​​からこの受信レポートブロックを送信するまでの遅延（1/65536秒単位）. SRRCパケットがSSRC_nからまだ受信されていない場合、DLSRフィールドはゼロに設定されます. 

SSRC_rに、このレシーバーレポートを発行するレシーバーを示します. ソースSSRC_nは、この受信レポートブロックが受信された時間Aを記録することにより、SSRC_rへの往復伝播遅延を計算できます. 最後のSRタイムスタンプ（LSR）フィールドを使用して合計往復時間A-LSRを計算し、このフィールドを差し引いて往復伝搬遅延を（A-LSR-DLSR）のままにします. これを図2に示します. 時間は、32ビットフィールドの16進表記と、同等の浮動小数点10進表記の両方で表示されます. コロンは、16ビット整数部と16ビット小数部に分割された32ビットフィールドを示します. 

一部のリンクには非常に非対称的な遅延がありますが、これはクラスターレシーバーまでの距離のおおよその目安として使用できます. 

   [10 Nov 1995 11:33:25.125 UTC]       [10 Nov 1995 11:33:36.5 UTC]
   n                 SR(n)              A=b710:8000 (46864.500 s)
   ---------------------------------------------------------------->
                      v                 ^
   ntp_sec =0xb44db705 v               ^ dlsr=0x0005:4000 (    5.250s)
   ntp_frac=0x20000000  v             ^  lsr =0xb705:2000 (46853.125s)
     (3024992005.125 s)  v           ^
   r                      v         ^ RR(n)
   ---------------------------------------------------------------->
                          |<-DLSR->|
                           (5.250 s)

   A     0xb710:8000 (46864.500 s)
   DLSR -0x0005:4000 (    5.250 s)
   LSR  -0xb705:2000 (46853.125 s)
   -------------------------------
   delay 0x0006:2000 (    6.125 s)
        
           Figure 2: Example for round-trip time computation

6.4.2 RR：レシーバーレポートRTCPパケット

        0                   1                   2                   3
        0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
header |V=2|P|    RC   |   PT=RR=201   |             length            |
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       |                     SSRC of packet sender                     |
       +=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+
report |                 SSRC_1 (SSRC of first source)                 |
block  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  1    | fraction lost |       cumulative number of packets lost       |
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       |           extended highest sequence number received           |
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       |                      interarrival jitter                      |
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       |                         last SR (LSR)                         |
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       |                   delay since last SR (DLSR)                  |
       +=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+
report |                 SSRC_2 (SSRC of second source)                |
block  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  2    :                               ...                             :
       +=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+
       |                  profile-specific extensions                  |
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        
受信者レポート（RR）パケットのフォーマットはSRパケットのフォーマットと同じですが、パケットタイプフィールドに定数201が含まれ、送信者情報の5ワードが省略されています（これらはNTPおよびRTPタイムスタンプと送信者のパケットであり、オクテット数）. 残りのフィールドは、SRパケットと同じ意味です. 

報告するデータの送受信がない場合は、空のRRパケット（RC = 0）を複合RTCPパケットの先頭に配置する必要があります. 

6.4.3送信者および受信者レポートの拡張

送信者または受信者について定期的に報告する必要がある追加情報がある場合、プロファイルは送信者レポートと受信者レポートのプロファイル固有の拡張を定義する必要があります（SHOULD）. このメソッドは、オーバーヘッドが少ないため、別のRTCPパケットタイプを定義するよりも優先して使用する必要があります. 

oパケット内のオクテットが少ない（RTCPヘッダーまたはSSRCフィールドがない）. 

oそのプロファイルの下で実行されているアプリケーションは、受信レポート後に直接アクセス可能な場所の拡張フィールドを常に期待するようにプログラムされるため、よりシンプルで高速な解析. 

拡張子は、送信者または受信者レポートパケットの4番目のセクションであり、受信レポートがブロックされた後、最後に送信されます. 追加の送信者情報が必要な場合、送信者レポートの場合は最初に拡張セクションに含まれますが、受信者レポートの場合は存在しません. 受信者に関する情報を含める場合、そのデータは、既存の受信レポートブロックの配列に平行なブロックの配列として構造化する必要があります（SHOULD）. つまり、ブロックの数はRCフィールドで示されます. 

6.4.4送信者および受信者レポートの分析

受信品質のフィードバックは、送信者だけでなく、他の受信者やサードパーティのモニターにも役立つことが期待されています. 送信者はフィードバックに基づいて送信を変更できます. レシーバは、問題がローカル、リージョナル、グローバルのいずれであるかを判断できます. ネットワーク管理者は、対応するRTPデータパケットではなくRTCPパケットのみを受信するプロファイルに依存しないモニターを使用して、マルチキャスト配信のためのネットワークのパフォーマンスを評価できます. 

送信者情報ブロックと受信者レポートブロックの両方で累積カウントが使用されるため、任意の2つのレポート間の差異を計算して、短期と長期の両方で測定を行い、レポートの損失に対する回復力を提供できます. 受信した最後の2つのレポートの違いを使用して、最近の分布の質を推定できます. NTPタイムスタンプが含まれているため、2つのレポートの間隔でこれらの差からレートを計算できます. そのタイムスタンプはデータエンコーディングのクロックレートに依存しないため、エンコーディングおよびプロファイルに依存しない品質モニターを実装することが可能です. 

計算例としては、2つの受信レポート間のインターバルにおけるパケット損失率があります. 失われたパケットの累積数の違いは、その間隔中に失われた数を示します. 受信した拡張最後のシーケンス番号の違いにより、間隔中に予想されるパケット数がわかります. これら2つの比率は、インターバルにおけるパケット損失率です. 2つのレポートが連続している場合、この比率は損失率フィールドと等しくなるはずですが、そうでない場合はそうではありません. 1秒あたりの損失率は、損失率を秒単位で表したNTPタイムスタンプの差で割ることで取得できます. 受信したパケット数は、予想されるパケット数から失われた数を引いたものです. 予想されるパケット数は、損失推定の統計的妥当性を判断するためにも使用できます. 例えば、

サードパーティのモニターは、送信者情報から、データを受信せずに、ある間隔での平均ペイロードデータレートと平均パケットレートを計算できます. 2つの比率をとると、平均ペイロードサイズがわかります. パケット損失がパケットサイズとは無関係であると想定できる場合、特定のレシーバーが受信したパケット数に平均ペイロードサイズ（または対応するパケットサイズ）を掛けると、そのレシーバーで利用できる見かけのスループットが得られます. 

レポート間の差異を使用して長期間のパケット損失測定を可能にする累積カウントに加えて、割合損失フィールドは、単一のレポートからの短期測定を提供します. これは、セッションのサイズが大きくなり、すべてのレシーバーの受信状態情報が保持されない可能性があるか、レポート間の間隔が長くなり、特定のレシーバーから1つのレポートしか受信されなかった場合に重要になります. 

到着間ジッタフィールドは、ネットワークの輻輳の2番目の短期的な測定値を提供します. パケット損失は持続的な輻輳を追跡し、ジッター測定は一時的な輻輳を追跡します. ジッタ測定は、パケット損失につながる前に輻輳を示す場合があります. 到着間ジッタフィールドは、レポート時のジッタのスナップショットにすぎず、定量的に取得することを意図したものではありません. むしろ、それは、時間の経過に伴う1つのレシーバーからの、または同時に（たとえば、単一のネットワーク内の）複数のレシーバーからの多数のレポート全体の比較を目的としています. レシーバー間で比較できるようにするには、すべてのレシーバーが同じ式に従ってジッターを計算することが重要です. 

ジッタの計算は、パケットの最初のデータがサンプリングされた瞬間を表すRTPタイムスタンプに基づいているため、サンプリングの瞬間とパケットが送信される時間との間の遅延の変動は、計算されるジッタに影響します. このような遅延の変動は、さまざまな期間のオーディオパケットで発生します. また、タイムスタンプは1つのフレームのすべてのパケットで同じですが、それらのパケットがすべて同時に送信されるわけではないため、ビデオエンコーディングでも発生します. 送信までの遅延の変動は、それ自体でネットワークの動作の尺度としてのジッター計算の精度を低下させますが、レシーバーバッファーが対応する必要があることを考慮することを含めるのが適切です. 比較計算としてジッター計算を使用すると、伝送が差し引かれるまでの遅延の変動による（一定の）成分. これにより、ネットワークジッタ成分の変化が比較的小さい場合を除き、観測できます. 変化が小さい場合、それは重要ではない可能性があります. 

6.5 SDES：ソース記述RTCPパケット

        0                   1                   2                   3
        0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
header |V=2|P|    SC   |  PT=SDES=202  |             length            |
       +=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+
chunk  |                          SSRC/CSRC_1                          |
  1    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       |                           SDES items                          |
       |                              ...                              |
       +=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+
chunk  |                          SSRC/CSRC_2                          |
  2    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       |                           SDES items                          |
       |                              ...                              |
       +=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+

        
SDESパケットは、ヘッダーと0個以上のチャンクで構成される3レベルの構造であり、各チャンクは、そのチャンクで識別されたソースを説明するアイテムで構成されています. 項目については、以降のセクションで個別に説明します. 

バージョン（V）、パディング（P）、長さ：SRパケットについて説明したとおり（セクション6.4.1を参照）. 

パケットタイプ（PT）：8ビットこれをRTCP SDESパケットとして識別する定数202が含まれています. 

ソースカウント（SC）：5ビットこのSDESパケットに含まれるSSRC / CSRCチャンクの数. ゼロの値は有効ですが、役に立ちません. 

各チャンクは、SSRC / CSRC識別子と、それに続く0個以上の項目のリストで構成され、SSRC / CSRCに関する情報を保持します. 各チャンクは32ビット境界で始まります. 各項目は、8ビットタイプのフィールド、テキストの長さを表す8ビットのオクテットカウント（したがって、この2オクテットのヘッダーは含まない）、およびテキスト自体で構成されます. テキストは255オクテット以下にする必要がありますが、これはRTCP帯域幅の消費を制限する必要性と一致しています. 

テキストは、RFC 2279 [5]で指定されているUTF-8エンコーディングに従ってエンコードされます. US-ASCIIはこのエンコーディングのサブセットであり、追加のエンコーディングは必要ありません. マルチオクテットエンコーディングの存在は、文字の最上位ビットを1の値に設定することで示されます. 

アイテムは連続しています. つまり、アイテムは32ビット境界まで個別にパディングされていません. 一部のマルチオクテットエンコーディングにはnullオクテットが含まれるため、テキストはnullで終了しません. 各チャンク内のアイテムのリストは、1つ以上のヌルオクテットで終了する必要があります. 最初のオクテットは、リストの終わりを示すゼロのアイテムタイプとして解釈されます. null項目タイプオクテットの後に長さオクテットはありませんが、次の32ビット境界までパディングする必要がある場合は、追加のnullオクテットを含める必要があります. このパディングは、RTCPヘッダーのPビットで示されるパディングとは異なることに注意してください. ゼロ項目（4つのヌルオクテット）のチャンクは有効ですが、役に立たないものです. 

エンドシステムは、独自のソース識別子を含む1つのSDESパケットを送信します（固定RTPヘッダーのSSRCと同じ）. ミキサーは、SDES情報の受信元となるソースごとにチャンクを含む1つのSDESパケットを送信します. そのようなソースが31以上ある場合は、セクション7を参照してください. 

現在定義されているSDESアイテムについては、次のセクションで説明します. CNAMEアイテムのみが必須です. ここに表示される一部のアイテムは特定のプロファイルにのみ役立つ場合がありますが、アイテムタイプはすべて1つの共通スペースから割り当てられ、共有の使用を促進し、プロファイルに依存しないアプリケーションを簡略化します. セクション15で説明するように、タイプ番号をIANAに登録することにより、プロファイルで追加の項目を定義できます. 

6.5.1 CNAME：Canonical End-Point Identifier SDESアイテム

    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |    CNAME=1    |     length    | user and domain name        ...
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        
CNAME識別子には次のプロパティがあります. 

oランダムに割り当てられたSSRC識別子は、競合が発見された場合、またはプログラムが再起動された場合に変更される可能性があるため、SSRC識別子からソース（送信者または受信者）の識別子へのバインディングを提供するCNAMEアイテムを含める必要があります. 

o SSRC識別子と同様に、CNAME識別子も1つのRTPセッション内のすべての参加者の間で一意である必要があります（SHOULD）. 

o一連の関連するRTPセッションで1人の参加者が使用する複数のメディアツールにバインドを提供するには、その参加者に対してCNAMEを修正する必要があります（SHOULD）. 

oサードパーティの監視を容易にするために、CNAMEは、プログラムまたは人がソースを特定するのに適している必要があります. 

したがって、CNAMEはアルゴリズムで導出する必要があり、可能な場合は手動で入力しないでください. これらの要件を満たすには、プロファイルで代替の構文またはセマンティクスが指定されていない限り、次の形式を使用する必要があります（SHOULD）. CNAMEアイテムの形式は「user @ host」、またはシングルユーザーシステムのようにユーザー名が利用できない場合は「host」にする必要があります. どちらの形式でも、「ホスト」は、リアルタイムデータの発信元であるホストの完全修飾ドメイン名であり、RFC 1034 [6]、RFC 1035 [7]およびRFC 1123のセクション2.1で指定された規則に従ってフォーマットされています.  [8]; または、RTP通信に使用されるインターフェース上のホストの数値アドレスの標準ASCII表記. たとえば、IPバージョン4アドレスの標準ASCII表現は「ドット付き10進数」で、ドット付きクワッドとも呼ばれます. IPバージョン6の場合、アドレスはコロンで区切られた16進数字のグループとしてテキストで表されます（RFC 3513 [23]で詳細に説明されているようにバリエーションがあります）. 他のアドレスタイプには、相互に一意のASCII表現が必要です. 完全修飾ドメイン名は人間の観察者にとってより便利であり、さらにNAMEアイテムを送信する必要を回避する可能性がありますが、一部の動作環境では確実に取得することが困難または不可能である場合があります. そのような環境で実行される可能性のあるアプリケーションは、代わりにアドレスのASCII表現を使用する必要があります. 完全修飾ドメイン名は人間の観察者にとってより便利であり、さらにNAMEアイテムを送信する必要を回避する可能性がありますが、一部の動作環境では確実に取得することが困難または不可能である場合があります. そのような環境で実行される可能性のあるアプリケーションは、代わりにアドレスのASCII表現を使用する必要があります. 完全修飾ドメイン名は人間の観察者にとってより便利であり、さらにNAMEアイテムを送信する必要を回避する可能性がありますが、一部の動作環境では確実に取得することが困難または不可能である場合があります. そのような環境で実行される可能性のあるアプリケーションは、代わりにアドレスのASCII表現を使用する必要があります. 

たとえば、マルチユーザーシステムの場合、「doe@sleepy.example.com」、「doe@192.0.2.89」、「doe @ 2201：056D :: 112E：144A：1E24」などです. ユーザー名のないシステムでは、例は「sleepy.example.com」、「192.0.2.89」または「2201：056D :: 112E：144A：1E24」です. 

ユーザー名は、「finger」や「talk」などのプログラムが使用できる形式にする必要があります. つまり、通常は個人名ではなくログイン名です. ホスト名は、参加者の電子メールアドレスのホスト名と必ずしも同じではありません. 

アプリケーションがユーザーが1つのホストから複数のソースを生成することを許可する場合、この構文は各ソースに一意の識別子を提供しません. そのようなアプリケーションは、ソースをさらに識別するためにSSRCに依存する必要があります. または、そのアプリケーションのプロファイルは、CNAME識別子の追加の構文を指定する必要があります. 

各アプリケーションが個別にCNAMEを作成する場合、関連するRTPセッションのセットの1つの参加者に属する複数のメディアツールにバインドを提供するために必要となるため、結果のCNAMEは同一ではない可能性があります. クロスメディアバインディングが必要な場合、各ツールのCNAMEを調整ツールによって同じ値で外部的に構成する必要がある場合があります. 

アプリケーション作成者は、RFC 1918 [24]で提案されているNet-10割り当てなどのプライベートネットワークアドレス割り当てが、グローバルに一意ではないネットワークアドレスを作成する可能性があることに注意する必要があります. プライベートアドレスがあり、パブリックインターネットへの直接IP接続がないホストのRTPパケットがRTPレベルのトランスレータを介してパブリックインターネットに転送される場合、これは一意でないCNAMEにつながります. （RFC 1627 [25]も参照してください. ）このケースを処理するために、アプリケーションは一意のCNAMEを構成する手段を提供できますが、プライベートアドレスが必要にならないようにする必要がある場合は、CNAMEをプライベートアドレスからパブリックアドレスに変換するトランスレータの負担になります. 露出した. 

6.5.2 NAME：ユーザー名SDESアイテム

    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |     NAME=2    |     length    | common name of source       ...
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        
これは、「John Doe、Bit Recycler」など、ソースを説明するために使用される実際の名前です. これは、ユーザーが希望する任意の形式にすることができます. 会議などのアプリケーションでは、この形式の名前が参加者リストでの表示に最も適しているため、CNAME以外のアイテムの中で最も頻繁に送信される可能性があります. プロファイルはそのような優先順位を確立してもよい（MAY）. NAME値は、少なくともセッションの間は一定のままであることが期待されます. セッションのすべての参加者の間で一意であるとは限りません. 

6.5.3電子メール：電子メールアドレスSDESアイテム

    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |    EMAIL=3    |     length    | email address of source     ...
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        
電子メールアドレスは、RFC 2822 [9]に従ってフォーマットされます（例： "John.Doe@example.com"）. EMAIL値は、セッションの期間中一定のままであると予想されます. 

6.5.4電話：電話番号SDESアイテム

    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |    PHONE=4    |     length    | phone number of source      ...
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        
電話番号は、国際アクセスコードを置き換えるプラス記号でフォーマットする必要があります. たとえば、米国の番号の場合は「+1 908 555 1212」. 

6.5.5 LOC：地理的ユーザーの場所SDESアイテム

    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |     LOC=5     |     length    | geographic location of site ...
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        
アプリケーションに応じて、さまざまな詳細度がこのアイテムに適しています. 会議アプリケーションの場合、「ニュージャージー州マレーヒル」のような文字列で十分ですが、アクティブなバッジシステムの場合、「Room 2A244、AT＆T BL MH」のような文字列が適切な場合があります. 詳細度は実装やユーザーに委ねられますが、フォーマットとコンテンツはプロファイルによって規定される場合があります. LOC値は、モバイルホストを除き、セッションの期間中一定のままであると予想されます. 

6.5.6ツール：アプリケーションまたはツール名のSDESアイテム

    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |     TOOL=6    |     length    |name/version of source appl. ...
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        
ストリームを生成するアプリケーションの名前と、場合によってはバージョンを示す文字列（例： "videotool 1.2"）. この情報はデバッグに役立つ場合があり、MailerまたはMail-System-Version SMTPヘッダーに似ています. TOOL値は、セッションの期間中一定のままであることが期待されます. 

6.5.7注：通知/ステータスSDESアイテム

    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |     NOTE=7    |     length    | note about the source       ...
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        
このアイテムには次のセマンティクスが推奨されますが、これらまたは他のセマンティクスはプロファイルによって明示的に定義される場合があります. NOTE項目は、ソースの現在の状態を説明する一時的なメッセージを対象としています（例：「電話中、話せません」）. または、セミナー中に、このアイテムを使用してトークのタイトルを伝えることもできます. これは例外的な情報を伝えるためにのみ使用する必要があり、受信レポートとCNAMEが送信される速度が遅くなり、プロトコルのパフォーマンスが低下するため、すべての参加者が日常的に含めるべきではありません. 特に、ユーザーの構成ファイルのアイテムとして含めたり、今日の見積もりの​​ように自動的に生成したりしないでください. 

NOTEアイテムはアクティブなときに表示することが重要な場合があるため、NAMEなどの他のCNAME以外のアイテムが送信される速度が低下し、NOTEアイテムがRTCP帯域幅のその部分を占めるようになる場合があります. 一時的なメッセージが非アクティブになると、NOTアイテムは同じ繰り返しレートで数回送信され続ける必要がありますが、受信者に信号を送るために長さがゼロの文字列で送信されます. ただし、受信者は、繰り返し数の小さな倍数、またはおそらく20〜30 RTCP間隔で受信されない場合、NOTEアイテムを非アクティブと見なす必要があります. 

6.5.8 PRIV：Private Extensions SDESアイテム

     0                   1                   2                   3
     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |     PRIV=8    |     length    | prefix length |prefix string...
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    ...             |                  value string               ...
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        
この項目は、実験的またはアプリケーション固有のSDES拡張を定義するために使用されます. 項目には、長さと文字列のペアで構成される接頭辞が含まれ、その後に値文字列が残りの項目を埋め、必要な情報を保持します. プレフィックス長フィールドは8ビット長です. プレフィックス文字列は、このアプリケーションが受け取る可能性のある他のPRIVアイテムに対して一意になるようにPRIVアイテムを定義する人が選択した名前です. アプリケーションの作成者は、必要に応じて、アプリケーション名と追加のサブタイプIDを使用することを選択できます. または、他の人が彼らが表すエンティティに基づいて名前を選択し、そのエンティティ内での名前の使用を調整することをお勧めします. 

接頭辞は、アイテムの全長255オクテット内のスペースをいくらか消費するため、接頭辞はできるだけ短くする必要があります. この機能と制約されたRTCP帯域幅は過負荷にならないようにしてください. すべてのアプリケーションのすべての制御通信要件を満たすことは意図されていません. 

SDES PRIVプレフィックスはIANAによって登録されません. 何らかの形のPRIVアイテムが一般的な有用性があることが判明した場合は、プレフィックスが不要になるように、IANAに登録された通常のSDESアイテムタイプを割り当てる必要があります（SHOULD）. これにより、使用が簡単になり、伝送効率が向上します. 

6.6 BYE：さようならRTCPパケット

       0                   1                   2                   3
       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |V=2|P|    SC   |   PT=BYE=203  |             length            |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |                           SSRC/CSRC                           |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      :                              ...                              :
      +=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+
(opt) |     length    |               reason for leaving            ...
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        
BYEパケットは、1つ以上のソースがアクティブではなくなったことを示します. 

バージョン（V）、パディング（P）、長さ：SRパケットについて説明したとおり（セクション6.4.1を参照）. 

パケットタイプ（PT）：8ビットこれをRTCP BYEパケットとして識別する定数203が含まれています. 

ソースカウント（SC）：5ビットこのBYEパケットに含まれるSSRC / CSRC識別子の数. ゼロのカウント値は有効ですが、役に立ちません. 

BYEパケットを送信する必要がある場合の規則は、セクション6.3.7および8.2で指定されています. 

BYEパケットがミキサーによって受信された場合、ミキサーは、SSRC / CSRC識別子を変更せずにBYEパケットを転送する必要があります（SHOULD）. ミキサーがシャットダウンする場合、ミキサーは、処理するすべてのソースと、独自のSSRC識別子をリストしたBYEパケットを送信する必要があります（SHOULD）. 必要に応じて、BYEパケットは、8ビットのオクテットカウントの後に、たとえば「カメラの誤動作」や「RTPループが検出された」などの理由を示すテキストの多くのオクテットが続く場合があります. 文字列のエンコードは、SDESで説明したものと同じです. 文字列が次の32ビット境界までパケットを満たす場合、文字列はnullで終了していません. そうでない場合、BYEパケットは次の32ビット境界までヌルオクテットでパディングする必要があります. このパディングは、RTCPヘッダーのPビットで示されるものとは別です. 

6.7 APP：アプリケーション定義のRTCPパケット

    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |V=2|P| subtype |   PT=APP=204  |             length            |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                           SSRC/CSRC                           |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                          name (ASCII)                         |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                   application-dependent data                ...
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        
APPパケットは、パケットタイプ値の登録を必要とせずに、新しいアプリケーションや新機能が開発された実験的な使用を目的としています. 認識されない名前のAPPパケットは無視する必要があります. テスト後、幅広い使用が正当化される場合は、各APPパケットをサブタイプおよび名前フィールドなしで再定義し、RTCPパケットタイプを使用してIANAに登録することをお勧めします. 

バージョン（V）、パディング（P）、長さ：SRパケットについて説明したとおり（セクション6.4.1を参照）. 

サブタイプ：5ビットサブタイプとして使用して、一連のAPPパケットを1つの一意の名前で定義したり、アプリケーションに依存するデータに使用したりできます. 

パケットタイプ（PT）：8ビットこれをRTCP APPパケットとして識別する定数204が含まれています. 

name：4オクテットこのアプリケーションが受信する可能性のある他のAPPパケットに対して一意になるようにAPPパケットのセットを定義する人が選択した名前. アプリケーションの作成者は、アプリケーション名を使用することを選択し、アプリケーションの新しいパケットタイプを定義したい他の人へのサブタイプ値の割り当てを調整できます. または、他の人が彼らが表すエンティティに基づいて名前を選択し、そのエンティティ内での名前の使用を調整することをお勧めします. 名前は、4つのASCII文字のシーケンスとして解釈され、大文字と小文字は区別されます. 

アプリケーション依存データ：可変長アプリケーション依存データは、APPパケットに含まれる場合と含まれない場合があります. これは、RTP自体ではなく、アプリケーションによって解釈されます. 32ビットの倍数である必要があります. 


7. RTPトランスレーターとミキサー

エンドシステムに加えて、RTPは「トランスレータ」と「ミキサー」の概念をサポートしています. これは、RTPレベルで「中間システム」と見なすことができます. このサポートによりプロトコルが多少複雑になりますが、これらの機能の必要性は、インターネットでのマルチキャストオーディオおよびビデオアプリケーションの実験によって明らかになりました. セクション2.3に記載されているトランスレータとミキサーの使用例は、ファイアウォールと低帯域幅接続の存在に由来します. これらは両方とも残る可能性があります. 

7.1一般的な説明

RTPトランスレータ/ミキサーは、2つ以上のトランスポートレベルの「クラウド」を接続します. 通常、各クラウドは、共通のネットワークとトランスポートプロトコル（IP / UDPなど）に加えて、マルチキャストアドレスとトランスポートレベルの宛先ポートまたはユニキャストアドレスとポートのペアによって定義されます. （IPバージョン4からIPバージョン6などのネットワークレベルのプロトコルトランスレーターは、R​​TPからは見えないようにクラウド内に存在する場合があります. ）1つのシステムが、複数のRTPセッションのトランスレーターまたはミキサーとして機能する場合がありますが、それぞれが論理的に見なされます. 別のエンティティ. 

トランスレータまたはミキサーがインストールされているときにループが発生しないようにするために、次のルールを遵守する必要があります. 

o 1つのRTPセッションに参加しているトランスレーターとミキサーによって接続されている各クラウドは、これらのパラメーター（プロトコル、アドレス、ポート）の少なくとも1つが他のすべてと区別されているか、ネットワークレベルで他から分離されている必要があります. 

o最初のルールの派生物は、転送されるソースのセットを分割する配置がない限り、複数のトランスレータまたはミキサーを並列に接続してはならないことです. 

同様に、1つ以上のRTPトランスレータまたはミキサーを介して通信できるすべてのRTPエンドシステムは、同じSSRCスペースを共有します. つまり、SSRC識別子は、これらすべてのエンドシステム間で一意である必要があります. セクション8.2では、SSRC識別子を一意に保ち、ループを検出する衝突解決アルゴリズムについて説明します. 

さまざまな目的とアプリケーション向けに設計された多くの種類のトランスレータとミキサーがあるかもしれません. いくつかの例は、暗号化の追加または削除、データまたは基になるプロトコルのエンコーディングの変更、またはマルチキャストアドレスと1つ以上のユニキャストアドレス間の複製です. トランスレーターとミキサーの違いは、トランスレーターは異なるソースからのデータストリームを個別に通過するのに対し、ミキサーはそれらを結合して1つの新しいストリームを形成することです. 

トランスレーター：RTPパケットを、SSRC IDをそのままにして転送します. これにより、すべてのソースからのパケットが同じトランスレータを通過し、トランスレータのネットワークソースアドレスを伝送する場合でも、レシーバは個々のソースを識別できます. 一部の種類のトランスレータはそのままデータを通過しますが、他の種類のトランスレータはデータのエンコーディングを変更して、RTPデータのペイロードタイプとタイムスタンプを変更する場合があります. 複数のデータパケットが1つに再エンコードされる場合、またはその逆の場合、トランスレータは、新しいシーケンス番号を発信パケットに割り当てる必要があります. 着信パケットストリームの損失は、発信シーケンス番号に対応するギャップを引き起こす可能性があります. レシーバーは、他の方法で、元のソースが使用したペイロードタイプまたはトランスポートアドレスを知らない限り、トランスレーターの存在を検出できません. 

ミキサー：1つ以上のソースからRTPデータパケットのストリームを受信し、データ形式を変更し、何らかの方法でストリームを結合してから、結合したストリームを転送します. 複数の入力ソース間のタイミングは一般に同期されないため、ミキサーはストリーム間のタイミング調整を行い、結合されたストリームに対して独自のタイミングを生成するため、同期ソースになります. したがって、ミキサーによって転送されるすべてのデータパケットは、ミキサー自体のSSRC識別子でマークされている必要があります. 混合パケットに寄与する元のソースのIDを保持するために、ミキサーは、パケットの固定RTPヘッダーに続くCSRC識別子リストにSSRC識別子を挿入する必要があります（SHOULD）. 

一部のアプリケーションでは、ミキサーがCSRCリストでソースを識別しないことが許容される場合があります. ただし、これにより、これらのソースを含むループが検出されない危険性が生じます. 

オーディオなどのアプリケーションでのトランスレーターに対するミキサーの利点は、入力側で複数のソースがアクティブな場合でも、出力帯域幅が1つのソースの帯域幅に制限されることです. これは、低帯域幅のリンクにとって重要な場合があります. 短所は、ミキサーのリモートコントロール用に何らかのメカニズムが実装されていない限り、出力側のレシーバーがどのソースを通過またはミュートするかを制御できないことです. ミキサーによる同期情報の再生成は、レシーバーが元のストリームのメディア間同期を実行できないことも意味します. マルチメディアミキサーはそれを行うことができます. 

         [E1] [E6]
          | |
    E1：17 | E6：15 |
          | | E6：15
          V M1：48（1,17）M1：48（1,17）V M1：48（1,17）
         （M1）-------------> <T1> -----------------> <T2> --------- -----> [E7]
          ^ ^ E4：47 ^ E4：47
     E2：1 | E4：47 | | M3：89（64,45）
          | | |
         [E2] [E4] M3：89（64,45）|
                                                  | 伝説：
   [E3] --------->（M2）----------->（M3）------------ | 【エンドシステム】
          E3：64 M2：12（64）^（ミキサー）
                                   | E5：45 <翻訳者>
                                   |
                                  [E5]出典：SSRC（CSRC）
                                                ------------------->
        
図3：エンドシステム、ミキサー、トランスレーターを含むサンプルRTPネットワーク

SSRCおよびCSRC識別子への影響を示すために、ミキサーとトランスレーターのコレクションを図3に示します. この図では、エンドシステムは長方形（Eという名前）、トランスレータは三角形（Tという名前）、ミキサーは楕円（Mという名前）として示されています. 表記「M1：48（1,17）」は、M1の（ランダムな）48のSSRC値と、E1およびE2からのパケットのSSRC識別子からコピーされた2つのCSRC識別子1および17によって識別されるミキサーM1を発信するパケットを示します.  . 

7.2トランスレータでのRTCP処理

データパケットの転送に加えて、おそらく変更されたトランスレータとミキサーも、RTCPパケットを処理する必要があります. 多くの場合、エンドシステムから受信した複合RTCPパケットを分解して、SDES情報を集約し、SRまたはRRパケットを変更します. この情報の再送信は、パケットの到着、またはトランスレーターまたはミキサー自体のRTCPインターバルタイマーによってトリガーされます. 

データパケットを変更しないトランスレータ（たとえば、マルチキャストアドレスとユニキャストアドレスの間で複製するトランスレータ）は、変更されていないRTCPパケットを転送するだけでもかまいません（MAY）. ペイロードを何らかの方法で変換するトランスレータは、SRおよびRR情報に対応する変換を行わなければならないため、データの特性と受信品質が反映されます. これらのトランスレータは、RTCPパケットを単純に転送してはなりません（MUST NOT）. 一般に、トランスレータは、異なるソースからのSRパケットとRRパケットを1つのパケットに集約するべきではありません（SHRLD NOT）. これは、LSRおよびDLSRフィールドに基づく伝播遅延測定の精度を低下させるためです. 

SR送信者情報：トランスレーターは独自の送信者情報を生成しませんが、1つのクラウドから受信したSRパケットを他のクラウドに転送します. SSRCはそのまま残されますが、変換で必要な場合は送信者情報を変更する必要があります. トランスレータがデータエンコーディングを変更する場合は、「送信者のバイト数」フィールドを変更する必要があります. 複数のデータパケットを1つの出力パケットに結合する場合も、「送信者のパケット数」フィールドを変更する必要があります. タイムスタンプの頻度を変更する場合は、SRパケットの「RTPタイムスタンプ」フィールドを変更する必要があります. 

SR / RR受信レポートブロック：トランスレーターは、1つのクラウドから受信した受信レポートを他のクラウドに転送します. これらはデータと反対方向に流れることに注意してください. SSRCはそのまま残されます. トランスレータが複数のデータパケットを1つの出力パケットに結合し、したがってシーケンス番号を変更する場合、パケット損失フィールドと「拡張された最後のシーケンス番号」フィールドの逆の操作を行う必要があります. これは複雑な場合があります. 極端な場合、受信レポートを翻訳する意味のある方法がない可能性があるため、トランスレータは受信レポートをまったく渡さないか、独自の受信に基づいた合成レポートを渡してもよい（MAY）. 一般的なルールは、特定の翻訳に意味のあることを行うことです. 

トランスレーターは独自のSSRC IDを必要としませんが、受け取ったものについてのレポートを送信する目的でそれを割り当てることを選択できます（MAY）. 受信レポートは通常すべての参加者にマルチキャストされるため、これらは接続されているすべてのクラウドに送信され、それぞれがそのクラウドに送信されたデータストリームの変換に対応します. 

SDES：通常、トランスレーターは1つのクラウドから他のクラウドに受信するSDES情報を変更せずに転送しますが、たとえば、帯域幅が制限されている場合は、非CNAME SDES情報をフィルターに掛けることを決定できます. SSRC識別子の衝突検出を機能させるには、CNAMEを転送する必要があります. 独自のRRパケットを生成するトランスレーターは、自身に関するSDES CNAME情報を、それらのRRパケットを送信するのと同じクラウドに送信する必要があります. 

BYE：トランスレータはBYEパケットを変更せずに転送します. パケットの転送を中止しようとしているトランスレーターは、以前にそのクラウドに転送されていたすべてのSSRC識別子を含む各接続済みクラウドにBYEパケットを送信する必要があります（独自のレポートを送信した場合はトランスレーター自身のSSRC識別子を含む）. 

APP：トランスレータはAPPパケットを変更せずに転送します. 

7.3ミキサーでのRTCP処理

ミキサーは独自の新しいデータストリームを生成するため、SRまたはRRパケットをまったく通過せず、代わりに両側の新しい情報を生成します. 

SR送信者情報：ソースストリームの特性が混合で失われるため、ミキサーは、混合するソースからの送信者情報を通過しません. 同期ソースとして、ミキサーは、混合データストリームに関する送信者情報を含む独自のSRパケットを生成し、それらを混合ストリームと同じ方向に送信する必要があります（SHOULD）. 

SR / RR受信レポートブロック：ミキサーは、各クラウド内のソースの独自の受信レポートを生成し、同じクラウドにのみ送信します. これらの受信レポートを他のクラウドに送信してはならず、ソースがそこにあるSSRCではないため（CSRCのみ）、1つのクラウドから他のクラウドに受信レポートを転送してはなりません. 

SDES：ミキサーは通常、1つのクラウドから他のクラウドに受信するSDES情報を変更せずに転送しますが、たとえば、帯域幅が制限されている場合は、CNAME以外のSDES情報をフィルタリングすることを決定できます. SSRC識別子の衝突検出を機能させるには、CNAMEを転送する必要があります. （ミキサーによって生成されたCSRCリスト内の識別子は、エンドシステムによって生成されたSSRC識別子と衝突する可能性があります. ）ミキサーは、SRまたはRRパケットを送信するのと同じクラウドに、自身に関するSDES CNAME情報を送信する必要があります. 

ミキサーはSRまたはRRパケットを転送しないため、通常、複合RTCPパケットからSDESパケットを抽出します. オーバーヘッドを最小化するために、SDESパケットからのチャンクは単一のSDESパケットに集約されてもよく、ミキサーから発信されたSRまたはRRパケットにスタックされます. SDESパケットを集約するミキサーは、複合パケットが長くなるため、個々のソースよりも多くのRTCP帯域幅を使用しますが、ミキサーが複数のソースを表すため、これは適切です. 同様に、受信時にSDESパケットを通過するミキサーは、単一のソースレートよりも高い速度でRTCPパケットを送信しますが、パケットが複数のソースから送信されるため、これも正しいことです. RTCPパケットレートは、ミキサーの両側で異なる場合があります. 

CSRC識別子を挿入しないミキサーも、SDES CNAMEを転送しない場合があります. この場合、2つのクラウドのSSRC IDスペースは独立しています. 前述のように、この操作モードでは、ループを検出できない危険があります. 

BYE：ミキサーはBYEパケットを転送する必要があります. パケットの転送を停止しようとしているミキサーは、以前にそのクラウドに転送されていたすべてのSSRC識別子を含む接続された各クラウドにBYEパケットを送信する必要があります（独自のレポートを送信した場合はミキサー自体のSSRC識別子を含む）. 

APP：ミキサーによるAPPパケットの処理はアプリケーション固有です. 

7.4カスケードミキサー

図3に示すように、RTPセッションにはミキサーとトランスレーターのコレクションが含まれる場合があります. 図のM2とM3のように2つのミキサーがカスケード接続されている場合、ミキサーによって受信されたパケットはすでに混合されており、CSRCリストが含まれている場合があります. 複数の識別子. 2番目のミキサーは、すでに混合されている入力パケットのCSRC識別子と混合されていない入力パケットのSSRC識別子を使用して、発信パケットのCSRCリストを作成する必要があります（SHOULD）. これは、図のM3：89（64,45）とラベル付けされたミキサーM3からの出力アークに示されています. カスケードされていないミキサーの場合のように、結果のCSRCリストに15を超える識別子がある場合、残りは含めることができません. 

8. SSRC識別子の割り当てと使用
RTPヘッダーおよびRTCPパケットのさまざまなフィールドで伝送されるSSRC識別子は、RTPセッション内でグローバルに一意である必要がある32ビットのランダムな番号です. 同じネットワーク上の参加者または同時に開始する参加者が同じ番号を選択する可能性が低くなるように、注意して番号を選択することが重要です. 

アドレスは一意でない可能性があるため、識別子にローカルネットワークアドレス（IPv4アドレスなど）を使用するだけでは不十分です. RTPトランスレーターとミキサーは、異なるアドレススペースを持つ複数のネットワーク間の相互運用を可能にするため、2つのスペース内のアドレスの割り当てパターンは、ランダム割り当ての場合よりもはるかに高い衝突率になる可能性があります. 

1つのホストで実行されている複数のソースも競合します. 

また、状態を慎重に初期化せずにrandom（）を呼び出すだけでSSRC識別子を取得するだけでは不十分です. ランダムな識別子を生成する方法の例を付録A.6に示します. 

8.1衝突の確率

識別子はランダムに選択されるため、2つ以上のソースが同じ番号を選択する可能性があります. たとえば、セッション管理イベントによって自動的にトリガーされた場合など、すべてのソースが同時に開始されると、衝突が発生する可能性が最も高くなります. Nがソースの数でLが識別子の長さ（ここでは32ビット）である場合、2つのソースが独立して同じ値を選択する確率は、大きなNの場合に近似できます[26] 1-exp（-N ** 2 / 2 **（L + 1））. N = 1000の場合、確率は約10 **-4です. 

通常の衝突確率は、上記の最悪の場合よりもはるかに低くなります. 他のすべてのソースが既に一意の識別子を持っているRTPセッションに1つの新しいソースが参加する場合、衝突の確率は、スペースの外で使用される数の一部にすぎません. ここでも、Nがソースの数でLが識別子の長さである場合、衝突の確率はN / 2 ** Lです. N = 1000の場合、確率は約2 * 10 **-7です. 

新しいソースが最初のパケット（データまたは制御）を送信する前に他の参加者からパケットを受信する機会があるため、衝突の確率はさらに減少します. 新しいソースが他の参加者を（SSRC識別子によって）追跡している場合、最初のパケットを送信する前に、新しいソースはその識別子が受信したものと競合していないことを確認するか、再度選択することができます. 

8.2衝突解決とループ検出

SSRC識別子の衝突の可能性は低いですが、すべてのRTP実装は、衝突を検出し、衝突を解決するために適切なアクションを実行できるように準備する必要があります. ソースが別のソースが自身と同じSSRC識別子を使用していることをいつでも検出した場合、古い識別子のRTCP BYEパケットを送信し、別のランダムなものを選択する必要があります. （以下で説明するように、この手順はループの場合に1回だけ実行されます. ）レシーバーは、他の2つのソースが衝突していることを検出した場合、別のソースからパケットを保持し、別のソースからパケットを検出できる場合は、パケットを破棄します. ソーストランスポートアドレスまたはCNAME. 2つのソースは、状況が持続しないように衝突を解決することが期待されています. 

ランダムSSRC識別子はRTPセッションごとにグローバルに一意に保たれるため、ミキサーまたはトランスレーターによって導入される可能性のあるループを検出するためにも使用できます. ループは、次の例のように、変更されていないか、混合されている可能性があるデータと制御情報の重複を引き起こします. 

oトランスレーターは、直接またはトランスレーターのチェーンを介して、パケットを受信した同じマルチキャストグループに誤ってパケットを転送する場合があります. その場合、異なるネットワークソースから発信された同じパケットが数回現れます. 

o 2つのトランスレータが誤って並列に設定された場合、つまり、両側に同じマルチキャストグループが存在する場合、どちらも1つのマルチキャストグループから別のマルチキャストグループにパケットを転送します. 単方向トランスレータは2つのコピーを生成します. 双方向トランスレータはループを形成します. 

oミキサーは、直接または別のミキサーまたはトランスレーターを介して、パケットを受信するのと同じトランスポート宛先に送信することにより、ループを閉じることができます. この場合、ソースは、データパケットではSSRCとして、混合データパケットではCSRCとして表示されます. 

ソースは、自身のパケットがループしていること、または別のソースからのパケットがループしていること（サードパーティのループ）を発見する可能性があります. ソース識別子のランダムな選択におけるループと衝突の両方により、パケットは同じSSRC識別子で到着しますが、ソーストランスポートアドレスは異なります. これは、パケットを発信するエンドシステムまたは中間システムのアドレスである可能性があります. 

したがって、ソースがそのソーストランスポートアドレスを変更する場合、ループされたソースとして解釈されないように、新しいSSRC識別子を選択することもできます（MAY）. （RTPソースの一部のアプリケーションでは、セッション中にアドレスを変更することが予想されるため、これは必須ではありません. ）トランスレータが再起動し、その結果、転送するソーストランスポートアドレスを変更した場合（たとえば、UDPソースポート番号を変更した場合）パケットの場合、SSRC IDは元のソースによって適用され、変更されないため、これらのパケットはすべて、ループされているように受信者に表示されます. この問題は、再起動後もソーストランスポートアドレスを固定しておくことで回避できますが、いずれの場合も、レシーバーでのタイムアウト後に解決されます. 

トランスレーターまたはミキサーの反対側で発生するループまたは衝突は、パケットのすべてのコピーがトランスレーターまたはミキサーを通過する場合、ソーストランスポートアドレスを使用して検出できません. ただし、2つのRTCP SDESパケットからのチャンクに同じSSRC IDですが、CNAMEが異なります. 

これらの競合を検出して解決するために、RTP実装には、以下で説明するアルゴリズムと同様のアルゴリズムを含める必要があります（ただし、実装は、競合するサードパーティソースからのパケットを保持するための別のポリシーを選択する場合があります）. 以下で説明するアルゴリズムは、確立されたソースと衝突する新しいソースまたはループからのパケットを無視します. 古い識別子のRTCP BYEを送信し、新しい識別子を選択することで、参加者自身のSSRC識別子との衝突を解決します. ただし、参加者自身のパケットのループによって衝突が誘発された場合、アルゴリズムは新しい識別子を1回だけ選択し、その後、ループしている送信元トランスポートアドレスからのパケットを無視します. これは、BYEパケットのフラッドを回避するために必要です. 

このアルゴリズムでは、ソース識別子でインデックスが付けられ、その識別子で受信された最初のRTPパケットと最初のRTCPパケットからのソーストランスポートアドレス、およびそのソースの他の状態を含むテーブルを保持する必要があります. たとえば、UDP送信元ポート番号はRTPパケットとRTCPパケットで異なる場合があるため、2つの送信元トランスポートアドレスが必要です. ただし、ネットワークアドレスが両方のソーストランスポートアドレスで同じであると想定される場合があります. 

RTPまたはRTCPパケットで受信された各SSRCまたはCSRC識別子は、そのデータまたは制御情報を処理するために、ソース識別子テーブルで検索されます. パケットのソーストランスポートアドレスは、テーブル内の対応するソーストランスポートアドレスと比較され、ループまたは衝突が一致しない場合に検出されます. 制御パケットの場合、独自のSSRC識別子を持つ各要素（SDESチャンクなど）には、個別のルックアップが必要です. （レポーターが受信したソースを識別し、レポーターが送信したRTCPパケットのソーストランスポートアドレスとは関係がないため、受信レポートブロックのSSRC識別子は例外です. ）SSRCまたはCSRCが見つかった場合、新しいエントリが作成されます. 

同じホスト上の2つのソースが、受信機の動作開始時に同じソース識別子で送信している場合、最初に受信したRTPパケットが一方のソースから送信され、最初のRTCPパケットが他方から送信された可能性があります.  . これにより、間違ったRTCP情報がRTPデータに関連付けられることになりますが、この状況は十分にまれで無害であり、無視される可能性があります. 

参加者自身のデータパケットのループを追跡するために、実装は、競合することが判明したソーストランスポートアドレス（識別子ではない）の個別のリストも保持する必要があります. ソース識別子テーブルと同様に、競合するRTPパケットとRTCPパケットを個別に追跡するために、2つのソーストランスポートアドレスを保持する必要があります. 競合するアドレスリストは短く、通常は空である必要があります. このリストの各要素には、送信元アドレスと、最新の競合するパケットが受信された時刻が格納されています. 要素は、競合するパケットがそのソースから10 RTCPレポート間隔のオーダーでしばらくの間到着しなかった場合にリストから削除される場合があります（セクション6.2を参照）. 

示されているアルゴリズムの場合、参加者自身のソース識別子と状態がソース識別子テーブルに含まれていると想定されています. アルゴリズムを再構成して、最初に参加者自身のソース識別子と個別に比較することができます. 

      （SSRCまたはCSRC識別子がソースで見つからない場合
          識別子テーブル）{
          データまたはコントロールソースを格納する新しいエントリを作成する
              トランスポートアドレス、SSRCまたはCSRC、およびその他の状態. 
      }
        
      / *識別子はテーブルにあります* /
        
      else if（テーブルエントリが制御パケットの受信時に作成された
               これが最初のデータパケット、またはその逆）{
          このパケットからのソーストランスポートアドレスを格納します. 
      }
      else if（パケットのソーストランスポートアドレスが一致しない
               この識別子のテーブルエントリに保存されたもの）{
        
          / *識別子の衝突またはループが示されています* /
        
          if（ソース識別子が参加者自身のものではない）{
              / *オプションのエラーカウンターステップ* /
              if（ソース識別子はRTCP SDESチャンクからのもの
                  CNAMEとは異なるCNAMEアイテムを含む
                  テーブルエントリ内）{
                  サードパーティの衝突をカウントします. 
              } そうしないと {
                  サードパーティのループを数える;
              }
              データパケットまたは制御要素の処理を中止します. 
              / *新しいソースを保持するために別のポリシーを選択してもよい* /
          }
        
          / *参加者自身のパケットの衝突またはループ* /
        
          else if（ソーストランスポートアドレスがリストにある
                   競合するデータまたは制御ソースの転送
                   アドレス）{
              / *オプションのエラーカウンターステップ* /
              if（ソース識別子がRTCP SDESチャンクからのものではない場合
                  CNAMEアイテムまたはCNAMEを含む
                  参加者自身）{
                  ループした自身のトラフィックの発生をカウントします. 
              }
              競合するアドレスリストエントリの現在時刻をマークします. 
              データパケットまたは制御要素の処理を中止します. 
          }
        
          / *新しい衝突、SSRC識別子の変更* /
        
          そうしないと {
              衝突の発生を記録します. 
              競合するデータまたはコントロールに新しいエントリを作成する
                  ソーストランスポートアドレスリストと現在時刻のマーク. 
              古いSSRC識別子を含むRTCP BYEパケットを送信します. 
              新しいSSRC識別子を選択します. 
              ソース識別子テーブルに新しいエントリを作成します
                  古いSSRCとソーストランスポートアドレス
                  処理中のデータまたは制御パケット. 
          }
      }
        
このアルゴリズムでは、新しく競合する送信元アドレスからのパケットは無視され、元の送信元アドレスからのパケットは保持されます. 元のソースから長期間パケットが到着しない場合、テーブルエントリがタイムアウトし、新しいソースが引き継ぐことができます. これは、元のソースが衝突を検出して新しいソース識別子に移動した場合に発生する可能性がありますが、通常の場合、RTCP BYEパケットが元のソースから受信され、タイムアウトを待たずに状態を削除します. 

元のソースアドレスがミキサーを介して受信された場合（つまり、CSRCとして学習）、後で同じソースが直接受信された場合、ミックス内の他のソースが失われない限り、受信者は新しいソースアドレスに切り替えることをお勧めします. さらに、RTPセッション中にモバイルエンティティなどの一部のソースがアドレスを変更する可能性があるテレフォニーなどのアプリケーションの場合、RTP実装は、衝突検出アルゴリズムを変更して、新しいソーストランスポートアドレスからのパケットを受け入れる必要があります. 真の衝突が発生した場合にアドレス間のフリップフロップを防ぐために、アルゴリズムには、このケースを検出して切り替えを回避する手段が含まれている必要があります（SHOULD）. 

衝突が原因で新しいSSRC識別子が選択された場合、候補識別子は最初にソース識別子テーブルで検索され、他のソースによってすでに使用されているかどうかを確認する必要があります. もしそうなら、別の候補が生成されなければならず、プロセスが繰り返されなければなりません. 

マルチキャスト宛先へのデータパケットのループは、深刻なネットワークフラッディングを引き起こす可能性があります. すべてのミキサーとトランスレーターは、ループを中断できるように、ここに示すようなループ検出アルゴリズムを実装する必要があります. これにより、過剰なトラフィックが元のトラフィックの重複コピーを1つだけに制限するはずです. これにより、セッションを続行できるため、ループの原因を特定して修正できます. ただし、ミキサーまたはトランスレーターがループを適切に解除せず、高トラフィックレベルが発生する極端なケースでは、エンドシステムがデータまたは制御パケットの送信を完全に停止する必要がある場合があります. この決定は、アプリケーションによって異なります. 必要に応じて、エラー状態を示す必要があります. 長いランダムな時間（分単位）の後、定期的に送信が再試行される場合があります. 

8.3階層化エンコーディングでの使用

個別のRTPセッションで送信される階層化エンコーディング（セクション2.4を参照）の場合、すべてのレイヤーのセッション全体で単一のSSRC識別子スペースを使用する必要があり（SHOULD）、コア（ベース）レイヤーをSSRC識別子の割り当てと衝突解決に使用する必要があります（SHOULD）. ソースは、衝突したことを検出すると、ベースレイヤーのみでRTCP BYEパケットを送信しますが、SSRC識別子をすべてのレイヤーの新しい値に変更します. 

9.セキュリティ
下位層のプロトコルは、認証、整合性、機密性など、RTPのアプリケーションに必要なすべてのセキュリティサービスを最終的に提供する可能性があります. これらのサービスは、[27]でIPに対して指定されています. RTPを使用する最初のオーディオおよびビデオアプリケーションでは、IPレイヤーで機密サービスが利用可能になる前に機密サービスが必要だったため、次のセクションで説明する機密サービスは、RTPおよびRTCPで使用するために定義されました. その説明は、既存の慣行を成文化するためにここに含まれています. RTPの新しいアプリケーションは、下位互換性のためにこのRTP固有の機密性サービスを実装する場合があります. また、代替のセキュリティサービスを実装する場合もあります. この機密性サービスのRTPプロトコルのオーバーヘッドは低く、

あるいは、他のサービス、サービスの他の実装、および他のアルゴリズムは、将来RTPに対して定義される可能性があります. 特に、セキュアリアルタイムトランスポートプロトコル（SRTP）[28]と呼ばれるRTPプロファイルが開発されており、RTPヘッダーをクリアのままにしてRTPペイロードの機密性を提供し、リンクレベルのヘッダー圧縮アルゴリズムが引き続き動作できるようにします. SRTPは多くのアプリケーションにとって正しい選択となることが期待されています. SRTPはAdvanced Encryption Standard（AES）に基づいており、ここで説明するサービスよりも強力なセキュリティを提供します. ここで紹介する方法が特定のセキュリティのニーズに適しているとは主張していません. プロファイルは、アプリケーションによって提供されるサービスとアルゴリズムを指定し、適切な使用に関するガイダンスを提供します. 

鍵の配布と証明書は、このドキュメントの範囲外です. 

9.1守秘義務

機密性とは、意図した受信者のみが受信したパケットをデコードできることを意味します. その他の場合、パケットには有用な情報が含まれていません. コンテンツの機密性は暗号化によって実現されます. 

このセクションで指定された方法に従ってRTPまたはRTCPを暗号化する必要がある場合、単一の下位層パケットでの送信用にカプセル化されるすべてのオクテットは、1つの単位として暗号化されます. RTCPの場合、暗号化する前に、ユニットごとに32ビットの乱数を再描画する必要があります. RTPの場合、プレフィックスは付加されません. 代わりに、シーケンス番号とタイムスタンプのフィールドはランダムなオフセットで初期化されます. ランダム性の特性が低いため、これは弱い初期化ベクトル（IV）と見なされます. さらに、後続のフィールドであるSSRCが敵によって操作される可能性がある場合、暗号化方式にはさらに弱点があります. 

RTCPの場合、実装は、複合RTCPパケット内の個々のRTCPパケットを2つの別々の複合RTCPパケットに分離できます（1つは暗号化され、もう1つはクリアテキストで送信されます）. たとえば、暗号化キーを知らないサードパーティのモニターに対応するために、受信レポートが平文で送信されている間にSDES情報が暗号化される場合があります. 図4に示すこの例では、すべての複合RTCPパケットがSRまたはRRパケットで始まるという要件を満たすために、SDES情報をレポート（および乱数）なしでRRパケットに追加する必要があります. SDES CNAME項目は、暗号化されたパケットまたは暗号化されていないパケットのいずれかで必要ですが、両方では必要ありません. 暗号化を危険にさらす可能性があるため、同じSDES情報を両方のパケットで送信しないでください. 

             UDPパケットUDPパケット
   ----------------------------- --------------------- ---------
   [ランダム] [RR] [SDES #CNAME ...] [SR #senderinfo＃site1＃site2]
   ----------------------------- --------------------- ---------
             暗号化されていない
        
＃：SSRC識別子

図4：暗号化および非暗号化RTCPパケット

暗号化の存在と正しいキーの使用は、ヘッダーまたはペイロードの有効性チェックを通じて受信者によって確認されます. RTPおよびRTCPヘッダーのそのような有効性チェックの例は、付録A.1およびA.2に記載されています. 

RFC 1489 [29]のセクション1.1で説明されているように、RFC 1889のRTPの初期仕様の既存の実装と整合性を保つため、デフォルトの暗号化アルゴリズムは暗号ブロック連鎖（CBC）モードのデータ暗号化標準（DES）アルゴリズムです. ただし、8オクテットの倍数へのパディングは、セクション5.1のPビットで説明されているように示されます. ランダムな値はRTPヘッダーで提供されるか、複合RTCPパケットのランダムなプレフィックスによって提供されるため、初期化ベクトルはゼロです. CBC初期化ベクトルの使用の詳細については、[30]を参照してください. 

ここで指定された暗号化方式をサポートする実装は、相互運用性を最大にするために、この方式のデフォルトの暗号としてCBCモードのDESアルゴリズムを常にサポートする必要があります（SHOULD）. この方法が選択されたのは、インターネットで運用されている実験的なオーディオおよびビデオツールでの使用が簡単で実用的であることが実証されているためです. ただし、DESは簡単に壊れてしまうことが判明しています. 

デフォルトのアルゴリズムの代わりに、Triple-DESなどのより強力な暗号化アルゴリズムを使用することをお勧めします. さらに、セキュアCBCモードでは、各パケットの最初のブロックを、暗号のブロックサイズと同じサイズのランダムな独立したIVとXORする必要があります. RTCPの場合、これは（部分的に）各パケットに個別に選択された32ビットの乱数を各パケットの先頭に追加することによって実現されます. RTPの場合、タイムスタンプとシーケンス番号はランダムな値から始まりますが、連続するパケットは個別にランダム化されません. どちらの場合（RTPとRTCP）のランダム性にも制限があることに注意してください. 高セキュリティアプリケーションは、他のより一般的な保護手段を検討する必要があります. 他の暗号化アルゴリズムは、RTP以外の方法でセッションに対して動的に指定できます. 特に、

上記のIPレベルまたはRTPレベルでの暗号化の代替として、プロファイルは、暗号化されたエンコーディングの追加のペイロードタイプを定義する場合があります. これらのエンコーディングは、パディングや暗号化の他の側面の処理方法を指定する必要があります. この方法では、必要なアプリケーションのヘッダーをクリアなままにして、データのみを暗号化できます. これは、復号化と復号化の両方を処理するハードウェアデバイスに特に役立ちます. また、RTPおよび下位層ヘッダーのリンクレベルの圧縮が必要であり、ヘッダーの暗号化によって圧縮が排除されるため、ペイロード（ただしアドレスではない）の機密性で十分なアプリケーションにも役立ちます. 

9.2認証とメッセージの整合性

認証およびメッセージ整合性サービスはRTPレベルで定義されていません. これらのサービスは、キー管理インフラストラクチャなしでは直接実現できないためです. 認証および整合性サービスは、下位層プロトコルによって提供されることが期待されています. 

10.輻輳制御
インターネットで使用されるすべてのトランスポートプロトコルは、何らかの方法で輻輳制御に対処する必要があります[31]. RTPも例外ではありませんが、RTPを介して転送されるデータは非弾性（固定レートまたは制御レートで生成）であることが多いため、RTPの輻輳を制御する方法は、TCPなどの他の転送プロトコルの場合とはかなり異なる場合があります. ある意味では、RTPストリームはTCPストリームのようにすべての利用可能な帯域幅を消費するように拡張されないため、非弾性は輻輳のリスクを軽減します. ただし、非弾性とは、RTPストリームが発生したときに輻輳を解消するためにネットワークの負荷を勝手に削減できないことも意味します. 

RTPは多くの異なるコンテキストでさまざまなアプリケーションに使用できるため、すべてに対して機能する単一の輻輳制御メカニズムはありません. したがって、輻輳制御は、必要に応じて各RTPプロファイルで定義する必要があります（SHOULD）. 一部のプロファイルでは、エンジニアリングによって輻輳が回避される環境にそのプロファイルの使用を制限する適用性ステートメントを含めるだけで十分な場合があります. 他のプロファイルの場合、RTCPフィードバックに基づくデータレート適応などの特定の方法が必要になる場合があります. 

11. RTP over Network and Transport Protocols
このセクションでは、特定のネットワークおよびトランスポートプロトコル内でRTPパケットを伝送することに固有の問題について説明します. この仕様外のプロトコル固有の定義に置き換えられない限り、次のルールが適用されます. 

RTPは、基になるプロトコルに依存して、RTPデータとRTCP制御ストリームの逆多重化を提供します. UDPおよび類似のプロトコルの場合、RTPは偶数の宛先ポート番号を使用する必要があり（SHOULD）、対応するRTCPストリームは次に大きい（奇数）宛先ポート番号を使用する必要があります（SHOULD）. 単一のポート番号をパラメーターとして受け取り、その番号からRTPとRTCPのポートペアを取得するアプリケーションの場合、奇数が指定された場合、アプリケーションは、その番号を次に低い（偶数）番号に置き換えて、そのベースとして使用する必要があります（SHOULD）. ポートのペア. RTPおよびRTCP宛先ポート番号が明示的で別個のパラメーター（シグナリングプロトコルまたはその他の手段を使用）を介して指定されているアプリケーションの場合、アプリケーションは、ポート番号が偶数/奇数で連続しているという制限を無視する場合がありますが、偶数/奇数のポートペアを使用することをお勧めします. RTPはポート番号に依存してRTPデータとRTCP制御ストリームを逆多重化するため、RTPとRTCPのポート番号は同じにしないでください. 

ユニキャストセッションでは、両方の参加者がRTPパケットとRTCPパケットを受信するためのポートペアを識別する必要があります. 両方の参加者が同じポートペアを使用する場合があります. 参加者は、着信RTPまたはRTCPパケットのソースポートが発信RTPまたはRTCPパケットの宛先ポートとして使用できると想定してはなりません（MUST NOT）. RTPデータパケットが両方向で送信されている場合、各参加者のRTCP SRパケットは、他の参加者がRTCPの受信用に指定したポートに送信する必要があります. RTCP SRパケットは、発信データの送信者情報と着信データの受信レポート情報を組み合わせます. サイドがアクティブにデータを送信していない場合（セクション6.4を参照）、代わりにRTCP RRパケットが送信されます. 

レイヤードエンコーディングアプリケーション（セクション2.4を参照）では、一連の連続したポート番号を使用することをお勧めします. 複数のマルチキャストアドレスで同じポートを使用できない既存のオペレーティングシステムの欠陥のため、ポート番号は異なる必要があります. ユニキャストの場合、許可されるアドレスは1つだけです. したがって、レイヤーnの場合、データポートはP + 2nで、制御ポートはP + 2n + 1です. IPマルチキャストが使用される場合、マルチキャストルーティングとグループメンバーシップはアドレスの細分性で管理されるため、アドレスも異なる必要があります. ただし、一部のグループは異なるスコープを必要とする場合があり、したがって異なるアドレス範囲から割り当てられる場合があるため、連続したIPマルチキャストアドレスの割り当ては想定できません. 

前の段落は、SDP仕様、RFC 2327 [15]と競合します. RFC2327 [15]は、アドレスとポートの関連付けがあいまいになる可能性があるため、同じセッションの説明で複数のアドレスと複数のポートの両方を指定することは違法であると述べています. この制限は、RFC 2327の改訂で緩和され、同数のアドレスとポートを1対1のマッピングを指定して指定できるようにすることを目的としています. 

RTPデータパケットには、長さフィールドやその他の説明が含まれていないため、RTPは、長さを示すために基礎となるプロトコルに依存しています. RTPパケットの最大長は、基になるプロトコルによってのみ制限されます. 

RTPパケットが、メッセージ（パケット）ではなく連続オクテットストリームの抽象化を提供する基になるプロトコルで運ばれる場合は、RTPパケットのカプセル化を定義して、フレーミングメカニズムを提供する必要があります. 基になるプロトコルにパディングが含まれている可能性があり、RTPペイロードの範囲を判別できない場合は、フレーミングも必要です. フレーミングのメカニズムはここでは定義されていません. 

UDPパケットなど、1つの下位層プロトコルデータユニットで複数のRTPパケットを伝送できるようにするために、フレーミングを提供するプロトコルでRTPが伝送される場合でも、プロファイルは使用するフレーミング方法を指定できます（MAY）. 1つのネットワークまたはトランスポートパケットで複数のRTPパケットを伝送すると、ヘッダーのオーバーヘッドが減少し、異なるストリーム間の同期が簡略化される場合があります. 

12.プロトコル定数のまとめ
このセクションには、この仕様で定義されている定数の要約リストが含まれています. 

RTPペイロードタイプ（PT）定数は、このドキュメントではなくプロファイルで定義されています. ただし、マーカービットとペイロードタイプを含むRTPヘッダーのオクテットは、付録で説明されているヘッダー検証手順のために、RTPパケットをRTCP SRおよびRRパケットタイプから区別するために、予約値200および201（10進数）を回避する必要があります.  A.1. この仕様に示されているように、1つのマーカービットと7ビットのペイロードタイプフィールドの標準定義では、この制限はペイロードタイプ72と73が予約されていることを意味します. 

12.1 RTCPパケットタイプ

略語. 名前値SR送信者レポート200 RR受信者レポート201 SDESソースの説明202 BYEさようなら203 APPアプリケーション定義204

これらのタイプ値は、RTPパケットまたは他の無関係なパケットと比較してRTCPパケットのヘッダー有効性チェックを改善するために、200〜204の範囲で選択されました. RTCPパケットタイプフィールドをRTPヘッダーの対応するオクテットと比較すると、この範囲はマーカービットが1（通常はデータパケットにはない）であり、標準ペイロードタイプフィールドの高ビットが1（静的ペイロードタイプは通常、下半分で定義されているため）. すべて0と1は一般的なデータパターンであるため、この範囲は、数値的に0〜255の距離になるように選択されました. 

すべての複合RTCPパケットはSRまたはRRで始まる必要があるため、これらのコードは偶数/奇数のペアとして選択され、RTCP有効性チェックでマスクと値を使用してビットの最大数をテストできるようにしました. 

IANAを通じて追加のRTCPパケットタイプを登録できます（セクション15を参照）. 

12.2 SDESタイプ

略語. 名前値END SDESリストの終わり0 CNAME正規名1 NAMEユーザー名2 EMAILユーザーの電子メールアドレス3 PHONEユーザーの電話番号4 LOC地理的なユーザーの場所5アプリケーションまたはツールのTOOL名6ソースに関する注記7 PRIVプライベート拡張8

IANAを通じて追加のSDESタイプを登録できます（セクション15を参照）. 

13. RTPプロファイルとペイロード形式の仕様
特定のアプリケーションのRTPの完全な仕様には、ここで説明する2つのタイプの1つ以上の関連ドキュメントが必要です. プロファイルとペイロード形式の仕様です. 

RTPは、要件が多少異なるさまざまなアプリケーションに使用できます. これらの要件に適応する柔軟性は、メインのプロトコル仕様で複数の選択肢を許可し、適切な選択肢を選択するか、特定の環境とアプリケーションのクラスの拡張を別のプロファイルドキュメントで定義することで提供されます. 通常、アプリケーションは特定のRTPセッションで1つのプロファイルのみで動作するため、RTPプロトコル自体の中で、どのプロファイルが使用されているかを明示的に示すものはありません. オーディオおよびビデオアプリケーションのプロファイルは、関連するRFC 3551で見つけることができます. プロファイルのタイトルは通常、「RTP Profile for ...」です. 

コンパニオンドキュメントの2番目のタイプは、H.261エンコードされたビデオなどの特定の種類のペイロードデータをRTPでどのように伝送するかを定義するペイロード形式仕様です. これらのドキュメントのタイトルは通常、「XYZ Audio / Video EncodingのRTPペイロード形式」です. ペイロード形式は、複数のプロファイルで役立つ場合があるため、特定のプロファイルとは無関係に定義できます. プロファイルドキュメントは、必要に応じて、その形式のデフォルトマッピングをペイロードタイプ値に割り当てる責任があります. 

この仕様では、プロファイル内で可能な定義のために次の項目が識別されていますが、このリストは完全なものではありません. 

RTPデータヘッダー：マーカービットとペイロードタイプフィールドを含むRTPデータヘッダーのオクテットは、たとえばマーカービットの増減など、さまざまな要件に合わせてプロファイルで再定義できます（セクション5.3、p. 18）. 

ペイロードタイプ：ペイロードタイプフィールドが含まれていると仮定すると、プロファイルは通常、一連のペイロードフォーマット（メディアエンコーディングなど）とそれらのフォーマットからペイロードタイプ値へのデフォルトの静的マッピングを定義します. 一部のペイロード形式は、個別のペイロード形式の仕様を参照することで定義できます. 定義されたペイロードタイプごとに、プロファイルは、使用するRTPタイムスタンプクロックレートを指定する必要があります（セクション5.1、p. 14）. 

RTPデータヘッダーの追加：ペイロードタイプとは無関係にプロファイルのアプリケーションクラス全体で追加機能が必要な場合は、追加のフィールドを固定RTPデータヘッダーに追加できます（セクション5.3、p. 18）. 

RTPデータヘッダー拡張：RTPデータヘッダー拡張構造の最初の16ビットの内容は、そのメカニズムの使用を実装固有の拡張のプロファイルで許可する場合に定義する必要があります（セクション5.3.1、p. 18）. 

RTCPパケットタイプ：新しいアプリケーションクラス固有のRTCPパケットタイプを定義し、IANAに登録できます. 

RTCPレポート間隔：プロファイルは、RTCPレポート間隔の計算に使用される定数についてセクション6.2で提案された値が使用されることを指定する必要があります（SHOULD）. これらは、セッション帯域幅のRTCP部分、最小レポート間隔、および送信者と受信者の間で分割された帯域幅です. スケーラブルな方法で機能することが実証されている場合、プロファイルは代替値を指定してもよい（MAY）. 

SR / RR拡張：送信者または受信者について定期的に報告する必要がある追加情報がある場合は、RTCP SRおよびRRパケットの拡張セクションを定義できます（セクション6.4.3、p. 42および43）. 

SDESの使用：プロファイルは、RTCP SDESアイテムが送信または完全に除外される相対的な優先順位を指定してもよい（セクション6.3.9）. CNAMEアイテムの代替の構文またはセマンティクス（6.5.1節）. LOCアイテムの形式（セクション6.5.5）. NOTEアイテムのセマンティクスと使用（セクション6.5.7）. または、IANAに登録される新しいSDESアイテムタイプ. 

セキュリティ：プロファイルは、アプリケーションによって提供されるセキュリティサービスとアルゴリズムを指定することができ（MAY）、それらの適切な使用に関するガイダンスを提供することができます（セクション9、65ページ）. 

文字列からキーへのマッピング：プロファイルは、ユーザー指定のパスワードまたはパスフレーズを暗号化キーにマッピングする方法を指定する場合があります. 

輻輳：プロファイルは、そのプロファイルに適切な輻輳制御動作を指定する必要があります（SHOULD）. 

基礎となるプロトコル：RTPパケットを伝送するための特定の基礎となるネットワークまたはトランスポート層プロトコルの使用が必要になる場合があります. 

トランスポートマッピング：セクション11で定義されている標準マッピング以外のトランスポートレベルアドレス（UDPポートなど）へのRTPおよびRTCPのマッピング. 68を指定できます. 

カプセル化：RTPパケットのカプセル化を定義して、複数のRTPデータパケットを1つの下位レイヤーパケットで伝送できるようにするか、基になっていないプロトコルでフレーミングを提供できます（セクション11、69ページ）. 

すべてのアプリケーションに新しいプロファイルが必要になることは想定されていません. 1つのアプリケーションクラス内では、アプリケーションは通常1つのプロファイルでのみ実行されるため、アプリケーション間の相互運用を容易にするために、新しいプロファイルを作成するよりも、既存のプロファイルを拡張する方が適切です. 追加のペイロードタイプ値やRTCPパケットタイプの定義などの単純な拡張は、IANAを通じてそれらを登録し、それらの説明をプロファイルの補遺またはペイロード形式の仕様で公開することによって実現できます. 

14.セキュリティに関する考慮事項
RTPには、基礎となるプロトコルと同じセキュリティ上の問題があります. たとえば、詐欺師は送信元または宛先のネットワークアドレスを偽造したり、ヘッダーやペイロードを変更したりできます. RTCP内では、CNAMEおよびNAME情報を使用して、別の参加者になりすますことができます. さらに、RTPはIPマルチキャストを介して送信される場合があります. これは送信者が送信されたデータのすべての受信者を知るための直接的な手段を提供しないため、プライバシーの測定ができません. 当然のことながら、ユーザーは、従来の形式のネットワーク通信よりも、オーディオおよびビデオ通信のプライバシーの問題に敏感になる可能性があります[33]. したがって、RTPでのセキュリティメカニズムの使用は重要です. これらのメカニズムについては、セクション9で説明します. 

RTPレベルのトランスレータまたはミキサーを使用して、RTPトラフィックがファイアウォールの背後にあるホストに到達できるようにすることができます. これらのデバイスの設計とインストール、およびファイアウォールの背後で使用するRTPアプリケーションの承認では、このドキュメントの範囲を超える適切なファイアウォールセキュリティの原則と実践に従う必要があります. 

15. IANAに関する考慮事項
追加のRTCPパケットタイプとSDESアイテムタイプは、Internet Assigned Numbers Authority（IANA）を通じて登録できます. これらの数値スペースは小さいため、新しい値を無制限に登録できるようにすることは賢明ではありません. 要求のレビューを容易にし、複数のアプリケーション間での新しいタイプの共有使用を促進するために、新しい値の登録の要求は、RFCまたは他の共同標準化団体の製品（ITU T）. 「指定された専門家」の助言の下で、他の要求も受け入れることができます. （現在の専門家の連絡先情報については、IANAに連絡してください. ）

RTPプロファイル仕様は、「RTP / xxx」の形式でプロファイルの名前をIANAに登録する必要があります. ここで、xxxはプロファイルタイトルの短い省略形です. これらの名前は、セッション記述プロトコル（SDP）、RFC 2327 [15]などの上位レベルの制御プロトコルがトランスポート方式を参照するために使用します. 

16.知的財産権に関する声明
IETFは、このドキュメントで説明されているテクノロジーの実装または使用に関連すると主張される可能性がある知的財産またはその他の権利の有効性または範囲、またはそのような権利に基づくライセンスが適用されるかどうかについて、いかなる立場も取りません. 利用可能. また、そのような権利を特定するために何らかの努力をしたことも表していません. 標準化過程および標準化関連文書の権利に関するIETFの手順に関する情報は、BCP-11にあります. 公開に利用できるようにされた権利の主張と利用可能になるライセンスの保証のコピー、またはこの仕様の実装者またはユーザーによる一般的なライセンスまたはそのような所有権の使用の許可を得ようとした試みの結果を入手できます.  IETF事務局から. 

IETFは、この規格の実践に必要となる可能性のある技術をカバーする可能性のある著作権、特許、特許出願、またはその他の所有権に注意を向けるよう、利害関係者に呼びかけます. IETF Executive Directorに情報を送信してください. 

17.謝辞
この覚書は、Stephen CasnerとColin Perkinsが議長を務めるIETF Audio / Video Transportワーキンググループ内の議論に基づいています. 現在のプロトコルは、ネットワーク音声プロトコルとパケットビデオプロトコル（ダニーコーエンとランディコール）と、バットアプリケーション（ヴァンジェイコブソンとスティーブマッキャンネ）によって実装されたプロトコルに起源があります. Christian Huitemaは、ランダムIDジェネレーターのアイデアを提供しました. タイマー再検討アルゴリズムの広範な分析とシミュレーションは、Jonathan Rosenbergによって行われました. レイヤードエンコーディングの追加は、Michael SpeerおよびSteve McCanneによって指定されました. 

付録A-アルゴリズム

RTP送信側および受信側アルゴリズムの側面のCコードの例を示します. 特定の動作環境でより高速であるか、または他の利点がある他の実装方法があるかもしれません. これらの実装ノートは情報提供のみを目的としており、RTP仕様を明確にすることを目的としています. 

次の定義はすべての例で使用されます. 明快さと簡潔さのために、構造体の定義は32ビットのビッグエンディアン（最上位オクテットが最初）のアーキテクチャでのみ有効です. ビットフィールドは、ビッグエンディアンのビット順で密にパックされ、追加のパディングはないものと見なされます. 移植可能な実装を構築するには、変更が必要です. 

   / *
    * rtp.h-RTPヘッダーファイル
    * /
   #include <sys / types.h>
        
   / *
    *以下の型定義は、32ビットアーキテクチャおよび
    * 16ビットまたは64ビットアーキテクチャでは調整が必要な場合があります. 
    * /
   typedef unsigned char u_int8;
   typedef unsigned short u_int16;
   typedef unsigned int u_int32;
   typedef short int16;
        
   / *
    *現在のプロトコルバージョン. 
    * /
   #define RTP_VERSION 2
        
   #define RTP_SEQ_MOD（1 << 16）
   #define RTP_MAX_SDES 255 / * SDESの最大テキスト長* /
        
   typedef enum {
       RTCP_SR = 200、
       RTCP_RR = 201、
       RTCP_SDES = 202、
       RTCP_BYE = 203、
       RTCP_APP = 204
   } rtcp_type_t;
        
   typedef enum {
       RTCP_SDES_END = 0、
       RTCP_SDES_CNAME = 1、RTCP_SDES_NAME = 2
       RTCP_SDES_EMAIL = 3
       RTCP_SDES_PHONE = 4
       RTCP_SDES_LOC = 5
       RTCP_SDES_TOOL = 6
       RTCP_SDES_NOTE = 7
       RTCP_SDES_PRIV = 8
   } rtcp_sdes_type_t;
        
   / *
    * RTPデータヘッダー
    * /
   typedef struct {
       unsigned int version：2; / *プロトコルバージョン* /
       unsigned int p：1; / *パディングフラグ* /
       unsigned int x：1; / *ヘッダー拡張フラグ* /
       unsigned int cc：4; / * CSRCカウント* /
       unsigned int m：1; / *マーカービット* /
       unsigned int pt：7; / *ペイロードタイプ* /
       unsigned int seq：16; / *シーケンス番号* /
       u_int32 ts; / *タイムスタンプ* /
       u_int32 ssrc; / *同期ソース* /
       u_int32 csrc [1]; / *オプションのCSRCリスト* /
   } rtp_hdr_t;
        
   / *
    * RTCP共通ヘッダーワード
    * /
   typedef struct {
       unsigned int version：2; / *プロトコルバージョン* /
       unsigned int p：1; / *パディングフラグ* /
       unsigned int count：5; / *パケットタイプによって異なります* /
       unsigned int pt：8; / * RTCPパケットタイプ* /
       u_int16長さ; / * pkt lenを単語で、この単語なしで* /
   } rtcp_common_t;
        
   / *
    *バージョン、パディングビット、パケットタイプのペアのビッグエンディアンマスク
    * /
   #define RTCP_VALID_MASK（0xc000 | 0x2000 | 0xfe）
   #define RTCP_VALID_VALUE（（RTP_VERSION << 14）| RTCP_SR）
        
   / *
    *受信レポートブロック
    * /
   typedef struct {
       u_int32 ssrc; / *レポートされるデータソース* /
       符号なし整数の小数部：8; / *最後のSR / RR以降に失われた割合* / int lost：24; / *累積. 番号. 失われたパケット（署名済み！）* /
       u_int32 last_seq; / *最後のシーケンスを拡張しました. 番号. 受け取った* /
       u_int32ジッタ; / *到着間ジッタ* /
       u_int32 lsr; / *このソースからの最後のSRパケット* /
       u_int32 dlsr; / *最後のSRパケット以降の遅延* /
   } rtcp_rr_t;
        
   / *
    * SDESアイテム
    * /
   typedef struct {
       u_int8タイプ; / *アイテムのタイプ（rtcp_sdes_type_t）* /
       u_int8長さ; / *アイテムの長さ（オクテット単位）* /
       char data [1]; / * nullで終了しないテキスト* /
   } rtcp_sdes_item_t;
        
   / *
    * 1つのRTCPパケット
    * /
   typedef struct {
       rtcp_common_t common; / *共通ヘッダー* /
       ユニオン{
           / *送信者レポート（SR）* /
           構造体{
               u_int32 ssrc; / *このレポートを生成する送信者* /
               u_int32 ntp_sec; / * NTPタイムスタンプ* /
               u_int32 ntp_frac;
               u_int32 rtp_ts; / * RTPタイムスタンプ* /
               u_int32 psent; / *送信されたパケット* /
               u_int32 osent; / *オクテット送信* /
               rtcp_rr_t rr [1]; / *可変長リスト* /
           } sr;
        
           / *受信レポート（RR）* /
           構造体{
               u_int32 ssrc; / *このレポートを生成するレシーバー* /
               rtcp_rr_t rr [1]; / *可変長リスト* /
           } rr;
        
           / *ソース記述（SDES）* /
           struct rtcp_sdes {
               u_int32 src; / *最初のSSRC / CSRC * /
               rtcp_sdes_item_t item [1]; / * SDESアイテムのリスト* /
           } sdes;
        
           / *さようなら* /
           構造体{
               u_int32 src [1]; / *ソースのリスト* /
        
               / *理由により末尾のテキストを表現できません* /
           さようなら. 
       } r;
   } rtcp_t;
        
typedef struct rtcp_sdes rtcp_sdes_t;

   / *
    *ソースごとの状態情報
    * /
   typedef struct {
       u_int16 max_seq; / *最高のシーケンス 見た数* /
       u_int32サイクル. / *シーケンスのカウントをシフトしました 数サイクル* /
       u_int32 base_seq; / *基本シーケンス番号* /
       u_int32 bad_seq; / *最後の「不良」シーケンス番号+ 1 * /
       u_int32保護観察; / *続き ソースが有効になるまでのパケット* /
       u_int32を受け取りました. / *受信したパケット* /
       u_int32 expected_prior; / *最後の間隔で予期されるパケット* /
       u_int32 received_prior; / *最後の間隔で受信されたパケット* /
       u_int32トランジット. / *前のパケットの相対転送時間* /
       u_int32ジッタ; / *推定ジッタ* /
       / * ... * /
   }ソース;
        
A.1 RTPデータヘッダーの有効性チェック

RTPレシーバーは、暗号化されているか、誤ってアドレス指定された別のアプリケーションからのものである可能性があるため、着信パケットのRTPヘッダーの有効性を確認する必要があります. 同様に、セクション9で説明されている方法による暗号化が有効になっている場合、着信パケットが正しく復号化されたことを確認するためにヘッダー有効性チェックが必要ですが、ヘッダー有効性チェックの失敗（不明なペイロードタイプなど）は必ずしも示すとは限りません復号化に失敗しました. 

これまで聞いたことがないソースからのRTPデータパケットでは、弱い有効性チェックのみが可能です. 

o RTPバージョンフィールドは2でなければなりません. 

oペイロードタイプは既知である必要があり、特にSRまたはRRと等しくない必要があります. 

o Pビットが設定されている場合、パケットの最後のオクテットには、有効なオクテットカウントが含まれている必要があります. 

oプロファイルがヘッダー拡張メカニズムを使用できることを指定していない場合、Xビットはゼロでなければなりません. それ以外の場合、拡張の長さフィールドは、合計パケットサイズから固定ヘッダー長とパディングを差し引いた値よりも小さくなければなりません. 

oパケットの長さは、CCおよびペイロードタイプと一致している必要があります（ペイロードの長さがわかっている場合）. 

最後の3つのチェックはいくぶん複雑で常に実行できるとは限らず、最初の2つだけが残り、合計はほんの数ビットです. パケット内のSSRC識別子が以前に受信されたものである場合、パケットはおそらく有効であり、シーケンス番号が期待される範囲内にあるかどうかを確認することで、さらに検証を行うことができます. SSRC識別子が以前に見られなかった場合、その識別子を運ぶデータパケットは、少数の連続したシーケンス番号で到着するまで無効と見なされます. 結果として生じる遅延が許容できる場合、検証が達成されたら、これらの無効なパケットは破棄されるか、または格納されて配信される場合があります. 

以下に示すルーチンupdate_seqは、MIN_SEQUENTIALパケットが順番に受信された後にのみ、ソースが有効であると宣言されることを保証します. また、新しく受信したパケットのシーケンス番号seqを検証し、sが指す構造内のパケットのソースのシーケンス状態を更新します. 

新しいソースが初めて聞こえたとき、つまり、そのSSRC識別子がテーブルに存在せず（セクション8.2を参照）、ソースごとの状態がそれに割り当てられている場合、s-> probationはシーケンシャルの数に設定されます. ソースが有効であると宣言する前に必要なパケット（パラメーターMIN_SEQUENTIAL）およびその他の変数が初期化されます. 

      init_seq（s、seq）;
      s-> max_seq = seq-1;
      s-> probation = MIN_SEQUENTIAL;
        
ゼロ以外のs-> probationは、ソースをまだ有効ではないものとしてマークするため、セクション6.2.1で説明したように、長いタイムアウトではなく短いタイムアウトの後に状態が破棄される場合があります. 

ソースが有効であると見なされた後、s-> max_seqより前のMAX_DROPOUT以下、または後のMAX_MISORDER以下の場合、シーケンス番号は有効であると見なされます. 新しいシーケンス番号がRTPシーケンス番号の範囲（16ビット）を法とするmax_seqよりも前であるが、max_seqよりも小さい場合は、循環し、シーケンス番号サイクルの（シフトされた）カウントが増加します. 有効なシーケンス番号を示すために、1の値が返されます. 

それ以外の場合は、検証が失敗したことを示すために値0が返され、不正なシーケンス番号に1を加えたものが格納されます. 受信した次のパケットが次に大きいシーケンス番号を持っている場合、それはおそらく拡張ドロップアウトまたはソースの再起動によって引き起こされた新しいパケットシーケンスの有効な開始と見なされます. 複数の完全なシーケンス番号サイクルが失われた可能性があるため、パケット損失統計がリセットされます. 

50パケット/秒での2秒の最大誤順序時間と1分の最大ドロップアウトに基づいて、パラメーターの典型的な値が表示されます. ドロップアウトパラメータMAX_DROPOUTは、再起動後の新しいシーケンス番号が再起動前のシーケンス番号の許容範囲に収まらないという妥当な確率を与えるために、16ビットのシーケンス番号スペースのごく一部である必要があります. 

   void init_seq（source * s、u_int16 seq）
   {
       s-> base_seq = seq;
       s-> max_seq = seq;
       s-> bad_seq = RTP_SEQ_MOD + 1; / *したがってseq == bad_seqはfalse * /
       s-> cycles = 0;
       s-> received = 0;
       s-> received_prior = 0;
       s-> expected_prior = 0;
       / *その他の初期化* /
   }
        
   int update_seq（source * s、u_int16 seq）
   {
       u_int16 udelta = seq-s-> max_seq;
       const int MAX_DROPOUT = 3000;
       const int MAX_MISORDER = 100;
       const int MIN_SEQUENTIAL = 2;
        
       / *
        * MIN_SEQUENTIALパケットが送信されるまでソースは無効です. 
        *シーケンス番号を受け取りました. 
        * /
       if（s-> probation）{
           / *パケットは連続しています* /
           if（seq == s-> max_seq + 1）{
               s->保護観察-;
               s-> max_seq = seq;
               if（s-> probation == 0）{
                   init_seq（s、seq）;
                   s-> received ++;
                   1を返します. 
        
               }
           } そうしないと {
               s-> probation = MIN_SEQUENTIAL-1;
               s-> max_seq = seq;
           }
           0を返します. 
       } else if（udelta <MAX_DROPOUT）{
           / *順番に、許容ギャップあり* /
           if（seq <s-> max_seq）{
               / *
                *シーケンス番号の折り返し-別の64Kサイクルをカウントします. 
                * /
               s-> cycles + = RTP_SEQ_MOD;
           }
           s-> max_seq = seq;
       } else if（udelta <= RTP_SEQ_MOD-MAX_MISORDER）{
           / *シーケンス番号が非常に大きくジャンプしました* /
           if（seq == s-> bad_seq）{
               / *
                * 2つの連続したパケット-反対側を想定
                *通知せずに再起動したため、再同期するだけ
                *（つまり、これが最初のパケットであったと仮定します）. 
                * /
               init_seq（s、seq）;
           }
           そうしないと {
               s-> bad_seq =（seq + 1）＆（RTP_SEQ_MOD-1）;
               0を返します. 
           }
       } そうしないと {
           / *パケットの複製または並べ替え* /
       }
       s-> received ++;
       1を返します. 
   }
        
有効性チェックは、2つ以上のパケットを順番に要求することで、より強力にできます. 不利な点は、多数の初期パケットが破棄される（またはキューで遅延する）ことと、パケット損失率が高いと検証が妨げられる可能性があることです. ただし、RTCPヘッダーの検証は比較的強力であるため、データパケットの前にソースからRTCPパケットを受信した場合、2つのパケットのみが順番に必要になるようにカウントを調整できます. 数秒間の初期データ損失が許容できる場合、アプリケーションは、ソースから有効なRTCPパケットが受信されるまで、ソースからのすべてのデータパケットを破棄することを選択できます（MAY）. 

アプリケーションとエンコーディングに応じて、アルゴリズムはペイロードフォーマットに関する追加の知識を活用して、さらに検証します. タイムスタンプの増分がすべてのパケットで同じであるペイロードタイプの場合、シーケンス番号の違いを使用して、同じソースから受信した前のパケットからタイムスタンプ値を予測できます（ペイロードタイプに変更がない場合）. 

新しく受信したRTPデータパケットのヘッダーの最初の4つのオクテットは、シーケンス番号が異なることを除いて、同じSSRCからの前のパケットとまったく同じであるため、強力な「高速パス」チェックが可能です.  1増加しました. 同様に、単一エントリのキャッシュは、通常、一度に1つのソースからデータを受信するアプリケーションで、より高速なSSRCルックアップに使用できます. 

A.2 RTCPヘッダーの有効性チェック

次のチェックをRTCPパケットに適用する必要があります. 

o RTPバージョンフィールドは2でなければなりません. 

o複合パケットの最初のRTCPパケットのペイロードタイプフィールドは、SRまたはRRと等しくなければなりません. 

o複合RTCPパケットの最初のパケットのパディングビット（P）はゼロにする必要があります. パディングは、必要な場合にのみ、最後のパケットに適用する必要があるためです. 

o個々のRTCPパケットの長さフィールドの合計は、受信した複合RTCPパケットの全長になる必要があります. これはかなり強力なチェックです. 

以下のコードフラグメントは、これらすべてのチェックを実行します. 不明なパケットタイプが存在する可能性があり、無視する必要があるため、後続のパケットのパケットタイプはチェックされません. 

      u_int32 len; / *ワード単位の複合RTCPパケットの長さ* /
      rtcp_t * r; / * RTCPヘッダー* /
      rtcp_t * end; / *複合RTCPパケットの終わり* /
        
      if（（*（u_int16 *）r＆RTCP_VALID_MASK）！= RTCP_VALID_VALUE）{
          / *パケット形式に問題があります* /
      }
      エンド=（rtcp_t *）（（u_int32 *）r + len）;
        
      do r =（rtcp_t *）（（u_int32 *）r + r-> common.length + 1）;
      while（r <end && r-> common.version == 2）;
        
      if（r！= end）{
          / *パケット形式に問題があります* /
      }
        
A.3予想されるパケット数と失われるパケット数の決定

パケット損失率を計算するには、以下のコードのポインターsを介して参照されるstruct sourceで定義されたソースごとの状態情報を使用して、各ソースから予期され、実際に受信されるRTPパケットの数を知る必要があります. 受信されたパケット数は、到着したパケットの数であり、遅延パケットまたは重複パケットを含みます. 予想されるパケット数は、受信した最大シーケンス番号（s-> max_seq）と最初に受信したシーケンス番号（s-> base_seq）との差として、レシーバーで計算できます. シーケンス番号は16ビットのみでラップアラウンドするので、シーケンス番号のラップアラウンド（s-> cycles）の（シフトされた）カウントで最大シーケンス番号を拡張する必要があります. 

      extended_max = s-> cycles + s-> max_seq;
      期待される= extended_max-s-> base_seq + 1;
        
失われたパケット数は、予想されるパケット数から実際に受信されたパケット数を差し引いた数として定義されます. 

      失われた=期待される-s-> received;
        
この符号付きの数値は24ビットで運ばれるため、折り返しではなく、正の損失の場合は0x7fffffに、負の損失の場合は0x800000にクランプする必要があります. 

最後のレポート間隔中に失われたパケットの割合（前のSRまたはRRパケットが送信されたため）は、間隔全体の予想パケット数と受信パケット数の差から計算されます. expected_priorとreceived_priorは、前回の受信レポートが保存されたときに保存された値です. 生成された：

      expected_interval = expected-s-> expected_prior;
      s-> expected_prior =期待;
      received_interval = s-> received-s-> received_prior;
      s-> received_prior = s-> received;
      lost_interval = expected_interval-received_interval;
      if（expected_interval == 0 || lost_interval <= 0）fraction = 0;
      それ以外の場合、割合=（lost_interval << 8）/ expected_interval;
        
結果の端数は、2進小数点が左端にある8ビットの固定小数点数です. 

A.4 RTCP SDESパケットの生成

この関数は、配列タイプ、値、および長さで提供されるargc項目で構成されるバッファーbに1つのSDESチャンクを構築します. b内で次に使用可能な場所へのポインタを返します. 

   char * rtp_write_sdes（char * b、u_int32 src、int argc、
                        rtcp_sdes_type_t type []、char * value []、
                        int length []）
   {
       rtcp_sdes_t * s =（rtcp_sdes_t *）b;
       rtcp_sdes_item_t * rsp;
       int i;
       int len;
       intパッド;
        
       / * SSRCヘッダー* /
       s-> src = src;
       rsp =＆s-> item [0];
        
       / * SDESアイテム* /
       for（i = 0; i <argc; i ++）{
           rsp-> type = type [i];
           len = length [i];
           if（len> RTP_MAX_SDES）{
               / *長さが無効です. 他のアクションを実行する必要があるかもしれません* /
               len = RTP_MAX_SDES;
           }
           rsp-> length = len;
           memcpy（rsp-> data、value [i]、len）;
           rsp =（rtcp_sdes_item_t *）＆rsp-> data [len];
       }
        
       / *エンドマーカーで終了し、次の4オクテット境界にパッドします* /
       len =（（char *）rsp）-b;
       パッド= 4-（len＆0x3）;
       b =（char *）rsp;
       while（パッド-）* b ++ = RTCP_SDES_END;
        
       リターンb;
   }
        
A.5 RTCP SDESパケットの解析

この関数は、SDESパケットを解析し、関数find_member（）を呼び出して、SSRC識別子が与えられたセッションメンバーの情報へのポインターを検索し、member_sdes（）がそのメンバーの新しいSDES情報を格納します. この関数は、RTCPパケットのヘッダーへのポインターを想定しています. 

   void rtp_read_sdes（rtcp_t * r）
   {
       int count = r-> common.count;
       rtcp_sdes_t * sd =＆r-> r.sdes;
       rtcp_sdes_item_t * rsp、* rspn;
       rtcp_sdes_item_t * end =（rtcp_sdes_item_t *）
                               （（u_int32 *）r + r-> common.length + 1）;
       ソース* s;
        
       while（--count> = 0）{
           rsp =＆sd-> item [0];
           if（rsp> = end）break;
           s = find_member（sd-> src）;
        
           for（; rsp-> type; rsp = rspn）{
               rspn =（rtcp_sdes_item_t *）（（char *）rsp + rsp-> length + 2）;
               if（rspn> = end）{
                   rsp = rspn;
                   ブレーク;
               }
               member_sdes（s、rsp-> type、rsp-> data、rsp-> length）;
           }
           sd =（rtcp_sdes_t *）
                （（u_int32 *）sd +（（（char *）rsp-（char *）sd）>> 2）+1）;
       }
       if（count> = 0）{
           / *無効なパケット形式* /
       }
   }
        
A.6ランダム32ビット識別子の生成

次のサブルーチンは、RFC 1321 [32]で公開されているMD5ルーチンを使用してランダムな32ビット識別子を生成します. システムルーチンはすべてのオペレーティングシステムに存在するわけではありませんが、使用できる情報の種類に関するヒントとして機能する必要があります. その他の適切なシステムコールには、o getdomainname（）、

o getwd（）、または

o getrusage（）. 

「ライブ」ビデオまたはオーディオサンプルも乱数の優れたソースですが、オフのマイクやブラインドカメラをソースとして使用しないように注意する必要があります[17]. 

RTCP期間を生成する乱数ジェネレータの初期シード（付録A.7を参照）を生成し、シーケンス番号とタイムスタンプの初期値を生成し、SSRC値を生成するには、このルーチンまたは同様のルーチンの使用をお勧めします. このルーチンはCPUを集中的に使用する可能性が高いため、予測可能性が問題にならないため、RTCP期間を生成するために直接使用することは不適切です. このルーチンは、type引数に異なる値が指定されない限り、システムクロックの値が変化するまで、繰り返しの呼び出しで同じ結果を生成することに注意してください. 

   / *
    *ランダムな32ビット量を生成します. 
    * /
   #include <sys / types.h> / * u_long * /
   #include <sys / time.h> / * gettimeofday（）* /
   #include <unistd.h> / * get ..（）* /
   #include <stdio.h> / * printf（）* /
   #include <time.h> / * clock（）* /
   #include <sys / utsname.h> / * uname（）* /
   #include "global.h" / * RFC 1321から* /
   #include "md5.h" / * RFC 1321から* /
        
#define MD_CTX MD5_CTX #define MDInit MD5Init #define MDUpdate MD5Update #define MDFinal MD5Final

   static u_long md_32（char * string、int length）
   {
       MD_CTXコンテキスト. 
       ユニオン{
           char c [16];
           u_long x [4];
       }ダイジェスト. 
       u_long r;
       int i;
        
MDInit（＆context）;

       MDUpdate（＆context、string、length）;
       MDFinal（（unsigned char *）＆digest、＆context）;
       r = 0;
       for（i = 0; i <3; i ++）{
           r ^ = digest.x [i];
       }
       rを返す;
   } / * md_32 * /
        
   / *
    *ランダムな符号なし32ビット量を返します. 次の場合は「type」引数を使用します
    *複数の異なる値を連続して生成する必要があります. 
    * /
   u_int32 random32（intタイプ）
   {
       構造体{
           intタイプ. 
           struct timeval tv;
           clock_t cpu;
           pid_t pid;
           u_long hid;
           uid_t uid;
           gid_t gid;
           struct utsname name;
       } s;
        
       gettimeofday（＆s.tv、0）;
       uname（＆s.name）;
       s.type = type;
       s.cpu = clock（）;
       s.pid = getpid（）;
       s.hid = gethostid（）;
       s.uid = getuid（）;
       s.gid = getgid（）;
       / *また：システム稼働時間* /
        
       md_32（（char *）＆s、sizeof（s））;を返します. 
   } / * random32 * /
        
A.7 RTCP送信間隔の計算

以下の関数は、セクション6.2で説明されているRTCP送信および受信ルールを実装します. これらのルールは、いくつかの関数でコード化されています. 

o rtcp_interval（）は、秒単位で測定された決定論的に計算された間隔を計算します. パラメータはセクション6.3で定義されています. 

o RTCP送信タイマーが期限切れになるとOnExpire（）が呼び出されます. 

o OnReceive（）は、RTCPパケットが受信されるたびに呼び出されます. 

OnExpire（）とOnReceive（）はどちらも引数としてイベントeを持っています. これは、RTCPレポートまたはBYEパケットのいずれかである、その参加者に対して次にスケジュールされているイベントです. 以下の機能が利用可能であることを前提としています. 

o Schedule（time t、event e）は、イベントeが時刻tに発生するようにスケジュールします. 時間tが到着すると、関数OnExpireがeを引数として呼び出されます. 

o Reschedule（time t、event e）は、以前にスケジュールされたイベントeを時間tに再スケジュールします. 

o SendRTCPReport（event e）はRTCPレポートを送信します. 

o SendBYEPacket（event e）はBYEパケットを送信します. 

o TypeOfEvent（event e）は、処理中のイベントがBYEパケットの送信用である場合はEVENT_BYEを返し、そうでない場合はEVENT_REPORTを返します. 

oパケットpがRTCPレポート（BYEではない）の場合、PacketType（p）はPACKET_RTCP_REPORTを返し、BYE RTCPパケットの場合はPACKET_BYE、通常のRTPデータパケットの場合はPACKET_RTPを返します. 

o ReceivedPacketSize（）およびSentPacketSize（）は、参照されたパケットのサイズをオクテットで返します. 

oパケットpを送信した参加者が現在メンバーリストにない場合、NewMember（p）は1を返し、そうでない場合は0を返します. RTPパケット内の各CSRC識別子とBYEパケット内の各SSRCを処理する必要があるため、この機能は完全な実装には不十分です. 

o NewSender（p）は、パケットpを送信した参加者が現在メンバーリストの送信者サブリストにない場合は1を返し、そうでない場合は0を返します. 

o AddMember（）およびRemoveMember（）は、メンバーリストに参加者を追加および削除します. 

o AddSender（）およびRemoveSender（）は、メンバーリストの送信者サブリストに参加者を追加および削除します. 

これらの関数は、送信側と非送信側のRTCP帯域幅の割合を、25％と75％の固定値ではなく明示的なパラメーターとして指定できる実装に拡張する必要があります. rtcp_interval（）の拡張実装では、パラメータの1つがゼロの場合、ゼロによる除算を回避する必要があります. 

   double rtcp_interval（intメンバー、
                        intセンダー、
                        ダブルrtcp_bw、
                        int we_sent、
                        ダブルavg_rtcp_size、
                        int initial）
   {
       / *
        *このサイトからのRTCPパケット間の最小平均時間（
        *秒）. 今回は、レポートが
        *セッションは短く、多数の法則は役に立たない
        *トラフィックをスムーズにするため. レポート間隔も保持します
        *以下のような一時的な停止中に、途方もなく小さくなる
        *ネットワークパーティション. 
        * /
       double const RTCP_MIN_TIME = 5 .;
       / *
        *アクティブ間で共有されるRTCP帯域幅の割合
        *送信者. （この割合は、一般的な
        * 1つまたは2つのアクティブな送信者とのセッション、計算されたレポート
        *時間は、レポートの最小時間とほぼ同じになるため、
        *レシーバーレポートを不必要に遅くすることはありません. ）
        *受信側の比率は1でなければなりません-送信側の比率. 
        * /
       double const RTCP_SENDER_BW_FRACTION = 0.25;
       double const RTCP_RCVR_BW_FRACTION =（1-RTCP_SENDER_BW_FRACTION）;
       / *
       / *に収束する「タイマーの再検討」を補正する
        *意図した平均を下回る値. 
        * /
       double const COMPENSATION = 2.71828-1.5;
        
       ダブルt; / *間隔* /
       double rtcp_min_time = RTCP_MIN_TIME;
       int n; /* 番号. 計算するメンバーの数* /
        
       / *
        *アプリケーションの起動時の非常に最初の呼び出しは半分を使用します
        *少し時間をおいて、通知を早くするための遅延
        *ランダム化のために報告する前、およびその他について学ぶため
        *レポート間隔が正しい値に収束するようにソース
        *間隔がより速くなります. 
        
        * /
       if（初期）{
           rtcp_min_time / = 2;
       }
       / *
        * RTCP帯域幅の一部を送信者専用にしない
        *送信者の数が十分に多いため、共有は
        *その分数より多い. 
        * /
       n =メンバー;
       if（送信者<=メンバー* RTCP_SENDER_BW_FRACTION）{
           if（we_sent）{
               rtcp_bw * = RTCP_SENDER_BW_FRACTION;
               n =送信者. 
           } そうしないと {
               rtcp_bw * = RTCP_RCVR_BW_FRACTION;
               n-=送信者;
           }
       }
        
       / *
        *有効サイト数と平均パケットサイズの積は
        *各サイトがレポートを送信するときに送信されるオクテットの総数. 
        *これを有効帯域幅で割ると、時間が得られます
        *これらのパケットを送信する必要がある間隔
        *最小限の強制で、帯域幅の目標を満たします. その中で
        *時間間隔は1つのレポートを送信するため、今回も
        *レポート間の平均時間. 
        * /
       t = avg_rtcp_size * n / rtcp_bw;
       if（t <rtcp_min_time）t = rtcp_min_time;
        
       / *
        *との意図しない同期によるトラフィックバーストを回避するため
        *他のサイトでは、実際の次のレポート間隔を
        * 0.5 * tと1.5 * tの間で一様に分布する乱数. 
        * /
       t = t *（drand48（）+ 0.5）;
       t = t /補償;
       tを返す;
   }
        
   void OnExpire（event e、
                 intメンバー、
                 intセンダー、
                 ダブルrtcp_bw、
                 int we_sent、
                 double * avg_rtcp_size、int * initial、
                 time_tp tc、
                 time_tp * tp、
                 int * pmembers）
   {
       / *この関数は、送信するかどうかを決定します
        * RTCPレポートまたはBYEパケットを今すぐ、または送信を再スケジュールします. 
        *また、pmembers、initial、tp、
        *およびavg_rtcp_size状態変数. この関数は
        * Schedule（）によって使用されるイベントタイマーの期限切れ時に呼び出されます. 
        * /
        
       ダブルt; / *間隔* /
       ダブルtn; / *次の送信時間* /
        
       / * BYEの場合、「タイマーの再検討」を使用して
        *必要に応じてBYEの送信を再スケジュールします* /
        
       if（TypeOfEvent（e）== EVENT_BYE）{
           t = rtcp_interval（members、
                             送信者、
                             rtcp_bw、
                             we_sent、
                             * avg_rtcp_size、
                             *初期）;
           tn = * tp + t;
           if（tn <= tc）{
               SendBYEPacket（e）;
               exit（1）;
           } そうしないと {
               Schedule（tn、e）;
           }
        
       } else if（TypeOfEvent（e）== EVENT_REPORT）{
           t = rtcp_interval（members、
                             送信者、
                             rtcp_bw、
                             we_sent、
                             * avg_rtcp_size、
                             *初期）;
           tn = * tp + t;
           if（tn <= tc）{
               SendRTCPReport（e）;
               * avg_rtcp_size =（1./16.)*SentPacketSize(e）+
                   （15./16.)*(*avg_rtcp_size）;
               * tp = tc;
        
               / *間隔を再描画する必要があります. 再利用しないでください
        
                  上で計算されたもの
                  条件付きなので、同じように配布
                  パケットを発生させるのに十分なほど小さい
                  送信されます */
        
t = rtcp_interval（members、senders、rtcp_bw、we_sent、* avg_rtcp_size、* initial）;

               Schedule（t + tc、e）;
               *初期= 0;
           } そうしないと {
               Schedule（tn、e）;
           }
           * pmembers =メンバー;
       }
   }
        
   void OnReceive（packet p、
                  イベントe、
                  int *メンバー、
                  int * pmembers、
                  int * senders、
                  double * avg_rtcp_size、
                  ダブル* tp、
                  ダブルtc、
                  ダブルtn）
   {
       / *私たちが何をするかは、グループを去ったかどうか、そして
        * BYE（TypeOfEvent（e）== EVENT_BYE）またはRTCPの送信を待機しています
        * 報告する. pは、受信されたばかりのパケットを表します. * /
        
       if（PacketType（p）== PACKET_RTCP_REPORT）{
           if（NewMember（p）&&（TypeOfEvent（e）== EVENT_REPORT））{
               AddMember（p）;
               *メンバー+ = 1;
           }
           * avg_rtcp_size =（1./16.)*ReceivedPacketSize(p）+
               （15./16.)*(*avg_rtcp_size）;
       } else if（PacketType（p）== PACKET_RTP）{
           if（NewMember（p）&&（TypeOfEvent（e）== EVENT_REPORT））{
               AddMember（p）;
               *メンバー+ = 1;
           }
           if（NewSender（p）&&（TypeOfEvent（e）== EVENT_REPORT））{
        
               AddSender（p）;
               *送信者+ = 1;
           }
       } else if（PacketType（p）== PACKET_BYE）{
           * avg_rtcp_size =（1./16.)*ReceivedPacketSize(p）+
               （15./16.)*(*avg_rtcp_size）;
        
           if（TypeOfEvent（e）== EVENT_REPORT）{
               if（NewSender（p）== FALSE）{
                   RemoveSender（p）;
                   *送信者-= 1;
               }
        
               if（NewMember（p）== FALSE）{
                   RemoveMember（p）;
                   *メンバー-= 1;
               }
        
               if（* members <* pmembers）{
                   tn = tc +
                       （（（double）*メンバー）/（* pメンバー））*（tn-tc）;
                   * tp = tc-
                       （（（double）*メンバー）/（* pメンバー））*（tc-* tp）;
        
                   / *時間tnの次のレポートを再スケジュールします* /
        
                   Reschedule（tn、e）;
                   * pmembers = *メンバー;
               }
        
           } else if（TypeOfEvent（e）== EVENT_BYE）{
               *メンバー+ = 1;
           }
       }
   }
        
A.8到着間ジッタの推定

以下のコードフラグメントは、受信レポートの到着間ジッタフィールドに挿入されるRTPデータ到着間時間の統計的分散の推定値を計算するために、セクション6.4.1で指定されたアルゴリズムを実装します. 入力は、r-> ts（着信パケットからのタイムスタンプ）および到着（同じ単位の現在時刻）です. ここで、sはソースの状態を指します. s-> transitは前のパケットの相対通過時間を保持し、s-> jitterは推定ジッターを保持します. 受信レポートのジッターフィールドはタイムスタンプ単位で測定され、符号なし整数として表されますが、ジッター推定値は浮動小数点で保持されます. 各データパケットが到着すると、ジッター推定値が更新されます. 

      intトランジット=到着-r-> ts;
      int d =通過-s->通過;
      s-> transit =トランジット;
      if（d <0）d = -d;
      s-> jitter + =（1./16. ）*（（double）d-s-> jitter）;
        
このメンバーに対して受信レポートブロック（rrポイント）が生成されると、現在のジッタ推定が返されます. 

      rr-> jitter =（u_int32）s-> jitter;
        
または、ジッター推定値を整数として保持することもできますが、丸め誤差を減らすためにスケーリングされます. 計算は最後の行を除いて同じです：

      s-> jitter + = d-（（s-> jitter + 8）>> 4）;
        
この場合、受信レポートの推定値は次のようにサンプリングされます. 

      rr-> jitter = s-> jitter >> 4;
        
付録B-RFC 1889からの変更

このRFCのほとんどはRFC 1889と同じです. ネットワーク上のパケット形式に変更はなく、プロトコルの使用方法を管理するルールとアルゴリズムにのみ変更があります. 最大の変更は、RTCPパケットを送信するタイミングを計算するためのスケーラブルタイマーアルゴリズムの拡張です. 

oセクション6.2および6.3で指定され、付録A.7に示されているRTCP送信間隔を計算するためのアルゴリズムは、多くの参加者が同時にセッションに参加したときに意図したレートを超える送信を最小限に抑えるための「再検討」と「逆再検討」を含むように拡張されています.  "参加者の数が急激に減少したときに、誤った参加者のタイムアウトの発生率と期間を削減します. パッシブレシーバーモードからアクティブセンダーモードに移行するときに、RTCP SRを送信する前の遅延を短縮するために、逆再検討も使用されます. 

oセクション6.3.7は、多くの参加者が同時にセッションを離れたときにパケットのフラッドを回避するために、RTCP BYEパケットをいつ送信するかを制御する新しいルールを指定しています. 

o一般的なネットワークパーティションにまたがるのに十分な期間、非アクティブな参加者の状態を保持する要件は、セクション6.2.1から削除されました. 多くの参加者が短時間参加し、BYEの送信に失敗するセッションでは、この要件により、参加者数が大幅に過大評価されます. このリビジョンで追加された再検討アルゴリズムは、パーティションが回復したときに同時に参加する多数の新しい参加者を補正します. 

これらの機能強化は、セッションの参加者の数が多く（数千人）、ほとんどの参加者が同時に参加または脱退する場合にのみ大きな効果があることに注意してください. これにより、ライブネットワークでのテストが困難になります. ただし、アルゴリズムはそのパフォーマンスを検証するために徹底的な分析とシミュレーションが行われました. さらに、拡張アルゴリズムはRFC 1889のアルゴリズムと相互運用するように設計されているため、ステップ結合中の過剰なRTCP帯域幅の減少の程度は、拡張アルゴリズムを実装する参加者の割合に比例します. 2つのアルゴリズムの相互運用は、ライブネットワークで実験的に検証されています. 

その他の機能変更は次のとおりです. 

oセクション6.2.1は、実装が参加者のSSRC識別子のサンプリングのみを保存して、非常に大きなセッションへのスケーリングを可能にすることを指定しています. アルゴリズムはRFC 2762 [21]で指定されています. 

oセクション6.2では、RTCP送信側と非送信側の帯域幅を、セッション帯域幅の厳密な割合ではなく、セッションの個別のパラメーターとして設定し、ゼロに設定することができると規定されています. IPマルチキャストを使用するRTPセッションでRTCPが必須であるという要件は緩和されました. ただし、RTCPをオフにすることは推奨されないという説明も追加されました. 

oセクション6.2、6.3.1、および付録A.7では、送信者が専用のRTCP帯域幅を取得する参加者の割合が、固定の1/4からRTCP送信者および非送信者の帯域幅パラメーターに基づく比率に変化することが指定されていますそれらが与えられたとき. 一時的な状態であると予想されるため、送信者がいないときに送信者専用の帯域幅がないという条件は削除されました. また、意図しない場合に、非送信者が送信者RTCP帯域幅を使用しないようにします. 

oセクション6.2では、高帯域幅セッションの場合、最小RTCP間隔をより小さい値にスケーリングできること、およびユニキャストセッションの場合、初期RTCP遅延をゼロに設定できることが指定されています. 

o参加者のタイムアウトは、アクティブな送信者であっても、受信者のRTCP帯域幅の割合を使用して計算された、いくつかのRTCPレポート間隔の非アクティブに基づいています. 

oセクション7.2および7.3は、トランスレーターとミキサーが転送しなくなったソースに対してBYEパケットを送信することを指定しています. 

oレイヤードエンコーディングのルール変更は、セクション2.4、6.3.9、8.3、11で定義されています. これらの最後では、アドレスとポートの割り当てルールはSDP仕様、RFC 2327 [15]と競合しますが、この制限は、RFC 2327の改訂で緩和される予定です. 

oセクション11のRTPとRTCPで偶数/奇数のポートペアを使用するための規則は、宛先ポートを参照するように明確化されました. 2つのポートが明示的に指定されている場合は、偶数/奇数のポートペアを使用する必要がなくなりました. ユニキャストRTPセッションの場合、2つの端（セクション3、7.1、および11）に異なるポートペアを使用できます. 

o RTPを使用するアプリケーションでの輻輳制御の要件を説明するために、新しいセクション10が追加されました. 

oセクション8.2では、ソーストランスポートアドレスが変更されるたびに新しいSSRC識別子を選択する必要があるという要件が緩和され、新しいSSRC識別子を選択できる場合があります. 同様に、他の2つの参加者間でSSRC衝突が発生した場合、実装は既存の送信元アドレスではなく、新しい送信元アドレスからのパケットを保持することを選択できることを明確にし、モバイルなどの一部の送信元がテレフォニーなどのアプリケーションでそうする必要がある（SHOULD）エンティティは、RTPセッション中にアドレスを変更する場合があります. 

oセクション8.2の衝突検出および解決アルゴリズムの疑似コードのRFC 1889印刷におけるインデントのバグは、構文を疑似C言語に変換することによって修正され、RTPとRTPの両方の制限を削除するようにアルゴリズムが変更されました.  RTCPは同じ送信元ポート番号から送信する必要があります. 

o RTCPパケットのパディングメカニズムの説明が明確になり、パディングは複合RTCPパケットの最後のパケットにのみ適用する必要があると指定されています. 

oセクションA.1で、base_seqの初期化がseq-1ではなくseqになるように修正されました. また、テキストが修正され、不正なシーケンス番号に1を加えたものが格納されます. アルゴリズムのmax_seqおよび他の変数の初期化は、init_seq（）関数の呼び出しに加えてこの初期化を実行する必要があることを明確にするためにテキストから分離されました（およびドキュメントをソースから出力に処理するときにRFC 1889で失われたいくつかの単語）フォームが復元されました）. 

oセクションA.3で失われたパケット数のクランプは、正の制限と負の制限の両方を使用するように修正されました. 

o RTCP SRセクションでの「相対」NTPタイムスタンプの仕様では、これらのタイムスタンプが、複数のアプリケーションで同じではないセッションの経過時間ではなく、システム稼働時間などの最も一般的なシステム固有のクロックに基づくように定義されています. 同じマシンで異なる時間に開始されました. 

非機能的な変更：

oレシーバーが理解できないペイロードタイプのパケットを無視する必要があることを指定します. 

o図2では、浮動小数点NTPタイムスタンプ値が修正され、欠落している先行ゼロが16進数で追加され、UTCタイムゾーンが指定されました. 

o 2036年にラップアラウンドするNTPタイムスタンプの重要性について説明します. 

o RTCPパケットタイプとSDESタイプの登録に関するポリシーは、新しいセクション15、IANAの考慮事項で明確になりました. 実験者が必要な数を登録してから、不要であることが判明した数を登録解除するという提案は、APPとPRIVの使用を支持して削除されました. プロファイル名の登録も指定されました. 

o UTF-8文字セットの参照は、X / Open予備仕様からRFC 2279に変更されました. 

o RFC 1597のリファレンスはRFC 1918に更新され、RFC 2543のリファレンスはRFC 3261に更新されました. 

oインターネットへの展開を制限するよう実装者に警告するRFC 1889の導入の最後の段落は、もはや関連がないと見なされたため削除されました. 

o Source-Specific Multicast（SSM）でのRTPの使用に関する非規範的な注記がセクション6に追加されました. 

oセクション3の「RTPセッション」の定義が拡張され、単一のセッションが複数の宛先トランスポートアドレスを使用できることを認識し（常にトランスレータまたはミキサーの場合と同様）、RTPセッションの特徴的な機能は次のとおりであることを説明しました. それぞれが個別のSSRC IDスペースに対応しています. 「マルチメディアセッション」の新しい定義が追加され、「セッション」という言葉の混乱を減らします. 

o「サンプリングインスタント」の意味は、セクション5.1のRTPヘッダーのタイムスタンプフィールドの定義の一部として、より詳細に説明されました. 

o読者からの質問に答えるために、いくつかの場所で文章の小さな明確化が行われました. 特に：

-RFC 1889では、セクション2.2の2番目の文の最初の5ワードが、ソースから出力形式へのドキュメントの処理で失われましたが、現在は復元されています. 

-セクション5で「RTPメディアタイプ」の定義が追加され、セクション5.2でのRTPセッションの多重化の説明が、複数のメディアの多重化に関してより明確になるようになりました. そのセクションでは、SSRC識別子に基づいて同じメディアの複数のソースを多重化することが適切であり、マルチキャストセッションの標準であることも説明しています. 

-「非RTP手段」の定義は、非RTP手段を構成する他のプロトコルの例を含むように拡張されました. 

-セッション帯域幅パラメータの説明がセクション6.2で拡張されました. これには、制御トラフィック帯域幅がデータトラフィックのセッション帯域幅に追加されることが明記されています. 

-ジッターの計算に対するパケット持続時間の変化の影響は、セクション6.4.4で説明されています. 

-SDESアイテムのシーケンスを終了およびパディングする方法は、セクション6.5で明確になりました. 

-セクション6.5.1のSDES CNAMEの説明にIPv6アドレスの例が追加され、他のサンプルドメイン名の代わりに「example.com」が使用されました. 

-「セキュリティ」セクションでは、IPSECが正式に参照できるようになったため、この仕様で定義されている機密保持方法は、主に既存の慣行を成文化することであると述べています. デフォルトのアルゴリズムの代わりにTriple-DESなどのより強力な暗号化アルゴリズムを使用することをお勧めします. 将来的には、AESに基づくSRTPプロファイルが正しい選択になることに注意してください. 初期化ベクトルとしてのRTPヘッダーの弱点に関する注意が追加されました. また、ヘッダー圧縮を可能にするためにペイロードのみの暗号化が必要であることも指摘されました. 

-RTCPの部分暗号化の方法が明確になりました. 特に、複合RTCPパケットが分割される場合、SDES CNAMEは1つの部分でのみ伝送されます. 

-レポート間隔ごとに1つの複合RTCPパケットのみを送信する必要があること、およびレポートがMTUに収まらないほどアクティブなソースが多すぎる場合は、複数の間隔でソースのサブセットをラウンドロビンで選択する必要があることを明確にしました. 

-付録A.1に、RTPヘッダーの検証中にパケットが保存され、成功時に配信されるというメモが追加されました. 

-セクション7.3では、SDESパケットを集約するミキサーがパケットが長いためにRTCP帯域幅をより多く使用し、RTCPを通過するミキサーはパケットを単一のソースレートよりも高く送信するが、両方の動作が有効であることを説明します. 

-セクション13では、RTPアプリケーションが複数のプロファイルを使用する場合があることを明記していますが、通常、特定のセッションでは1つのみです. 

-「MUST」、「SHOULD」、「MAY」などの用語は、RFC 2119で定義されているように使用されます. 

-参考文献は、規範的および有益な参考文献に分けられました. 

参考文献

規範的な参考文献

[1] Schulzrinne、H. およびS. Casner、「Minimal Controlを使用したオーディオおよびビデオ会議のRTPプロファイル」、RFC 3551、2003年7月. 

[2] Bradner、S.、「要件レベルを示すためにRFCで使用するキーワード」、BCP 14、RFC 2119、1997年3月. 

[3]ポステルJ.、「インターネットプロトコル」、STD 5、RFC 791、1981年9月. 

[4] Mills、D. 、「Network Time Protocol（Version 3）Specification、Implementation and Analysis」、RFC 1305、1992年3月. 

[5] Yergeau、F. 、「UTF-8、ISO 10646の変換フォーマット」、RFC 2279、1998年1月. 

[6] Mockapetris、P. 、「ドメイン名-概念と機能」、STD 13、RFC 1034、1987年11月. 

[7] Mockapetris、P. 、「ドメイン名-実装と仕様」、STD 13、RFC 1035、1987年11月. 

[8] Braden、R. 、「インターネットホストの要件-アプリケーションとサポート」、STD 3、RFC 1123、1989年10月. 

[9] Resnick、P. 、「インターネットメッセージフォーマット」、RFC 2822、2001年4月. 

参考情報

[10] SIGCOMM Symposium on Communications Architectures and Protocols（Philadelphia、Pennsylvania）、pp. 200--208、IEEE Computer Communications Review、 "Clark、D. and D. Tennenhouse、" Architectural Considerations for a New Generation of Protocols "巻. 20（4）、1990年9月. 

[11] Schulzrinne、H.、「オーディオおよびビデオ会議、および他の複数参加者のリアルタイムアプリケーション用のトランスポートプロトコルを設計する際の問題. 」1993年10月にインターネットドラフトが期限切れになりました. 

[12] Comer、D.、TCP / IPによるインターネットワーキング、vol. 1.ニュージャージー州イングルウッドクリフス：プレンティスホール、1991年. 

[13] Rosenberg、J.、Schulzrinne、H.、Camarillo、G.、Johnston、A.、Peterson、J.、Sparks、R.、Handley、M. およびE. Schooler、「SIP：Session Initiation Protocol」、 RFC 3261、2002年6月. 

[14]国際電気通信連合、「保証されていないサービス品質を提供するローカルエリアネットワーク用のビジュアル電話システムおよび機器」、勧告H.323、ITUの電気通信標準化部門、スイス、ジュネーブ、2003年7月. 

[15] Handley、M. およびV. Jacobson、「SDP：Session Description Protocol」、RFC 2327、1998年4月. 

[16] Schulzrinne、H.、Rao、A. およびR. Lanphier、「Real Time Streaming Protocol（RTSP）」、RFC 2326、1998年4月. 

[17] Eastlake 3rd、D.、Crocker、S. およびJ. Schiller、「Randomness Recommendations for Security」、RFC 1750、1994年12月. 

[18] Bolot、J.-C.、Turletti、T. およびI. Wakeman、「SIGCOMM Symposium on Communications Architectures and Protocols」（ロンドン、イギリス）、pp.  58--67、ACM、1994年8月. 

[19] Busse、I.、Deffner、B. およびH. Schulzrinne、「RTPに基づくマルチメディアアプリケーションの動的QoS制御」、Computer Communications、vol. 19、pp.49--58、1996年1月. 

[20] Floyd、S.およびV. Jacobson、「The Synchronization of Periodic Routing Messages」、SIGCOMM Symposium on Communications Architectures and Protocols（DP Sidhu、ed. ）、（San Francisco、California）、pp. 33--44 、ACM、1993年9月. [34]にも掲載. 

[21] Rosenberg、J. およびH. Schulzrinne、「RTPのグループメンバーシップのサンプリング」、RFC 2762、2000年2月. 

[22] Cadzow、J. 、デジタル信号処理およびデータ分析の基礎ニューヨーク、ニューヨーク：マクミラン、1987. 

[23] Hinden、R. およびS. Deering、「Internet Protocol Version 6（IPv6）Addressing Architecture」、RFC 3513、2003年4月. 

[24] Rekhter、Y.、Moskowitz、B.、Karrenberg、D.、de Groot、G. およびE. Lear、「プライベートインターネットのアドレス割り当て」、RFC 1918、1996年2月. 

[25]リア、E. 、フェア、E. 、クロッカー、D. 、およびT.ケスラー、「ネットワーク10は有害であると見なされている（一部のプラクティスはコード化すべきではない）」、RFC 1627、1994年7月. 

[26]フェラー、W. 、確率論とその応用の紹介、vol. 1.ニューヨーク、ニューヨーク：ジョンワイリーアンドサンズ、第三版、1968. 

[27]ケント、S. 、およびR.アトキンソン、「インターネットプロトコルのセキュリティアーキテクチャ」、RFC 2401、1998年11月. 

[28]バウアーM.、ブロムR.、カララE.、マクルーグD.、ナスルンドM.、ノーマンK.およびD.オラン、「Secure Real-time Transport Protocol」、Work in Progress、 2003年4月. 

[29]バレンソン、D. 、「インターネット電子メールのプライバシー強化：パートIII」、RFC 1423、1993年2月. 

[30] Voydock、V. およびS.ケント、「高レベルネットワークプロトコルのセキュリティメカニズム」、ACM Computing Surveys、vol. 15、pp. 135-171、1983年6月. 

[31]フロイド、S. 、「輻輳制御原則」、BCP 41、RFC 2914、2000年9月. 

[32] Rivest、R. 、「The MD5 Message-Digest Algorithm」、RFC 1321、1992年4月. 

[33] Stubblebine、S.、「マルチメディア会議のためのセキュリティサービス」、第16回全国コンピュータセキュリティ会議（メリーランド州ボルチモア）、391-395ページ、1993年9月. 

[34]フロイドS.およびV.ジェイコブソン、「定期的なルーティングメッセージの同期」、IEEE / ACM Transactions on Networking、vol. 2、pp.122-136、1994年4月. 

著者のアドレス

ヘニングシュルズリンネコンピュータサイエンス学科コロンビア大学1214アムステルダムアベニューニューヨーク、ニューヨーク10027アメリカ合衆国

メール：schulzrinne@cs.columbia.edu

Stephen L.Casner Packet Design 3400 Hillview Avenue、Building 3 Palo Alto、CA 94304アメリカ合衆国

メール：casner@acm.org

Ron Frederick Blue Coat Systems Inc. 650 Almanor Avenue Sunnyvale、CA 94085アメリカ合衆国

メール：ronf@bluecoat.com

Van Jacobson Packet Design 3400 Hillview Avenue、Building 3 Palo Alto、CA 94304アメリカ合衆国

メール：van@packetdesign.com

完全な著作権表示

Copyright（C）The Internet Society（2003）. 全著作権所有. 

このドキュメントとその翻訳はコピーして他のユーザーに提供することができ、コメントまたはその他の方法で説明したり、その実装を支援する二次的著作物は、いかなる種類の制限なしに、全体または一部を準備、コピー、公開、および配布することができますただし、上記の著作権表示とこの段落は、そのようなすべてのコピーと派生物に含まれています. ただし、このドキュメント自体は、著作権に関する通知を削除したり、インターネットソサエティや他のインターネット組織への参照を削除したりするなどの方法で変更することはできません. ただし、インターネット標準を開発する目的で必要な場合は除きます. インターネット標準のプロセスに従うか、英語以外の言語に翻訳するために必要に応じて行う必要があります. 

上記で付与された制限付きのアクセス許可は永続的であり、インターネットソサエティまたはその後継者または譲受人によって取り消されることはありません. 

本書および本書に含まれる情報は「現状有姿」で提供され、インターネット社会およびインターネット技術タスクフォースは、明示または黙示を問わず、ここに含まれる情報の使用が保証するものに限定されない一切の保証を含みません. 商品性または特定の目的への適合性の権利または黙示の保証を侵害すること. 

了承

RFC Editor機能への資金提供は、現在Internet Societyによって提供されています. 