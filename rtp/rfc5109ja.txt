RFCトランス
プライバシーポリシー
コンタクト
イチジク
@ tex2e
5109
RFC5109-一般的な前方誤り訂正のためのRTPペイロード形式日本語訳
URL：https://tools.ietf.org/html/rfc5109
パッケージ：RFC5109-一般的な前方誤り訂正のためのRTPペイロード形式
編集編集：自動生成
[検索][txt| html | pdf |bibtex][トラッカー][WG][メール][Diff1][Diff2] [Nits]
差出人：draft-ietf-avt-ulp-23提案された標準
                                                        IPR宣言
                                                            エラッタexistNetworkワーキンググループA.Li、Ed. 
コメントのリクエスト：51092007年12月
廃止：2733、3009
カテゴリ：スタンダードトラック
        
一般的な前方誤り訂正のためのRTPペイロード形式

このメモのステータス

このドキュメントは、インターネットコミュニティのインターネット標準追跡プロトコルを指定し、改善のための議論と提案を要求します. このプロトコルの標準化の状態とステータスについては、「インターネット公式プロトコル標準」（STD 1）の最新版を参照してください. このメモの配布は無制限です. 

概要

このドキュメントでは、RTPにカプセル化されたメディアデータの一般的な前方誤り訂正（FEC）のペイロード形式を指定します. これは、排他的論理和（パリティ）演算に基づいています. このドキュメントで説明されているペイロード形式により、エンドシステムは、さまざまなメディアとチャネルの特性に適応するためにさまざまな保護グループサイズを使用することに加えて、さまざまな保護の長さとレベルを使用して保護を適用できます. パケット損失の状況に応じて、保護されたパケットの完全な回復またはペイロードの重要な部分の部分的な回復を可能にします. このスキームは、FECに対応していないホストと完全に互換性があるため、FECを実装していないマルチキャストグループの受信者は、保護データを無視するだけで機能します. この仕様は、RFC2733およびRFC3009を廃止します. 

目次

   1.はじめに...............................................  ..... 2
   2.用語...............................................  ...... 5
   3.基本操作..............................................  ... 6
   4.パリティコード..............................................  ......7
   5.不均一レベル保護（ULP）................................... 7
   6.RTPメディアパケット構造......................................9
   7.FECパケット構造............................................9
      7.1. パケット構造...........................................9
      7.2. FECパケットのRTPヘッダー................................10
      7.3. FECパケットのFECヘッダー................................11
      7.4. FECパケットのFECレベルヘッダー..........................12
   8.保護操作...........................................15
      8.1. FECヘッダーの生成..............................15
      8.2. FECペイロードの生成.............................16
   9.復旧手順............................................16
      9.1. RTPヘッダーの再構築..........................16
      9.2. RTPペイロードの再構築.........................18
   10.例...............................................  ....... 19
      10.1. 例はRFC2733と同様の保護を提供します.........19
      10.2. 2つの保護レベルの例....................21
      10.3. 冗長コーディングとしてFECを使用した例..................26
   11.セキュリティに関する考慮事項.......................................29
   12.輻輳に関する考慮事項.....................................30
   13.IANAの考慮事項...........................................31
      13.1. オーディオ/ulpfecの登録.............................31
      13.2. ビデオ/ulpfecの登録.............................32
      13.3. text/ulpfecの登録..............................34
      13.4. アプリケーション/ulpfecの登録.......................35
   14.FECの多重化...........................................36
      14.1. 個別のストリームとしてのFEC.................................36
      14.2. 冗長エンコーディングとしてのFEC................................38
      14.3. オファー/アンサーの考慮事項.............................39
   15.アプリケーションステートメント.........................................40
   16.謝辞...............................................  42
   17.参考文献...............................................  ..... 42
      17.1. 規範的参照.....................................42
      17.2. 有益な参考資料...................................43
        
1.はじめに
リアルタイムアプリケーションの性質上、通常のデータ送信よりも厳しい遅延要求があることを示唆している。そのため、このようなアプリケーションでは、失われたパケットの再送は一般に有効な選択肢ではありません。このような場合、パケットロスからの情報回復を試みるより良い方法は、FEC（Forward Error Correction）を利用することです。FEC は、次のような目的で使用される主な方法の 1 つです。

パケット交換ネットワークにおけるパケットロスからの保護 [9, 10] 。特に、パリティ符号、リードソロモン符号、ハミング符号などの伝統的な誤り訂正符号の利用が多く見受けられます。これらのメカニズムを適用するためには、プロトコルのサポートが必要である。RFC 2733 [9]とRFC 3009 [11]は、そのようなFECプロトコルの一つを定義しています。ただし、これら2つのRFCでは、RTPヘッダーの一部のフィールド (P、X、CCフィールド)が、RTP [1]の設計と整合しない方法で指定されている。このため、RTPパケットのペイロードに依存しない有効性チェックができな い。

本書は、RFC2733とRFC3009で定義されたFECを拡張し、ペイロードデータの不等間隔エラー保護を含むようにしたものである。本仕様では、従来の2つのRFCを特殊なケースとして、一般的なアルゴリズムを規定している。また、本仕様は、前述のRFC2733およびRFC3009との不整合を修正し、これら2つの旧RFCを廃止するものである。なお、本文書で規定するペイロードは、RFC2733 および RFC3009 との後方互換性はない。本文書で規定されるペイロードは、RFC3009 のものとは異なる MIME でシグナリングされるため、容量交換において異なるパリティ FEC バージョンを誤認する懸念はない。本書およびRFC2733、RFC3009で規定されたパリティFECでは、ペイロードデータは変更されず、ペイロードデータを保護するために追加のFECデータが一緒に送信される。したがって、パリティFECのバージョンが異なるホストやパリティFECを実装していないホスト間では、ペイロードデータの通信が問題なく流れることになる。送信ホストと互換性のないFECを持つ受信ホストでは、追加FECデータの恩恵を受けることができないため、RFC2733やRFC3009を実装する既存ホストは、可能な限り本仕様に従うようアップデートすることが推奨されます。

本文書は、リアルタイムメディアの汎用的な回送エラー修正を可能にする、RTP [1]のペイロード形式を定義する。この文脈では、汎用とは、FECプロトコルが、（1）保護されるメディアの性質（音、 ビデオ、その他）に依存しない、（2）多様なFEC構成に対応できるほど柔軟である、 （3）帯域外シグナリングなしでFEC技術を簡単に変更できるように適応性を持 つように設計されている、（4）FECパケットの伝送に多くの異なるメカニズムをサポート している、という意味である。

さらに、多くのシナリオで、ネットワーク接続の帯域幅は非常に限られたリソースです。一方、従来のFEC方式のほとんどは、限られた帯域幅リソースを最適に利用するように設計されていません。よく使われる改善策として、データストリームの重要度が異なる部分に対して異なる保護レベルを提供する不等間隔エラー保護があります。不等辺誤り検出方式は、通常、帯域幅をより効率的に使用し、データストリームの全体的な保護を向上させることができます。

ストリームを損失から保護します。これらの不等間隔エラー保護機構を実現するためには、適切なプロトコルサポートが不可欠である。不等誤り保護方式の多くは、データストリームの異なる部分に対する重要性の知識を持つことが必要である。そのため、このような方式の多くは、保護されるメディアの構造に応じて特定のタイプのメディア用に設計されており、結果として汎用的ではありません。

この文書では、リアルタイムメディア用の不平等誤り保護付き汎用順方向誤り訂正のためのFECアルゴリズムとプロトコルを定義している。ここで定義された特定のアルゴリズムは、不平等レベル保護（ULP：Uneven Level Protection）と呼ばれる。ペイロードデータは、1つ以上の保護レベルによって保護される。低い保護レベルでは、FEC パケットの生成に小さなグループサイズ（高い保護レベルと比較して）を使用することで、より大きな保護を提供することができます。後述するように、オーディオ/ビデオアプリケーションでは、一般に、ULP などの各パケットの先頭部分に多くの保護を与える不等間隔エラー保護スキームが有効であると考えられます。パケットの先頭に近いデータは一般に重要度が高く、パケット内の後方にあるデータよりも多くの情報を運ぶ傾向があります。

多くのマルチメディアストリームでは、データのより重要な部分が常にデータパケットの先頭にあることはよく知られています。これは、パケットの先頭がヘッダの再同期マーカーに近いため、正しくデコードされる可能性が高いことから、コーデック設計では一般的に行われていることです。さらに、ほとんどすべてのメディア・フォーマットでは、パケットの先頭にフレーム・ヘッダがあり、これはパケットの最も重要な部分である。

ビデオストリームでは、ビデオマクロブロックのヘッダデータ、動きベクトルデータ、離散コサイン変換（DCT）係数データを個々のパーティションに分離して、エラー耐性を高めるデータ分割モードが、最近のほとんどのフォーマットでオプションとして用意されています。例えば、ITU-T H.263 version 3では、Annex Vのオプションのデータ分割構文があり、MPEG-4 Visual Simple Profileでは、オプションのデータ分割モードがある。これらのモードが有効な場合、ビデオマクロブロック（MB）ヘッダと動きベクトルのパーティション（これらはビデオ再構成の品質にとってより重要である）は、ビデオパケットの先頭にあるパーティションで送信され、残留DCT係数パーティション（これはあまり重要ではない）はパケットの末尾に近いパーティションで送信される。データは重要度の高い順に配置されるため、パケットの先頭部分をより保護しながら伝送することが有効である。

オーディオストリームの場合、多くの新しいオーディオコーデックが生成するビットストリームにも、重要度の異なるクラスのデータが含まれています。そして、これらの異なるクラスは、以下の順序で伝送されます。

の重要性がある。このような場合、パケットの先頭により多くの保護を適用することも有益である。重要度が均一なオーディオストリームであっても、部分的に復元されたオーディオデータパケットには、様々なタイムシフトやストレッチの技術を適用することができます。

オーディオ／ビデオアプリケーションは、一般的にこの文書で指定された FEC アルゴリズムの恩恵を受けるだろう。ULPを使用すると、メディアペイロードの保護効率がさらに向上する可能性があ る。本文書は、RTPメディアペイロードに汎用FECを適用するためのプロトコルとアルゴリ ズムを規定する。

2.用語
本書では、以下の用語を使用します。

メディアペイロード。送信者から送信される生の、保護されていないユーザーデータ。メディアペイロードはRTPパケット内に配置される。

メディアヘッダ。メディアペイロードを含むパケットのRTPヘッダー。

メディアパケット。メディアペイロードとメディアヘッダの組み合わせはメディアパケットと呼ばれる。

FECパケット。送信機のFECアルゴリズムは、メディアパケットを入力とする。渡されたメディアパケットと、エラー訂正に使用する冗長なメディアデータを含むFECパケットと呼ばれる新たに生成されたパケットの両方を出力する。FECパケットは、本書で規定された規則に従ってフォーマットされる。

FECヘッダー。FECパケットに含まれるヘッダー情報。

FECレベルヘッダ。FECパケットに含まれる各レベルのヘッダー情報。

FECペイロード。FECパケットのペイロード。複数レベルに分割されることもある。

関連づけられる。FECパケットは、それらのメディアパケットがFECパケットを生成するために（排他的論理和演算を使用して）使用されるとき、一つ以上のメディアパケット（またはその逆）に「関連」していると言われます。これは、特に明示されていない場合、レベル0 FECペイロードを生成するために使用されるパケットのみを指す。

本文書におけるキーワード「MUST」「MUST NOT」「REQUIRED」「SHALL」「SHALL NOT」「SHOULD」「SHOULD NOT」「RECOMMENDED」「MAY」「OPTIONAL」は RFC 2119 [2] に記述されている通りに解釈されるものとします。

3.基本操作
ここで説明するペイロード形式は、RTPセッションの送信者が、送信するメディアストリームを汎用的なパリティFECで保護したい場合に使用される。この形式でサポートされるFECは、単純な排他的論理和(XOR)パリティ操作に基づくものである。送信者は、保護が必要なメディアストリームからパケットを取り出し、これらのパケットの保護レベルおよび各レベルの保護長を決定する。データは、後述のセクション7で説明するようにグループ化される。ペイロード全体にXOR演算を適用し、FEC情報を生成する。ここで定義された手順に従った結果は、FEC情報を含むRTPパケットである。これらのパケットは、FEC情報の生成に使用されたパケットまたはパケットの一部を回復するために、受信機で使用することができる。

FEC のペイロード形式は、送信側が受信側に、どのメディアパケットが FEC パケットで保護されているか、また各レベルの保護レベルと長さを正確に伝えることができる情報を含んでいる。具体的には、各FECパケットには、保護レベルkごとのオフセットマスクm（k）が含まれており、マスクm（k）内のビットiが1に設定されていれば、メディアパケット番号N＋iがこのFECパケットによってレベルkで保護されていることになります。レベルkで保護されるデータ量はL(k)で示され、これもFECパケットで送られる。保護長、オフセットマスク、ペイロードタイプ、およびシーケンス番号ベースは、少ないオーバーヘッドでFECパケットを生成するために適用されるパリティコードを完全に識別する。セクション 7.4 では、異なる保護レベルに対してどのようにマスクを設定すべきかを定義する一連の規則が説明されており、セクション 10 ではその例が示されている。

この文書では、すべての保護動作パラメータを帯域内で送信する手順についても説明する。これにより、送信者は現在のネットワーク条件にプロテクションを適応させ、受信者が回復のためにFECを使用できることを確認することができます。

受信機では、FECと元のメディアの両方が受信されます。メディアパケットの損失がなければ、FECパケットは無視することができる。損失が発生した場合、FECパケットを他の受信メディアと組み合わせて、失われたメディアパケットのすべてまたは一部を回復することができます。

4.パリティコード
簡潔にするために、関数 f(x,y,...) をデータブロック x,y,... に適用される XOR（パリティ）演算子と定義することにします。この関数の出力は、パリティブロックと呼ばれる別のブロックです。簡単のために、ここでは、パリティブロックは入力ブロックのビットごとのXORとして計算されると仮定します。正確な手順はセクション8で説明する。

パリティ符号を用いたデータブロックの保護は、データブロック群に1つ以上のパリティブロックを生成することで実現される。最も効果的なのは、パリティブロックがデータブロックの線形的に独立した組み合わせで生成されることである。この特定の組み合わせをパリティコードと呼ぶ。ペイロードフォーマットは、XOR パリティコードを使用する。

例えば、2つのデータブロックの上に1つのパリティブロックを生成するパリティ符号を考えてみましょう。元のメディアパケットがa,b,c,dの場合、送信側で生成されるパケットを

      a        b        c        d               <-- media stream
                 f(a,b)            f(c,d)        <-- FEC stream
 
ここで、時間は右へ向かって増加する。この例では、誤り訂正方式（ここでは、方式と符号の用語を使い分ける）により、50%のオーバーヘッドが発生する。しかし、bが失われた場合、aとf(a,b)を使ってbを回復することができる。

XOR パリティコード以外にも、ペイロードを保護するために使用できる多くの種類の順方向誤り訂正 コードがあることを指摘しておくことは有益であろう。注目すべき例としては、Reed-Solomon コードがあり、その他にも多くのものがある[12]。しかし、ここでは、プロトコル設計と実装の両方において、その有効性と簡便性から、XORパリティコードが使用されています。これは、リソースが限られたノードで実装する場合に特に重要である。

5.レベル不揃い保護（ULP）
上記の簡単な例からわかるように、データに対する保護はグループのサイズに依存します。したがって、3つのパケット（2つのペイロードパケットと1つのFECパケット）のうち1つが失われたとしても、元のペイロードデータは回復することができます。

一般に、FEC保護動作は、帯域幅と保護強度の間のトレードオフである。ソースメディアパケットの割合として生成されるFECパケットが多いほど、損失に対する保護は強くなりますが、結合されたストリームによって消費される帯域幅が大きくなります。

ほとんどのメディアペイロードに共通することですが、パケットのすべての部分が同じ重要性を持っているわけではありません。この性質を利用して、不均等なエラー保護、つまり、パケットの異なる部分に異なる保護を適用することで、チャネルの帯域幅をより効率的に使用できる可能性があります。より重要な部分の保護にはより多くの帯域幅を使用し、重要でない部分の保護にはより少ない帯域幅を使用します。

パケットは重要度の低い部分から順に分割され、それぞれの部分に対して異なる強度の保護処理が施される-この分割は「レベル」と呼ばれる。保護動作は、各レベルで独立して適用されます。1つのFECパケットで、複数のレベルのパリティデータを伝送することができます。このアルゴリズムは、凸凹レベル保護（ULP）と呼ばれています。

ULP による保護は、以下の図 1 に示すとおりです。この例では、2 つの ULP FEC パケットが 4 つのペイロードパケットを保護しています。

ULP FECパケット#1は、パケットAとBを保護する1レベルのみで、AとBのパケット全体にパリティ演算を施すのではなく、両パケットのデータ長のみを保護する。この長さは、セッション中に動的に選択・変更することができ、保護長と呼ばれる。

ULP FEC packet #2 には、2つの保護レベルがあります。レベル0は、パケットCとDで動作することを除いて、ULP FECパケット#1と同じです。レベル1の保護は、パケットA、B、C、Dのデータに対してパリティ動作を適用しています。情報はすべてこの文書で指定されたプロトコルによってインバンドで伝達される。

         Packet A          #####################
                                  :        :
         Packet B          ############### :
                                  :        :
         ULP FEC Packet #1 @@@@@@@@        :
                                  :        :
         Packet C          ###########     :
                                  :        :
         Packet D          ###################################
                                  :        :
         ULP FEC Packet #2 @@@@@@@@@@@@@@@@@
                           :      :        :
                           :<-L0->:<--L1-->:

                     図1：不平等なレベルの保護

冒頭で説明したように、メディアストリームは通常、より重要な部分をパケットの先頭に持ってきます。通常、パケットの先頭に近いレベルではより強力な保護を行い、後方のレベルではより弱い保護を行うことが有効です。ULPアルゴリズムはこのようなFEC保護を提供します。

ULP FECは、パケットの先頭部分（より重要）をより保護するだけでなく、パケットの前のセクションは回復不可能で、後のセクションは回復できる（しばしば廃棄しなければならない）という効率の悪いシナリオを可能な限り回避することができます。

6.RTPメディアパケット構造
メディアパケットのフォーマットは、FECの影響を受けません。FECが別のストリームとして送信される場合、メディアパケットはFECがないかのように送信されます。

この方法は、FECをサポートしない受信機でもメディアパケットを解釈できるという利点がある。FEC をサポートしない受信機との互換性は、マルチキャストシナリオで特に有用です。FEC スキームを使用するためのオーバーヘッドは FEC パケットにのみ存在し、使用中の FEC の量を追跡することで簡単にモニターし調整することができます。

7.FECパケット構造
7.1.パケット構造
FECパケットは、図2に示すように、FECヘッダと1レベル以上のペイロードをRTPペイロードに配置することで構築される。

   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                RTP Header (12 octets or more)                 |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                    FEC Header (10 octets)                     |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                      FEC Level 0 Header                       |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                     FEC Level 0 Payload                       |
   |                                                               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                      FEC Level 1 Header                       |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                     FEC Level 1 Payload                       |
   |                                                               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                            Cont.                              |
   |                                                               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        
図2：FECパケット構造

7.2. FECパケットのRTPヘッダー
FECパケットのRTPヘッダーは、FECがプロテクトされたペイロードストリーム (セクション14で定義)とは別のストリームで送信される場合にのみ使用される。したがって、以下の議論の多くは、このシナリオにのみ適用される。FECパケットのRTPヘッダーのすべてのフィールドは、RFC 3550 [1]に従って使用されるが、そのうちのいくつかは以下でさらに明確化される。

マーカ。このフィールドは、このペイロードタイプでは使用されず、0に設定されなければならない（SHALL）。

同期ソース(Synchronization Source)(SSRC)。SSRC値は、保護するメディアストリームのSSRC値と同一でなければならない（SHALL）。

シーケンス番号(SN)。シーケンス番号は標準的な定義であり、前に送信されたFECパケットのシーケンス番号より1つ上位でなければならない（MUST）。

タイムスタンプ(TS)。タイムスタンプは、FECパケットが送信される瞬間のメディアRTPクロックの値に設定されなけれ ばならない(MUST)。したがって、FECパケットのTS値は常に単調に増加する。

ペイロード・タイプ。FECパケットのペイロードタイプは、帯域外の動的な手段で決定される。RFC 3550 [1]によると、ペイロードタイプを認識できないRTP参加者は、それを破棄 しなければならない。これは下位互換性を提供する。その後、FECメカニズムは

は、FEC 対応受信機と FEC 非対応受信機が混在するマルチキャストグループで使用され、特に FEC 保護が冗長エンコーディングとして送信される場合 (セクション 14 参照) に使用されます。このような場合、FEC プロテクションは FEC 非対応受信機では認識できないペイロードタイプを持つことになり、無視されることになる。

7.3.FEC パケットの FEC ヘッダ
FECヘッダは10オクテットである。ヘッダのフォーマットは、図3に示すように、拡張フラグ（Eビット）、ロングマスクフラグ（Lビット）、P回復フィールド、X回復フィールド、CC回復フィールド、M回復フィールド、PT回復フィールド、SNベースフィールド、TS回復フィールド、長さ回復フィールドから構成されています。

    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |E|L|P|X|  CC   |M| PT recovery |            SN base            |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                          TS recovery                          |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |        length recovery        |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        
図3：FECヘッダー形式

E ビットは、本仕様に対する将来の拡張を示すために予約された拡張フラグである。0に設定するものとし、受信機では無視されるべきです。

Lビットはロングマスクを使用するか否かを示す。Lビットが設定されていない場合，マスクは16ビット長である。Lビットが設定された場合，マスクは48ビット長になる。

P回復フィールド、X回復フィールド、CC回復フィールド、M回復フィールド、PT回復フィールドは、FECパケットに関連付けられたメディアパケットのRTPヘッダーから対応するP、X、CC、M、PT値に適用される保護演算を介して取得されます。

SNベースフィールドには、FECで保護されたメディアパケット(すべてのレベル)のうち、折り返しを考慮した最小のシーケンス番号を設定しなければならない(MUST)。これにより、Lフィールドが0に設定された場合は最大16パケット、Lフィールドが1に設定された場合は48パケットなど、任意の文字列にFEC操作を拡張することができる。

TS回復フィールドは、このFECパケットに関連するメディアパケットのタイムスタンプに適用される保護操作を介して計算される。これにより、タイムスタンプを完全に回復することができる。

長さ回復フィールドは、回復されたパケットの長さを決定するために使用される。これは、このFECパケットに関連付けられた各メディアパケットのメディアペイロード、CSRCリスト、拡張、パディングの長さ（バイト単位）の合計の符号なしネットワーク順16ビット表現に適用される保護操作によって計算される（言い換えれば、メディアペイロードパケットのCSRCリスト、RTP拡張、パディングは、存在すればペイロードの一部として「カウント」される）。これにより、保護されたメディアパケットの長さが同一でない場合にも、FEC手順を適用することができる。例えば、2つのメディアパケットをxor結合してFECパケットを生成しているとする。2つのメディアパケットのペイロードの長さは、それぞれ3（0b011）バイトと5（0b101）バイトである。このとき、長さ回復フィールドは、0b011 xor 0b101 = 0b110 として符号化される。

7.4. FECパケットのFECレベルヘッダー
FEC レベルヘッダは 4 オクテットまたは 8 オクテット（FEC ヘッダの L ビットに依存）である。ヘッダのフォーマットを図 4 に示す。

FECレベルヘッダは、保護長フィールドとマスクフィールドから構成される。保護長フィールドは、16ビット長である。マスクフィールドは、16ビット長（Lビット非設定時）または48ビット長（Lビット設定時）である。

FECレベルヘッダのマスクフィールドは、どのパケットが現在のレベルのFECパケットに関連づけられるかを示す。L ビットの値によって、16 ビットまたは 48 ビットになります。マスクのビットiが1に設定されている場合、シーケンス番号N＋iのメディアパケットがこのFECパケットに関連付けられ、ここでNはFECパケットヘッダのSN Baseフィールドである。マスクの最上位ビットはi=0に対応し、最下位ビットは、Lビットが0に設定されている場合はi=15に、Lビットが1に設定されている場合はi=47に対応する。

    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |       Protection Length       |             mask              |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |              mask cont. (present only when L = 1)             |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        
図4：ULPレベルのヘッダー形式

マスクフィールドの設定は、以下の規則に従わなければならない。

a. メディアパケットは、レベル0よりも高い各保護レベルにおいて一度だけ保護されなけれ ばならない[SHALL]。メディアパケットは、異なるパケットによってレベル0で複数回保護してもよい(MAY)が、これらのパケットのレベル0の保護長が同じであることが条件である。

b. メディアパケットがレベルpで保護されるためには、どのFECパケットにおいてもレベルp-1で保護されなければならない(MUST)。メディアパケットの保護レベルpは、同じメディアパケットの保護レベルp-1を含むFECパケットとは異なるFECパケットにあることができることに留意してください。

c. ULP FECパケットがレベルpの保護を含む場合、それはレベルp-1の保護も含まなければならない(MUST)。レベルpで保護されるペイロードパケットの組み合わせは、レベルp-1のものと異なる可能性があることに注意すること。

ルール(a)の根拠は、多重保護は回復実装の複雑さを増すことである。より高いレベルでは、多重保護の利点は減少するので、その適用はより単純な実装のためにレベル0に制限される。ルール (b) の根拠は、(関連する各パケットの) 保護オフセットがプロトコル内で明示的に信号化されないことである。この制限により、オフセットは各レベルの保護長から容易に差し引くことができる。規則(c)の根拠は、保護レベルが明示的に示されていないことである。本ルールは、暗黙のうちにレベルを指定するように設定されている。

保護機能の組み合わせの一例を、以下の図5に示す。これは図1に示したものと同じ例である。この同じ例も、ヘッダーのフィールドがどのように設定されるかを説明するために、セクション10.2でより詳細に示されている。

         Packet A          #####################
                                  :        :
         Packet B          ############### :
                                  :        :
         ULP FEC Packet #1 @@@@@@@@        :
                                  :        :
         Packet C          ###########     :
                                  :        :
         Packet D          ###################################
                                  :        :
         ULP FEC Packet #2 @@@@@@@@@@@@@@@@@
                           :      :        :
                           :<-L0->:<--L1-->:

         Payload packet #  |  ULP FEC packet that protects at level
                           |          L0             L1
      ---------------------+---------------------------------------
                A          |          #1             #2
                B          |          #1             #2
                C          |          #2             #2
                D          |          #2             #2
        
図5：保護の組み合わせの例

この例では、ULP FEC packet #1 は保護レベル 0 のみを持っています。表から読み取ると、ペイロードパケットAはレベル0のULP FECパケット#1、レベル1のULP FECパケット#2によって保護されていることがわかる。また、ULP FEC packet #2 は、レベル 0 のペイロードパケット C と D、レベル 1 のペイロードパケット A-D などを保護していることが表から容易に読み取れます。より詳細な他の例については、第10章「例」を参照してください。

各レベルのULP FECパケットのペイロードは、そのレベルのULP FECパケットに関連するメディアペイロードとメディアパケットのパディングに適用される保護操作（XOR）である。詳細は、保護演算のセクション8で説明する。

ULP FECパケットのサイズは、保護動作のために選択された保護長によって決定される。上記の例では、ULP FECパケット#1は長さL0(とヘッダオーバーヘッド)である。2レベルのULP FECパケット#2は、長さL0+L1(+ヘッダオーバーヘッド)を有する。これは、それが保護するいくつかのパケット(この例ではパケットBとC)より長く、それが保護するいくつかのパケット(この例ではパケットAとD)より短い。

FECパケット(非ULPおよびULP)は、ヘッダのオーバーヘッドやULPに大きな保護長が選択された場合、それが保護する最長のメディアパケットより大きくなる可能性があることに注意してください。その結果、FECパケットが送信されるパスの最大送信単位サイズを超えることになると、問題が生じる可能性があります。

8.保護操作
FECパケットは、保護メディアRTPパケットのデータから生成される「FECビット列」 から形成される。より具体的には、FECビット列は、保護メディアRTPパケットの「保護ビット列」のビット単位の排他的論理和となる。

保護操作のために、以下の手順に従ってもよい(MAY)。他の手順を使用してもよいが、最終結果はここで説明したものと同じでなければならない(MUST)。

8.1. FECヘッダーの生成
FEC ヘッダの場合、FEC レベル 0 で保護するメディアパケット毎に保護ビット列（80 ビット長）を生成する。これは、以下のフィールドを指定された順に連結することで形成される。

o RTPヘッダーの最初の64ビット（64bit）。

o バイト単位のメディアパケット長から12(固定RTPヘッダーの場合)を引いた、符号なし ネットワーク順の16ビット表現、すなわち、CSRCリスト、拡張ヘッダー、RTPペイロード、RTPパディングが存在する場合はその長さの合計(16ビット)。

保護ビット列にパリティ演算を施して FEC ビット列を形成した後、FEC ビット列から以下のように FEC ヘッダを生成する。

FEC ビット列の最初の（最上位の）2 ビットはスキップされる。
FEC パケットの FEC ヘッダの P リカバリビットには、FEC ビット列の次のビットが書き込まれる。
FEC ビット列の次のビットが FEC ヘッダーの E リカバリビットに書き込まれる。
FECビット列の次の4ビットは、FECヘッダーのCCリカバリーフィールドに書き込まれる。
次のビットは、FECヘッダーのMリカバリービットに書き込まれる。
FEC ビットストリングの次の 7 ビットは、FEC ヘッダーの PT リカバリフィールドに書き込まれる。
次の16ビットはスキップされる。
FECヘッダーのTSリカバリーフィールドに、FECビット列の次の32ビットが書き込まれる。
次の16ビットはパケットヘッダの長さ回復フィールドに書き込まれる。

8.2.FEC ペイロードの生成
FECペイロードを生成する場合、保護ビット列は、単に保護されたRTPパケットである。したがって、FECビット列は、これらの保護されたメディアRTPパケットのビット毎排他的論理和 (bitwise exclusive OR)である。保護されたペイロードパケットのグループは各レベルで異なる可能性があるため、このようなFECビット列は各レベルで生成される必要がある。保護されたRTPパケットの長さが等しくない場合、各短いパケットは、末尾にオクテット 0を追加して、最長パケットの長さにパディングされなければならない[MUST]。

保護レベル n（n=0、1、...）の場合、レベル n の ULP ヘッダの後に、FEC レベル n ペイロードデータとして Ln オクテットのデータのみが設定される。このデータは、FEC ビット列の（Sn＋13）番目のオクテットから始まる Ln オクテットのデータであ る。

Sn = sum(Li : 0 <= i < n).

Li はレベル i の保護長、S0 は 0 と定義される。最初の 12 オクテットを省略する理由は、その情報は既に FEC ヘッダーで保護されているからである。

9.復旧の手順
FECパケットにより、エンドシステムはメディアパケットの損失から回復することができます。このセクションでは、このリカバリーを行うための手順について説明します。

リカバリーには、2つの異なる操作が必要です。1つ目は、失われたパケットを復元するために、どのパケット（メディアとFEC）を組み合わせなければならないかを決定することです。これが完了したら、2 番目のステップは実際にデータを再構築することです。第二段階は、以下に説明するように実行されなければならない(MUST)。最初のステップは、実装者によって選択されたどのようなアルゴリズムに基づいてもよい(MAY)。異なるアルゴリズムは、複雑さと、可能であれば欠落したパケットを復元する能力との間のトレードオフをもたらす。

失われたペイロードパケットは、不等誤り保護（使用されている場合）の性質上、データ損失の状況に応じて、完全または部分的に回復されることがある。パケットの部分的な回復は、FECヘッダーから取得したパケットの回復長を、回復したペイロードデータの実際の長さと照合することで検出することができる。

9.1.RTPヘッダーの再構築
レベル0であるメディアパケットxiを回復するために組み合わせることができるパケット（FECとメディア）のリストをTとする。その手順は次の通りである。

1.Tのメディアパケットについて、前節のFECヘッダの生成のために説明した手順に従って、保護ビット列の最初の80ビットを計算する。

2.TのFECパケットの場合、FECビット列は80ビットのFECヘッダである。

3.Tのすべてのメディアパケットから生成された保護ビット列と、TのすべてのFECパケットから生成されたFECビット列のビットごとの排他的論理和として、回復ビット列を計算する。

4.標準の12バイトのRTPヘッダとペイロードのない新しいパケットを作成します。

5.新しいパケットのバージョンを2に設定する。 回復ビット列の最初の2ビットをスキップする。

6.新しいパケットのPaddingビットを回復ビット列の次のビットに設定する。

7.新しいパケットのExtensionビットを回復ビット列の次のビットに設定する。

8.CCフィールドにリカバリービット列の次の4ビットを設定する。

9.新しいパケットのマーカビットを回復ビット列の次のビットに設定する。

10.新しいパケットのペイロードタイプを、回復ビット列の次の7ビットに設定する。

11.新しいパケットのSNフィールドをxiに設定する。回復ビット列の次の16ビットをスキップする。

12.新しいパケットのTSフィールドに、回復ビット列の次の32ビットを設定する。

13.回復ビット列の次の16ビットを取り出す。これがどのような符号なし整数であっても(ネットワーク順と仮定)、回復ビット列からそのバイト数を取り出し、新しいパケットに追加する。これは、CSRCリスト、拡張、ペイロード、RTPペイロードのパディングを表す。

14.新しいパケットのSSRCを、それが保護しているメディアストリームのSSRC、すなわち、FECストリームが関連付けられているメディアストリームのSSRCに設定する。

この手順では、RTPパケットのSSRCフィールドまでのヘッダを復元する。

9.2.RTPペイロードの再構築
あるメディアパケットxiをある保護レベルで回復するために組み合わせることができるパケット（FECとメディア）のリストをTとする。その手順は以下の通りである。

1.レベルnのデータを再構築すると仮定すると、まずレベルnのULPヘッダからレベルnの保護長（Ln）を求める。

2.TのFECパケットについて、レベルnのFECビット列は、FECレベルnペイロード、すなわち、レベルnのULPヘッダに続くLnオクテットのデータである。

3.Tのメディアパケットについて、レベルnの保護ビット列は、パケットの（Sn＋13）番目のオクテットから始まるLn個のオクテットのデータである。Snは、8.2節で定義したものと同じである。レベル0の保護は、メディアパケットのSSRCフィールドの後の13番目のオクテットから始まることに注意すること。最初の 12 オクテットの情報は、FEC ヘッダによって保護される。

4.メディアパケットから生成されたレベルnの保護ビット列のいずれかが、現在のレベルの保護長より短い場合、その長さにパディングする。ビット列の最後には、オクテット0のパディングを付加しなければならない(MUST)。

5.Tの全てのメディアパケットから生成されたレベルnの保護ビット列と、Tの全てのFECパケットから生成されたレベルnのFECビット列とのビットごとの排他的論理和として、回復ビット列を計算する。

6.上記で生成された現在の保護レベルの回復ビット列は、他のすべてのレベルの回復ビット列と連結することによって結合され、(完全または部分的に)回復したメディアパケットを形成する。各保護レベルの回復ビット列は、保護長の設定に基づいて、そのレベルの回復メディアパケット内の正しい位置に配置されなければならない(MUST)ことに注意すること。

7.回復メディアパケットの保護レベル0での回復操作から、回復メディアパケットの全長が回復される。この情報は、（全レベルの）完全な回復操作がパケットを全長に回復させたかどうかを確認するために使用することができます。

下位の保護レベルで保護されたデータは、上位の保護データが回復可能であれば、 大半のケースで回復可能である。この手順(下位保護レベルの手順と合わせて)は、通常、現在のレベルの保護長ま で、RTPパケットのヘッダーとペイロードの両方を回復する。

10.事例紹介
以下の最初の2つの例(セクション10.1および10.2)では、セクション14.1の説明 に従って、FECストリームを別のRTPセッションで送信すると想定している。これらの例では、SSRC 2からA、B、C、Dの4つのメディアパケットを送信すると想定する。
それらのシーケンス番号はそれぞれ8、9、10、11であり、
タイムスタンプはそれぞれ3、5、7、9である。
パケットAとCはペイロードタイプ11を、パケットBとDはペイロードタイプ18を使用している。
パケットAは200バイト、パケットBは140バイト、パケットCは100バイト、パケットDは340バイトのペイロードを持つ。パケット A と C にはマーカビットが設定されている。

第3の例（10.3項）は、FECデータをペイロードパケットと一緒に冗長データとして送信する場合について説明するものである。

10.1.RFC2733と同様の保護を提供する例
1つのFECパケットで4つのペイロードパケットを1つのレベルで全長保護することができる。これはRFC2733と同様の保護を提供する。図6に示すようなスキームです。

                    +-------------------+             :
         Packet A   |                   |             :
                    +-------------+-----+             :
         Packet B   |             |                   :
                    +---------+---+                   :
         Packet C   |         |                       :
                    +---------+-----------------------+
         Packet D   |                                 |
                    +---------------------------------+
                                                      :
                    +---------------------------------+
         Packet FEC |                                 |
                    +---------------------------------+
                    :                                 :
                    :<------------- L0 -------------->: 
図6：1レベルプロテクションを用いたFEC方式

この4つのパケットからFECパケットが生成される。FECパケットを示すために、ペイロードタイプ127が使用されると仮定する。結果として、図7に示すようなRTPヘッダが生成される。

FECパケット内のFECヘッダを図8に示す。

レベル 0 の FEC レベルヘッダを図 9 に示す。

    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |1 0|0|0|0 0 0 0|0|1 1 1 1 1 1 1|0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1|
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 1|
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0|
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

      Version:   2
      Padding:   0
      Extension: 0
      Marker:    0
      PT:        127
      SN:        1
      TS:        9
      SSRC:      2

図7：FECパケットのRTPヘッダ

    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |0|0|0|0|0 0 0 0|0|0 0 0 0 0 0 0|0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0|
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0|
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |0 0 0 0 0 0 0 1 0 1 1 1 0 1 0 0|
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

      E:         0     [this specification]
      L:         0     [short 16-bit mask]
      P rec.:    0     [0 XOR 0 XOR 0 XOR 0]
      X rec.:    0     [0 XOR 0 XOR 0 XOR 0]
      CC rec.:   0     [0 XOR 0 XOR 0 XOR 0]
      M rec.:    0     [1 XOR 0 XOR 1 XOR 0]
      PT rec.:   0     [11 XOR 18 XOR 11 XOR 18]
      SN base:   8     [min(8,9,10,11)]
      TS rec.:   8     [3 XOR 5 XOR 7 XOR 9]
      len. rec.: 372   [200 XOR 140 XOR 100 XOR 340]

図8：FECパケットのFECヘッダ

    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |0 0 0 0 0 0 0 1 0 1 0 1 0 1 0 0|1 1 1 1 0 0 0 0 0 0 0 0 0 0 0 0|
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

      L0:        340   [the longest of 200, 140, 100, and 340]
      mask:      61440 [with Bits 1, 2, 3, and 4 marked accordingly for
                        Packets 8, 9, 10, and 11]

レベル 0 のペイロード長は 340 バイトである。

図 9：FEC レベルヘッダ（レベル 0）

10.2.2つの保護レベルを持つ例
より複雑な例として、FEC を 2 つのレベルで使用することができます。レベル 0 の FEC は、ペイロードパケットの最初の部分により大きな保護を提供します。レベル 1 の FEC は、パケットの残りの部分に追加の保護を適用する。これは図 10 に示されている。この例では、L0 = 70、L1 = 90です。

              +------:--------:---+
   Packet A   |      :        :   |
              +------:------+-:---+
   Packet B   |      :      | :
              +------:--+---+ :
                     :        :
              +------+        :
   ULP #1     |      |        :
              +------+        :
                     :        :
              +------:--+     :
   Packet C   |      :  |     :
              +------:--+-----:-----------------+
   Packet D   |      :        :                 |
              +------:--------:-----------------+
                     :        :
              +------:--------+
   ULP #2     |      :        |
              +------:--------+
              :      :        :
              :<-L0->:<--L1-->:

図10：保護レベル0とレベル1を持つULP FECスキーム

これにより、#1 と#2 の2つのFECパケットが生成されます。

その結果、ULP FECパケット#1は、図11に示すようなRTPヘッダを持つことになる。ULP FECパケット#1のFECヘッダは、図12に示すようになる。レベル0 ULPヘッダは、図13に示すように、#1 のためのものである。

    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |1 0|0|0|0 0 0 0|1|1 1 1 1 1 1 1|0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1|
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 1|
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0|
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

      Version:   2
      Padding:   0
      Extension: 0
      Marker:    1
      PT:        127
      SN:        1
      TS:        5
      SSRC:      2

図11：FECパケット#1のRTPヘッダ

    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |0|0|0|0|0 0 0 0|0|0 0 1 1 0 0 1|0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0|
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 0|
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |0 0 0 0 0 0 0 0 0 1 0 0 0 1 0 0|
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

      E:         0     [this specification]
      L:         0     [short 16-bit mask]
      P rec.:    0     [0 XOR 0 XOR 0 XOR 0]
      X rec.:    0     [0 XOR 0 XOR 0 XOR 0]
      CC rec.:   0     [0 XOR 0 XOR 0 XOR 0]
      M rec.:    0     [1 XOR 0 XOR 1 XOR 0]
      PT rec.:   25    [11 XOR 18]
      SN base:   8     [min(8,9)]
      TS rec.:   6     [3 XOR 5]
      len. rec.: 68    [200 XOR 140]
   
図 12: ULP FEC Packet #1 の FEC Header

    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |0 0 0 0 0 0 0 0 0 1 0 0 0 1 1 0|1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0|
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

      L0:        70
      mask:      49152 [with Bits 1 and 2 marked accordingly for
                        Packets 8 and 9]

レベル 0 のペイロード長は 70 バイトである。

       図13：FECパケット#1のFECレベルヘッダー(レベル0)        
その結果、FECパケット#2は、図14に示すようなRTPヘッダを持つことになる。FECパケット#2のFECヘッダは、図15に示すようになる。また、＃2のレベル0ULPヘッダは、図16に示すようになる。のレベル1ULPヘッダは、図17に示すようになる。

    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |1 0|0|0|0 0 0 0|1|1 1 1 1 1 1 1|0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0|
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 1|
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0|
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

      Version:   2
      Padding:   0
      Extension: 0
      Marker:    1
      PT:        127
      SN:        2
      TS:        9
      SSRC:      2


図14：FECパケット#2のRTPヘッダー

    
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |0|0|0|0|0 0 0 0|0|0 0 1 1 0 0 1|0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0|
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 1 0|
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |0 0 0 0 0 0 0 1 0 0 1 1 0 0 0 0|
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

      E:         0     [this specification]
      L:         0     [short 16-bit mask]
      P rec.:    0     [0 XOR 0 XOR 0 XOR 0]
      X rec.:    0     [0 XOR 0 XOR 0 XOR 0]
      CC rec.:   0     [0 XOR 0 XOR 0 XOR 0]
      M rec.:    0     [1 XOR 0 XOR 1 XOR 0]
      PT rec.:   25    [11 XOR 18]
      SN base:   8     [min(8,9,10,11)]
      TS rec.:   14    [7 XOR 9]
      len. rec.: 304   [100 XOR 340]

図15：FECパケット#2のFECヘッダ

    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |0 0 0 0 0 0 0 0 0 1 0 0 0 1 1 0|0 0 1 1 0 0 0 0 0 0 0 0 0 0 0 0|
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

      L0:        70
      mask:      12288 [with Bits 3 and 4 marked accordingly for
                        Packets 10 and 11]

レベル 0 のペイロード長は 70 バイトである。

    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |0 0 0 0 0 0 0 0 0 1 0 1 1 0 1 0|1 1 1 1 0 0 0 0 0 0 0 0 0 0 0 0|
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

      L1:        90
      mask:      61440 [with Bits 1, 2, 3, and 4 marked accordingly for
                        Packets 8, 9, 10, and 11]

レベル 1 のペイロード長は 90 バイトである。

       図17：FECパケット#2のFECレベルヘッダ(レベル1)        

10.3.FECを冗長符号化した例
この例では、ペイロードと同じストリームで冗長な符号化として送信されるFECを説明する。SSRC2からA、B、C、D、Eの5つのメディアパケットが送信されると仮定する。それらのシーケンス番号はそれぞれ8、9、10、11、12であり、タイムスタンプはそれぞれ3、5、7、9、11である。メディアデータはすべて一次符号化（および冗長符号化は一次符号化のみを保護するためFEC）され、ペイロードタイプ11が使用されています。パケットAは200バイト、パケットBは140、パケットCは100、パケットDは340、パケットEは160のペイロードを持つ。パケット A と C にはマーカビットが設定されています。

使用する FEC 方式は、10.1 節の図 6 に示すように、1 レベルとする。保護長 L0 = 340 オクテットとする。

冗長符号化パケット化は、ペイロードタイプ100で使用される。FECのペイロードタイプは127であるとする。最初の4つのREDパケット、RED＃1〜RED＃4は、それぞれ個別のメディアパケット、A、B、C、またはDを含む。最初の4つのメディアパケット内のメディアデータを保護するFECデータが生成される。5番目のパケットであるRED＃5には、メディアパケットEとともに、このFECデータが冗長符号化として含まれている。

   RED Packet #1:    Media Packet A
   RED Packet #2:    Media Packet B
   RED Packet #3:    Media Packet C
   RED Packet #4:    Media Packet D
   RED Packet #5:    FEC Packet, Media Packet E
    
REDパケット#1〜#4は、図18に示すような構造になる。REDパケット#1のRTPヘッダは図19に示すとおりであり、他のすべてのREDパケットも同様の形式で、対応するシーケンス番号とタイムスタンプが付されている。REDパケットの一次エンコードブロックヘッダは、図20に示すとおりである。

   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                 RTP Header (RED) - 6 octets                   |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |        Primary Encoding Block Header (RED) - 1 octet          |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                      Media Packet Data                        |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

図18：REDパケット構造 - メディアデータのみ

    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |1 0|0|0|0 0 0 0|0|1 1 0 0 1 0 0|0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1|
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 1|
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0|
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

      Version:   2
      Padding:   0
      Extension: 0
      Marker:    0     [Even though media packet A has marker set]
      PT:        100   [Payload type for RED]
      SN:        1
      TS:        5
      SSRC:      2

               Figure 19: RTP Header of RED Packet #1

    0 1 2 3 4 5 6 7
   +-+-+-+-+-+-+-+-+
   |0|0 0 0 1 0 1 1|
   +-+-+-+-+-+-+-+-+

      F bit:     0     [This is the primary coding data]
      Block PT:  11    [The payload type of media]


図 20：一次エンコードブロックヘッダ

FECデータは、REDパケットから直接生成されるのではなく、メディアパケットデータを含む仮想RTPパケットから生成される。仮想RTPパケットは、冗長コーディングが含まれる場合と含まれない場合の両方で、REDパケットから非常に簡単に生成することができる。REDパケットから仮想RTPパケットへの変換は、（1）REDブロックヘッダと冗長符号化データをすべて削除し、（2）RTPヘッダのPTを一次符号化のPTに置き換えることで簡単に行うことができる。

注）RFC2198で規定されている冗長符号化のペイロードフォーマットでは、REDパケットで一次符号化を行った時点でマーカビットが失われます。そのため、FECの使用有無にかかわらず、マーカビットは回復できない。

前述のように、REDパケット＃5には、FECデータ（メディアパケットA、B、C、Dを保護するデータ）とメディアパケットEのデータが含まれる。REDパケット＃5の構造は、図21に示すとおりである。

   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                 RTP Header (RED) - 6 octets                   |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |       Redundant Encoding Block Header (RED) - 4 octets        |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                        FEC Packet Data                        |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |        Primary Encoding Block Header (RED) - 1 octet          |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                       Media Packet Data                       |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

図21：REDパケット構造 - FECデータあり

FECを含むREDパケットのRTPヘッダは、図19と同じで、シーケンス番号とタイムスタンプが対応する。

REDパケット＃5では、FECパケットデータブロックの冗長符号化ブロックヘッダは、図22に示すように、以下のようになる。これに続いて、FECパケットデータ、この場合、FECヘッダ（図8に示すように10オクテット）、ULPレベル0ヘッダ（図9に示すように4オクテット）、ULPレベル0データ（レベル0に設定されているように340オクテット）が含まれることになる。これらに続いて、メディアパケットEのデータを含む一次符号化ブロックが配置される。

    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |1|1 1 1 1 1 1 1|0 0 0 0 0 0 0 0 0 0 0 0 0 0|0 1 0 1 1 0 0 0 1 0|
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

      F bit:     1     [This is the redundant coding data]
      Block PT:  127   [The dynamic payload type for FEC]
      TS Offset: 0     [The instance at which the FEC data is
                        transmitted]
      Block Len: 354   [FEC header (10 octets) plus ULP level 0 header
                        (4 octets) and ULP level 0 data (340 octets)]

図 22：冗長エンコードブロックヘッダ

11.セキュリティに関する考察
セキュアな通信において、暗号化とともにFECを使用する方法には、すでに暗号化されたペイロードにFECを適用する方法と、暗号化の前にFECを適用する方法の2通りがある。最初のケースは、メディアデータが暗号化された後、送信中に信頼できないノードによってFECが必要とされる場合に遭遇する。2つ目のケースは、メディアデータが安全なトランスポートで送信される前に、FECによって保護される場合である。

このFECの保護されたペイロードはRTPパケットであるため、暗号化されたペイ ロードのFEC適用は、主にセキュアRTP(SRTP)[13]の場合に適用可能であ る。FECはペイロードにXORを適用するため、FECパケットは、元のペイロードと同 じように暗号的に安全であるべきである。この場合、FECパケットの追加的な暗号化は必要ない。

以下の議論では、暗号化の前にペイロードにFECが適用されることを想定している。FECの使用は、暗号化のための鍵の使用と変更に影響を与える。FECパケットは個別のストリームで構成されているため、暗号化の使用にはいくつかの組み合わせがある。以下のようなものがある。

o FECストリームは暗号化されるかもしれないが、メディアストリームは暗号化され ない。

o メディアストリームは暗号化されるかもしれないが、FECストリームは暗号化されない。

o メディアストリームとFECストリームの両方が暗号化されているが、同じキーを使用している。

o メディアストリームとFECストリームは共に暗号化されているが、異なるキーを使用している。

最初の3つは、使用するすべてのアプリケーションレベルのシグナリング プロトコルがFECの使用を認識し、メディアとFECストリームで別々にキーを交換 し、暗号化の使用をネゴシエートすることが必要になる。最後のケースでは、そのような追加のメカニズムは必要ない。ULP FECパケットは他のRTPパケットと同様に扱われるべきであるため、最初の2 つのケースはレイヤー違反となる。また、1つのストリームだけを暗号化すると、特定の既知のプレーンテキスト 攻撃を可能にする可能性がある。このような理由から、暗号化を使用するアプリケーションは、両方のスト リームを暗号化すべきである[SHOULD](つまり、最後の2つのオプション)。

さらに、特定の暗号では、メディアペイロードとFECデータの間の既知の関係 によって、暗号化が弱められる可能性があるため、メディアペイロードとFEC データを別々のストリームで送信する場合、ストリームごとに異なる暗号化キー を使用しなければならない[MUST]。RTPセッションのセキュリティにSRTP [13]を使用する場合、SRTP仕様に よって、各RTPセッションに異なるキーが必要である、ということに注意し てほしい。

暗号鍵の変更も重要な問題であり、対処が必要である。2つのパケットa、bが、それらを保護するFECパケットとともに送信される場合を考えてみましょう。aとbの暗号化に使用した鍵は異なるので、FECパケットの復号にはどちらの鍵を使用すべきでしょうか。一般に、古い鍵はキャッシュしておく必要があります。メディアストリームの鍵が変わったとき、ULP FECパケットの鍵も変わったと判断されるまで、古い鍵を使うことができるからです。さらに、新しい鍵は、古い鍵と新しい鍵で暗号化されたペイロードパケットの組み合わせから生成されるFECパケットを暗号化するために使用されるべきである(SHOULD)。送信者と受信者は、どのように暗号化が行われ、どのように鍵が使われるかを定義する必要がある。

FEC データとパケットの改変は、再構成動作に大きな影響を与える可能性がある。FECデータの一部のビットを変更する攻撃は、ペイロードパケットの計算と復元に大きな影響を与える可能性があります。例えば、長さ回復フィールドを変更すると、長すぎるパケットを回復することになります。また、リカバリーの計算複雑度は、少なくとも1桁まで容易に影響を与えることができる。アプリケーションのシナリオによっては、リカバリ動作を行う前に、受信したペイロードデータとFECデータのサニティチェックを行い、リカバリ動作から回復したデータの有効性を判断してから使用すると便利な場合があります。

12.混雑の考慮
FEC を使用する際のもう一つの問題は、ネットワーク輻輳への影響です。多くの場合、ネットワークでのパケットロスは、輻輳によって引き起こされます。このような状況では、ネットワーク損失の増加に遭遇したときに FEC を追加することは避けなければなりません。もし、それが

が広く使用されると、輻輳の増加や最終的な輻輳の崩壊につながる可能性があります。アプリケーションにはより強力な保護機能を含めると同時に、ペイロードパケッ トの帯域幅を縮小することもできる。いずれにせよ、実装は、ネットワーク損失の増加に伴い、使用中の総帯域 幅(ペイロードとFECを含む)を大幅に増加させてはならない[MUST NOT]。

RTP [1]および適用可能なRTPプロファイル(たとえば、RTP/AVP [14])を参照。ベストエフォート型サービスを使用する場合の追加要件は、このペイロード形式 のユーザーは、パケットロス率が許容パラメータ内にあることを確認するた めに、パケットロスを監視しなければならない[MUST]ということである。同じネットワークパスを通過し、同じネットワーク条件を経験するTCPフ ローが、妥当なタイムスケールで測定した平均スループットを達成し、RTPフロー の達成値を下回らない場合、パケットロスは許容可能と見なされる。この条件は、伝送レート(またはレイヤーマルチキャストセッションにサブスクライブ したレイヤーの数)を調整する輻輳制御メカニズムを実装するか、損失率が受 容できないほど高い場合に受信者がセッションを離れるように手配することで満たすこ とができる。

13.IANA の検討事項
このセクションで説明するように、4つの新しいメディアサブタイプがIANAに登録されました。この登録は、登録テンプレート[3]を使用し、RFC 3555[4]に従って行われます。

13.1.audio/ulpfecの登録
型名：オーディオ

サブタイプ名：ulpfec

必要なパラメータ。

レート。レート: 別ストリームのFECパケットの送信時刻をマークするために使用されるRTPタイムスタンプレート。別のストリームに冗長データとして送信される場合、レートは、保護するために使用する主エンコーディングと同じにしなければならない(SHALL)。別のストリームで使用する場合、RTCPの動作に十分な解像度を提供するため、レートは 1000Hzより大きくしなければならない[SHALL]。選択されたレートは、1000 Hz以上のどのような値でもよい[MAY]が、このストリー ムが保護するメディアのレートに合わせることが推奨される[RECOMMENDED]。

オプションのパラメータ。

onelevelonly。1つのFEC保護レベルのみを使用するかどうかを指定する。許容される値は0と1である。 1が通知された場合、ストリームでは1つのレベルのFEC保護のみを使用しなければならない(SHALL)。0を指定した場合、複数のFEC保護レベルを使用してもよい（MAY）。省略した場合は、デフォルト値である0を持つ。

エンコーディングの考慮点このフォーマットはフレーム化されており (テンプレート文書 [3] のセクション 4.8 参照)、バイナリデータを含む。

セキュリティの考慮事項RFC5109に詳述されているように、これらのメディアタイプ登録に は、それらのためのペイロードと同じセキュリティの考慮事項が適用され る。

相互運用性についての考慮事項：なし

公開されている仕様です。RFC 5109

このメディアタイプを使用するアプリケーション。メディアストリームに追加データを送信することで、損失に対する回復力を向上させようとするマルチメディアアプリケーション。

その他の情報：なし

お問い合わせ先担当者＆メールアドレスAdam Li adamli@hyervision.com IETF Audio/Video Transport Working Group

想定される使用方法コモン

使用上の制限このメディアタイプはRTPフレーミングに依存するため、RTP [1]を介した転送のために のみ定義されている。これはRTPの堅牢性メカニズムであるため、他のフレーミン グプロトコルでの伝送は定義してはならない[SHALL NOT]。

著者アダム・リー adamli@hyervision.com

変更コントローラ：IESGから委任されたIETF Audio/Video Transport Working Group。

13.2.ビデオ/ULPFECの登録
タイプ名：ビデオ

サブタイプ名：ulpfec

必要なパラメータ。

レート。レート: 別ストリームのFECパケットの送信時刻をマークするために使用されるRTPタイムスタンプレート。別のストリームに冗長データとして送信される場合、レートは、保護するために使用される主エンコーディングと同じでなければならない[SHALL]。別のストリームで使用する場合、RTCPの動作に十分な解像度を提供するために、レートを 1000Hzより大きくしなければならない[SHALL]。選択されたレートは、1000Hz以上のどのような値でも構わないが、このストリームが 保護するメディアのレートと一致させることが推奨される[RECOMMENDED]。

オプションのパラメータです。

onelevelonly。1つのFEC保護レベルのみを使用するかどうかを指定する。許容される値は0と1である。 1が通知された場合、ストリームでは1つのレベルのFEC保護のみを使用しなければならない(SHALL)。0を指定した場合、複数のFEC保護レベルを使用してもよい（MAY）。省略した場合は、デフォルト値である0を持つ。

エンコーディングの考慮点このフォーマットはフレーム化されており (テンプレート文書 [3] のセクション 4.8 参照)、バイナリデータを含む。

セキュリティの考慮事項RFC5109に詳述されているように、これらのメディアタイプ登録に は、それらのためのペイロードと同じセキュリティの考慮事項が適用され る。

相互運用性についての考慮事項：なし

公開されている仕様です。RFC 5109

このメディアタイプを使用するアプリケーション。メディアストリームに追加データを送信することで、損失に対する回復力を向上させようとするマルチメディアアプリケーション。

その他の情報：なし

お問い合わせ先担当者＆メールアドレスAdam Li adamli@hyervision.com IETF Audio/Video Transport Working Group

想定される使用方法コモン

使用上の制限このメディアタイプはRTPフレーミングに依存するため、RTP [1]を介した 転送のためにのみ定義されている。これはRTPの堅牢性メカニズムであるため、他のフレーミン グプロトコルでの転送は定義してはならない[SHALL NOT]。

著者アダム・リー adamli@hyervision.com

変更コントローラ：IESGから委任されたIETF Audio/Video Transport Working Group。

13.3.テキスト/ulpfecの登録
型名：text

サブタイプ名：ulpfec

必要なパラメータ。

レート。レート: 別ストリームのFECパケットの送信時刻をマークするために使用されるRTPタイムスタンプレート。別のストリームに冗長データとして送信される場合、レートは、保護するために使用される主エンコーディングと同じでなければならない[SHALL]。別のストリームで使用する場合、RTCPの動作に十分な解像度を提供するために、レートを 1000Hzより大きくしなければならない[SHALL]。選択されたレートは、1000Hz以上のどのような値でも構わないが、このストリームが 保護するメディアのレートと一致させることが推奨される[RECOMMENDED]。

オプションのパラメータ。

onelevelonly。1つのFEC保護レベルのみを使用するかどうかを指定する。許容される値は0と1である。 1が通知された場合、ストリームでは1つのレベルのFEC保護のみを使用しなければならない(SHALL)。0を指定した場合、複数のFEC保護レベルを使用してもよい（MAY）。省略した場合は、デフォルト値である0を持つ。

エンコーディングの考慮点このフォーマットはフレーム化されており (テンプレート文書 [3] のセクション 4.8 参照)、バイナリデータを含む。

セキュリティの考慮事項RFC5109に詳述されているように、これらのメディアタイプ登録に は、それらのペイロードと同じセキュリティの考慮事項が適用される。

相互運用性についての考慮事項：なし

公開されている仕様です。RFC 5109

このメディアタイプを使用するアプリケーション。メディアストリームに追加データを送信することで、損失に対する回復力を向上させようとするマルチメディアアプリケーション。

その他の情報：なし

お問い合わせ先担当者＆メールアドレスAdam Li adamli@hyervision.com IETF Audio/Video Transport Working Group

想定される使用方法コモン

使用上の制限このメディアタイプはRTPフレーミングに依存するため、RTP [1]を介した 転送のためにのみ定義されている。これはRTPの堅牢性メカニズムであるため、他のフレーミン グプロトコルでの転送は定義してはならない[SHALL NOT]。

著者アダム・リー adamli@hyervision.com

変更コントローラ：IESGから委任されたIETF Audio/Video Transport Working Group。

13.4.アプリケーションの登録/ULPFEC
タイプ名：アプリケーション

サブタイプ名：ulpfec

必要なパラメータ。

レート。レート: 別ストリームのFECパケットの送信時刻を示すために使用されるRTPタイムスタンプレート。別のストリームに冗長データとして送信される場合、レートは、保護するために使用される主エンコーディングと同じでなければならない[SHALL]。別のストリームで使用する場合、RTCPの動作に十分な解像度を提供するために、レートを 1000Hzより大きくしなければならない[SHALL]。選択されたレートは、1000Hz以上のどのような値でも構わないが、このストリームが 保護するメディアのレートと一致させることが推奨される[RECOMMENDED]。

オプションのパラメータです。

onelevelonly。1つのFEC保護レベルのみを使用するかどうかを指定する。許容される値は0と1である。 1が通知された場合、ストリームでは1つのレベルのFEC保護のみを使用しなければならない(SHALL)。0を指定した場合、複数のFEC保護レベルを使用してもよい（MAY）。省略した場合は、デフォルト値である0を持つ。

エンコーディングの考慮点このフォーマットはフレーム化されており (テンプレート文書 [3] のセクション 4.8 参照)、バイナリデータを含む。

セキュリティの考慮事項RFC5109に詳述されているように、これらのメディアタイプ登録に は、それらのペイロードと同じセキュリティの考慮事項が適用される。

相互運用性についての考慮事項：なし

公開されている仕様です。RFC 5109

このメディアタイプを使用するアプリケーション。メディアストリームに追加データを送信することで、損失に対する回復力を向上させようとするマルチメディアアプリケーション。

その他の情報：なし

お問い合わせ先担当者＆メールアドレスAdam Li adamli@hyervision.com IETF Audio/Video Transport Working Group

想定される使用方法コモン

使用上の制限このメディアタイプはRTPフレーミングに依存するため、RTP [1]を介した 転送のためにのみ定義されている。これはRTPの堅牢性メカニズムであるため、他のフレーミン グプロトコルでの転送は定義してはならない[SHALL NOT]。

著者アダム・リー adamli@hyervision.com

変更コントローラ：IESGから委任されたIETF Audio/Video Transport Working Group。

14.FECの多重化
FECパケットは、主に2つの方法（別個のストリームとして、または冗長エンコーディングとして同じストリームとして）で保護されたペイロードと共に受信機に送信することができる。設定オプションは、帯域外に示されなければならない（MUST）。このセクションでは、RFC2327[8]で規定されているセッション記述 プロトコル(SDP)を使用して、この方法を実現する方法についても記述す る。

14.1.別ストリームとしてのFEC
FECパケットを別ストリームで送信する場合、いくつかの情報を伝達する必要があります。

o FECの送信先のアドレスとポート

o FEC のペイロードタイプ番号

o FECが保護するメディアストリーム

FECには静的なペイロードタイプの割り当てがないため、動的なペイロードタイプ番号を使用しな ければならない[MUST]。FECストリームのSSRCは、保護されたペイロードストリームと同じに設定されなけれ ばならない[MUST]。FECストリームと対応するストリームの関連付けは、SDP [5]の行グループ化と FECセマンティクス[6]、または他の外部手段によって行われる。

RFC 3550 [1]のセクション5.2に記載されている原則に従い、FECストリームとそれに 関連するペイロードストリームの多重化は、通常、各RTPセッションで異なる宛先 トランスポートアドレス（ネットワークアドレスとポート番号）によって提 供される。FECをペイロードと一緒に1つのRTPセッションで送信し、SSRCまたはペイロードタ イプによってのみ多重化することで、排除することができる。(1)ペイロードとFEC保護データに異なるネットワークパスまたはネットワークリ ソース割り当てを使用する。(2)特にFECを理解しないホストの場合、必要に応じてメディアのサブ セットを受信する。さらに、FECとペイロードデータストリームを多重化すると、元のペイロードストリームのタイミングとシーケンス番号空間に影響を与えるが、これは通常望ましくないことである。したがって、FECストリームとペイロードストリームは、2つの別個の RTPセッションを介して送信されるべきであり[SHOULD]、ペイロードタイプ別に 1つのRTPセッションに多重化することは回避されるべきである[SHOULD]。さらに、FECとペイロードは常に同じSSRCを持つため、SSRCによって1つのRTP セッションに多重化してはならない[MUST NOT]。

他のメディアストリームと同様に、FECストリームのポート番号とペイロードタ イプ番号は、SDPのm行で伝達される。FECには静的なペイロードタイプの割り当てがないため、動的なペイロードタ イプ番号を使用しなければならない[MUST]。この番号へのバインディングは、rtpmap属性で示される。このバインディングで使用される名前は、「ulpfec」である。FECストリームがあるアドレスは、対応するc行で伝えられる。

FECストリームとそれが保護するペイロードストリームの間の関連性は、 FECセマンティクス (RFC 4756) [6]を使用して、SDPのメディアライングループ化 (RFC 3388) [5]によって伝達される。FECストリームと保護されたペイロードストリームは、FECグループを形成する。

以下は、マルチキャストセッションにおけるFECアプリケーションのSDPの例である。

       v=0 o=adam 289083124 289083124 IN IP4 host.example.com s=ULP FEC Seminar t=0 0 c=IN IP4 224.2.17.12/127 a=group:FEC 1 2 a=group:FEC 3 4 m=audio 30000 RTP/AVP 0 a=mid:1 m=application 30002 RTP/AVP 100 a=rtpmap:100 ulpfec/8000 a=mid:2 m=video 30004 RTP/AVP 31 a=mid:3 m=application 30004 RTP/AVP 101 c=IN IP4 224.2.17.13/127 a=rtpmap:101 ulpfec/8000 a=mid:4       
このSDPに2つのa=group行が存在することは、2つのFECグループがあることを示 している。a=group:FEC 1 2」行で示される最初のFECグループは、ストリーム1 (PCM [14]を使用するオーディオストリーム) とストリーム2 (プロテクトFECストリーム) で構成される。FECストリームは、同じマルチキャストグループに送信され、オーディオと同じTTL (Time to Live)を持つが、ポート番号は2つ上である。a=group:FEC 3 4 "の行で示される2つ目のFECグループは、ストリーム3（ビデオストリーム）とストリーム4（プロテクトFECストリーム）で構成されています。FECストリームは異なるマルチキャストアドレスに送信されるが、ペイロードビデオストリームと同じポート番号（30004）である。

14.2.冗長エンコーディングとしてのFEC
FECストリームが冗長エンコーディング形式でセカンダリコーデックとして送信 される場合、SDPでシグナリングする必要がある。これを行うには、RFC 2198 [7]に定義されている手順を使用して、冗長エンコーディ ングの使用をシグナリングする。FECペイロードタイプは、他のセカンダリコデックと同じ方法で示される。FECは、メインコーデックのみを保護しなければならない[MUST]。FECエンジ ンのペイロードは、メインコーデックデータから作成された仮想RTPパケットに由来 する。仮想RTPパケットは、（1）追加ヘッダーと冗長なコーディングデータをすべて削除し、 （2）RTPヘッダーのペイロードタイプを主コーデックのものに置き換えるだけで、 RFC 2198パケットから非常に簡単に変換することができる。

注）RFC2198で規定されている冗長符号化のペイロードフォーマットでは、REDパケットで一次符号化を行った時点でマーカビットが失われます。そのため、FECの使用有無にかかわらず、マーカビットは回復できない。

FEC データ（ULP ヘッダを含む）は保護されたペイロードと同じパケットで送信されるため、FEC データは同じストリームにバンドルされることで保護されたペイロードと関連づけられる。

FECストリームが冗長エンコーディング形式のセカンダリコーデックとして送信 される場合、SDPを介してこれをシグナリングすることができる。これを行うには、RFC 2198 [7]に定義されている手順を使用して、冗長エンコーディ ングの使用をシグナリングする。FECペイロードタイプは、他のセカンダリコデックと同じ方法で示される。FECパケットの動的なペイロードタイプ番号を示すために、rtpmap属性を使用しなけれ ばならない[MUST]。FECはメインコーデックのみを保護しなければならない(MUST)。

例えば、こんな感じです。

      m=audio 12345 RTP/AVP 121 0 5 100 a=rtpmap:121 red/8000/1 a=rtpmap:100 ulpfec/8000 a=fmtp:121 0/5/100       
このSDPは、PCM(メディアフォーマット0)、DVI(メディアフォーマット5)、 冗長エンコーディング(rtpmap属性を通してredにバインドされているメディア フォーマット121で示される)、またはFEC(rtpmap属性を通してulpfecにバインド されているメディアフォーマット100)で構成できる単一のオーディオストリーム があることを示すものである。FECフォーマットは、このストリームの可能なコーディングとして指定されていますが、FECはこのストリームのためにそれ自体で送信されてはなりません(MUST NOT)。m行にFECが必要なのは、RFC2198に従って非主要コーデックをここに記載しなければならないからに他ならない。fmtp属性は、DVIを二次符号化、FECを三次符号化として、冗長符号化方式を使用できることを示す。

14.3.オファー/アンサー検討
SDPをオファー/アンサー[15]交換に使用する場合、いくつかの考慮事項が必要であ る。

onelevelonly」パラメータは宣言的なものである。sendonlyとして宣言されたストリームでは、この値は、1レベルのFECのみを送信 するかどうかを示す。recvonlyまたはsendrecvとして宣言されたストリームの場合、値は、受信者が何を受信することを受け入れるかを示す。

FECが別のストリームとして送信され、FECセマンティクス(RFC 4756)[6] を使用してSDP (RFC 3388)[5] のメディア行グループ化によってシグナリングされる場合、オファー側はRFC 3388とRFC 4756の両方を実装しなければならない[MUST]。RFC 3388およびRFC 4756のオファー/アンサーのルールに従わなければならない [SHALL]が、以下の点を追加で考慮する必要がある。FECを使用するすべてのオファーについて、アンサー側は、ポートを0に設定し、 FECセッションを保護されているRTPセッションとグループ化する「a=group」 属性を削除することで、個別のFECセッションを拒否してもよい[MAY]。アンサー側がFECの用法を受け入れる場合、アンサー側は、オファーに含まれる FEC RTPセッションとグループ化を、アンサーに同じグループ化を含めること で、単に受け入れる。FEC RTPセッションの拒否は、メディアセッションをFECなしで受け入れ、使用 することを妨げない、ということに注意。

FECストリームが冗長エンコーディング形式(RFC 2198)[7] のセカンダリーコーデックとして送信される場合、オファー側は、セクション14.2 で規定されているようにFECストリームを示すことができる。回答側は、FECストリームのペイロードタイプを削除することで、FECストリームを 拒否してもよい[MAY]。FECの使用を受け入れるには、アンサーにFECペイロードタイプを含めなければな らない。FECを唯一のセカンダリーコーデックとして冗長ペイロード形式[7]を使用する場 合、FECストリームを拒否するときに冗長エンコーディングペイロードタイプも 削除されるべきである[SHOULD]ことに注意すること。

15.アプリケーションステートメント
本書は、単純パリティ符号やインターリーブパリティ符号など、幅広いショートブロックパリティFECアルゴリズムをサポートする前進誤り訂正の汎用プロトコルを記述したものである。この方式は、48パケットの距離でパリティコードをインターリーブすることに限定される。この FEC アルゴリズムは、FEC 対応でないホストと完全に互換性があります。メディアペイロードは変更されず、保護は追加情報として送信されるため、本文書で規定される汎用FECを知らない受信者は、単に追加FEC情報を無視して、主メディアペイロードを処理することができる。この相互運用性は、既存のホストとの互換性のために特に重要であり、また、マルチキャスト時など、多くの異なるホストが同時に通信する必要があるシナリオでも重要である。

本書で規定する汎用 FEC アルゴリズムは、次のような特徴を持つ汎用保護アルゴリズムでもある。(1) 保護するメディアの性質（音声、映像、その他）に依存しない (2) 多様な FEC の仕組みや設定に対応できる柔軟性がある (3) 汎用的な保護アルゴリズムである。

帯域外シグナリングに頼ることなく、FECパラメータを容易に変更できるよう、適応性を考慮した設計になっていること、（4）FECパケットを伝送するためのさまざまなメカニズムをサポートしていること。

ここで指定された FEC は、不等間隔エラー保護機能をユーザに提供する。他のアルゴリズムでは、他の手段で不等間隔エラー保護機能を提供することもある。たとえば、AVTワーキンググループの「An RTP Payload Format for Erasure-Resilient Transmission of Progressive Multimedia Streams」において、UXP（Unequal Erasure Protection）方式が提案されています。UXP方式は、保護すべきペイロードストリームをリードソロモン演算で得られた追加の冗長情報でインターリーブすることにより、メディアペイロードに不等間隔エラー保護を適用するものである。

保護メディアペイロードの構造を変更することにより、UXP方式は、UXPをサポートしない端末との後方互換性を犠牲にしている。このため、後方互換性が必要な場合にUXPを適用することが難しくなる。しかし、ULPの場合、メディアペイロードは変更されず、常に端末で使用することができる。受信側の端末がULPをサポートしていない場合、追加の保護は単に無視することができる。

同時に、UXPではメディアペイロードの構造が変更されるため、元のメディアペイロードの構造や適用される保護とは無関係にパケットサイズを変更する独自の能力を提供し、プロトコルのオーバーヘッド制約にのみ従います。この特性は、トランスポートレベルでメディアのパケットサイズを変更することが望まれるシナリオで有用です。

UXPではインターリーブが使用されているため、エンコード側とデコード側の両方で遅延が発生します。UXPでは、エンコードを開始する前に伝送ブロック内のすべてのデータが到着する必要があり、伝送ブロックがデコードされる前に適切な数のパケットを受信する必要があります。ULP方式では、エンコード側での遅延はほとんど発生しません。復号側では、正しく受信したパケットをすぐに配信することができます。ULPで遅延が発生するのは、パケットロスが発生したときだけです。

UXPはインターリーブ方式であるため、UXPで保護されたデータで発生した回復不能なエラーは、通常ペイロードストリームに多数の破損したホールが発生することになります。一方、ULPでは、ビットストリームのパケットロスによる回復不能なエラーは、通常、パケットの末尾に連続した欠落として現れる。メディアペイロードストリームのエンコーディングによっては、多くのアプリケーションで、パースしてデータを抽出することが容易になる場合があります。

特に、穴が独立に復号可能な断片の境界と一致していない場合は、破損した複数の穴があるパケットよりも、末尾に連続した部分だけが欠落しているパケットを使用することができます。

ULPで用いられる排他的論理和（XOR）パリティチェック演算は、リード・ソロモン符号で必要とされる複雑な演算よりも単純で高速である。このため、ULPは計算コストに制約のあるアプリケーションに適しています。

前述のとおり、ULPとUXPの両スキームは、RTPメディアストリームに不等間隔のエ ラー保護を適用するが、それぞれ異なる手法を使用している。どちらの方式にも独自の特性があり、それぞれ異なる要件を持つ シナリオに適用することができる。

16.謝辞
本書は、以下の著者の方々に多大なご協力をいただきました。Adam H. Li, Fang Liu, John D. Villasenor, Dong-Seek Park, Jeong-Hoon Park, Yung-Lyul Lee, Jonathan D. Rosenberg, and Henning Schulzrinne.また、多くの方々、特にStephen Casner, Jay Fahlen, Cullen Jennings, Colin Perkins, Tao Tian, Matthieu Tisserand, Jeffery Tseng, Mark Watson, Stephen Wenger, Magnus Westerlund からの示唆に謝意を表したい。

17.参考文献
17.1.標準的な参考文献
[1] Schulzrinne, H., Casner, S., Frederick, R., and V. Jacobson, "RTP: A Transport Protocol for Real-Time Applications", STD 64, RFC 3550, July 2003.

[2] Bradner, S., "Key words for use in RFC to Indicate Requirement Levels", BCP 14, RFC 2119, March 1997.

[3] Freed, N. and J. Klensin, "Media Type Specifications and Registration Procedures", BCP 13, RFC 4288, December 2005.

[4] Casner, S., "Media Type Registration of RTP Payload Formats", RFC 4855, February 2007.

[5] Camarillo, G., Eriksson, G., Holler, J., and H. Schulzrinne, "Grouping of Media Lines in Session Description Protocol (SDP)"、RFC 3388、 2002年12月。

[6] Li, A., "Forward Error Correction Grouping Semantics in Session Description Protocol", RFC 4756, November 2006.

[7] Perkins, C., Kouvelas, I., Hodson, O., Hardman, V., Handley, M., Bolot, J., Vega-Garcia, A., および S. Fosse-Parisis, "RTP Payload for Redundant Audio Data", RFC 2198, 1997年9月.

[8] Handley, M., Jacobson, V., and C. Perkins, "SDP:セッション記述プロトコル", RFC 4566, 2006年7月.

17.2.参考文献
[9] Rosenberg, J. and H. Schulzrinne, "An RTP Payload Format for Generic Forward Error Correction", RFC 2733, December 1999.

[10] Perkins, C. and O. Hodson, "Options for Repair of Streaming Media", RFC 2354, June 1998.

[11] Rosenberg, J. and H. Schulzrinne, "Registration of parityfec MIME types", RFC 3009, November 2000.

[12] Luby, M., Vicisano, L., Gemmell, J., Rizzo, L., Handley, M., and J. Crowcroft, "Forward Error Correction (FEC) Building Block", RFC 3452, December 2002.

[13] Baugher, M., McGrew, D., Naslund, M., Carrara, E., and K. Norrman, "The Secure Real-time Transport Protocol (SRTP)", RFC 3711, March 2004 （「安全なリアルタイム伝送プロトコル(SRTP)」）。

[14] Schulzrinne, H. and S. Casner, "RTP Profile for Audio and Video Conferences with Minimal Control", STD 65, RFC 3551, July 2003.

[15] Rosenberg, J. and H. Schulzrinne, "An Offer/Answer Model with Session Description Protocol (SDP)", RFC 3264, June 2002.

編集部住所

Adam H. Li 10194 Wateridge Circle #152 San Diego, CA 92121 USA Phone:+1 858 622 9038 Eメール：adamli@hyervision.com

著作権表示

Copyright (C) The IETF Trust (2007).

本書は、BCP78に含まれる権利、ライセンスおよび制限に従うものであり、そこに規定されたものを除き、すべての権利は著者が保持します。

この文書とここに含まれる情報は「現状有姿」で提供され、寄稿者、寄稿者が代表または後援する組織 (存在する場合)、インターネット協会、IETFトラスト、インターネット技術タスクフォースはすべての保証を放棄しています。本書の情報の使用がいかなる権利も侵害しないという保証、または商品性もしくは特定目的への適合性に関する黙示の保証を含むがこれに限定されない、明示または黙示のあらゆる保証を否認する。

知的財産権

IETFは、この文書に記述された技術の実装または使用に関連すると主張され るかもしれない知的財産権または他の権利の有効性または範囲、あるいはそのような 権利に基づくライセンスが利用可能または不可能な範囲に関して、いかなる立場 も持たない。また、このような権利を識別するために独自の努力を行ったことを 表明するものでもない。RFC文書の権利に関する手続きについての情報は、BCP 78およびBCP 79に記載されています。

IETF事務局に対して行われたIPR開示のコピー、および利用可能になるライ センスの保証、またはこの仕様の実装者やユーザーによるそのような所有権の 使用のための一般ライセンスや許可を得ようとした結果は、IETFオンラインIPR リポジトリ( http://www.ietf.org/ipr )から入手することができる。

IETFは、この標準を実装するのに必要な技術をカバーする可能性のある著作権、特許、特許 申請、またはその他の所有権について、関心を寄せる関係者を募集しています。宛先はIETF（ietf-ipr@ietf.org）までお願いします。