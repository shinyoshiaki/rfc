RFCトランス
プライバシーポリシー
コンタクト
イチジク
@ tex2e
2198
rfc2198日本語訳
URL：https：//tools.ietf.org/html/rfc2198
パッケージ：rfc2198
編集編集：自動生成
[検索] [txt | html | pdf | bibtex] [トラッカー] [WG] [メール] [ニット]
        
From：draft-ietf-avt-rtp-redundancy-00 Proposed Standard Updated by：6354 Network Working Group C. Perkins Request for Comments：2198 I. Kouvelas Category：Standards Track O. Hodson V. Hardman University College London M. Handley ISI JC Bolot A. Vega-Garcia S. Fosse-Parisis INRIA Sophia Antipolis 1997年9月

冗長オーディオデータのRTPペイロード

このメモのステータス

このドキュメントは、インターネットコミュニティのインターネット標準追跡プロトコルを指定し、改善のための議論と提案を要求します。このプロトコルの標準化の状態とステータスについては、「インターネット公式プロトコル標準」（STD 1）の最新版を参照してください。このメモの配布は無制限です。

概要

このドキュメントでは、冗長オーディオデータをエンコードするためにリアルタイムトランスポートプロトコル（RTP）バージョン2で使用するペイロード形式について説明します。ここで説明するスキームの主な動機は、インターネットMboneなどの損失の多いパケットネットワークで使用するための音声会議ツールの開発ですが、このスキームはそのようなアプリケーションに限定されません。

1はじめに

マルチメディア会議がインターネットMboneコミュニティで広く使用されるようになる場合、ユーザーは、ほとんどのアプリケーションにとって十分に優れた品質であると認識している必要があります。会議の品質を損なう多くの問題を特定しましたが、その中で最も重要なのはパケット損失です。これは、特にインターネットの人気が高まり、したがって負荷が増大していることを考えると、永続的な問題です。現在経験されている低い損失率でさえ音声明瞭度の混乱は、インターネットを介したマルチメディア会議が実行可能ではないことを全世代のユーザーに納得させるかもしれない。データストリームへの冗長性の追加は、ソリューションとして提供されています[1]。パケットが失われた場合、欠落している情報は、次のパケットで到着する冗長データから受信者で再構築される可能性があります。

連続して失われるパケットの数は少ないです。最近の研究[4,5]は、インターネットのパケット損失パターンが、このスキームが通常うまく機能するようなものであることを示しています。

このドキュメントでは、このような冗長な方法でエンコードされたオーディオデータを送信するためのRTPペイロード形式について説明します。セクション2は、このペイロード形式の定義につながる要件と動機を示しており、ペイロード形式の定義の一部を構成していません。セクション3以降では、冗長オーディオデータのRTPペイロード形式を定義します。

2要件/動機

RTPでの冗長エンコーディングスキームの要件は次のとおりです。

oパケットは、プライマリエンコーディングと1つ以上の冗長エンコーディングを伝送する必要があります。

o冗長情報には多数のエンコーディングが使用される可能性があるため、冗長エンコーディングの各ブロックにはエンコーディングタイプ識別子が必要です。

o可変サイズのエンコーディングを使用することが望ましいため、パケット内のエンコードされた各ブロックには長さインジケータが必要です。

o RTPヘッダーは、エンコードされたデータの作成時刻に対応するタイムスタンプフィールドを提供します。冗長エンコーディングが使用されている場合、このタイムスタンプフィールドはプライマリエンコーディングデータの作成時刻を参照できます。データの冗長ブロックはプライマリデータとは異なる時間間隔に対応するため、冗長エンコーディングの各ブロックには独自のタイムスタンプが必要になります。タイムスタンプを伝送するために必要なバイト数を減らすために、冗長エンコーディングのタイムスタンプとプライマリのタイムスタンプの差としてエンコードできます。

標準的なRTP仕様に冗長オーディオを追加するには、2つの基本的な方法があります。1つはヘッダーの拡張機能に冗長性を持たせる方法、もう1つは1つ以上の追加ペイロードタイプを定義する方法です。

ヘッダー拡張にパケットのすべての冗長性情報を含めると、冗長性を実装していないアプリケーションがパケットを破棄して、プライマリエンコーディングデータを処理するのが簡単になります。ただし、このスキームにはいくつかの欠点があります。

o拡張ヘッダー（4）に必要なバイト数と、4バイト境界（最大3バイト）に切り上げるために拡張の最後に必要となる可能性のあるパディングには、大きなオーバーヘッドがあります。多くのアプリケーションでは、このオーバーヘッドは許容できません。

oヘッダー拡張機能を使用すると、拡張機能にさらに構造が導入されない限り、アプリケーションは単一の冗長エンコーディングに制限されます。これにより、さらにオーバーヘッドが発生します。

これらの理由から、冗長オーディオエンコーディングを保持するためのRTPヘッダー拡張の使用は無視されます。

音声およびビデオ会議のRTPプロファイル[3]は、ペイロードタイプのセットをリストし、会議制御プロトコルを介して定義できる32エンコーディングのダイナミックレンジを提供します。これにより、冗長オーディオアプリケーションに追加のRTPペイロードタイプを割り当てるための2つの可能なスキームが導き出されます。

1.動的エンコーディングスキームは、RTP動的ペイロードタイプ範囲を使用して、プライマリ/冗長ペイロードタイプの組み合わせごとに定義できます。

2.冗長性のあるパケットを表すために、単一の固定ペイロードタイプを定義できます。次に、これを静的RTPペイロードタイプに割り当てるか、このペイロードタイプを動的に割り当てることができます。

提供される32の動的ペイロードタイプのそれぞれについて、プライマリエンコーディングとセカンダリエンコーディングの特定の組み合わせを示すペイロードタイプのセットを定義することができます。可能な組み合わせの数が多すぎないため、これは、冗長性の単一ブロックを持つパケットに対して、わずかに制限的でありながら実行可能なソリューションになります。ただし、冗長性の複数のブロックが必要になると、エンコーディングの組み合わせの数が大幅に増加し、このソリューションは実行不可能になります。

上記の解決策の修正版は、会議の開始前に、会議の期間中に使用される32のエンコーディングの組み合わせを決定することである可能性があります。会議のすべてのツールは、このワーキングセットのエンコーディングの組み合わせで初期化できます。ワーキングセットの通信は、外部の帯域外メカニズムを使用して行うことができます。同じパラメータでツールを起動する場合は細心の注意を払う必要があるため、セットアップは複雑です。このスキームは、エンコーディングの組み合わせを識別するために1バイトのみが使用されるため、より効率的です。

ペイロードタイプのマッピングを冗長データの組み合わせに分散することに固有の複雑さにより、このメカニズムの使用が妨げられていると思われます。

より柔軟な解決策は、冗長性のあるパケットを示す単一のペイロードタイプを持つことです。次に、そのパケットはコンテナになり、複数のペイロードを1つのRTPパケットにカプセル化します。任意の量の冗長性を単一のパケット内にカプセル化できるため、このようなスキームは柔軟性があります。ただし、カプセル化された各ペイロードの前に、囲まれたデータのタイプを示すヘッダーを付ける必要があるため、オーバーヘッドはわずかです。これは、柔軟性と拡張性の両方があり、オーバーヘッドが比較的低いため、推奨されるソリューションです。このドキュメントの残りの部分では、このソリューションについて説明します。

3ペイロードフォーマット仕様

このドキュメントのキーワード「MUST」、「MUST NOT」、「REQUIRED」、「SHALL」、「SHALL NOT」、「SHOULD」、「SHOULD NOT」、「RECOMMENDED」、「MAY」、「OPTIONAL」は次のとおりです。 RFC2119 [7]で説明されているように解釈されます。

この新しいパケット形式へのRTPペイロードタイプの割り当ては、このドキュメントの範囲外であり、ここでは指定しません。特定のクラスのアプリケーションのRTPプロファイルは、このエンコーディングにペイロードタイプを割り当てることが期待されます。そうでない場合は、ダイナミックレンジのペイロードタイプを選択する必要があります。

冗長データを含むRTPパケットには、冗長性を示すペイロードタイプを備えた標準RTPヘッダーが必要です。RTPヘッダーの他のフィールドは、冗長データのプライマリデータブロックに関連しています。

RTP ヘッダーの後には、下図のようないくつかの追加ヘッダーがあり、パケットで伝送される各エンコーディングの内容を指定します。 これらの追加ヘッダーの後には、いくつかのデータブロックがあり、これらのエンコーディングの標準的なRTPペイロードデータが含まれています。 すべてのヘッダは32ビット境界にアラインされていますが、ペイロードデータは通常アラインされませんのでご注意ください。 1つのパケットに複数の冗長なエンコーディングが含まれる場合、それらは異なる時間間隔に対応する必要があります。

    0                   1                    2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3  4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |F|   block PT  |  timestamp offset         |   block length    |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        
ヘッダーのビットは次のように指定されます。

F：1ビット ヘッダーの最初のビットは、別のヘッダーブロックが続くかどうかを示す。 1の場合は、さらにヘッダーブロックが続き、0の場合は、これが最後のヘッダーブロックとなります。

ブロックPT：このブロックの7ビットRTPペイロードタイプ。

タイムスタンプオフセット：14ビットRTPヘッダーで指定されたタイムスタンプに対するこのブロックのタイムスタンプの符号なしオフセット。符号なしオフセットの使用は、冗長データをプライマリデータの後に送信する必要があることを意味します。したがって、このブロックが冗長であるデータのタイムスタンプを決定するために、現在のタイムスタンプから差し引かれる時間です。

ブロック長：10ビットヘッダーを除く対応するデータブロックのバイト単位の長さ。

符号なしタイムスタンプオフセットを使用すると、冗長データの使用がわずかに制限されることに注意してください。プライマリエンコーディングの前に冗長性を送信することはできません。これは、冗長性に適した低帯域幅のコーディングがエンコードプロセスの早い段階で生成されるスキームに影響を与える可能性があり、したがって、早期に実行可能に送信される可能性があります。ただし、符号ビットを追加すると、タイムスタンプオフセットの範囲が許容できないほど小さくなり、フィールドのサイズを14ビットより大きくすると、ブロック長フィールドが制限されます。プライマリの後に送信される冗長性を制限すると、他のフィールドのサイズを制限するよりも問題が少なくなるようです。

冗長ブロックのタイムスタンプオフセットは、プライマリエンコーディングのタイムスタンプと同じ単位で測定されます（つまり、プライマリと同じクロックレートのオーディオサンプル）。これは、冗長エンコーディングをプライマリと同じレートでサンプリングする必要があることを意味します。

さらに、ブロック長とタイムスタンプオフセットはそれぞれ10ビットと14ビットであることに注意してください。より明白な8ビットと16ビットではなく。このようなエンコーディングは、ヘッダー情報の解析をわずかに複雑にし、処理のオーバーヘッドを追加しますが、より明白な選択に関連するいくつかの問題があります。8ビットのブロック長フィールドは、すべてではありませんが、ほとんどの可能なエンコーディングに十分です。例80msPCMおよびDVIオーディオパケットは256バイトを超えて構成されており、1バイト長のフィールドでエンコードすることはできません。ブロック長フィールドに追加の構造を課すことは可能です（たとえば、上位ビットセットは下位7ビットがバイトではなくワード単位の長さをコード化することを意味する可能性があります）が、そのようなスキームは複雑です。10ビットのブロック長フィールドを使用すると、

タイムスタンプ値の範囲が狭くなる代わりに、単純で範囲が拡大されます。

プライマリエンコーディングブロックヘッダーは、パケットの最後に配置されます。したがって、タイムスタンプフィールドとブロック長フィールドはRTPヘッダーと全体のパケット長から決定される可能性があるため、このブロックのヘッダーから省略できます。プライマリ（最終）ブロックのヘッダーは、ゼロFビットと、ブロックペイロードタイプ情報の合計8ビットのみで構成されます。これを次の図に示します。

                      0 1 2 3 4 5 6 7
                     +-+-+-+-+-+-+-+-+
                     |0|   Block PT  |
                     +-+-+-+-+-+-+-+-+
        
最後のヘッダーの直後に、ヘッダーと同じ順序で格納されたデータブロックが続きます。データブロック間にパディングやその他の区切り文字はなく、通常は32ビットで整列されていません。この場合も、この選択は、追加のデコード時間を犠牲にして、帯域幅のオーバーヘッドを削減するために行われました。

使用するエンコーディングの選択は、それらのエンコーディングの帯域幅要件を反映する必要があります。冗長エンコーディングは、プライマリエンコーディングよりも大幅に少ない帯域幅を使用することが予想されます。例外は、プライマリが非常に低帯域幅であり、処理要件が高い場合です。この場合、プライマリのコピーを冗長性として使用できます。 。冗長エンコーディングは、プライマリよりも高い帯域幅であってはなりません。

複数レベルの冗長性を使用する必要があることはめったにありません。ただし、それが必要な場合、各レベルの冗長性に必要な帯域幅は、前のレベルの帯域幅よりも大幅に少なくなると予想されます。

4制限

RTPマーカービットは、冗長データブロック用に保持されません。したがって、プライマリ（このマーカーを含む）が失われると、マーカーは失われます。これによって過度の問題が発生することはないと考えられます。マーカービットが冗長な情報で送信されたとしても、その損失の可能性があるため、アプリケーションはこれを念頭に置いて作成する必要があります。

さらに、CSRC情報は冗長データ用に保存されません。冗長オーディオパケットのRTPヘッダーのCSRCデータは、プライマリのみに関連しています。オーディオストリームのCSRCデータは比較的まれにしか変更されないと予想されるため、次のことをお勧めします。

この情報を必要とするアプリケーションは、RTPヘッダーのCSRCデータが再構築された冗長データに適用される可能性があることを前提としています。

5SDPとの関係

冗長ペイロードを使用する場合は、RTP動的ペイロードタイプにバインドする必要がある場合があります。これは、任意の帯域外メカニズムを介して実現できますが、一般的な方法の1つは、Session Description Protocol（SDP）[6]を使用してこのバインディングを通信することです。SDPには、「rtpmap」属性を使用して、動的ペイロードタイプを特定のコーデック、サンプルレート、およびチャネル数にバインドするメカニズムがあります。その使用例（RTPオーディオ/ビデオプロファイル[3]を使用）は次のとおりです。

       m = audio 12345 RTP / AVP 121 0 5
       a = rtpmap：121 red / 8000/1
        
これは、RTPを使用するオーディオストリームがペイロードタイプ121（動的ペイロードタイプ）、0（PCM u-law）、および5（DVI）を使用していることを指定します。「rtpmap」属性は、ペイロードタイプ121をコーデック「red」にバインドするために使用されます。これは、このコーデックが実際には冗長フレーム、8KHz、およびモノラルであることを示します。SDPで使用する場合、「赤」という用語は、このドキュメントで説明されている冗長フォーマットを示すために使用されます。

この場合、PCMとDVIの追加フォーマットが指定されています。したがって、受信機はこれらのフォーマットを使用する準備をする必要があります。このような仕様は、送信者がデフォルトで冗長性を送信することを意味しますが、PCMまたはDVIも送信する場合があります。ただし、冗長ペイロードの場合、これは、PCMまたはDVI以外のコーデックが冗長エンコーディングで使用されないことを意味します。「m =」フィールドで定義された追加のペイロード形式は、それ自体が動的ペイロードタイプである可能性があり、その場合、これらの動的ペイロードタイプを記述するためにいくつかの追加の「a =」属性が必要になる場合があることに注意してください。

冗長ストリームを受信するには、これが必要なすべてです。ただし、冗長ストリームを送信するには、送信者は、プライマリおよびセカンダリ（およびターシャリなど）のエンコーディングに推奨されるコーデックを知る必要があります。この情報は冗長フォーマットに固有であり、フォーマット固有の情報を伝達する追加の属性「fmtp」を使用して指定されます。セッションディレクトリは、fmtp属性で指定された値を解析せず、変更せずにメディアツールに渡すだけです。冗長性を確保するために、フォーマットパラメータをスラッシュ「/」で区切られたRTPペイロードタイプのリストとして定義します。

したがって、完全な例は次のとおりです。

       m = audio 12345 RTP / AVP 121 0 5
       a = rtpmap：121 red / 8000/1
       a = fmtp：121 0/5
        
これは、送信者のデフォルト形式が冗長性であり、プライマリエンコーディングとしてPCM、セカンダリエンコーディングとしてDVIであることを指定します。メディア（ "m ="）行で有効なエンコーディングとしても指定されていない限り、エンコーディングをfmtp属性で指定することはできません。

6セキュリティに関する考慮事項

冗長情報を含むRTPパケットは、RTP仕様[2]で説明されているセキュリティの考慮事項、および適切なRTPプロファイル（[3]など）の対象となります。これは、メディアストリームの機密性が暗号化によって達成されることを意味します。冗長データストリームの暗号化は、次の2つの方法で発生する可能性があります。

1.ストリーム全体を保護する必要があり、すべての参加者はストリーム全体をデコードするためのキーを持っている必要があります。この場合、特別なことは何もする必要はなく、暗号化は通常の方法で実行されます。

2.ストリームの一部は、残りの部分とは異なるキーで暗号化されます。この場合、送信する正しいキーで暗号化された後続のパケットがないため、その部分の最後のパケットの冗長コピーを送信できません。暗号化を有効/無効にするときにも、同様の制限が発生する可能性があります。

これら2つのどちらを選択するかは、エンコーダーのみの問題です。デコーダーは、変更なしでどちらの形式も復号化できます。

オーディオストリームに低帯域幅の冗長性を追加することは、そのストリームをパケット損失から保護するための効果的な手段ですが、アプリケーション設計者は、大量の冗長性を追加するとネットワークの輻輳が増加し、パケット損失が増加することに注意する必要があります。冗長性の使用が解決しようとしていた問題の悪化につながります。最悪の場合、これは過度のネットワーク輻輳につながる可能性があり、サービス拒否攻撃を構成する可能性があります。

7パケット例

RTPオーディオ/ビデオプロファイル[3]で定義されているように、DVI4（8KHz）プライマリと8KHz LPC（両方とも20msパケット）を使用してエンコードされた冗長性の単一ブロックを含むRTPオーディオデータパケットが示されています。

    0                   1                    2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3  4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |V=2|P|X| CC=0  |M|      PT     |   sequence number of primary  |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |              timestamp  of primary encoding                   |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |           synchronization source (SSRC) identifier            |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |1| block PT=7  |  timestamp offset         |   block length    |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |0| block PT=5  |                                               |
   +-+-+-+-+-+-+-+-+                                               +
   |                                                               |
   +                LPC encoded redundant data (PT=7)              +
   |                (14 bytes)                                     |
   +                                               +---------------+
   |                                               |               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+               +
   |                                                               |
   +                                                               +
   |                                                               |
   +                                                               +
   |                                                               |
   +                                                               +
   |                DVI4 encoded primary data (PT=5)               |
   +                (84 bytes, not to scale)                       +
   /                                                               /
   +                                                               +
   |                                                               |
   +                                                               +
   |                                                               |
   +                                               +---------------+
   |                                               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        
8人の著者のアドレス

Colin Perkins / Isidor Kouvelas / Orion Hodson / Vicky Hardman Department of Computer Science University College London London WC1E6BTイギリス

   Eメール：{c.perkins | i.kouvelas | o.hodson | v.hardman} @ cs.ucl.ac.uk
        
Mark Handley USC Information Sciences Institute c / o MIT Laboratory for Computer Science 545 Technology Square Cambridge、MA 02139、USA

Eメール：mjh@isi.edu

Jean-Chrysostome Bolot / Andres Vega-Garcia / Sacha Fosse-Parisis INRIAソフィアアンティポリス2004ルートデルシオール、BP 9306902ソフィアアンティポリスフランス

   Eメール：{bolot | avega | sfosse}@sophia.inria.fr
        
9参考文献

   [1] VJ Hardman、MA Sasse、M。Handley、A。Watson; 信頼性のある
   インターネット経由で使用するためのオーディオ。議事録INET'95、ホノルル、オアフ島、
   ハワイ、1995年9月。http：//www.isoc.org/in95prc/
        
[2] Schulzrinne、H.、Casner、S.、Frederick R.、およびV. Jacobson、「RTP：リアルタイムアプリケーションのトランスポートプロトコル」、RFC 1889、1996年1月。

[3] Schulzrinne、H。、「最小限の制御を備えたオーディオおよびビデオ会議のRTPプロファイル」、RFC 1890、1996年1月。

[4] M. Yajnik、J。Kurose、D。Towsley; MBoneマルチキャストネットワークでのパケット損失の相関。IEEE Globecomインターネットワークショップ、ロンドン、1996年11月

[5] J.-C. ボロットとA.ベガ-ガルシア; インターネットにおけるパケットオーディオのFECベースのエラー制御の場合。ACMマルチメディアシステム、1997年

[6] Handley、M。、およびV. Jacobson、「SDP：セッション記述プロトコル（ドラフト03.2）」、進行中の作業。

[7] Bradner、S。、「要件レベルを示すためにRFCで使用するキーワード」、RFC 2119、1997年3月。