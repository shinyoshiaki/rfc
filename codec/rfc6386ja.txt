RFCトランス
プライバシーポリシー
コンタクト
イチジク
@ tex2e
6386
RFC6386-VP8データフォーマットおよびデコードガイド日本語訳
URL：https://tools.ietf.org/html/rfc6386
スクリプト：RFC6386-VP8データフォーマットおよびデコードガイド
編集編集：自動生成
[検索][txt| html | pdf | with errata | bibtex] [Tracker] [WG] [Email] [Diff1] [Diff2] [Nits]
差出人：draft-bankoski-vp8-bitstream-06情報
                                                        IPR宣言
                                                            エラッタが存在する独立した提出J.Bankoski
コメントのリクエスト：6386 J. Koleszar
カテゴリ：情報L. Quillio
ISSN：2070-1721J.サロネン
                                                              P.ウィルキンス
                                                                   Y. Xu
                                                             Google Inc.
                                                           2011年11月
        
VP8データフォーマットおよびデコードガイド

概要

このドキュメントでは、VP8圧縮ビデオデータ形式について説明し、その形式のデコード手順についても説明します. 

このメモのステータス

このドキュメントはインターネット標準化過程の仕様ではありません. 情報提供の目的で公開されています. 

これは、他のRFCストリームとは関係なく、RFCシリーズへの貢献です. RFCエディターは、その裁量でこのドキュメントを公開することを選択し、実装または展開の価値については何も述べていません. RFCエディターによって公開が承認されたドキュメントは、どのレベルのインターネット標準の候補でもありません. RFC5741のセクション2を参照してください. 

このドキュメントの現在のステータス、正誤表、およびフィードバックの提供方法に関する情報は、http：//www.rfc-editor.org/info/rfc6386で入手できます. 

著作権表示

Copyright（c）2011IETFTrustおよびドキュメントの作成者として特定された人物. 全著作権所有. 

このドキュメントは、このドキュメントの発行日に有効なBCP 78およびIETFドキュメントに関連するIETFトラストの法的規定（http://trustee.ietf.org/license-info）の対象となります. これらのドキュメントは、このドキュメントに関するあなたの権利と制限を説明しているため、注意深く確認してください. 

目次

   1.はじめに...............................................  ..... 4
   2.フォーマットの概要..............................................  ... 5
   3.圧縮フレームタイプ..........................................7
   4.圧縮データ形式の概要..............................8
   5.デコードプロセスの概要................................9
   6.アルゴリズムの説明......................................14
   7.ブールエントロピーデコーダー........................................16
      7.1. 基礎となるコーディング理論...............................17
      7.2. 実用的なアルゴリズムの説明...........................18
      7.3. 実際の実装.....................................20
   8.圧縮データコンポーネント.....................................25
      8.1. ツリーコーディングの実装................................27
      8.2. ツリーコーディングの例.......................................28
   9.フレームヘッダー..............................................  ..... 30
      9.1. 非圧縮データチャンク...................................30
      9.2. 色空間とピクセルタイプ（キーフレームのみ）.............. 33
      9.3. セグメントベースの調整.................................34
      9.4. ループフィルターのタイプとレベル...............................35
      9.5. トークンパーティションとパーティションデータオフセット................36
      9.6. 量子化解除指数....................................37
      9.7. ゴールデンフレームとAltrefフレームを更新.....................38
      9.8. 最後のフレームバッファを更新する.................................39
      9.9. DCT係数確率の更新........................39
      9.10. 残りのフレームヘッダーデータ（非キーフレーム）.............. 40
      9.11. 残りフレームヘッダデータ（キーフレーム）.................. 41
   10.セグメントベースの機能調整.............................41
   11.キーフレームマクロブロック予測レコード.......................42
      11.1. mb_skip_coeff ............................................ 42
      11.2. ルマモード.........................................................42
      11.3. サブブロックモードのコンテキスト...................................45
      11.4. クロマモード.............................................46
      11.5. サブブロックモード確率表..........................47
   12.フレーム内予測.........................................50
      12.1. mb_skip_coeff ............................................ 51
      12.2. クロマ予測........................................51
      12.3. ルマ予測..........................................54
   13.DCT係数デコード......................................60
      13.1. 非ゼロ係数値のないマクロブロック...........61
      13.2. 個々の係数値のコーディング..................61
      13.3. トークンの確率......................................63
      13.4. トークン確率の更新................................68
      13.5. デフォルトのトークン確率テーブル..........................73
        
   14.DCTとWHTの反転とマクロブロックの再構築...........76
      14.1. 量子化解除...........................................76
      14.2. 逆変換.......................................78
      14.3. WHT反転の実装......................78
      14.4. DCT反転の実装......................81
      14.5. 予測子と残差の合計.......................83
   15.ループフィルター..............................................  ..... 84
      15.1. フィルタの形状と全体的な手順....................85
      15.2. シンプルフィルター............................................87
      15.3. 通常のフィルター............................................91
      15.4. 制御パラメータの計算........................95
   16.フレーム間マクロブロック予測レコード......................97
      16.1. 予測されたマクロブロック..............................97
      16.2. 相互予測されたマクロブロック..............................98
      16.3. モードと動きベクトルのコンテキスト..........................99
      16.4. 分割予測........................................105
   17.動きベクトルのデコード.......................................108
      17.1. 各コンポーネントのコーディング................................108
      17.2. 確率の更新.....................................110
   18.フレーム間予測........................................113
      18.1. 動きベクトルの境界と調整............113
      18.2. 予測サブブロック....................................115
      18.3. サブピクセル補間.................................115
      18.4. フィルタのプロパティ.......................................118
   19.付録A：ビットストリーム構文.................................... 120
      19.1. 非圧縮データチャンク.................................121
      19.2. フレームヘッダー............................................122
      19.3. マクロブロックデータ.........................................130
   20.添付資料1：リファレンスデコーダーのソースコード................ 133
      20.1. bit_ops.h...............................................  133
      20.2. bool_decoder.h .......................................... 133
      20.3. dequant_data.h .......................................... 137
      20.4. dixie.c...............................................  ..138
      20.5. dixie.h...............................................  ..151
      20.6. dixie_loopfilter.c ...................................... 158
      20.7. dixie_loopfilter.h ...................................... 170
      20.8. idct_add.c .............................................. 171
      20.9. idct_add.h .............................................. 174
      20.10. mem.h...............................................  ... 175
      20.11. modemv.c...............................................  176
      20.12. modemv.h...............................................  192
      20.13. modemv_data.h .......................................... 193
      20.14. 予測.c..............................................198
      20.15. 予測.h..............................................231
      20.16. tokens.c...............................................  232
      20.17. tokens.h...............................................  242
      20.18. vp8_prob_data.h ........................................ 243
      20.19. vpx_codec_internal.h ................................... 252
        
      20.20. vpx_decoder.h .......................................... 263
      20.21. vpx_decoder_compat.h ................................... 271
      20.22. vpx_image.c ............................................ 285
      20.23. vpx_image.h ............................................ 291
      20.24. vpx_integer.h .......................................... 298
      20.25. 著者ファイル...........................................299
      20.26. ライセンス................................................301
      20.27. 特許................................................302
   21.セキュリティに関する考慮事項......................................302
   22.参考文献...............................................  .... 303
      22.1. 規範的参照.....................................303
      22.2. 有益な参考資料..................................303
        
1.はじめに
このドキュメントでは、VP8圧縮ビデオデータ形式について説明し、その形式のデコード手順についても説明します. これは、添付資料1（セクション20）で提供されているリファレンスデコーダーのソースコードと組み合わせて、またそのガイドとして使用することを目的としています. この説明と参照ソースコードの間に矛盾がある場合は、参照ソースコードが正しいと見なす必要があります. ビットストリームは、この説明ではなく、参照ソースコードによって定義されます. 

多くの最新のビデオ圧縮スキームと同様に、VP8は、フレームをピクセルの正方形のサブブロックに分解し、以前に構築されたブロックを使用してそのようなサブブロックを予測し、離散コサイン変換（以下、予測されていないブロックの合成）を使用してそのような予測を調整します.  DCTと略されます）. ただし、1つの特殊なケースでは、VP8はDCTの代わりにウォルシュ-アダマール変換（以下、WHTと略します）を使用します. 

大まかに言えば、このようなシステムは、ほとんどのビデオ信号の時間的および空間的コヒーレンスを利用することにより、データレートを低下させます. ピクセル値を指定するよりも、前のフレームの視覚的に類似した部分の位置を指定する方が効率的です. DCTとWHTによって提供される周波数分離は、元の信号の空間コヒーレンスと、再構成された信号の忠実度の低下を緩和するための人間の視覚系の許容度の両方の活用を容易にします. 

VP8は、とりわけ、コンテキスト確率の高度な使用法でこれらの基本概念を強化します. その結果、特定の品質でのデータレートが大幅に低下します. 

いくつかの同様のスキーム（たとえば、古いMPEG形式）とは異なり、VP8は再構成されたピクセルの正確な値を指定します. 具体的には、再構成のDCT部分とWHT部分の仕様では、分数の切り捨てによって引き起こされる「ドリフト」は考慮されていません. むしろ、アルゴリズムは固定精度の整数演算のみを使用して指定されます. これにより、デコーダーの実装の正しさの検証が大幅に容易になり、そのような実装間の視覚的な不一致を予測するのが困難になります. 

完全なビデオ再生システムでは、表示されるフレームが再構成されたフレームと同一である場合と同一でない場合があることに注意する必要があります. 多くのシステムは、表示する前に、再構築されたフレームに最終レベルのフィルタリング（一般に後処理と呼ばれる）を適用します. このような後処理は、後続のフレーム（完全に指定された再構築フレームを使用して予測される）のデコードと再構築には影響せず、このドキュメントの範囲を超えています. 実際には、この種の後処理の性質と範囲は、ユーザーの好みと再生環境の計算機能の両方に依存します. 

このドキュメントのキーワード「MUST」、「MUST NOT」、「REQUIRED」、「SHALL」、「SHALL NOT」、「SHOULD」、「SHOULD NOT」、「RECOMMENDED」、「MAY」、「OPTIONAL」は次のとおりです.  RFC2119[RFC2119]で説明されているように解釈されます. 

2.フォーマットの概要
VP8は、8ビットYUV 4：2：0画像形式でのみ動作します. この形式では、2つの彩度平面（UおよびV）の各8ビットピクセルは、Y平面の8ビット輝度ピクセルの2x2ブロックに位置的に対応します. Yブロックの左上隅の座標は、もちろん、対応するクロマピクセルの座標のちょうど2倍です. 平面を指定せずにピクセルまたはピクセル距離を参照する場合、暗黙的にY平面または完全な画像を参照します. どちらも同じ（フル）解像度です. 

通常の場合と同様に、ピクセルは単純に上から下に行に格納されたバイトの大きな配列であり、各行は左から右に格納されます. この「左から右」、次に「上から下」のラスタースキャン順序は、圧縮データのレイアウトにも反映されます. 

予約ビットの形式で、セカンダリYUVカラーフォーマットをサポートするためのプロビジョニングがVP8ビットストリームヘッダーで行われました. 

時折、非常に低いデータレートでは、圧縮システムが入力信号の解像度を下げて効率的な圧縮を容易にすることを決定する場合があります. VP8データ形式は、出力前の内部再構築バッファーのオプションのアップスケーリングを介してこれをサポートします（これは

デコード自体とは関係のない、前述のオプションの後処理とは完全に異なります）. このアップサンプリングにより、ビデオフレームが元の解像度に復元されます. 言い換えると、圧縮/解凍システムは「ブラックボックス」と見なすことができ、入力と出力は常に特定の解像度になります. コンプレッサーは、信号をより低い解像度で「チート」して処理することを決定する場合があります. その場合、デコンプレッサは信号を元の解像度に復元する機能を必要とします. 

内部的には、VP8は各出力フレームをマクロブロックの配列に分解します. マクロブロックは、Y次元が16x16で、U次元とV次元が8x8のピクセルの正方形配列です. 圧縮されたフレーム内のマクロブロックレベルのデータは、フレームを構成するピクセルと同様のラスター順序で発生します（処理する必要があります）. 

マクロブロックはさらに4x4のサブブロックに分解されます. すべてのマクロブロックには、16個のYサブブロック、4個のUサブブロック、および4個のVサブブロックがあります. サブブロックレベルのデータ（およびそのようなデータの処理）は、ラスター順に、今回は含まれているマクロブロック内でラスター順に再び発生します. 

以下でさらに詳しく説明するように、データはマクロブロックとそのサブブロックの両方のレベルで指定できます. 

ピクセルは常に、少なくともサブブロックのレベルで扱われます. サブブロックは、VP8アルゴリズムの「アトム」と見なすことができます. 特に、4x4 Yサブブロックに対応する2x2クロマブロックは、データ形式またはアルゴリズム仕様で明示的に扱われることはありません. 

DCTとWHTは常に4x4の解像度で動作します. DCTは、16Y、4U、および4Vサブブロックに使用されます. WHTは、マクロブロックの16個のYサブブロックの平均強度を含む4x4アレイをエンコードするために使用されます（すべてではありませんが、一部の予測モードで）. これらの平均強度は、一定の正規化係数までは、Yサブブロックの0番目のDCT係数にすぎません. この「高レベル」WHTは、サブブロックのDCTがサブブロックを構成するピクセル値の指定を置き換えるのとまったく同じ方法で、これらの係数の明示的な指定の代わりになります. この4x4配列をY2と呼ばれる2次サブブロックと見なし、マクロブロックを24個の「実」サブブロックと25番目の「仮想」サブブロックを含むものと見なします. これについては、セクション13で詳しく説明します. 

参照デコーダーで使用されるフレームレイアウトは、ファイルvpx_image.h（セクション20.23）にあります. 

3.圧縮フレームタイプ
VP8には2種類のフレームしかありません. 

イントラフレーム（キーフレームとも呼ばれ、MPEG用語ではIフレーム）は、シーケンス内の他のフレームを参照せずにデコードされます. つまり、デコンプレッサはそのようなフレームを「デフォルト」状態から再構築します. キーフレームは、ビデオストリーム内のランダムアクセス（またはシーク）ポイントを提供します. 

インターフレーム（予測フレームとも呼ばれ、MPEG用語ではPフレーム）は、前のフレーム、特に最新のキーフレームまでのすべての前のフレームを参照してエンコードされます. 一般的に、フレーム間を正しくデコードするには、最新のキーフレームとそれに続くすべてのフレームを正しくデコードする必要があります. したがって、デコードアルゴリズムは、ドロップされたフレームを許容しません. フレームがドロップまたは破損する可能性がある環境では、キーフレームが正しく受信されるまで、正しいデコードはできません. 

MPEGとは対照的に、双方向予測は使用されません. 時間的に後続のフレームを使用してフレームが予測されることはありません. MPEGBフレームに類似したものはありません. 

次に、VP8は、ゴールデンフレームおよびaltrefフレーム（代替参照フレーム）と呼ばれる代替予測フレームの概念でこれらの概念を強化します. フレーム間内のブロックは、直前のフレームのブロックと、最新のゴールデンフレームまたはaltrefフレームを使用して予測できます. すべてのキーフレームは自動的にゴールデンおよびaltrefであり、任意のインターフレームが最新のゴールデンまたはaltrefフレームをオプションで置き換えることができます. 

ゴールデンフレームとaltrefフレームを使用して、上記のドロップされたフレームに対する不寛容を部分的に克服することもできます. コンプレッサーが前のゴールデンフレーム（およびキーフレーム）のみを参照してゴールデンフレームをコーディングするように構成されている場合、キーの「サブストリーム」ゴールデンフレームは、他のインターフレームの損失に関係なくデコードできます. 大まかに言えば、実装では（コンプレッサー側で）ゴールデンフレームが介在するインターフレームによって影響を受けるコンテキスト更新を包含して再コード化する必要があります. このアプローチの典型的なアプリケーションはビデオ会議であり、前のゴールデンフレームの再送信および/または次のゴールデンフレームの受信までの再生の遅延が、次のキーフレームまでのより大きな再送信および/または遅延よりも好ましい. 

4.圧縮データ形式の概要
VP8デコーダーへの入力は、圧縮されたフレームのシーケンスであり、その順序は時間の順序と一致します. フレームの長さ、対応するオーディオ、同期などの問題は、通常、再生環境によって提供され、デコードプロセス自体とは無関係です. ただし、高速シークを支援するために、開始コードが各キーフレームのヘッダーに含まれています. 

デコーダーは、圧縮されたフレームのシーケンスを単純に提示され、入力シーケンスに対応する解凍された（再構築された）YUVフレームのシーケンスを生成します. はじめにで述べたように、再構築されたフレームの正確なピクセル値はVP8の仕様の一部です. このドキュメントでは、圧縮されたフレームのレイアウトを指定し、再構築されたフレームを正しく生成するための明確なアルゴリズムを提供します. 

デコンプレッサに提示される最初のフレームは、もちろんキーフレームです. この後には、任意の数のインターフレームが続く場合があります. 各フレームの正しい再構成は、キーフレームまでのすべての前のフレームに依存します. 次のキーフレームはこのプロセスを再開します. キーフレームを受信すると、デコンプレッサはデフォルトの初期状態にリセットされ、キーフレーム（およびそれに続くフレーム間）のデコードは、以前のデコードから完全に独立しています. 

最高レベルでは、すべての圧縮フレームに3つ以上のピースがあります. キーフレームの場合は10バイト、インターフレームの場合は3バイトで構成される非圧縮データチャンクから始まります. この後に、圧縮データの2つ以上のブロック（パーティションと呼ばれる）が続きます. これらの圧縮データパーティションは、バイト境界で開始および終了します. 

最初の圧縮パーティションには、次の2つのサブセクションがあります. 

1.フレーム全体に適用されるヘッダー情報. 

2.デコンプレッサーで使用可能な再構成済みデータから各マクロブロックを予測する方法を指定するマクロブロックごとの情報. 

上記のように、マクロブロックレベルの情報はラスタースキャンの順序で発生します. 

残りのパーティションには、ブロックごとに、予測されたブロック値に追加される残差信号のDCT / WHT係数（量子化および論理圧縮）が含まれています. 通常、データレート全体の約70％を占めます. VP8は、圧縮されたDCT/WHT係数のデータをマクロブロックからパックすることをサポートします

行を別々のパーティションに分割します. これらの係数に複数のパーティションがある場合、最後のパーティションを除くパーティションのサイズ（バイト単位）も、上記の最初のパーティションの直後のビットストリームに存在します. 各サイズは、リトルエンディアン形式で記述された3バイトのデータ項目です. これらのサイズにより、デコーダーはすべてのDCT / WHT係数パーティションに直接アクセスできるため、デコーダーでの係数の並列処理が可能になります. 

予測データと係数データを個別に分割することで、デコンプレッサの実装に柔軟性を持たせることもできます. 実装では、フレーム全体の予測情報をデコードして保存し、残差信号をデコード、変換して、フレーム全体に追加することができます. 両方のパーティションを同時にデコードし、予測情報を計算し、各ブロックの残差信号を順番に追加する場合があります. フレームタグの長さフィールドは、最初のパーティションが完全にデコードされる前に2番目のパーティションのデコードを開始できるようにするもので、2番目の「一度にブロック」デコーダーの実装に必要です. 

すべてのパーティションは、セクション7で説明したブールエントロピーデコーダーの個別のインスタンスを使用してデコードされます. パーティション内に表示されるデータの一部は概念的に「フラット」ですが（ビットはビットであり、いずれかの方法で確率的な期待はありません）. このようなコーダーの動作方法では、「概念ビット」と圧縮データパーティション内の実際の物理ビットが直接対応することはありません. 上記の3バイトまたは10バイトの非圧縮チャンクにのみ、そのような物理的な対応があります. 

関連する問題は、パーティション内でのシークがサポートされていないことです. データは、パーティションで発生した順序で解凍および処理（または少なくとも保存）する必要があります. 

このドキュメントでは、パーティションデータの順序を正しく指定していますが、理解を容易にするために、このデータの詳細とセマンティクスについてより論理的な方法で説明しています. たとえば、フレームヘッダーには、マクロブロックごとのデータのデコードに使用される多くの確率テーブルの更新が含まれています. マクロブロックごとのデータは、ビットストリームでの順序とは逆ですが、確率とその更新のレイアウトの前に記述されることがよくあります. 

5. デコードプロセスの概要
VP8デコーダーは、解像度がエンコードされた画像の解像度と少なくとも等しい4つのYUVフレームバッファーを維持する必要があります. これらのバッファは、再構築中の現在のフレーム、直前に再構築されたフレーム、最新のゴールデンフレーム、および最新のaltrefフレームを保持します. 

ほとんどの実装では、これらのバッファに、可視画像の4つのエッジすべてを超えて適度な数のピクセルを拡張する「不可視」ピクセルを「パディング」する必要があります. これにより、すべての（またはほとんどの）予測ブロック（前のフレームの可視領域内にあることが保証されていない）が使用可能な画像データをアドレス指定できるようになるため、フレーム間予測が簡素化されます. 

選択したパディングの量に関係なく、画像の上（または下）の非表示の行は、画像の一番上（または一番下）の行のコピーで埋められます. 画像の左（または右）の非表示の列は、左端（または右端）の表示行のコピーで埋められます. そして、4つの目に見えないコーナーは、対応する目に見えるコーナーピクセルのコピーで埋められます. これらの予測バッファの使用（およびハローの推奨サイズ）については、このドキュメントの後半で、モーションベクトル、フレーム間予測、およびサブピクセル補間について詳しく説明します. 

フレームヘッダーの説明に示されているように、画像のサイズはキーフレームごとに指定されます（変更される可能性があります）. これらのバッファ（およびサイズが画像のサイズに依存するその他のデータ構造）は、ディメンションがデコードされた直後に割り当て（または再割り当て）する必要があります. 

後の詳細のためにほとんどの詳細を残して、以下はデコードプロセスの概要です. 

最初に、フレームヘッダー（最初のデータパーティションの先頭）がデコードされます. デコーダーの維持状態を変更または拡張することで、マクロブロックごとのデータを解釈できるコンテキストが提供されます. 

マクロブロックデータは、ラスタースキャンの順序で発生します（処理する必要があります）. このデータは2つ以上の部分に分かれています. 最初の（予測またはモード）部分は、最初のデータパーティションの残りの部分にあります. 他の部分は、残差信号のDCT/WHT係数のデータパーティションを構成します. マクロブロックごとに、予測データを残差の前に処理する必要があります. 

各マクロブロックは、4つの可能なフレームのうちの1つ（および1つのみ）を使用して予測されます. キーフレーム内のすべてのマクロブロック、およびフレーム間内のすべてのイントラコーディングされたマクロブロックは、現在のフレーム内のすでにデコードされたマクロブロックを使用して予測されます. フレーム間内のマクロブロックは、前のフレーム、ゴールデンフレーム、またはaltrefフレームを使用して予測することもできます. このようなマクロブロックは、相互にコード化されていると言われます. 

予測の目的は、すでに構築された画像データを使用して、再構築されている元の画像の部分を概算することです. 予測モードの効果は、この近似を含むマクロブロックサイズの予測バッファーを書き込むことです. 

予測方法に関係なく、残差DCT信号はデコードされ、量子化され、逆変換され、予測バッファーに追加されて、現在のフレームバッファーの正しい位置に格納される、マクロブロックの（ほぼ最終的な）再構成値が生成されます.  . 

残差信号は、24個（16個のY、4個のU、および4個のV）の4x4量子化および可逆圧縮DCT変換で構成され、非圧縮ソースの元のマクロブロックと予測バッファーの差を近似します. ほとんどの予測モードでは、16個のYサブブロックの0番目の係数は、上記の2次仮想Y2サブブロックの25番目のWHTを介して表されます. 

イントラ予測は、フレームの空間的コヒーレンスを利用します. 16x16輝度（Y）および8x8彩度（UV）コンポーネントは、すでに再構築された（16ピクセル長の輝度、8ピクセル長の彩度）から開始して、ピクセル伝播の4つの単純な手段の1つを使用して互いに独立して予測されます. 現在のマクロブロックの上の行と左の列. 4つの方法は次のとおりです. 

1.予測バッファ全体に上から行をコピーします. 

2.予測バッファー全体で左から列をコピーします. 

3.行と列の平均値を予測バッファー全体にコピーします. 

4.左上隅からの（固定された）2番目の差（水平および垂直）を使用した行と列からの外挿. 

さらに、16個のYサブブロックは、10個の異なるモードの1つを使用して互いに独立して予測でき、そのうち4個は上記の4x4アナログであり、6個の「対角」予測方法で拡張されます. 予測には2つのタイプがあります. 1つはイントラ予測で、もう1つは（すべてのモードの中で）、残差信号は16の4x4YサブブロックDCTのDC部分をエンコードするためにY2ブロックを使用しません. この「独立したYサブブロック」モードは、8x8クロマ予測に影響を与えません. 

相互予測は、近くのフレーム間の時間的コヒーレンスを利用します. 予測フレーム自体の選択を除いて、前のフレームに基づく相互予測と、ゴールデンフレームまたはaltrefフレームに基づく相互予測に違いはありません. 

相互予測は概念的に非常に単純です. 効率の理由から、現在のマクロブロックと予測フレームの対応するセクションとの関係をエンコードする方法はいくつかありますが、最終的に16個のYサブブロックのそれぞれは、予測フレームの4x4サブブロックに関連付けられ、そのフレーム内での位置が決まります. 現在のサブブロックの位置とは（通常は小さい）変位が異なります. これらの2次元変位は、モーションベクトルと呼ばれます. 

VP8で使用される動きベクトルの精度は1/4ピクセルです. たまたま整数（整数）成分を持つ動きベクトルを使用したサブブロックの予測は非常に簡単です. 前のフレーム、ゴールデンフレーム、またはaltrefフレームの変位したブロックからのピクセルの4x4ブロックは、現在の正しい位置にコピーされるだけです. マクロブロックの予測バッファー. 

部分変位は、概念的および実装上、より複雑です. それらは、厳密に言えば、存在しないサンプル値の推論（または合成）を必要とします. これは信号処理における最も基本的な問題の1つであり、その主題に精通している読者は、VP8が採用したアプローチが堅牢性、精度、および効率のバランスが取れていることに気付くでしょう. 

以下の実装の説明の詳細を残して、ピクセル補間は、合成されるピクセルの水平方向と垂直方向の両方の両側に3つのピクセルをカーネルフィルター（妥当な精度の整数演算を使用）を適用することによって計算されます. 結果として得られる合成ピクセルの4x4ブロックは、整数変位の場合とまったく同じ位置にコピーされます. 

8つの彩度サブブロックのそれぞれは同様に処理されます. それらの動きベクトルが明示的に指定されることはありません. 代わりに、各クロマサブブロックの動きベクトルは、フレームの同じ領域を占める4つのYサブブロックのベクトルを平均することによって計算されます. クロマピクセルはルマピクセルの2倍の直径（および4倍の面積）を持っているため、計算されたクロマ動きベクトルの解像度は1/8ピクセルですが、各サブブロックのピクセルをコピーまたは生成する手順は、ルマ平面. 

すべてのマクロブロックが生成された後（DCT / WHT残差で予測および修正された後）、フィルタリングステップ（ループフィルター）がフレーム全体に適用されます. ループフィルターの目的は、マクロブロック間の境界およびマクロブロックのサブブロック間のブロッキングアーティファクトを減らすことです. このフィルターは「コーディングループ」の一部であるため、「ループフィルター」という用語が使用されます. つまり、後続のフレームを予測するために使用される再構築されたフレームバッファに影響します. これは、前に説明した後処理フィルターとは異なります. 後処理フィルターは、表示されたビデオにのみ影響し、後続のフレームには「フィードイン」しません. 

次に、データで通知された場合、現在のフレームがゴールデンフレーム予測バッファおよび/またはaltrefフレームバッファを置き換える可能性があります. 

次に、フレームバッファのハローが上記のように埋められます. 最後に、少なくともデコードに関する限り、次のフレームの準備として、「現在の」フレームバッファと「最後の」フレームバッファ（への参照）を交換する必要があります. 

生成されたフレームを表示する前に、さまざまなプロセスが必要になる（または必要になる）場合があります. 以下のフレーム寸法情報で説明されているように、フレームの切り捨ておよび/またはアップスケーリングが必要になる場合があります. 一部の再生システムでは、異なるフレーム形式（RGB、YUY2など）が必要になる場合があります. 最後に、「はじめに」で述べたように、表示前に画像をさらに後処理またはフィルタリングすることが望ましい場合があります. このドキュメントの主な目的はデコード仕様であるため、このドキュメントでは後処理は指定されていません. 

VP8で使用される予測と修正の基本的な考え方は単純ですが、詳細の多くは非常に複雑です. 確率の管理は特に複雑です. イントラ予測と動きベクトル仕様のさまざまなモードには確率が関連付けられているだけでなく、DCT係数と動きベクトルのコーディングとともに、これらの確率はさまざまなコンテキスト情報に基づいていることがよくあります（デコードされたものから計算されます）. 遠い）、およびフレームヘッダーを介した明示的な変更. 

デコードとフレーム再構築の「トップレベル」は、リファレンスデコーダファイルdixie.c（セクション20.4）に実装されています. 

これで、デコードと再構築の概要は終わりです. 引き続き、個々の側面についてさらに詳しく説明します. 

デコーダーの実装に対する合理的な「分割統治」アプローチは、キーフレームのみで構成されるストリームをデコードすることから始めることです. それが確実に機能した後、完全な機能を試みた場合よりも簡単にフレーム間処理を追加できます

すぐに. これに従って、最初にキーフレームのデコードに必要なコンポーネント（そのほとんどはフレーム間デコードでも使用されます）について説明し、フレーム間専用のトピックで締めくくります. 

6.アルゴリズムの説明
このドキュメントの目的は、リファレンスデコーダのソースコードとともに、VP8ビデオストリームのデコードと再構築のためのプラットフォームに依存しない手順を指定することであるため、多くの（小さな）アルゴリズムを正確に記述する必要があります. 

そのほぼ普遍性、簡潔さ、特定の精度で計算を簡単に記述する能力、およびOn2の参照VP8デコーダーがCで記述されているという事実により、これらのアルゴリズムフラグメントはCプログラミング言語を使用して記述され、以下のいくつかの簡単な定義で拡張されます. 

Cの標準的な（そして最良の）リファレンスは[Kernighan]です. 

このドキュメントでは、多くのコードフラグメントを紹介します. 一部は、リファレンスデコーダーの対応するセクションとほぼ同じです. 他は異なります. 大まかに言えば、このような違いには3つの理由があります. 

1.効率上の理由から、リファレンスデコーダのバージョンはあまりわかりにくい場合があります. 

2.参照デコーダーは、多くの場合、ここで説明または使用する必要のないコンテキストを維持するために大きなデータ構造を使用します. 

3.このドキュメントの作成者は、同じアルゴリズムの異なる表現が説明を容易にする可能性があると感じました. 

選択した表示に関係なく、ここで説明するアルゴリズムのいずれかによって実行される計算は、参照デコーダーの対応する部分によって実行される計算と同じです. 

すべてのVP8デコードアルゴリズムは整数演算を使用します. 算術精度の指定を容易にするために、次のタイプを定義します. 

   ----コードブロックを開始--------------------------------------
        
   typedef signed char int8; /*正確に8ビット幅のsignedint* /
   typedef unsigned char uint8; /*符号なし""* /
        
   typedef short int16; /*正確に16ビット幅のsignedint* /
   typedef unsigned int16 uint16; /*符号なし""* /
        
   /*int32は少なくとも32ビット幅の符号付き整数型です*/
        
   typedef long int32; /*すべてのシステムで動作することが保証されています*/
   typedef int int32; /*一部のシステムではより効率的になります*/
        
typedef unsigned int32 uint32;

   / *符号なし整数型、少なくとも16ビット幅、正確なサイズ
      使用しているプロセッサに最も便利です*/
        
typedef unsigned int uint;

   / *ピクセル自体は8ビットの符号なし整数ですが、
      ピクセル演算は、多くの場合、16ビットまたは32ビットの精度で発生します. 
      結果は「飽和」するか、8ビットにクランプする必要があります
      範囲. * /
        
typedefuint8ピクセル;

   ピクセルclamp255（int32 v）{return v <0？0：（v <255？v：255）;}
        
   / *以下のbool_decoderの説明で詳しく説明されているように、
       VP8は、確率を符号なし8ビット数として表します. * /
        
typedef uint8 Prob;

   ----終了コードブロック----------------------------------------
        
正直な「無限精度」の実数を含む数学関数について議論する必要がある場合があります. DCTは、最初に余弦関数cosを介して記述されます. 円周の長さと円の直径の比率は円周率で表されます. ある時点で、logで表される（底1/2）対数を取ります. pow（x、y）は、xのy乗を示します. x = 2で、yが負でない小さな整数の場合、pow（2、y）はCで1<<yとして表すことができます. 

最後に、符号付き整数を2の累乗で除算する必要がある場合があります. つまり、符号付きの数値を右シフトすることがあります. このようなシフトの動作（つまり、符号ビットの伝搬）は、おそらく驚くべきことに、C言語自体では定義されておらず、個々のコンパイラーに任されています. この頻繁に必要とされる操作の有用性のために、少なくとも言語によって定義されるべきであり（符号ビットを自然に伝播するため）、少なくとも、合理的なコンパイラーによって正しく実装されるべきであるということは議論の余地があります. 厳密な移植性のために、これらのシフトが発生したときに注意を喚起しようとします. 

7.ブールエントロピーデコーダー
上記の概要で説明したように、基本的にVP8データストリーム全体がブールエントロピーコーダーを使用してエンコードされます. 

bool_decoderを理解することは、VP8デコンプレッサーの実装にとって重要であるため、bool_decoderについて詳しく説明します. 圧縮されたデータパーティションを書き込むためにコンプレッサーが使用するbool_encoderと組み合わせてbool_decoderを理解する方が簡単です. 

bool_encoderは、一度に1つのbool（0または1のブール値）をエンコード（およびbool_decoderデコード）します. その目的は、読み取り時に同一の対応する確率を使用して、書き込み時にゼロまたは1になる確率を（定数または以前にコード化された情報を介して）十分に推定できる一連のブールを可逆圧縮することです.  . 

読者がおそらく知っているように、ブール値が1よりもはるかにゼロである可能性が高い場合（たとえば）、平均して、値ごとに1ビットよりはるかに少ないビットを使用して忠実にエンコードできます. bool_encoderはこれを利用します. 

1940年代に、[Shannon]は、一連のboolの忠実なエンコーディング（確率分布が既知であり、互いに独立している）の平均データレートに下限があること、およびこれを近似するエンコーディングアルゴリズムがあることを証明しました. 必要に応じて下限を設定します. 

ゼロになる確率がpである（そして1になる確率が1-pである）boolのシーケンスをエンコードする場合、値ごとの可能な最低のデータレートは

   plog（p）+（1-p）log（1-p）;
        
対数を底1/2にすると、データレートはビット/値で表されます. 

2つの簡単な例を示します. 極端な例として、p = 1/2の場合、log（p）= log（1-p）= 1であり、ブールあたりの可能な最低データレートは1/2 + 1/2=1です. つまり、単に文字通りビットを書き出す以上のことはできません. 別の極端な例として、pが非常に小さい場合、たとえばp = 1/1024の場合、log（p）= 10、log（1-p）は約.0014であり、可能な最低のデータレートは約10/1024+.0014です. ブールあたり約1/100ビット. 

VP8データストリーム内のほとんどのブール値は1/2に近い確率がゼロであるため、bool_encoderによって提供される圧縮はVP8のパフォーマンスにとって重要です. 

VP8で使用されるブールコーダーは、算術コーダーの変形です. 算術符号化（およびその他の可逆圧縮技術）の優れた説明は、[Bell]にあります. 

7.1. 基礎となるコーディング理論
ブールコーダーが使用する基本的な考え方は、データストリーム全体（この場合はパーティションのいずれか）を、0 <= x <1の単一の数値xのバイナリ展開と見なすことです. xのビット（またはバイト）は次のとおりです. もちろん、上位から下位に書き込まれ、b [j]（B [j]）がパーティション内のj ^（th）ビット（バイト）である場合、値xは単純に合計になります（j = 1で始まる） pow（2、-j）* b [j]またはpow（256、-j）*B[j]の. 

最初のブール値がコーディングされる前に、xのすべての値が可能です. 

各ブール値のコーディングは、コーディングされる確率に比例してxの可能な値を制限します. p1が最初のブール値がゼロになる確率であり、ゼロがコード化されている場合、xの可能な値の範囲は0 <=x<p1に制限されます. 1つがコード化されている場合、範囲はp1 <=x<1になります. 

同じ考えを繰り返すことでコーディングを続けます. すべての段階で、xの可能な値の間隔a <=x<bがあります. pがこの段階でゼロがコード化される確率であり、ゼロがコード化される場合、間隔はa <= x <a +（p（ba））になります. 1つがコーディングされている場合、xの可能な値はa +（p（ba））<=x<bに制限されます. 

コーディングする値が有限であると仮定すると、エンコーダーは最後のブール値を受け取った後、最後の間隔にある任意の値xを出力として書き込むことができます. VP8は、最後の間隔の左側のエンドポイントを書き込むだけです. その結果、エンコードがいつでも停止した場合に生成される出力は、各ブール値がエンコードされるときに増加するか、同じままになります. 

デコードは、パラレルエンコーディングです. デコーダーには、初期制限0 <= x <1のみを持つ数値xが表示されます. 最初のブール値をデコードするために、デコーダーには最初の確率p1が与えられます. x <p1の場合、ゼロがデコードされます. x> = p1の場合、1がデコードされます. いずれの場合も、xの新しい制限（つまり、xの可能な値の間隔）が記憶されます. 

デコードはまったく同じ方法で続行されます. a<=x<bが現在の間隔であり、確率pがゼロのboolをデコードする場合、a <= x <a +（p（ba））の場合はゼロを返します.  a +（p（ba））<=x<bの場合は1. いずれの場合も、次のブール値をデコードする準備として、新しい制限が記憶されます. 

上で概説したプロセスは、確率と範囲を表すために実数の無限精度を使用します. 確かに、このプロセスを実現し、提供された確率が値の分布と一致する多数のboolをコーディングできれば、エンコードされるboolの数が増えるにつれて、達成されるデータレートは理論上の最小値に近づきます. 

残念ながら、コンピューターは有限の精度で動作するため、上記の理論的に完全なプロセスへの近似が必要です. このような近似によりデータレートが増加しますが、かなり中程度の精度で、さまざまなデータセットの場合、この増加は無視できます. 

唯一の概念上の制限は、第1に、コーダーの確率を有限の精度で表現する必要があること、第2に、デコーダーが一定量の入力を調べることにより、値の間隔に対する個々の変更を検出できることです. 実際問題として、実装の詳細の多くは、コーダーが小さな「ウィンドウ」のみを使用して機能し、任意精度の数値xを段階的に読み書きできるという事実に由来しています. 

7.2. 実用的なアルゴリズムの説明
VP8のブールコーダーは8ビットの確率pで動作します. このようなpの範囲は0<=p<=255です. pで表される実際の確率はp/256です. また、コーダーは、ブール値のデコードに8ビットの比較しか必要としないように設計されているため、エンコーダーとデコーダーの両方の状態を、少数の符号なし16ビット整数を使用して簡単に表すことができます. 

最初にビット単位の入力と出力を使用してアルゴリズムを説明すると、詳細が最も簡単に理解できます. このビットストリームと書き込み/読み取りビットの位置を維持する機能とは別に、エンコーダには、すでに出力されているビットに1を追加する機能も必要です. nビットを書き込んだ後、既存の出力に1を追加することは、xにpow（2、-n）を追加することと同じです. 

エンコーダは、ビット位置とともに、「ボトム」と「レンジ」と呼ばれる2つの符号なし8ビット数を維持する必要があります. すでに書き込まれているnビットにwを書き込み、1バイト先の現在のビット位置のスケールにS = pow（2、--n-8）を書き込むと、wの将来のすべての値v（最終値vを含む）に次の制約があります.  = x）：

   w +（S *ボトム）<= v <w +（S *（ボトム+レンジ））
        
したがって、すでに書き込まれているビットwにbottomを追加すると、可能な値の間隔の左側の端点が得られ、bottom + rangeを追加すると右側の端点が得られ、範囲自体（現在の出力位置にスケーリング）が間隔の長さになります. 

確率的エンコーディングが適度に正確であるように、範囲を2倍以上変化させないようにします. 範囲128<=範囲<=255内にとどまります. 

ゼロになる確率がprob/256-であり、1になる確率が（256-prob）/ 256--であり、1 <= prob<=255であるブール値valをエンコードするプロセスは次のとおりです. 

符号なし16ビット乗算とそれに続く符号なし右シフトを使用して、符号なし8ビット分割値を計算します. 

   分割=1+（（（範囲-1）*確率）]] >> 8）
        
splitはおおよそ（prob / 256）*範囲であり、範囲1 <= split <=範囲-1内にあります. これらの範囲は、以下で説明するデコード手順の正確さを保証します. 

エンコードされる入力ブール値がfalseの場合、左側の区間の端点を下のままにして範囲を縮小し、splitに置き換えます. 着信値がtrueの場合、左端を上に移動して下+分割し、キャリーをすでに書き込まれた値wに伝播し（これはwに1を追加する機能が必要な場所です）、範囲を範囲に縮小します-分割. 

エンコードされた値に関係なく、範囲は縮小され、境界は1 <= range <= 254になります. range<128の場合、エンコーダーはそれを2倍にし、上位ビットをボトムから出力にシフトします.  、128<=範囲<=255になるまで、このプロセスを一度に1ビットずつ繰り返します. これが完了すると、エンコーダーは上記の制約を維持しながら、別のブール値を受け入れる準備が整います. 

最後のブール値をエンコードした後、ビットストリームにボトムを追加することでパーティションを完成させることができます. 

デコーダーはエンコーダーの状態を模倣します. これは、入力ビット位置とともに、2つの符号なし8ビット数、エンコーダーによって維持される範囲と同じ範囲、および値を維持します. 一度に1つのブール値をデコードすると、デコーダーは（事実上）エンコーダーと同じ左インターバルエンドポイントを追跡し、残りの入力からそれを減算します. ビットストリームの未読部分を8ビット値に追加すると、エンコードされた実際の値と既知の左側のエンドポイントの差が得られます. 

デコーダーは、範囲= 255を設定し、最初の16入力ビットを値に読み込むことによって初期化されます. デコーダーは範囲を維持し、エンコーダーとまったく同じ方法でスプリットを計算します. 

ブール値をデコードするために、値を分割と比較します. 値<splitの場合、boolはゼロであり、範囲はsplitに置き換えられます. value> = splitの場合、boolは1であり、rangeはrange --splitに置き換えられ、valueはvalue--splitに置き換えられます. 

この場合も、範囲は少なくとも128になるまで一度に1ビットずつ倍増します. 値は並行して倍増し、毎回新しい入力ビットを最下位にシフトします. 

値の値を未読の入力ビットと一緒に書き込み、範囲の範囲を右側にゼロで無期限に拡張すると、値<範囲の条件がデコーダーによって常に維持されます. 特に、2倍になるときに値からシフトアウトされるビットは常にゼロです. 

7.3. 実際の実装
以下のCコードは、上記のエンコーダーとデコーダーの完全な実装を提供します. これらは「ビットアットアタイム」バージョンと論理的に同一ですが、ビットストリームの2、3バイトの余分なバイトを内部的にバッファリングします. これにより、I / Oを（より実際的には）一度に1バイト実行できるようになり、エンコーダーが既に書き込まれたデータに伝播する必要のあるキャリーの数が大幅に削減されます. 

別の（論理的に同等の）実装は、参照デコーダーファイルbool_decoder.h（セクション20.2）にあります. 

   ----コードブロックを開始--------------------------------------
        
   /*最初のエンコーダー*/
        
   typedef struct {
     uint8*出力; /*書き込まれる次のバイトへのptr*/
     uint32範囲; / *128<=範囲<=255* /
     uint32ボトム; /*残りの出力の最小値*/
     int bit_count; /*出力バイトの前のシフト数
                        利用可能です */
   } bool_encoder;
        
   / *ブールを書き込む前に、エンコーダの初期状態を設定する必要があります. * /
        
   void init_bool_encoder（bool_encoder * e、uint8 * start_partition）
   {{
     e-> output = start_partition;
     e->範囲=255;
     e-> bottom = 0;
     e-> bit_count = 24;
   }
        
   / *エンコードによって、伝播する必要のあるキャリーが生成されることはめったにありません
      すでに書き込まれた出力に. 算術はそれを保証します
      伝播は、
      出力. 言い換えれば、エンコードされた値xは常に小さいです
      1つより. * /
        
   void add_one_to_output（uint8 * q）
   {{
     while（*-q == 255）
       * q = 0;
     ++ * q;
   }
        
   /*メイン関数はbool_valueを書き込みます. 
      ゼロは（予想される）prob/256です. * /
        
   void write_bool（bool_encoder * e、Prob prob、int bool_value）
   {{
     / *分割はおよそ（範囲*確率）/ 256であり、
        重要なのは、厳密にゼロより大きく、厳密に
        範囲よりも小さい*/
        
     uint32 split = 1 +（（（e-> range-1）* prob）>> 8）;
        
     if（bool_value）{
       e->bottom+=分割; /*間隔の一番下に移動します*/
       e->範囲-=分割; /*対応する範囲の減少を伴う*/
     } そうしないと
       e->範囲=分割; / *範囲を狭め、下部をそのままにします* /
        
     while（e-> range <128）
     {{
       e->範囲<<=1;
        
       if（e-> bottom＆（1 << 31））/*キャリーを検出*/
         add_one_to_output（e-> output）;
        
       e->ボトム<<=1; /*ボトムをシフトする前*/
        
       if（！-e-> bit_count）{/*下位バイトの上位バイトを書き出す...* /
        
         * e-> output ++ =（uint8）（e-> bottom >> 24）;
        
         e-> bottom＆=（1 << 24）-1; /*...下位3バイトを維持*/
        
         e-> bit_count = 8; /*次の出力まで8シフト*/
       }
     }
   }
        
   / *最後の関数をエンコードした後、この関数を（正確に1回）呼び出します
      書き込まれているパーティションのbool値*/
        
   void flush_bool_encoder（bool_encoder * e）
   {{
     int c = e-> bit_count;
     uint32 v = e-> bottom;
        
     if（v＆（1 <<（32 --c）））/ *伝播（ありそうもない）キャリー* /
       add_one_to_output（e-> output）;
     v << = c＆7; /*残りの出力をシフトする前*/
     c >> = 3; /*内部バッファの先頭に*/
     while（--c> = 0）
       v << = 8;
     c = 4;
     while（--c> = 0）{/ *残りのデータを書き込み、場合によっては埋め込み* /
       * e-> output ++ =（uint8）（v >> 24）;
       v << = 8;
     }
   }
        
   / *デコーダーの状態は、エンコーダーの状態と正確に一致します. 
      「値」は、残りの入力とともに、
      完全なエンコードされた数値xから左端まで
      現在のコーディング間隔. * /
        
   typedef struct {
     uint8*入力; /*次の圧縮データバイトへのポインタ*/
     uint32範囲; /*常にエンコーダの範囲と同じ*/
     uint32値; /*少なくとも8つの有効ビットが含まれています*/
     int bit_count; /*シフトアウトされたビット数
                            値、最大7 * /
   } bool_decoder;
        
   / *からboolを読み取る前に、この関数を呼び出します
      パーティション. * /
        
   void init_bool_decoder（bool_decoder * d、uint8 * start_partition）
   {{
     {{
       int i = 0;
       d->値=0; /*値=最初の2入力バイト*/
       while（++ i <= 2）
        
         d-> value =（d-> value << 8）| * start_partition ++;
     }
        
     d-> input = start_partition; /*読み取られる次のバイトへのptr*/
     d->範囲=255; /*初期範囲がいっぱいです*/
     d-> bit_count = 0; /*まだビットをシフトアウトしていません*/
   }
        
   /*メイン関数は確率prob/256でエンコードされたブール値を読み取ります. 
      もちろん、これは、
      boolが書かれました. * /
        
   int read_bool（bool_decoder * d、Prob prob）
   {{
     /*範囲と分割は対応する値と同じです
        このブール値が書き込まれたときにエンコーダーによって使用されました*/
        
     uint32 split = 1 +（（（d-> range-1）* prob）>> 8）;
     uint32 SPLIT = split << 8;
     int retval; /*0または1になります*/
        
     if（d-> value> = SPLIT）{/*1をエンコード*/
       retval = 1;
       d->範囲-=分割; /*範囲を狭める*/
       d-> value-= SPLIT; /*間隔の左端を減算します*/
     } else{/*ゼロをエンコード*/
       retval = 0;
       d->範囲=分割; / *範囲を縮小し、左端を変更しない* /
     }
        
     while（d-> range <128）{/*無関係な値のビットをシフトアウト*/
       d->値<<=1;
       d->範囲<<=1;
       if（++ d-> bit_count == 8）{/*一度に8ビットずつ新しいビットにシフト*/
         d-> bit_count = 0;
         d-> value | = * d-> input ++;
       }
     }
     retvalを返します. 
   }
        
   / *コンビニエンス関数は「リテラル」、つまり「num_bits」を読み取ります-
      ビットが上位から下位になり、
      各ビットは確率128（つまり、1/2）でエンコードされます. * /
        
   uint32 read_literal（bool_decoder * d、int num_bits）
   {{
     uint32 v = 0;
        
     while（num_bits--）
       v =（v << 1）+ read_bool（d、128）;
     vを返す;
   }
        
   /*バリアントは符号付きの数値を読み取ります*/
        
   int32 read_signed_literal（bool_decoder * d、int num_bits）
   {{
     int32 v = 0;
     if（！num_bits）
       0を返します. 
     if（read_bool（d、128））
       v = -1;
     while（--num_bits）
       v =（v << 1）+ read_bool（d、128）;
     vを返す;
   }
        
   ----終了コードブロック----------------------------------------
        
8.圧縮データコンポーネント
最も低いレベルでは、VP8の圧縮データは、確率的にエンコードされた一連のブールです. このデータのほとんどは、boolsから作成された（わずかに）大きなセマンティックユニットで構成されています. これについては、ここで説明します. 

これらの記述は、データ形式の仕様内のC式で使用されることがあります. このコンテキストでは、適切なbool_decoder dへの呼び出しの戻り値を参照し、現在の参照ポイントから（いつものように）読み取ります. 

   + -------------- + ------- + -------------------------- ------------------ +
   | 電話| Alt. | 戻る|
   + -------------- + ------- + -------------------------- ------------------ +
   | Bool（p）| B（p）| 0である確率p/256でブール値. 
   | | | read_bool（d、p）の戻り値. |
   | | | |
   | フラグ| F | 1ビットフラグ（B（128）または|と同じもの
   | | | L（1））. 省略形F. |の戻り値
   | | | read_bool（d、128）. |
   | | | |
   | 点灯（n）| L（n）| n個のフラグとしてエンコードされた符号なしnビット数|
   | | | （「リテラル」）. 省略されたL（n）. |
   | | | ビットは上位から下位に読み取られます. |
   | | | read_literal（d、n）の戻り値. |
   | | | |
   | SignedLit（n）| | |と同様にエンコードされた符号付きnビット数
   | | | L（n）. |の戻り値
   | | | read_signed_literal（d、n）. これらは|
   | | | レア. |
   | | | |
   | P（8）| | 8ビットの確率. |と違いはありません
   | | | L（8）ですが、これを使用することもあります|
   | | | 確率を強調する表記|
   | | | コーディングされています. |
   | | | |
   | P（7）| | 8ビットの7ビット仕様|
   | | | 確率. L（7）番号xとしてコード化されています. |
   | | | 結果として得られる8ビットの確率はx？x |
   | | | << 1：1. |
   | | | |
   | F？X | | trueの場合、その後に|が続くフラグ. 
   | | | データの一部X. 
   | | | |
        
   | F？X：Y | | trueの場合、その後にX|が続くフラグ. 
   | | | そして、falseの場合、Yが続きます. 
   | | | Yが|である値を表すために使用されます
   | | | 暗黙のデフォルト（データにエンコードされていません|
   | | | ストリーム）、Fのように？P（8）：255、これ|
   | | | オプションの確率を表します. 
   | | | フラグがtrueの場合、確率が指定されます|
   | | | フラグが|の場合、8ビットリテラルとして
   | | | falseの場合、確率はデフォルトで255になります. 
   | | | |
   | B（p）？X | B（p）？| ブール値を使用した上記のバリアント|
   | | X：Y | 確率がないインジケーター|
   | | | 必然的に128. 
   | | | |
   | T | | 小さなアルファベットからのツリーエンコード値. |
   + -------------- + ------- + -------------------------- ------------------ +
        
最後のタイプは詳細が必要です. 値が少数の可能性（アルファベット）に制限されているものをエンコードしたいことがよくあります. 

これは、アルファベットを小さな二分木の葉として表すことによって行われます. ツリーの（非リーフ）ノードには確率pが関連付けられており、read_bool（d、p）の呼び出しに対応しています. ゼロはノードの下の左側のブランチを選択することと見なし、1は右側のブランチを選択することと見なします. 

したがって、ツリーの深さがxであるすべての値（リーフ）は、read_boolを正確にx回呼び出した後にデコードされます. 

n個の可能な値のアルファベットのエンコーディングを表すツリーには、その形状に関係なく、常にn-1個の非リーフノードが含まれます（これは、nの誘導によって簡単に確認できます）. 

与えられたアルファベットをそのように表現する方法はたくさんあります. ツリーの選択はデータレートにほとんど影響を与えませんが、デコーダーのパフォーマンスには影響を与えます. VP8で使用されるツリーは、（平均して）read_boolの呼び出し回数を最小限に抑えるように選択されています. これは、可能性が高い値が可能性が低い値よりもツリーの深さが小さくなるようにツリーを形成することを意味します. 

ハフマンコーディングに精通している読者は、各値の確率とともにアルファベットを指定すると、関連するハフマンツリーがread_boolへの予想される呼び出し数を最小限に抑えることに気付くでしょう. 

このような読者は、ここで説明するコーディング方法では、ハフマン法よりも高いデータレートが得られることはなく、実際、多くの場合、はるかに低いデータレートになることも理解できます. 実際、ハフマン符号化は、各ノードの確率が128（つまり、1/2）に固定されているこの方法の特殊なケースにすぎません. 

8.1. ツリーコーディングの実装
ツリーデータ構造の提案された実装を示し、続いてVP8によるその使用例をいくつか示します. 

小さな正の整数、通常はゼロからカウントアップする列挙型を使用して値を表すのが最も便利です. VP8によってツリーコード化される最大のアルファベット（セクション13で説明されているDCT係数のコード化に使用）には、12個の値しかありません. このアルファベットのツリーには11個の内部ノードが追加されているため、合計23個の位置があります. したがって、8ビットの数値は、ツリーの位置と戻り値の両方に簡単に対応できます. 

次に、ツリーは、8ビット整数（のペア）の配列としてコンパクトに表すことができます. 各（偶数）配列インデックスは、ツリーの内部ノードに対応します. もちろん、0番目のインデックスはツリーのルートに対応します. 配列エントリは、内部ノードの下のサブツリーの左（0）と右（1）のブランチに対応するペアで提供されます. 正の（偶数の）ブランチエントリはより深い内部ノードのインデックスであり、非正のエントリvは値が-vであるリーフに対応するという規則を使用します. 

ツリーでコード化された値に関連付けられたノード確率は、対応するツリー位置のインデックスの半分のインデックスを持つ配列に格納されます. 確率配列の長さは、アルファベットのサイズより1つ短くなります. 

上記を実装したCコードは次のとおりです. データ構造の利点に注意する必要があります. 構造自体の小ささを除けば、ツリー指向の読み取りアルゴリズムは基本的に1行のコードです. 

   ----コードブロックを開始--------------------------------------
        
   / *ツリー仕様は、単に8ビット整数の配列です. * /
        
   typedef int8 tree_index;
   typedef const tree_index Tree [];
        
   /*現在のデコーダーでツリーコード化された値を読み取って返します
      ポジション. * /
        
   int treed_read（
     bool_decoder * const d、/*bool_decoderは常に0または1を返します*/
     ツリーt、/*ツリー仕様*/
     const Prob p []/*対応する内部ノードの確率*/
   ）{
     レジスタtree_indexi= 0; /*ルートから開始*/
        
     /*葉に達するまで木を降ります*/
        
     while（（i = t [i + read_bool（d、p [i >> 1]）]）> 0）{}
        
     -iを返します. /*戻り値は非正のインデックスの否定です*/
   }
        
   ----終了コードブロック----------------------------------------
        
ツリーベースのデコードは、参照デコーダファイルbool_decoder.h（セクション20.2）に実装されています. 

8.2. ツリーコーディングの例
マルチパートの例として、マクロブロックのデコードのセマンティクス（もちろん以下で取り上げます）に深く入り込むことなく、予測内のマクロブロックの「モード」コーディングを見ていきます. 

統計の違いにより、Y（または輝度）モードのエンコーディングでは、キーフレーム用とインターフレーム用の2つの異なるツリーが使用されることがあります. これは、同じデータセットのVP8で、さまざまな状況下でさまざまなツリーによってコーディングされている唯一のインスタンスです. UV（またはクロマ）モードはYモードの適切なサブセットであり、そのため、独自のデコードツリーがあります. 

   ----コードブロックを開始--------------------------------------
        
   typedef列挙型
   {{
       DC_PRED、/*上の行と左の列を使用してDCを予測します*/
       V_PRED、/*上の行を使用して行を予測します*/
       H_PRED、/*左側の列を使用して列を予測します*/
       TM_PRED、/*「TrueMotion」で2番目の違いを伝播します*/
        
       B_PRED、/*各Yサブブロックは個別に予測されます*/
        
       num_uv_modes = B_PRED、/*最初の4つのモードはクロマに適用されます*/
       num_ymodes/*すべてのモードがlumaに適用されます*/
   }
   intra_mbmode;
        
   /*前述のツリーと暗黙のコーディング
      コメント. 
      実際の（つまり、正の）インデックスは常に偶数です. 
      値（つまり、非正）のインデックスは任意です. * /
        
   const tree_index ymode_tree [2 *（num_ymodes-1）] =
   {{
    -DC_PRED、2、/ *ルート：DC_PRED = "0"、"1"サブツリー*/
     4、6、/*"1"サブツリーには2つの子孫サブツリーがあります*/
      -V_PRED、-H_PRED、/ * "10"サブツリー：V_PRED = "100"、
                           H_PRED = "101" * /
      -TM_PRED、-B_PRED / * "11"サブツリー：TM_PRED = "110"、
                           B_PRED = "111" * /
   };
        
   const tree_index kf_ymode_tree [2 *（num_ymodes-1）] =
   {{
    -B_PRED、2、/ *ルート：B_PRED = "0"、"1"サブツリー*/
     4、6、/*"1"サブツリーには2つの子孫サブツリーがあります*/
      -DC_PRED、-V_PRED、/ * "10"サブツリー：DC_PRED = "100"、
                              V_PRED = "101" * /
      -H_PRED、-TM_PRED / * "11"サブツリー：H_PRED = "110"、
                              TM_PRED = "111" * /
   };
        
   const tree_index uv_mode_tree [2 *（num_uv_modes-1）] =
   {{
    -DC_PRED、2、/ *ルート：DC_PRED = "0"、"1"サブツリー*/
     -V_PRED、4、/ * "1"サブツリー：V_PRED = "10"、
                             「11」サブツリー*/
      -H_PRED、-TM_PRED / * "11"サブツリー：H_PRED = "110"、
                             TM_PRED = "111" * /
   };
        
   / * bool_decoder dが与えられると、Yモードは次のようにデコードされる可能性があります. * /
        
   const Prob pretend_its_huffman [num_ymodes-1] =
     {128、128、128、128};
        
   Ymode =（intra_mbmode）treed_read（d、ymode_tree、
     pretend_its_huffman）;
        
   ----終了コードブロック----------------------------------------
        
参照コードの再利用が非常に容易になり、他の方法で行う理由がないため、デコーダーの実装では、このドキュメント（およびVP8のすべてのツリーコード化データの参照コード）. 

9. フレームヘッダー
各フレームの開始時と最初のデータパーティションの最初の部分にある非圧縮データチャンクには、フレーム全体に関する情報が含まれています. フィールドを出現順にリストします. ヘッダーのデコードのほとんどは、参照デコーダーファイルdixie.c（セクション20.4）で行われます. 

9.1. 非圧縮データチャンク
非圧縮データチャンクは、次のように、4つのフィールドを含む共通の（キーフレームおよびインターフレーム用の）3バイトのフレームタグで構成されます. 

1. 1ビットフレームタイプ（キーフレームの場合は0、インターフレームの場合は1）. 

2. 3ビットのバージョン番号（0〜3は、デコードの複雑さが異なる4つの異なるプロファイルとして定義されます. 他の値は、VP8データ形式の将来のバリアント用に定義される可能性があります）. 

3. 1ビットのshow_frameフラグ（現在のフレームが表示されていない場合は0、現在のフレームが表示されている場合は1）. 

4.最初のデータパーティションのサイズをバイト単位で含む19ビットフィールド. 

バージョン番号の設定は、次のように、ビットストリームの特定の機能を有効または無効にします. 

            +---------+-------------------------+-------------+
            | Version | Reconstruction Filter   | Loop Filter |
            +---------+-------------------------+-------------+
            | 0       | Bicubic                 | Normal      |
            |         |                         |             |
            | 1       | Bilinear                | Simple      |
            |         |                         |             |
            | 2       | Bilinear                | None        |
            |         |                         |             |
            | 3       | None                    | None        |
            |         |                         |             |
            | Other   | Reserved for future use |             |
            +---------+-------------------------+-------------+
        
参照ソフトウェアは、上記の表のように、バージョン番号に基づいてループフィルターも調整します. バージョン番号1は「単純な」ループフィルターを意味し、バージョン番号2および3はループフィルターがないことを意味します. ただし、このコンテキストでの「単純な」フィルター設定は、デコードプロセスに何の影響も与えず、「ループフィルターなし」設定は、参照エンコーダーにフィルターレベルを0に設定するように強制するだけです. どちらもデコードプロセスに影響しません. デコードでは、重要なループフィルター設定はフレームヘッダーの設定のみです. 

キーフレームの場合、次のように、フレームタグの後にさらに7バイトの非圧縮データが続きます. 

   ---- Begin code block --------------------------------------

   Start code byte 0     0x9d
   Start code byte 1     0x01
   Start code byte 2     0x2a

   16 bits      :     (2 bits Horizontal Scale << 14) | Width (14 bits)
   16 bits      :     (2 bits Vertical Scale << 14) | Height (14 bits)

   ---- End code block ----------------------------------------
        
次のソースコードセグメントは、開始コードの検証と、キーフレームの幅、高さ、およびスケール係数の読み取りを示しています. 

   ----コードブロックを開始--------------------------------------
        
   unsigned char *c = pbi->source+3;

   // vet via sync code
   if (c[0]!=0x9d||c[1]!=0x01||c[2]!=0x2a)
       return -1;
        
   ----終了コードブロック----------------------------------------
        
ここで、pbi->sourceはフレームの先頭を指します. 

次のコードは、ビットストリームから画像のサイズを読み取ります. 

   ----コードブロックを開始--------------------------------------
        
   pc->Width      = swap2(*(unsigned short*)(c+3))&0x3fff;
   pc->horiz_scale = swap2(*(unsigned short*)(c+3))>>14;
   pc->Height     = swap2(*(unsigned short*)(c+5))&0x3fff;
   pc->vert_scale  = swap2(*(unsigned short*)(c+5))>>14;
        
   ----終了コードブロック----------------------------------------
        
swap2マクロが別のプラットフォームでエンディアンを処理する場合：

   ----コードブロックを開始--------------------------------------
        
   #if defined(__ppc__) || defined(__ppc64__)
   # define swap2(d)  \
     ((d&0x000000ff)<<8) |  \
     ((d&0x0000ff00)>>8)
   #else
     # define swap2(d) d
   #endif
        
   ----終了コードブロック----------------------------------------
        
   各フレームは16x16マクロブロックのラスタースキャンとしてエンコードされますが、
   フレームの寸法は、必ずしも16で割り切れるわけではありません. 
   この場合、ew = 16-（幅＆15）およびeh = 16-（高さ＆15）と記述します. 
   それぞれ、余分な幅と高さ. 彼らは
        
エンコードされている場合、最後のew列とeh行は実際には画像の一部ではないため、最終出力の前に破棄する必要があります. ただし、これらの「過剰なピクセル」は、後続のフレームを予測するために使用される内部再構築バッファに保持する必要があります. 

各次元のスケーリング仕様は、次のようにエンコードされます. 

             + ------- + -------------------------------------- +
             | 値| スケーリング|
             + ------- + -------------------------------------- +
             | 0 | アップスケーリングなし（最も一般的なケース）. |
             | | |
             | 1 | 5/4アップスケール. |
             | | |
             | 2 | 5/3アップスケール. |
             | | |
             | 3 | 2つアップスケール. 
             + ------- + -------------------------------------- +
        
アップスケーリングは再構築バッファに影響を与えません. 再構築バッファはエンコードされた解像度で維持する必要があります. アップサンプリングの合理的な方法（再生環境でビデオハードウェアによってサポートされる可能性のある方法を含む）を使用できます. スケーリングはデコードに影響を与えないため、これ以上説明しません. 

セクション5で説明したように、サイズが次元に依存するデータ構造（再構築バッファなど）の割り当て（または再割り当て）がここでトリガーされます. 

9.2. 色空間とピクセルタイプ（キーフレームのみ）
           + ------- + ----------------------------------------- -+
           | フィールド| 値|
           + ------- + ----------------------------------------- -+
           | L（1）| 1ビット色空間型仕様|
           | | |
           | L（1）| 1ビットピクセル値クランプ仕様|
           + ------- + ----------------------------------------- -+
        
色空間タイプビットは次のようにエンコードされます. 

o0-[ITU-R_BT.601]で定義されているYCrCb色空間と同様のYUV色空間

o1-将来の使用のために予約済み

ピクセル値クランプタイプビットは次のようにエンコードされます. 

o 0-再構築されたピクセル値を0〜255（両端を含む）にクランプするには、デコーダーが必要です. 

o1-再構築されたピクセル値は0から255の間であることが保証されています. クランプは必要ありません. 

このサブセクションの情報は、フレーム間には表示されません. 

9.3. セグメントベースの調整
このサブセクションには、デフォルトのデコーダーの動作にセグメント適応調整を実装するための確率と値の情報が含まれています. このサブセクションのデータは、後続のセグメントごとの情報のデコードに使用され、フレーム全体に適用されます. セグメント適応調整が有効になっている場合、各マクロブロックにはセグメントIDが割り当てられます. 同じセグメントIDを持つマクロブロックは同じセグメントに属し、フレームのデフォルトのベースライン値に対して同じ適応調整が行われます. 調整は、量子化器レベルまたはループフィルター強度にすることができます. 

マクロブロックレベルでこの機能をデコードするためのコンテキストは、フレームヘッダーのサブセクションによって提供されます. このサブセクションには次のものが含まれます. 

1. 1に設定されている場合はこのフレームの機能を有効にし、0に設定されている場合は無効にするsegmentation_enabledフラグ. 機能が有効になっている場合、次のフィールドが表示されます. 

2. L（1）は、セグメントマップが現在のフレーム（update_mb_segmentation_map）に対して更新されているかどうかを示します. 

3. L（1）は、セグメントフィーチャデータアイテムが現在のフレーム（update_segment_feature_data）に対して更新されているかどうかを示します. 

4.上記の項目3（update_segment_feature_data）が1の場合、次のフィールドが表示されます. 

a. セグメント特徴データのモード（segment_feature_mode）であるL（1）は、絶対値モード（0）またはデルタ値モード（1）にすることができます. 

b. セグメントフィーチャデータアイテムは、セグメントフィーチャごとにセグメントごとにデコードされます. すべてのデータ項目について、1ビットのフラグは、項目が0であるか、デコードされるゼロ以外の値であるかを示します. 値がゼロ以外の場合、値は大きさL（n）としてデコードされ、その後に1ビットの符号が続きます（正の場合はL（1）-0、負の場合は1）. 長さnは、すべてのフィーチャデータの事前定義された長さテーブルから検索できます. 

5.上記の項目2に記載されているL（1）フラグが1に設定されている場合、セグメントマップのデコードツリーの確率はビットストリームからデコードされます. 各確率は、確率がデフォルト値の255（フラグは0に設定）であるか、ビットストリームからの8ビット値L（8）であるかを示す1ビットフラグでデコードされます. 

マクロブロックレベルでこの機能をサポートするレイアウトとセマンティクスについては、セクション10で説明します. 

9.4. ループフィルターのタイプとレベル
VP8は、計算の複雑さが異なる2種類のループフィルターをサポートします. 次のビットは、現在のフレームに使用されるループフィルタのベースラインタイプ、強度、およびシャープネス動作の選択をサポートするためにヘッダーにあります. 

                       + ------- + ------------------- +
                       | インデックス| 説明|
                       + ------- + ------------------- +
                       | L（1）| filter_type |
                       | | |
                       | L（6）| loop_filter_level |
                       | | |
                       | L（3）| Sharpness_level |
                       + ------- + ------------------- +
        
これらの数字の意味については、セクション15で詳しく説明します. 

VP8には、マクロブロックの予測モードと参照フレームに基づいてループフィルターレベルを調整できるビットストリームの機能があります. マクロブロックごとの調整は、現在のフレームのデフォルトのループフィルターレベルに対するデルタ値を介して行われます. このサブセクションには、デフォルトのデコーダー動作にマクロブロックごとのループフィルターレベル調整を実装するためのフラグと値の情報が含まれています. このセクションのデータは、後続のマクロブロックごとの情報のデコードに使用され、フレーム全体に適用されます. 

L（1）は、現在のフレームに対してマクロブロックループフィルター調整がオンになっているかどうかを示す1ビットフラグです. 0は、そのような機能が現在のフレームでサポートされていないことを意味し、1は、この機能が現在のフレームで有効になっていることを意味します. 

調整が参照フレームまたはエンコードモードに基づいているかどうかにかかわらず、ループフィルターレベルの調整は、ベースラインループフィルター値に対するデルタ値を介して行われます. L（1）ビットmode_ref_lf_delta_updateが値1をとると、現在のフレームのデルタ値が更新されます. デルタ値には2つのグループがあります. デルタ値の1つのグループは参照フレームベースの調整用で、もう1つのグループはモードベースの調整用. 2つのグループのデルタ値の数は、それぞれMAX_REF_LF_DELTASとMAX_MODE_LF_DELTASです. 2つのグループ内のすべての値に対して、特定の値が更新されているかどうかを示す1ビットのL（1）があります. 1つが更新されると（1）、6ビットの大きさのL（6）として送信され、その後に1ビットの符号フラグが続きます（正の場合はL（1）-0、負の場合は1）. 

9.5. トークンパーティションとパーティションデータオフセット
VP8を使用すると、ヘッダーとマクロブロックごとの予測情報を含む最初のパーティションに加えて、DCT係数を複数のパーティションにパックできるため、デコーダーは効率的な方法で並列デコードを実行できます. 2ビットのL（2）は、圧縮されたフレーム内の係数データパーティションの数を示すために使用されます. 2つのビットは、次の表で定義されています. 

                 + ------- + ------- + ---------------------- +
                 | ビット1| ビット0| パーティションの数|
                 + ------- + ------- + ---------------------- +
                 | 0 | 0 | 1 |
                 | | | |
                 | 0 | 1 | 2 |
                 | | | |
                 | 1 | 0 | 4 |
                 | | | |
                 | 1 | 1 | 8 |
                 + ------- + ------- + ---------------------- +
        
オフセットはビットストリームに埋め込まれ、デコーダーがトークンパーティションに直接アクセスできるようにします. データパーティションの数が1より大きい場合、各パーティションのサイズ（最後を除く）は3バイト（24ビット）で書き込まれます. 最後のパーティションのサイズは、前のパーティションで使用されていない残りのデータです. 

パーティション化されたデータはビットストリーム内で連続しているため、サイズを使用して各パーティションのオフセットを計算することもできます. 次の擬似コードは、サイズ/オフセットがビットストリームの3バイトによってどのように定義されるかを示しています. 

   ----コードブロックを開始--------------------------------------
        
   オフセット/サイズ=（uint32）（byte0）+（（uint32）（byte1）<< 8）
     +（（uint32）（byte2）<< 16）;
        
   ----終了コードブロック----------------------------------------
        
9.6. 量子化解除インデックス
すべての残差信号は、マクロブロックのY、U、V、またはY2サブブロックに適用される量子化された4x4DCTを介して指定されます. セクション14で詳しく説明するように、変換を反転する前に、デコードされた各係数に6つの非量子化係数の1つが乗算されます. これらの係数の選択は、平面（Y、彩度= UまたはV、Y2）と係数位置（DC=係数0）によって異なります.  、AC =係数1〜15）. 6つの値は、7ビットのインデックスを使用して6つの対応する固定テーブルに指定されます（テーブルはセクション14に記載されています）. 

最初の7ビットインデックスは、yac_qiと呼ばれるY平面AC係数の非量子化テーブルインデックスを提供します. これは常にコード化され、他の5つの量子化インデックスのベースラインとして機能します. 各量子化インデックスは、このベースラインインデックスからのデルタで表されます. インデックスを読み取るための擬似コードは次のとおりです. 

   ----コードブロックを開始--------------------------------------
        
   yac_qi = L（7）; / *Yacインデックスは常に指定されます*/
   ydc_delta = F？delta（）：0; / *Ydcデルタが指定されている場合
                                   フラグはtrueです*/
        
   y2dc_delta = F？delta（）：0; / *Y2dcデルタが指定されている場合
                                   フラグはtrueです*/
   y2ac_delta = F？delta（）：0; / *Y2acデルタが指定されている場合
                                   フラグはtrueです*/
        
   uvdc_delta = F？delta（）：0; /*指定されたクロマDCデルタ
                                   フラグがtrueの場合*/
   uvac_delta = F？delta（）：0; /*指定されたクロマACデルタ
                                   フラグがtrueの場合*/
        
   ----終了コードブロック----------------------------------------
        
ここで、delta（）は、ビットストリームから5ビットを読み取って、符号付きデルタ値を決定するプロセスです. 

       + ------- + ----------------------------------------- --------- +
       | インデックス| 説明|
       + ------- + ----------------------------------------- --------- +
       | L（4）| デルタの大きさ|
       | | |
       | L（1）| デルタの符号、正の場合は0、負の場合は1 |
       + ------- + ----------------------------------------- --------- +
        
9.7. ゴールデンフレームとAltrefフレームを更新します
キーフレームの場合、デフォルトでは、ゴールデンフレームとaltrefフレームの両方が、現在再構築されたフレームによって更新/置換されます. 非キーフレームの場合、VP8は2ビットを使用して、再構築された現在のフレームを使用して、2つのフレームバッファが更新されるかどうかを示します. 

   + ------- + ----------------------------------------- ----------------- +
   | インデックス| 説明|
   + ------- + ----------------------------------------- ----------------- +
   | L（1）| ゴールデンフレームが更新されるかどうか（0はいいえ、1ははい）. |
   | | |
   | L（1）| altrefフレームが更新されるかどうか（0はいいえ、1ははい）. |
   + ------- + ----------------------------------------- ----------------- +
        
ゴールデンフレームのフラグが0の場合、VP8はビットストリーム内のさらに2ビットを使用して、バッファー（およびどのバッファー）がゴールデンフレームにコピーされるか、またはバッファーがコピーされないかを示します. 

           + ------- + ----------------------------------------- -+
           | インデックス| 説明|
           + ------- + ----------------------------------------- -+
           | L（2）| ゴールデンフレームバッファのバッファコピーフラグ|
           + ------- + ----------------------------------------- -+
        
どこ：

o 0は、バッファがゴールデンフレームにコピーされないことを意味します

o 1は、last_frameがゴールデンフレームにコピーされることを意味します

o 2は、alt_ref_frameがゴールデンフレームにコピーされることを意味します

同様に、altrefのフラグが0の場合、VP8はビットストリームの2ビットを使用して、どのバッファがalt_ref_frameにコピーされるかを示します. 

           + ------- + ----------------------------------------- -+
           | インデックス| 説明|
           + ------- + ----------------------------------------- -+
           | L（2）| altrefフレームバッファのバッファコピーフラグ|
           + ------- + ----------------------------------------- -+
        
どこ：

o 0は、バッファがaltrefフレームにコピーされないことを意味します

o 1は、last_frameがaltrefフレームにコピーされることを意味します

o 2は、golden_frameがaltrefフレームにコピーされることを意味します

golden_frameとalt_ref_frameのref_frame_sign_biasには、それぞれ2ビットが送信されます. 

                + ------- + --------------------------------- +
                | インデックス| 説明|
                + ------- + --------------------------------- +
                | L（1）| ゴールデンフレームのバイアスフラグに署名|
                | | |
                | L（1）| altrefフレームの符号バイアスフラグ|
                + ------- + --------------------------------- +
        
これらの値は、ゴールデンフレームまたはaltrefフレームがマクロブロックの参照フレームとして使用される場合に、モーションベクトルの符号を制御するために使用されます. 

9.8. 最後のフレームバッファを更新
VP8は、1ビットのL（1）を使用して、構築された現在のフレームを使用して最後のフレーム参照バッファーが更新されるかどうかを示します. キーフレームでは、このビットが上書きされ、最後のフレームバッファが常に更新されます. 

9.9. DCT係数確率の更新
このフィールドには、DCT係数のデコードに使用される確率テーブルの更新が含まれます. 表の確率ごとに、現在のフレームの確率が更新されているかどうかを示すL（1）フラグがあり、L（1）フラグが1に設定されている場合は、次のような追加の8ビット値が続きます. 新しい確率値. これらのテーブルはフレーム間で維持されますが、もちろん、すべてのキーフレームの先頭でデフォルトに置き換えられます. 

このフィールドのレイアウトとセマンティクスについては、セクション13で取り上げます. 

9.10. 残りのフレームヘッダーデータ（非キーフレーム）
   + ------- + ----------------------------------------- ------------------ +
   | インデックス| 説明|
   + ------- + ----------------------------------------- ------------------ +
   | L（1）| mb_no_skip_coeff. このフラグは、フレームレベルで|を示します. 
   | | ゼロ以外の係数のないマクロブロックをスキップする場合|
   | | 有効になっています. 0に設定されている場合、prob_skip_falseは|です. 
   | | 読み取られず、mb_skip_coeffはすべて0に強制されます|
   | | マクロブロック（セクション11.1および12.1を参照）. |
   | | |
   | L（8）| prob_skip_false=デコードに使用される確率|
   | | マクロブロックレベルのフラグ. マクロブロック|
   | | ゼロ以外の係数があります. 次の場合にのみ読む|
   | | mb_no_skip_coeffは1です. |
   | | |
   | L（8）| prob_intra=マクロブロックが「イントラ」である確率|
   | | 予測（つまり、すでにエンコードされている|から予測）
   | | 「inter」とは対照的に、現在のフレームの一部）|
   | | 予測（つまり、|の内容から予測）
   | | 前のフレーム）. |
   | | |
   | L（8）| prob_last=相互予測される確率|
   | | マクロブロックは直前から予測されます|
   | | 最新のゴールデンフレームまたは|とは対照的に、フレーム
   | | altrefフレーム. |
   | | |
   | L（8）| prob_gf=相互に予測されたマクロブロックの確率|
   | | |のように、最新のゴールデンフレームから予測されます. 
   | | altrefフレームとは対照的です. |
   | | |
   | F | trueの場合、|を更新する4つのL（8）が続きます. 
   | | さまざまなタイプのイントラ予測の確率|
   | | Y平面の場合. これらの確率は|に対応します
   | | Y内のデコードツリーの4つの内部ノード|
   | | フレーム間でのモード、つまり|の偶数の位置
   | | 上記のymode_tree配列. |
   | | |
   | F | trueの場合、|を更新する3つのL（8）が続きます. 
   | | さまざまなタイプのイントラ予測の確率|
   | | クロマ面用. これらの確率は|に対応します
   | | 上記のuv_mode_tree配列の偶数の位置. |
   | | |
   | X | 動きベクトルの確率の更新. 詳細は|に記載されています
   | | セクション17.2「確率の更新」. |
   + ------- + ----------------------------------------- ------------------ +
        
フレームヘッダーのこの部分のデコードは、参照デコーダファイルdixie.c（セクション20.4）で処理されます. 

9.11. 残りのフレームヘッダーデータ（キーフレーム）
   + ------- + ----------------------------------------- ------------------ +
   | インデックス| 説明|
   + ------- + ----------------------------------------- ------------------ +
   | L（1）| mb_no_skip_coeff. このフラグは、フレームレベルで|を示します. 
   | | ゼロ以外の係数のないマクロブロックをスキップする場合|
   | | 有効になっています. 0に設定されている場合、prob_skip_falseは|です. 
   | | 読み取られず、mb_skip_coeffはすべて0に強制されます|
   | | マクロブロック（セクション11.1および12.1を参照）. |
   | | |
   | L（8）| prob_skip_false=デコードに使用される確率|
   | | マクロブロックレベルのフラグ. マクロブロック|
   | | ゼロ以外の係数があります. 次の場合にのみ読む|
   | | mb_no_skip_coeffは1です. |
   + ------- + ----------------------------------------- ------------------ +
        
フレームヘッダーのこの部分のデコードは、参照デコーダファイルmodemV.c（セクション20.11）で処理されます. 

これでフレームヘッダーのレイアウトは完了です. 最初のデータパーティションの残りの部分は、マクロブロックレベルの予測データで構成されています. 

フレームヘッダーが処理された後、予測と残差データをデコードするために必要なすべての確率がわかっており、次のフレームまで変更されません. 

10.セグメントベースの機能調整
すべてのマクロブロックは、オプションでデコーダーのデフォルトの動作の一部をオーバーライドできます. 具体的には、VP8はセグメントベースの調整を使用して、マクロブロックの量子化器レベルとループフィルターレベルの変更をサポートします. フレームに対してセグメントベースの調整機能が有効になっている場合、フレーム内の各マクロブロックはsegment_idでコード化されます. これにより、現在のフレーム内のすべてのマクロブロックがいくつかの異なるセグメントに効果的にセグメント化されます. 同じセグメント内のマクロブロックは、量子化器とループフィルターのレベル調整でまったく同じように動作します. 

フレームヘッダーのサブセクションBのsegmentation_enabledフラグとupdate_mb_segmentation_mapフラグの両方が1の値をとる場合、各（イントラコードまたはインターコードされた）マクロブロックの予測データは、現在のマクロブロックのsegment_idの指定で始まります. この単純なツリーを使用してデコードされます...

   ----コードブロックを開始--------------------------------------
        
   const tree_index mb_segment_tree [2 *（4-1）] =
     {{
       2、4、/ *ルート： "0"、"1"サブツリー*/
       -0、-1、/ * "00" = 0番目の値、"01"=1番目の値*/
        -2、-3 / * "10" = 2番目の値、 "11"=3番目の値*/
     }
        
   ----終了コードブロック----------------------------------------
        
...3エントリの確率テーブルmb_segment_tree_probs[3]と組み合わせます. マクロブロックのsegment_idは、デコードプロセスの後半で、segment_feature_dataテーブルを調べて、クォンタイザーとループフィルターのレベルがどのように調整されるかを決定するために使用されます. 

segment_idのデコードは、イントラ予測モード（次に取り上げる）の解析とともに、参照デコーダーファイルmodemV.cに実装されています. 

11.キーフレームマクロブロック予測レコード
上記の機能を指定した後、マクロブロック予測レコードは次に、マクロブロックに使用される予測モードを指定します. 

11.1. mb_skip_coeff
mb_no_skip_coeffが1に設定されている場合にのみ、prob_skip_falseを使用して単一のboolフラグがデコードされます（セクション9.10および9.11を参照）. mb_no_skip_coeffが0に設定されている場合、この値はデフォルトで0になります. 

11.2. ルマモード
最初に、セクション8で説明されているように、kf_ymode_treeを使用してコード化され、便宜上ここで繰り返される、タイプintra_mbmodeのluma仕様があります. 

   ----コードブロックを開始--------------------------------------
        
   typedef列挙型
   {{
       DC_PRED、/*上の行と左の列を使用してDCを予測します*/
       V_PRED、/*上の行を使用して行を予測します*/
       H_PRED、/*左側の列を使用して列を予測します*/
       TM_PRED、/*「TrueMotion」で2番目の違いを伝播します*/
        
       B_PRED、/*各Yサブブロックは個別に予測されます*/
        
       num_uv_modes = B_PRED、/*最初の4つのモードはクロマに適用されます*/
       num_ymodes/*すべてのモードがlumaに適用されます*/
   }
   intra_mbmode;
        
   const tree_index kf_ymode_tree [2 *（num_ymodes-1）] =
   {{
    -B_PRED、2、/ *ルート：B_PRED = "0"、"1"サブツリー*/
     4、6、/*"1"サブツリーには2つの子孫サブツリーがあります*/
      -DC_PRED、-V_PRED、/ * "10"サブツリー：DC_PRED = "100"、
                              V_PRED = "101" * /
      -H_PRED、-TM_PRED / * "11"サブツリー：H_PRED = "110"、
                              TM_PRED = "111" * /
   };
        
   ----終了コードブロック----------------------------------------
        
キーフレームの場合、Yモードは次のように固定確率配列を使用してデコードされます. 

   ----コードブロックを開始--------------------------------------
        
   const Prob kf_ymode_prob [num_ymodes-1] = {145、156、163、128};
   Ymode =（intra_mbmode）treed_read（d、kf_ymode_tree、kf_ymode_prob）;
        
   ----終了コードブロック----------------------------------------
        
dはもちろん、最初のデータパーティションを読み取るために使用されるbool_decoderです. 

YmodeがB_PREDの場合、16個のYサブブロックごとに（ツリーコード化された）モードが続きます. 10個のサブブロックモードとそのコーディングツリーは次のとおりです. 

   ----コードブロックを開始--------------------------------------
        
   typedef列挙型
   {{
       B_DC_PRED、/*上の行と列を使用してDCを予測します
                      左の方です */
       B_TM_PRED、/*2番目の違いを伝播します
                      「トゥルーモーション」*/
        
       B_VE_PRED、/*上の行を使用して行を予測します*/
       B_HE_PRED、/*左側の列を使用して列を予測します*/
        
       B_LD_PRED、/ *南西（左と下）対角45度
                      予測 */
       B_RD_PRED、/ *南東（右下） "" * /
        
       B_VR_PRED、/ * SSE（垂直右）対角予測* /
       B_VL_PRED、/ * SSW（垂直左） "" * /
       B_HD_PRED、/ * ESE（水平下） "" * /
       B_HU_PRED、/ * ENE（水平上） "" * /
        
       num_intra_bmodes
   }
   intra_bmode;
        
   / *上記のコーディングツリー、コメントとしての暗黙のコーディング* /
        
   const tree_index bmode_tree [2 *（num_intra_bmodes-1）] =
   {{
    -B_DC_PRED、2、/ * B_DC_PRED = "0" * /
     -B_TM_PRED、4、/ * B_TM_PRED = "10" * /
      -B_VE_PRED、6、/ * B_VE_PRED = "110" * /
       8、12、
        -B_HE_PRED、10、/ * B_HE_PRED = "11100" * /
         -B_RD_PRED、-B_VR_PRED、/ * B_RD_PRED = "111010"、
                                        B_VR_PRED = "111011" * /
        -B_LD_PRED、14、/ * B_LD_PRED = "111110" * /
          -B_VL_PRED、16、/ * B_VL_PRED = "1111110" * /
            -B_HD_PRED、-B_HU_PRED / * HD = "11111110"、
                                        HU = "11111111" * /
   };
        
   ----終了コードブロック----------------------------------------
        
最初の4つのモードは、番号が少し異なりますが、上記の同様の名前の16x16モードの小さいバージョンです. 最後の6つの「対角」モードは、lumaサブブロックに固有のものです. 

11.3. サブブロックモードコンテキスト
キーフレームでのサブブロックモードのコーディングでは、サブブロックの左側と上部にあるサブブロック用にすでにコーディングされているモードを使用して、現在のサブブロックモードをデコードするための確率配列を選択します. これはコンテキスト予測の最初のインスタンスであり、それに関連するいくつかの警告があります. 

1.サブブロック間の隣接関係は、サブブロックの通常のデフォルトのラスター配置に基づいています. 

2.隣接するサブブロックは、現在のマクロブロックにある必要はありません. 左端のサブブロック0、4、8、および12の左側にあるサブブロックは、それぞれ、すぐ左にある（すでにコード化されている）マクロブロックの右端のサブブロック3、7、11、および15です. 同様に、上端のサブブロック0、1、2、および3の上のサブブロックは、すぐ上のすでにコーディングされているマクロブロックの下端のサブブロック12、13、14、および15です. 

3.画像の一番上の行または左端にあるマクロブロックの場合、一部の予測子は存在しません. このような予測子は、値B_DC_PREDを持っていると見なされます. これは、おそらく便利なことに、上記の列挙で値0を取ります. これらのコンテキストの単純な管理スキームは、上記の予測子と4つの左側の予測子の行を維持する場合があります. フレームをデコードする前に、行全体がB_DC_PREDに初期化されます. マクロブロックの各行をデコードする前に、左側の4つの予測子もB_DC_PREDに設定されます. マクロブロックをデコードした後、下の4つのサブブロックモードが行予測子にコピーされ（現在の位置で、次のマクロブロックの上に進みます）、右の4つのサブブロックモードが左の予測子にコピーされます. 

4.もちろん、多くのマクロブロックは16x16輝度予測モードを使用してコーディングされます. 後続のサブブロックモード（のみ）を予測する目的で、このようなマクロブロックは、次のように16x16輝度モードからマクロブロック全体で一定のサブブロックモードを導出します. 

5.セクション16でフレーム間モードについて説明しますが、ここで、インターフレームはここと以下で説明するすべてのイントラコーディングモードを使用しますが、インターフレームのサブブロックモードは、に依存しない単一の一定確率配列を使用してコーディングされることに注意してください. 任意のコンテキスト. 

サブブロックモードの確率の近くのサブブロックモードコンテキストへの依存は、3次元定数配列を使用して最も簡単に処理されます. 

   ----コードブロックを開始--------------------------------------
        
const Prob kf_bmode_prob [num_intra_bmodes] [num_intra_bmodes] [num_intra_bmodes-1];

   ----終了コードブロック----------------------------------------
        
この配列の外側の2次元は、現在のブロックの上部と左側にそれぞれ、すでにコーディングされているサブブロックモードによってインデックスが付けられます. 内側の次元は、インデックスが上記のbmode_treeの偶数のインデックスに対応する典型的なツリー確率リストです. j ^（th）lumaサブブロックのモードは次のようになります. 

   ----コードブロックを開始--------------------------------------
        
   Bmode =（intra_bmode）treed_read（d、bmode_tree、kf_bmode_prob
     [A] [L]）;
        
   ----終了コードブロック----------------------------------------
        
ここで、4x4 Yサブブロックインデックスjはラスター順に0から15まで変化し、AとLはj ^（th）サブブロックの左上で使用されるモードです. 

kf_bmode_prob配列の内容は、このセクションの最後に記載されています. 

11.4. クロマモード
Yモード（およびオプションのサブブロックモード）の指定の後に、クロマモードがあります. クロマモードはYモードのサブセットであり、セクション8で説明されているように、uv_mode_treeを使用してコード化され、便宜上ここで繰り返されます. 

   ----コードブロックを開始--------------------------------------
        
   const tree_index uv_mode_tree [2 *（num_uv_modes-1）] =
   {{
    -DC_PRED、2、/ *ルート：DC_PRED = "0"、"1"サブツリー*/
     -V_PRED、4、/ * "1"サブツリー：V_PRED = "10"、
                              「11」サブツリー*/
      -H_PRED、-TM_PRED / * "11"サブツリー：H_PRED = "110"、
                              TM_PRED = "111" * /
   };
        
   ----終了コードブロック----------------------------------------
        
Yモード（キーフレーム内）に関しては、クロマモードは固定されたコンテキストレス確率テーブルを使用してコード化されます. 

   ----コードブロックを開始--------------------------------------
        
   const Prob kf_uv_mode_prob [num_uv_modes-1] = {142、114、183};
   uv_mode =（intra_mbmode）treed_read（d、uv_mode_tree、
     kf_uv_mode_prob）;
        
   ----終了コードブロック----------------------------------------
        
これで、キーフレームのマクロブロック予測コーディングの説明は終わりです. セクション16で説明するように、フレーム間内のイントラモードのコーディングは、予測モード、および実際にVP8のすべてのツリーコーディングデータについてここで説明するもの（および参照コード）と類似していますが、同一ではありません. 

11.5. サブブロックモード確率テーブル
最後に、キーフレームのサブブロックモードをデコードするために使用される固定確率テーブルを次に示します. 

   ----コードブロックを開始--------------------------------------
        
   const Prob kf_bmode_prob [num_intra_bmodes] [num_intra_bmodes]
     [num_intra_bmodes-1] =
   {{
     {{
       {231、120、48、89、115、113、120、152、112}、
       {152、179、64、126、170、118、46、70、95}、
       {175、69、143、80、85、82、72、155、103}、
       {56、58、10、171、218、189、17、13、152}、
       {144、71、10、38、171、213、144、34、26}、
       {114、26、17、163、44、195、21、10、173}、
       {121、24、80、195、26、62、44、64、85}、
       {170、46、55、19、136、160、33、206、71}、
       {63、20、8、114、114、208、12、9、226}、
       {81、40、11、96、182、84、29、16、36}
     }、
        
     {{
       {134、183、89、137、98、101、106、165、148}、
       {72、187、100、130、157、111、32、75、80}、
       {66、102、167、99、74、62、40、234、128}、
       {41、53、9、178、241、141、26、8、107}、
       {104、79、12、27、217、255、87、17、7}、
       {74、43、26、146、73、166、49、23、157}、
       {65、38、105、160、51、52、31、115、128}、
       {87、68、71、44、114、51、15、186、23}、
       {47、41、14、110、182、183、21、17、194}、
       {66、45、25、102、197、189、23、18、22}
     }、
     {{
       {88、88、147、150、42、46、45、196、205}、
       {43、97、183、117、85、38、35、179、61}、
       {39、53、200、87、26、21、43、232、171}、
       {56、34、51、104、114、102、29、93、77}、
       {107、54、32、26、51、1、81、43、31}、
       {39、28、85、171、58、165、90、98、64}、
       {34、22、116、206、23、34、43、166、73}、
       {68、25、106、22、64、171、36、225、114}、
       {34、19、21、102、132、188、16、76、124}、
       {62、18、78、95、85、57、50、48、51}
     }、
     {{
       {193、101、35、159、215、111、89、46、111}、
       {60、148、31、172、219、228、21、18、111}、
       {112、113、77、85、179、255、38、120、114}、
       {40、42、1、196、245、209、10、25、109}、
       {100、80、8、43、154、1、51、26、71}、
       {88、43、29、140、166、213、37、43、154}、
       {61、63、30、155、67、45、68、1、209}、
       {142、78、78、16、255、128、34、197、171}、
       {41、40、5、102、211、183、4、1、221}、
       {51、50、17、168、209、192、23、25、82}
     }、
     {{
       {125、98、42、88、104、85、117、175、82}、
       {95、84、53、89、128、100、113、101、45}、
       {75、79、123、47、51、128、81、171、1}、
       {57、17、5、71、102、57、53、41、49}、
       {115、21、2、10、102、255、166、23、6}、
       {38、33、13、121、57、73、26、1、85}、
       {41、10、67、138、77、110、90、47、114}、
       {101、29、16、10、85、128、101、196、26}、
       {57、18、10、102、102、213、34、20、43}、
       {117、20、15、36、163、128、68、1、26}
     }、
        
     {{
       {138、31、36、171、27、166、38、44、229}、
       {67、87、58、169、82、115、26、59、179}、
       {63、59、90、180、59、166、93、73、154}、
       {40、40、21、116、143、209、34、39、175}、
       {57、46、22、24、128、1、54、17、37}、
       {47、15、16、183、34、223、49、45、183}、
       {46、17、33、183、6、98、15、32、183}、
       {65、32、73、115、28、128、23、128、205}、
       {40、3、9、115、51、192、18、6、223}、
       {87、37、9、115、59、77、64、21、47}
     }、
     {{
       {104、55、44、218、9、54、53、130、226}、
       {64、90、70、205、40、41、23、26、57}、
       {54、57、112、184、5、41、38、166、213}、
       {30、34、26、133、152、116、10、32、134}、
       {75、32、12、51、192、255、160、43、51}、
       {39、19、53、221、26、114、32、73、255}、
       {31、9、65、234、2、15、1、118、73}、
       {88、31、35、67、102、85、55、186、85}、
       {56、21、23、111、59、205、45、37、192}、
       {55、38、70、124、73、102、1、34、98}
     }、
     {{
       {102、61、71、37、34、53、31、243、192}、
       {69、60、71、38、73、119、28、222、37}、
       {68、45、128、34、1、47、11、245、171}、
       {62、17、19、70、146、85、55、62、70}、
       {75、15、9、9、64、255、184、119、16}、
       {37、43、37、154、100、163、85、160、1}、
       {63、9、92、136、28、64、32、201、85}、
       {86、6、28、5、64、255、25、248、1}、
       {56、8、17、132、137、255、55、116、128}、
       {58、15、20、82、135、57、26、121、40}
     }、
     {{
       {164、50、31、137、154、133、25、35、218}、
       {51、103、44、131、131、123、31、6、158}、
       {86、40、64、135、148、224、45、183、128}、
       {22、26、17、131、240、154、14、1、209}、
       {83、12、13、54、192、255、68、47、28}、
       {45、16、21、91、64、222、7、1、197}、
       {56、21、39、155、60、138、23、102、213}、
       {85、26、85、85、128、128、32、146、171}、
       {18、11、7、63、144、171、4、4、246}、
       {35、27、10、146、174、171、12、26、128}
     }、
        
     {{
       {190、80、35、99、180、80、126、54、45}、
       {85、126、47、87、176、51、41、20、32}、
       {101、75、128、139、118、146、116、128、85}、
       {56、41、15、176、236、85、37、9、62}、
       {146、36、19、30、171、255、97、27、20}、
       {71、30、17、119、118、255、17、18、138}、
       {101、38、60、138、55、70、43、26、142}、
       {138、45、61、62、219、1、81、188、64}、
       {32、41、20、117、151、142、20、21、163}、
       {112、19、12、61、195、128、48、4、24}
     }
   };
        
   ----終了コードブロック----------------------------------------
        
12.フレーム内予測
フレーム内予測では、現在のフレーム内ですでにコーディングされているマクロブロックを使用して、現在のマクロブロックの内容を概算します. これは、フレーム間内のコード化されたマクロブロックと、キーフレーム内のすべてのマクロブロックに適用されます. 

現在のマクロブロック「M」に関連して、すでにコーディングされているマクロブロックには、Mより上のすべてのマクロブロックと、Mと同じ行の左側にあるマクロブロックが含まれますが、実際に使用されるのはこれらのマクロブロックのうち最大4つです.  Mの真上にある「A」、Aのすぐ左と右のブロック、およびMのすぐ左のブロック. 

各予測モード（つまり、すでに計算された値からの外挿の手段）は、現在の位置に対する相対的な位置がモードによって定義されるピクセル値に対して、かなり単純な演算を使用します. 

彩度（Uと​​V）と輝度（Y）の予測は互いに独立しています. 

フレームの上の行または左の列のマクロブロックに適用されたピクセルの相対的なアドレス指定により、表示されているフレームの外側のピクセルが参照される場合があります. 通常、このような範囲外のピクセルの想定値は、表示フレームの左端の列の左側のピクセルの場合は129、表示フレームの一番上の行の上のピクセルの場合は127です（上のピクセルと表示されているフレームの左上のピクセルの左側）. これに対する例外（特定のモードに関連する）を以下に示します. 

イントラ予測によって参照されるすでにコード化されたマクロブロックは「再構築」されています. つまり、予測され、残差が調整されていますが（セクション14で説明）、ループフィルタリングされていません. 個々のマクロブロックと個々のサブブロックの間のエッジを処理しますが、すべてのマクロブロックが再構築された後、ループフィルタリング（セクション15で説明）がフレーム全体に適用されます. 

12.1. mb_skip_coeff
mb_no_skip_coeffが1に設定されている場合にのみ、prob_skip_falseを使用して単一のboolフラグがデコードされます（セクション9.10および9.11を参照）. mb_no_skip_coeffが0に設定されている場合、この値はデフォルトで0になります. 

12.2. クロマ予測
彩度予測は輝度予測よりも少し単純なので、最初に扱います. 各クロマモードはUとVを同じように扱います. つまり、UとVの予測値は、2つの平面のそれぞれで同じ相対アドレス指定と演算を使用して、並行して計算されます. 

モードは、ブロックのすぐ上にある8ピクセルの行「A」（つまり、現在のマクロブロックのすぐ上のマクロブロックの一番下の彩度行）とのすぐ左にある8ピクセルの列「L」を使用して予測値を推定します. ブロック（つまり、現在のマクロブロックのすぐ左にあるマクロブロックの右端の彩度列）. 

垂直予測（クロマモードV_PRED）は、8x8クロマブロックの各8ピクセル行を「上」の行（A）のコピーで埋めるだけです. 現在のマクロブロックがフレームの一番上の行にある場合、Aの8つのピクセル値すべてに値127が割り当てられます. 

同様に、水平予測（H_PRED）は、8x8クロマブロックの各8ピクセル列を「左」列（L）のコピーで埋めます. 現在のマクロブロックがフレームの左側の列にある場合、Lの8つのピクセル値すべてに値129が割り当てられます. 

DC予測（DC_PRED）は、8x8クロマブロックを単一の値で埋めます. フレームの一番左の列の一番上の行と右の下にあるマクロブロックの一般的なケースでは、この値は、上の行Aと左の列Lの（の和集合）にある16個の（実際に表示される）ピクセルの平均です. 

それ以外の場合、現在のマクロブロックがフレームの一番上の行にある場合は、Lの8ピクセルの平均が使用されます. フレームの左側の列にある場合は、Aの8ピクセルの平均が使用されます. 

これらの例外的なケースで使用される平均は、V_PREDおよびH_PREDに定義された範囲外のAおよびL値を使用して得られる平均と同じではないことに注意してください. フレームの一番上の行の左端のマクロブロックの場合、8x8ブロックは単に定数値128で埋められます. 

DC_PREDの場合、左上のマクロブロックの例外的なケースを除いて、16または8ピクセル値を平均して、8x8ブロックを満たす単一の予測値を取得します. 丸めは次のように行われます. 

   ----コードブロックを開始--------------------------------------
        
   int sum; / *（少なくとも）16ビット精度で8または16ピクセルの合計* /
   int shf; / *ピクセル数（3または4）の基数2の対数* /
        
   ピクセルDC値=（合計+（1 <<（shf-1）））>> shf;
        
   ----終了コードブロック----------------------------------------
        
被加数はすべて有効なピクセルであるため、DC値の計算に「クランプ」は必要ありません. 

残りの「TrueMotion」（TM_PRED）クロマモードの名前は、On2Technologiesで使用されていた古いビデオ圧縮技術に由来しています. 行「A」と列「L」に加えて、TM_PREDはクロマブロックの左上にあるピクセル「P」を使用します. 

次の図は、TM_PREDがどのように機能するかの例を示しています. 

   ----コードブロックを開始--------------------------------------
        
   | ----- | ----- | ----- | ----- | ----- | ----- | ----- | ----- |- ---- |
   | P | A0 | A1 | A2 | A3 | A4 | A5 | A6 | A7 |
   | ----- | ----- | ----- | ----- | ----- | ----- | ----- | ----- |- ---- |
   | L0 | X00 | X01 | X02 | X03 | X04 | X05 | X06 | X07 |
   | ----- | ----- | ----- | ----- | ----- | ----- | ----- | ----- |- ---- |
   | L1 | X10 | X11 | X12 | X13 | X14 | X15 | X16 | X17 |
   | ----- | ----- | ----- | ----- | ----- | ----- | ----- | ----- |- ---- |
   | L2 | X20 | X21 | X22 | X23 | X24 | X25 | X26 | X27 |
   | ----- | ----- | ----- | ----- | ----- | ----- | ----- | ----- |- ---- |
   | L3 | X30 | X31 | X32 | X33 | X34 | X35 | X36 | X37 |
   | ----- | ----- | ----- | ----- | ----- | ----- | ----- | ----- |- ---- |
   | L4 | X40 | X41 | X42 | X43 | X44 | X45 | X46 | X47 |
   | ----- | ----- | ----- | ----- | ----- | ----- | ----- | ----- |- ---- |
   | L5 | X50 | X51 | X52 | X53 | X54 | X55 | X56 | X57 |
   | ----- | ----- | ----- | ----- | ----- | ----- | ----- | ----- |- ---- |
   | L6 | X60 | X61 | X62 | X63 | X64 | X65 | X66 | X67 |
   | ----- | ----- | ----- | ----- | ----- | ----- | ----- | ----- |- ---- |
   | L7 | X70 | X71 | X72 | X73 | X74 | X75 | X76 | X77 |
   | ----- | ----- | ----- | ----- | ----- | ----- | ----- | ----- |- ---- |
        
   ----終了コードブロック----------------------------------------
        
ここで、P、As、およびLsは、以前にコード化されたブロックから再構築されたピクセル値を表し、X00からX77は、現在のブロックの予測値を表します. TM_PREDは、次の式を使用してX_ijを計算します. 

   X_ij = L_i + A_j-P（i、j = 0、1、2、3）
        
正確なアルゴリズムは次のとおりです. 

   ----コードブロックを開始--------------------------------------
        
   void TMpred（
       ピクセルb[8][8]、/ *クロマ（UまたはV）予測ブロック* /
       const Pixel A [8]、/*すでに構築されたピクセルの行
                              上記のブロック*/
       const Pixel L [8]、/*のすぐ左にある""の列
                              ブロック */
       const Pixel P /*Aのすぐ左のピクセルと
                              L*/より上
   ）{
       int r = 0; /* 行 */
       行う {
           int c = 0; /* 桁 */
           行う {
               b [r] [c] =クランプ255（L [r] + A [c]-P）;
           } while（++ c <8）;
       } while（++ r <8）;
   }
        
   ----終了コードブロック----------------------------------------
        
このプロセスは、Aのピクセルを使用して各列を開始し、L（Pから開始）のピクセル間の垂直方向の差を伝播することと同等に説明できることに注意してください. 

クロマイントラ予測の実装は、リファレンスデコーダファイルpredict.c（セクション20.14）にあります. 

DC_PREDとは異なり、最上行または左端のマクロブロックの場合、TM_PREDは、V_PREDおよびH_PREDに対して（それぞれ）定義された範囲外の値127および129を使用します. 

12.3. ルマ予測
最初の4つの16x16輝度モード（DC_PRED、V_PRED、H_PRED、およびTM_PRED）の予測プロセスは、上記の対応する彩度予測プロセスと本質的に同じですが、唯一の違いは、2つの8x8彩度ではなく単一の16x16輝度ブロックを予測していることです. ブロック. 

したがって、ここでの行「A」と列「L」には16ピクセルが含まれ、DC予測は16または32ピクセルを使用して計算され（shfは4または5）、もちろん予測バッファー全体、つまり16を満たします. それぞれ16ピクセルを含む行（または列）. 16x16輝度予測のリファレンス実装もpredict.cにあります. 

残りの輝度モード（B_PRED）では、各4x4 Yサブブロックは、10個のモードの1つを使用して個別に予測されます（セクション11に、それらのエンコーディングとともにリストされています）. 

また、すでに説明したフルマクロブロックモードとは異なり、一部のサブブロックモードでは、現在のサブブロックの右上にある予測ピクセルを使用します. 詳細には、各4x4サブブロック「B」は、（多くても）Bのすぐ左にある4ピクセルの列「L」とBのすぐ上にある8ピクセルの行「A」を使用して予測されます. 続いて、Bの右上に隣接する4つのピクセルと、Aのすぐ左（およびLのすぐ上）にある単一のピクセル「P」が続きます. 

サブブロック内予測の目的で、サブブロック内のピクセルのすぐ左と右にあるピクセルは、フレームバッファ「F」内の対応するピクセルのすぐ左と右にあるピクセルと同じです. 垂直オフセットも同様に動作します. 上の行AはFのBのすぐ上にあり、左側の列Lの隣接するピクセルはFの単一の行で区切られています. 

マクロブロック全体（構成サブブロックではなく）がラスタースキャン順序で再構築されるため、現在のマクロブロックの右端（一番上の行ではなく）に沿って配置されているサブブロックの場合、上記のAの4つの「余分な」予測ピクセルとBの右側はまだ実際には建設されていません. 

サブブロック7、11、および15が影響を受けます. これらの3つのサブブロックはすべて、サブブロック3（マクロブロックの右上隅）と同じ追加ピクセル、つまりサブブロック3のすぐ上と右の4ピクセルを使用します. フレームバッファー位置の書き込み（R、C）現在のマクロブロックの左上隅からR行とC列でオフセットされている場合、すべての右端のサブブロック（3、7、11、および15）の余分なピクセルは、位置（-1,16）、（-1）にあります.  、17）、（-1,18）、および（-1,19）. 一番上の行を除く各マクロブロック行の右端のマクロブロックの場合、追加のピクセルは、マクロブロック行のすぐ上の行の右端に表示されるピクセルである位置（-1,15）のピクセルと同じ値を使用する必要があります. 一番上のマクロブロック行の場合、すべての追加ピクセルは127の値を想定しています. 

予測モードの詳細は、コードで最も簡単に記述できます. 

   ----コードブロックを開始--------------------------------------
        
   / *結果のピクセルは、多くの場合、2つまたは3つの予測子の平均です. 
      ピクセル. 次のサブルーチンは、計算に使用されます
      これらの平均. 引数は有効なピクセルであるため、
      クランプが必要です. 実際の実装は
      おそらくインライン関数またはマクロを使用します. * /
        
   / * yw /隣接するx、zを中心とする加重平均を計算します* /
        
   Pixel avg3（Pixel x、Pixel y、Pixel z）{
     return（x + y + y + z + 2）>> 2;}
        
   /*pを中心とする3つの隣接するピクセルの加重平均*/
        
   Pixel avg3p（const Pixel * p）{return avg3（p [-1]、p [0]、p [1]）;}
        
   /*xとyの単純平均*/
        
   Pixel avg2（Pixel x、Pixel y）{return（x + y + 1）>> 1;}
        
   / *p[0]とp[1]の平均は合成と見なすことができます
      2つの間にあるピクセル、つまりpを半音過ぎたピクセル. * /
        
   Pixel avg2p（const Pixel * p）{return avg2（p [0]、p [1]）;}
        
   void subblock_intra_predict（
       ピクセルB[4][4]、/*Yサブブロック予測バッファー*/
       const Pixel * A、/ * A [0] ... A [7] =行の上、A [-1] = P * /
       const Pixel * L、/ * L [0] ... L [3] =左の列、L [-1] = P * /
       intra_bmodeモード/*列挙型はセクション11.2にあります*/
   ）{
       ピクセルE[9]; /*9つのすでに構築されたエッジピクセル*/
       E [0] = L [3]; E [1] = L [2]; E [2] = L [1]; E [3] = L [0];
       E [4] = A [-1]; / * == L [-1] == P * /
       E [5] = A [0]; E [6] = A [1]; E [7] = A [2]; E [8] = A [3];
        
     switch（mode）{
       /*最初の4つのモードは対応するものに似ています
          フルブロックモード. * /
        
       ケースB_DC_PRED：
       {{
           int v = 4; / * DC sum / avg、4は丸め調整です* /
           int i = 0; do {v + = A [i] + L [i];} while（++ i <4）;
           v >> = 3; /*平均8ピクセル*/
           i = 0; do{/*予測バッファを一定のDCで満たす
                              価値 */
        
               int j = 0; do {B [i] [j] = v;} while（++ j <4）;
           } while（++ i <4）;
           壊す;
       }
        
       ケースB_TM_PRED：/ *16x16TM_PREDと同じ*/
       {{
           int r = 0; 行う {
               int c = 0; 行う {
                   B [r] [c] =クランプ255（L [r] + A [c]-A [-1]）;
               } while（++ c <4）;
           } while（++ r <4）;
           壊す;
       }
        
       ケースB_VE_PRED：/*平均を使用することを除いて16x16V_PREDと同様*/
       {{
           int c = 0; do {/*4行すべて=平滑化された一番上の行*/
               B [0] [c] = B [1] [c] = B [2] [c] = B [3] [c] = avg3p（A + c）;
           } while（++ c <4）;
           壊す;
       }
        
       ケースB_HE_PRED：/*平均を使用することを除いて16x16H_PREDと同様*/
       {{
           / * L [4]が存在しないため、下の行は例外です* /
           int v = avg3（L [2]、L [3]、L [3]）;
           int r = 3; while（1）{/*4列すべて=左に平滑化
                                       桁 */
               B [r] [0] = B [r] [1] = B [r] [2] = B [r] [3] = v;
               if（--r <0）
                   壊す;
               v = avg3p（L + r）; /*上位3行はの平均を使用します
                                      3ピクセル*/
           }
           壊す;
       }
        
       / *残りの6つの「対角」モードは、
          対角線への予測バッファ. すべてのピクセル
          各行に同じ値が割り当てられます. この値は
          （の平滑化または合成バージョン）
          同じ上にあるすでに構築された予測値
          ライン. わかりやすくするために、コメントでは、
          これらの予測ピクセルの相対的な位置
          デスティネーションアレイBの左上隅. 
        
          これらのモードはサブブロック予測に固有であり、
          フルブロックのアナログはありません. 最初の2つの使用ラインは
          + |-水平から45度（または、同等に、
          垂直）、つまり、傾きが+|-1の線. */
        
       ケースB_LD_PRED：/ *南西（左および下）ステップ=
                             （-1、1）または（1、-1）* /
           / * avg3p（A + j）は、（-1、j）の「平滑化された」ピクセルです* /
           B [0] [0] = avg3p（A + 1）;
           B [0] [1] = B [1] [0] = avg3p（A + 2）;
           B [0] [2] = B [1] [1] = B [2] [0] = avg3p（A + 3）;
           B [0] [3] = B [1] [2] = B [2] [1] = B [3] [0] = avg3p（A + 4）;
           B [1] [3] = B [2] [2] = B [3] [1] = avg3p（A + 5）;
           B [2] [3] = B [3] [2] = avg3p（A + 6）;
           B [3] [3] = avg3（A [6]、A [7]、A [7]）; / *A[8]は存在しません*/
           壊す;
        
       ケースB_RD_PRED：/ *南東（右下）ステップ=
                          （1,1）または（-1、-1）* /
           B [3] [0] = avg3p（E + 1）; / *予測子は（2、-1）からです* /
           B [3] [1] = B [2] [0] = avg3p（E + 2）; / *（1、-1）* /
           B [3] [2] = B [2] [1] = B [1] [0] = avg3p（E + 3）; / *（0、-1）* /
           B [3] [3] = B [2] [2] = B [1] [1] = B [0] [0] =
             avg3p（E + 4）; / *（-1、-1）* /
           B [2] [3] = B [1] [2] = B [0] [1] = avg3p（E + 5）; / *（-1、0）* /
           B [1] [3] = B [0] [2] = avg3p（E + 6）; / *（-1、1）* /
           B [0] [3] = avg3p（E + 7）; / *（-1、2）* /
           壊す;
        
       / *残りの4つの対角モードは、傾きが
          +|-2および+|-1/2. これらの線の角度はおおよそです
          +|-水平または垂直から27度. 
        
          45度の対角線とは異なり、ここでは多くの場合、
          2つの実際の中間の「合成」予測ピクセル
          avg2p（p）を使用する予測子. 
          ピクセル「at」p[1/2]. * /
        
       ケースB_VR_PRED：/ * SSE（垂直右）ステップ=
                             （2,1）または（-2、-1）* /
           B [3] [0] = avg3p（E + 2）; / *予測子は（1、-1）からです* /
           B [2] [0] = avg3p（E + 3）; / *（0、-1）* /
           B [3] [1] = B [1] [0] = avg3p（E + 4）; / *（-1、-1）* /
           B [2] [1] = B [0] [0] = avg2p（E + 4）; / *（-1、-1 / 2）* /
           B [3] [2] = B [1] [1] = avg3p（E + 5）; / *（-1、0）* /
           B [2] [2] = B [0] [1] = avg2p（E + 5）; / *（-1、1/2）* /
           B [3] [3] = B [1] [2] = avg3p（E + 6）; / *（-1、1）* /
           B [2] [3] = B [0] [2] = avg2p（E + 6）; / *（-1、3 / 2）* /
        
           B [1] [3] = avg3p（E + 7）; / *（-1、2）* /
           B [0] [3] = avg2p（E + 7）; / *（-1、5/2）* /
           壊す;
        
       ケースB_VL_PRED：/ * SSW（垂直左）ステップ=
                             （2、-1）または（-2,1）* /
           B [0] [0] = avg2p（A）; / *予測子は（-1、1/2）からです* /
           B [1] [0] = avg3p（A + 1）; / *（-1、1）* /
           B [2] [0] = B [0] [1] = avg2p（A + 1）; / *（-1、3 / 2）* /
           B [1] [1] = B [3] [0] = avg3p（A + 2）; / *（-1、2）* /
           B [2] [1] = B [0] [2] = avg2p（A + 2）; / *（-1、5/2）* /
           B [3] [1] = B [1] [2] = avg3p（A + 3）; / *（-1、3）* /
           B [2] [2] = B [0] [3] = avg2p（A + 3）; / *（-1、7/2）* /
           B [3] [2] = B [1] [3] = avg3p（A + 4）; / *（-1、4）* /
           /*最後の2つの値はパターンに厳密に従っていません. * /
           B [2] [3] = avg3p（A + 5）; / *（-1、5）[avg2p（A + 4）=
                                        （-1,9 / 2）] * /
           B [3] [3] = avg3p（A + 6）; / *（-1、6）[avg3p（A + 5）=
                                        （-1,5）] * /
           壊す;
        
       ケースB_HD_PRED：/ * ESE（水平ダウン）ステップ=
                             （1,2）または（-1、-2）* /
           B [3] [0] = avg2p（E）; / *予測子は（5/2、-1）からです* /
           B [3] [1] = avg3p（E + 1）; / *（2、-1）* /
           B [2] [0] = B [3] [2] = svg2p（E + 1）; / *（3/2、-1）* /
           B [2] [1] = B [3] [3] = avg3p（E + 2）; / *（1、-1）* /
           B [2] [2] = B [1] [0] = avg2p（E + 2）; / *（1/2、-1）* /
           B [2] [3] = B [1] [1] = avg3p（E + 3）; / *（0、-1）* /
           B [1] [2] = B [0] [0] = avg2p（E + 3）; / *（-1 / 2、-1）* /
           B [1] [3] = B [0] [1] = avg3p（E + 4）; / *（-1、-1）* /
           B [0] [2] = avg3p（E + 5）; / *（-1、0）* /
           B [0] [3] = avg3p（E + 6）; / *（-1、1）* /
           壊す;
        
       ケースB_HU_PRED：/ * ENE（水平上）ステップ=（1、-2）
                             または（-1,2）* /
           B [0] [0] = avg2p（L）; / *予測子は（1/2、-1）からです* /
           B [0] [1] = avg3p（L + 1）; / *（1、-1）* /
           B [0] [2] = B [1] [0] = avg2p（L + 1）; / *（3/2、-1）* /
           B [0] [3] = B [1] [1] = avg3p（L + 2）; / *（2、-1）* /
           B [1] [2] = B [2] [0] = avg2p（L + 2）; / *（5/2、-1）* /
           B [1] [3] = B [2] [1] = avg3（L [2]、L [3]、L [3]）; / *（3、-1）* /
        
           /*底の大部分のパターンに従うことはできません
              （近くに）すでに構築されたピクセルがないため、行
              問題の対角線上. * /
           B [2] [2] = B [2] [3] = B [3] [0] = B [3] [1] = B [3] [2] = B [3] [3]
             = L [3];
     }
   }
        
   ----終了コードブロック----------------------------------------
        
サブブロック内予測の参照デコーダーの実装は、predict.c（セクション20.14）にあります. 

13.DCT係数デコード
2番目のデータパーティションは、残差信号の量子化されたDCT（およびWHT）係数のエンコードで構成されます. フォーマットの概要（セクション2）で説明したように、各マクロブロックについて、残差が（生成内または生成間）予測バッファーに追加され、最終的な（ループフィルタリングを除く）再構築されたマクロブロックが生成されます. 

VP8は、マクロブロックの24（またはY2サブブロックでは25）の4x4サブブロックに適用される4x4DCTおよびWHTでのみ機能します. 一般に、「残差」パーティション内のマクロブロックの順序は、最初の「予測」パーティションで使用されたものと同じラスタースキャンに従います. 

B_PRED（イントラ：Yサブブロックが独立して予測される）およびSPLITMV（インター）を除くすべてのイントラおよびインター予測モードでは、各マクロブロックの残差レコードは、WHTを使用してコード化された残差のY2コンポーネントで始まります. B_PREDおよびSPLITMVでコード化されたマクロブロックは、このWHTを省略し、16個のYサブブロックのそれぞれで0番目のDCT係数を指定します. 

オプションのY2ブロックの後、残差レコードはYサブブロックの16 DCTで続き、Uサブブロックの4 DCTが続き、Vサブブロックの4DCTで終わります. サブブロックは通常の順序で発生します. 

DCTとWHTは、メンバーが「トークン」と呼ばれる12要素のアルファベットを使用してツリーコード化されています. ブロック終了トークン（残りのサブブロック係数をゼロに設定し、次のブロックが続く）を除いて、各トークン（トークンの直後のデータで拡張される場合もあります）は、現在の単一係数の値を指定します（暗黙の）位置であり、次の（暗黙の）位置に適用されるトークンが続きます. 

すべてのYおよび彩度サブブロックについて、係数の順序はいわゆるジグザグ順序に従います. DCTは、Y2が存在する場合は係数1で始まり、Y2が存在しない場合は係数0で始まります. Y2サブブロックのWHTは、常に係数0から始まります. 

13.1. 非ゼロ係数値のないマクロブロック
マクロブロック（MB）MODE_INFO内のフラグが、マクロブロックにゼロ以外の係数がないことを示している場合、DCT係数のデコードプロセスはマクロブロックに対してスキップされます. 

13.2. 個々の係数値のコーディング
係数トークンのコーディングは、DCTとWHTで同じです. このセクションの残りの部分では、「DCT」はDCTまたはWHTのいずれかを意味すると解釈する必要があります. 

すべてのトークン（ブロックの終わりを除く）は、単一の符号なし値または符号なし値の範囲（すぐに）のいずれかを指定し、その後にその範囲のベースからの値のオフセットの単純な確率的エンコードが続きます. 

ゼロ以外の値（いずれかのタイプ）の後には、コード化された値の符号を示すフラグが続きます（1の場合は負、0の場合は正）. 

以下は、トークンとデコードツリーです. 

   ----コードブロックを開始--------------------------------------
        
   typedef列挙型
   {{
       DCT_0、/*値0* /
       DCT_1、/ * 1 * /
       DCT_2、/ * 2 * /
       DCT_3、/ * 3 * /
       DCT_4、/ * 4 * /
       dct_cat1、/ *範囲5〜6（サイズ2）* /
       dct_cat2、/ * 7-10（4）* /
       dct_cat3、/ * 11-18（8）* /
       dct_cat4、/ * 19-34（16）* /
       dct_cat5、/ * 35-66（32）* /
       dct_cat6、/ * 67-2048（1982）* /
       dct_eob、/*ブロックの終わり*/
        
       num_dct_tokens / * 12 * /
   }
   dct_token;
        
   const tree_index coeff_tree [2 *（num_dct_tokens-1）] =
   {{
    -dct_eob、2、/ * eob = "0" * /
     -DCT_0、4、/ * 0 = "10" * /
      -DCT_1、6、/ * 1 = "110" * /
       8、12、
        -DCT_2、10、/ * 2 = "11100" * /
         -DCT_3、-DCT_4、/ * 3 = "111010"、4 = "111011" * /
        14、16、
         -dct_cat1、-dct_cat2、/ * cat1 = "111100"、
                                  cat2 = "111101" * /
        18、20、
         -dct_cat3、-dct_cat4、/ * cat3 = "1111100"、
                                  cat4 = "1111101" * /
         -dct_cat5、-dct_cat6 / * cat4 = "1111110"、
                                  cat4 = "1111111" * /
   };
        
   ----終了コードブロック----------------------------------------
        
一般に、すべてのDCT係数は同じツリーを使用してデコードされます. ただし、前の係数がDCT_0の場合、dct_eobがDCT_0を追跡することはできないため、デコードは最初の分岐をスキップします. 

トークンdct_cat1...dct_cat6は、符号なし値の範囲を指定します. 範囲内の値は、符号なしオフセット（幅はそれぞれ1、2、3、4、5、または11ビット）をベースに追加することによって形成されます. 範囲、次のアルゴリズムと固定確率テーブルを使用します. 

   ----コードブロックを開始--------------------------------------
        
   uint DCTextra（bool_decoder * d、const Prob * p）
   {{
       uint v = 0;
       do {v + = v + read_bool（d、* p）;} while（* ++ p）;
       vを返す;
   }
        
   const Prob Pcat1 [] = {159、0};
   const Prob Pcat2 [] = {165、145、0};
   const Prob Pcat3 [] = {173、148、140、0};
   const Prob Pcat4 [] = {176、155、140、135、0 };
   const Prob Pcat5 [] = {180、157、141、134、130、0};
   const Prob Pcat6 [] =
       {254、254、243、230、196、177、153、140、133、130、129、0};
        
   ----終了コードブロック----------------------------------------
        
v（係数ツリーを使用してデコードされた符号なしの値、おそらく上記のプロセスによって拡張された値）がゼロ以外の場合、その符号はフラグを読み取るだけで設定されます. 

   ----コードブロックを開始--------------------------------------
        
   if（read_bool（d、128））
       v = -v;
        
   ----終了コードブロック----------------------------------------
        
13.3. トークンの確率
トークンツリーの確率の指定（上記の「追加ビット」の場合とは異なります）は、かなり複雑です. 3つのコンテキストを使用して、大きな確率テーブルにインデックスを付けます. その内容は、フレームヘッダーで段階的に変更できます. 完全な（一定でない）確率テーブルは、次のようにレイアウトされています. 

   ----コードブロックを開始--------------------------------------
        
Prob coeff_probs [4] [8] [3] [num_dct_tokens-1];

   ----終了コードブロック----------------------------------------
        
外側から内側に向​​かって作業すると、最も外側の寸法は、デコードされる平面のタイプによってインデックスが付けられます. 

o 0-係数1から始まるY（つまり、Y2の後のY）

o 1-Y2

o2-UまたはV

o 3-Yは係数0から始まります（つまり、Y2がない場合はY）. 

次の次元は、デコードされる係数の位置によって選択されます. その位置cは、ブロックタイプ1、2、または3の場合はゼロから始まり、ブロックタイプ0の場合は1から始まり、15まで1ずつ進みます. 2番目の配列インデックスは次のようになります. 

   ----コードブロックを開始--------------------------------------
        
coeff_bands [c]

   ----終了コードブロック----------------------------------------
        
どこ：

   ----コードブロックを開始--------------------------------------
        
   const int coeff_bands [16] = {
        0、1、2、3、6、4、5、6、6、6、6、6、6、6、6、7
   };
        
   ----終了コードブロック----------------------------------------
        
位置から「バンド」への固定マッピングです. 

3番目の次元は最もトリッキーです. 大まかに言えば、それは「局所的な複雑さ」または近くの係数が非ゼロである程度を測定します. 

最初の係数（DC、ブロックタイプが0でない限り）については、現在のブロックの左上にある同じ平面（Y2、Y、U、またはV）内の（すでにエンコードされている）ブロックを考慮します. その場合、コンテキストインデックスは、残差レコードにゼロ以外の係数が少なくとも1つあるこれらのブロックの数（0、1、または2）です. 特にY2の場合、左上のマクロブロックにはY2ブロックがある場合とない場合があるため、上のブロックはY2ブロックがある同じ列の最新のマクロブロックによって決定され、左側のブロックはY2ブロックを持つ同じ行の最新のマクロブロック. 

最初の係数を超えると、コンテキストインデックスは、最後にデコードされた係数（必要に応じて現在のブロック内）の絶対値によって決定され、最後の係数がゼロの場合は0、プラスまたはマイナス1の場合は1、2の場合は2になります. その絶対値が1を超えました. 

この測定値の直感的な意味は、係数がデコードされるにつれて変化することに注意してください. たとえば、最初のトークンの前のゼロは、ネイバーが空であることを意味し、現在のブロックも空である可能性があることを示します. 最初のトークンの後、ブロックの終わりのトークンはその前に少なくとも1つの非ゼロ値を持っている必要があるため、ゼロはゼロをデコードしたばかりであることを意味し、したがって非ゼロ係数がこのブロックの後半に表示されることを保証します. ただし、完全なコンテキストは係数バンドにも依存するため（バンド0は位置0によって排他的に占有されるため）、この意味のシフトは完全に問題ありません. 

VP8で使用される他のコンテキストと同様に、ここで説明する「隣接ブロック」コンテキストには、フレームの一番上の行または左端に沿って配置されるサブブロックの特別な定義が必要です. 画像の左上にあるこれらの「存在しない」予測子は、単に空であると見なされます. つまり、ゼロ以外の係数が含まれていないと見なされます. 

次に、各マクロブロックの残差のデコードには、2つの方向（上と左）のそれぞれで、単一のY2予測子、UとVのそれぞれに2つの予測子、およびYに4つの予測子で構成される集計係数予測子が必要です. マクロブロックのスキャン順序付けでは、デコーダーは単一の「左」集約予測子と「上」集約予測子の行を維持する必要があります. 

残差をデコードする前に、「存在しない」予測の定義に従って、これらの維持された予測子を単純にクリアすることができます. 各ブロックがデコードされた後、ブロックによって参照される2つの予測子は、ブロックの（空または非空の）状態に置き換えられ、デコードされたばかりのブロックの下および右側のブロックの後でのデコードに備えます. 

もちろん、トークン確率配列の4番目の最後の次元は、すべてのツリー確率配列と同様に、トークンツリー構造内の位置（半分）によってインデックス付けされます. 

以下の擬似コードは、デコードプロセスを示しています. **で区切られた基準、機能などは、デコーダアーキテクチャに依存するか、このドキュメントの他の場所で詳しく説明されていることに注意してください. 

   ----コードブロックを開始--------------------------------------
        
   int block [16] = {0}; /*現在の4x4ブロック係数*/
   int firstCoeff = 0;
   int平面;
   int ctx2;
   int ctx3 = 0; /*上記の説明で参照されている3番目のコンテキスト*/
   Prob * probTable;
   intトークン;
   int記号;
   int absValue;
   int extraBits;
   bool prevCoeffWasZero = false;
   bool currentBlockHasCoeffs = false;
   / *各カテゴリごとの基本係数abs値、elem＃0は
      DCT_VAL_CATEGORY1、*＃1はDCT_VAL_CATEGORY2などです. * /
   int categoryBase [6] = {5、7、11、19、35、67};
        
   /*使用する平面を決定します*/
   if（** current_block_is_Y2_block **）plane = 0;
   else if（** current_block_is_chroma **）plane = 2;
   else if（** current_macroblock_has_Y2 **）plane = 1;
   それ以外の場合、平面= 3;
        
   / *「Y2マクロブロック」の輝度ブロックの場合、係数インデックス＃0をスキップします* /
   if（plane == 1）
       firstCoeff ++;
        
   /*隣接する4x4ブロックに係数があるかどうかを判別します. 
      これは、現在デコードしているプレーンによって異なります. 
      つまり、同じ平面からの係数のみをチェックします. 
      現在のブロック. * /
   if（** left_neighbor_block_has_coefficients（plane）**）
       ctx3 ++;
   if（** above_neighbor_block_has_coefficients（plane）**）
       ctx3 ++;
        
   for（i = firstCoeff; i <16; ++ i）
   {{
       ctx2 = coeff_bands [i];
       probTable = coeff_probs [plane] [ctx2] [ctx3];
        
       / *前のトークンがDCT_0の場合、最初のコード（dct_eob）をスキップします* /
       if（prevCoeffWasZero）
           トークン=treed_read（d、** coeff_tree_without_eob **、
             probTable）;
       そうしないと
           トークン=treed_read（d、coeff_tree、probTable）;
        
       if（token == dct_eob）
           壊す;
        
       if（トークン！= DCT_0）
       {{
           currentBlockHasCoeffs = true;
     if（** token_has_extra_bits（token）**）
     {{
         extraBits = DCTextra（token）;
         absValue =
             categoryBase [** token_to_cat_index（token）**] +
       extraBits;
     }
     そうしないと
     {{
         absValue = ** token_to_abs_value（token）**;
     }
        
     sign = read_bool（d、128）;
           block [i] =記号？-absValue：absValue;
       }
       そうしないと
       {{
           absValue = 0;
       }
        
       /*次の係数のコンテキストなどを設定します*/
       if（absValue == 0）ctx3 = 0;
       else if（absValue == 1）ctx3 = 1;
       それ以外の場合、ctx3 = 2;
       prevCoeffWasZero = true;
   }
        
   /*現在のブロックステータスをデコーダー内部に保存します*/
   ** block_has_coefficients [currentMb] [currentBlock] ** =
     currentBlockHasCoeffs;
        
   ----終了コードブロック----------------------------------------
        
実際、係数のデコード手順については完全に説明しましたが、読者は、tokens.cファイル（セクション20.16）にあるリファレンス実装を参照すると役立つと思われます. 

13.4. トークン確率の更新
上記のように、トークンのデコード確率はフレームごとに変わる可能性があります. キーフレームが検出されると、もちろん、セクション13.5に示すようにデフォルトに設定されます. キーフレームとインターフレームの両方がこれらの確率を調整する可能性があるため、これはヘッダーの残りの部分をデコードする前に発生する必要があります. 

係数確率更新レコード（フレームヘッダーのセクションI）のレイアウトとセマンティクスは単純です. coeff_probs配列の位置ごとに、対応する確率を更新する必要があるかどうかを示す固定確率ブール値が発生します. ブール値が真の場合、その確率を置き換えるP（8）が続きます. 更新は累積的であることに注意してください. つまり、あるフレームで更新された確率は、次のキーフレームまで、または確率が別のフレームによって明示的に更新されるまで、後続のすべてのフレームで有効です. 

上記を実行するためのアルゴリズムは単純です. 

   ----コードブロックを開始--------------------------------------
        
   int i = 0; 行う {
    int j = 0; 行う {
     int k = 0; 行う {
      int t = 0; 行う {
        
           if（read_bool（d、coeff_update_probs [i] [j] [k] [t]））
               coeff_probs [i] [j] [k] [t] = read_literal（d、8）;
        
      } while（++ t <num_dct_tokens-1）;
     } while（++ k <3）;
    } while（++ j <8）;
   } while（++ i <4）;
        
   ----終了コードブロック----------------------------------------
        
（一定の）更新確率は次のとおりです. 

   ----コードブロックを開始--------------------------------------
        
   const Prob coeff_update_probs [4] [8] [3] [num_dct_tokens-1] =
   {{
    {{
     {{
      {255、255、255、255、255、255、255、255、255、255、255}、
      {255、255、255、255、255、255、255、255、255、255、255}、
      {255、255、255、255、255、255、255、255、255、255、255}
     }、
     {{
      {176、246、255、255、255、255、255、255、255、255、255}、
      {223、241、252、255、255、255、255、255、255、255、255}、
      {249、253、253、255、255、255、255、255、255、255、255}
     }、
     {{
      {255、244、252、255、255、255、255、255、255、255、255}、
      {234、254、254、255、255、255、255、255、255、255、255}、
      {253、255、255、255、255、255、255、255、255、255、255}
     }、
     {{
      {255、246、254、255、255、255、255、255、255、255、255}、
      {239、253、254、255、255、255、255、255、255、255、255}、
      {254、255、254、255、255、255、255、255、255、255、255}
     }、
     {{
      {255、248、254、255、255、255、255、255、255、255、255}、
      {251、255、254、255、255、255、255、255、255、255、255}、
      {255、255、255、255、255、255、255、255、255、255、255}
     }、
     {{
      {255、253、254、255、255、255、255、255、255、255、255}、
      {251、254、254、255、255、255、255、255、255、255、255}、
      {254、255、254、255、255、255、255、255、255、255、255}
     }、
     {{
      {255、254、253、255、254、255、255、255、255、255、255}、
      {250、255、254、255、254、255、255、255、255、255、255}、
      {254、255、255、255、255、255、255、255、255、255、255}
     }、
     {{
      {255、255、255、255、255、255、255、255、255、255、255}、
      {255、255、255、255、255、255、255、255、255、255、255}、
      {255、255、255、255、255、255、255、255、255、255、255}
     }
    }、
        
    {{
     {{
      {217、255、255、255、255、255、255、255、255、255、255}、
      {225、252、241、253、255、255、254、255、255、255、255}、
      {234、250、241、250、253、255、253、254、255、255、255}
     }、
     {{
      {255、254、255、255、255、255、255、255、255、255、255}、
      {223、254、254、255、255、255、255、255、255、255、255}、
      {238、253、254、254、255、255、255、255、255、255、255}
     }、
     {{
      {255、248、254、255、255、255、255、255、255、255、255}、
      {249、254、255、255、255、255、255、255、255、255、255}、
      {255、255、255、255、255、255、255、255、255、255、255}
     }、
     {{
      {255、253、255、255、255、255、255、255、255、255、255}、
      {247、254、255、255、255、255、255、255、255、255、255}、
      {255、255、255、255、255、255、255、255、255、255、255}
     }、
     {{
      {255、253、254、255、255、255、255、255、255、255、255}、
      {252、255、255、255、255、255、255、255、255、255、255}、
      {255、255、255、255、255、255、255、255、255、255、255}
     }、
     {{
      {255、254、254、255、255、255、255、255、255、255、255}、
      {253、255、255、255、255、255、255、255、255、255、255}、
      {255、255、255、255、255、255、255、255、255、255、255}
     }、
     {{
      {255、254、253、255、255、255、255、255、255、255、255}、
      {250、255、255、255、255、255、255、255、255、255、255}、
      {254、255、255、255、255、255、255、255、255、255、255}
     }、
     {{
      {255、255、255、255、255、255、255、255、255、255、255}、
      {255、255、255、255、255、255、255、255、255、255、255}、
      {255、255、255、255、255、255、255、255、255、255、255}
     }
    }、
    {{
     {{
      {186、251、250、255、255、255、255、255、255、255、255}、
      {234、251、244、254、255、255、255、255、255、255、255}、
      {251、251、243、253、254、255、254、255、255、255、255}
     }、
        
     {{
      {255、253、254、255、255、255、255、255、255、255、255}、
      {236、253、254、255、255、255、255、255、255、255、255}、
      {251、253、253、254、254、255、255、255、255、255、255}
     }、
     {{
      {255、254、254、255、255、255、255、255、255、255、255}、
      {254、254、254、255、255、255、255、255、255、255、255}、
      {255、255、255、255、255、255、255、255、255、255、255}
     }、
     {{
      {255、254、255、255、255、255、255、255、255、255、255}、
      {254、254、255、255、255、255、255、255、255、255、255}、
      {254、255、255、255、255、255、255、255、255、255、255}
     }、
     {{
      {255、255、255、255、255、255、255、255、255、255、255}、
      {254、255、255、255、255、255、255、255、255、255、255}、
      {255、255、255、255、255、255、255、255、255、255、255}
     }、
     {{
      {255、255、255、255、255、255、255、255、255、255、255}、
      {255、255、255、255、255、255、255、255、255、255、255}、
      {255、255、255、255、255、255、255、255、255、255、255}
     }、
     {{
      {255、255、255、255、255、255、255、255、255、255、255}、
      {255、255、255、255、255、255、255、255、255、255、255}、
      {255、255、255、255、255、255、255、255、255、255、255}
     }、
     {{
      {255、255、255、255、255、255、255、255、255、255、255}、
      {255、255、255、255、255、255、255、255、255、255、255}、
      {255、255、255、255、255、255、255、255、255、255、255}
     }
    }、
    {{
     {{
      {248、255、255、255、255、255、255、255、255、255、255}、
      {250、254、252、254、255、255、255、255、255、255、255}、
      {248、254、249、253、255、255、255、255、255、255、255}
     }、
     {{
      {255、253、253、255、255、255、255、255、255、255、255}、
      {246、253、253、255、255、255、255、255、255、255、255}、
      {252、254、251、254、254、255、255、255、255、255、255}
     }、
        
     {{
      {255、254、252、255、255、255、255、255、255、255、255}、
      {248、254、253、255、255、255、255、255、255、255、255}、
      {253、255、254、254、255、255、255、255、255、255、255}
     }、
     {{
      {255、251、254、255、255、255、255、255、255、255、255}、
      {245、251、254、255、255、255、255、255、255、255、255}、
      {253、253、254、255、255、255、255、255、255、255、255}
     }、
     {{
      {255、251、253、255、255、255、255、255、255、255、255}、
      {252、253、254、255、255、255、255、255、255、255、255}、
      {255、254、255、255、255、255、255、255、255、255、255}
     }、
     {{
      {255、252、255、255、255、255、255、255、255、255、255}、
      {249、255、254、255、255、255、255、255、255、255、255}、
      {255、255、254、255、255、255、255、255、255、255、255}
     }、
     {{
      {255、255、253、255、255、255、255、255、255、255、255}、
      {250、255、255、255、255、255、255、255、255、255、255}、
      {255、255、255、255、255、255、255、255、255、255、255}
     }、
     {{
      {255、255、255、255、255、255、255、255、255、255、255}、
      {254、255、255、255、255、255、255、255、255、255、255}、
      {255、255、255、255、255、255、255、255、255、255、255}
     }
    }
   };
        
   ----終了コードブロック----------------------------------------
        
13.5. デフォルトのトークン確率テーブル
デフォルトのトークン確率は次のとおりです. 

   ----コードブロックを開始--------------------------------------
        
   const Prob default_coeff_probs [4] [8] [3] [num_dct_tokens-1] =
   {{
    {{
     {{
      {128、128、128、128、128、128、128、128、128、128、128}、
      {128、128、128、128、128、128、128、128、128、128、128}、
      {128、128、128、128、128、128、128、128、128、128、128}
     }、
     {{
      {253、136、254、255、228、219、128、128、128、128、128}、
      {189、129、242、255、227、213、255、219、128、128、128}、
      {106、126、227、252、214、209、255、255、128、128、128}
     }、
     {{
      {1、98、248、255、236、226、255、255、128、128、128}、
      {181、133、238、254、221、234、255、154、128、128、128}、
      {78、134、202、247、198、180、255、219、128、128、128}
     }、
     {{
      {1、185、249、255、243、255、128、128、128、128、128}、
      {184、150、247、255、236、224、128、128、128、128、128}、
      {77、110、216、255、236、230、128、128、128、128、128}
     }、
     {{
      {1、101、251、255、241、255、128、128、128、128、128}、
      {170、139、241、252、236、209、255、255、128、128、128}、
      {37、116、196、243、228、255、255、255、128、128、128}
     }、
     {{
      {1、204、254、255、245、255、128、128、128、128、128}、
      {207、160、250、255、238、128、128、128、128、128、128}、
      {102、103、231、255、211、171、128、128、128、128、128}
     }、
     {{
      {1、152、252、255、240、255、128、128、128、128、128}、
      {177、135、243、255、234、225、128、128、128、128、128}、
      {80、129、211、255、194、224、128、128、128、128、128}
     }、
        
     {{
      {1、1、255、128、128、128、128、128、128、128、128}、
      {246、1、255、128、128、128、128、128、128、128、128}、
      {255、128、128、128、128、128、128、128、128、128、128}
     }
    }、
    {{
     {{
      {198、35、237、223、193、187、162、160、145、155、62}、
      {131、45、198、221、172、176、220、157、252、221、1}、
      {68、47、146、208、149、167、221、162、255、223、128}
     }、
     {{
      {1、149、241、255、221、224、255、255、128、128、128}、
      {184、141、234、253、222、220、255、199、128、128、128}、
      {81、99、181、242、176、190、249、202、255、255、128}
     }、
     {{
      {1、129、232、253、214、197、242、196、255、255、128}、
      {99、121、210、250、201、198、255、202、128、128、128}、
      {23、91、163、242、170、187、247、210、255、255、128}
     }、
     {{
      {1、200、246、255、234、255、128、128、128、128、128}、
      {109、178、241、255、231、245、255、255、128、128、128}、
      {44、130、201、253、205、192、255、255、128、128、128}
     }、
     {{
      {1、132、239、251、219、209、255、165、128、128、128}、
      {94、136、225、251、218、190、255、255、128、128、128}、
      {22、100、174、245、186、161、255、199、128、128、128}
     }、
     {{
      {1、182、249、255、232、235、128、128、128、128、128}、
      {124、143、241、255、227、234、128、128、128、128、128}、
      {35、77、181、251、193、211、255、205、128、128、128}
     }、
     {{
      {1、157、247、255、236、231、255、255、128、128、128}、
      {121、141、235、255、225、227、255、255、128、128、128}、
      {45、99、188、251、195、217、255、224、128、128、128}
     }、
     {{
      {1、1、251、255、213、255、128、128、128、128、128}、
      {203、1、248、255、255、128、128、128、128、128、128}、
      {137、1、177、255、224、255、128、128、128、128、128}
     }
    }、
        
    {{
     {{
      {253、9、248、251、207、208、255、192、128、128、128}、
      {175、13、224、243、193、185、249、198、255、255、128}、
      {73、17、171、221、161、179、236、167、255、234、128}
     }、
     {{
      {1、95、247、253、212、183、255、255、128、128、128}、
      {239、90、244、250、211、209、255、255、128、128、128}、
      {155、77、195、248、188、195、255、255、128、128、128}
     }、
     {{
      {1、24、239、251、218、219、255、205、128、128、128}、
      {201、51、219、255、196、186、128、128、128、128、128}、
      {69、46、190、239、201、218、255、228、128、128、128}
     }、
     {{
      {1、191、251、255、255、128、128、128、128、128、128}、
      {223、165、249、255、213、255、128、128、128、128、128}、
      {141、124、248、255、255、128、128、128、128、128、128}
     }、
     {{
      {1、16、248、255、255、128、128、128、128、128、128}、
      {190、36、230、255、236、255、128、128、128、128、128}、
      {149、1、255、128、128、128、128、128、128、128、128}
     }、
     {{
      {1、226、255、128、128、128、128、128、128、128、128}、
      {247、192、255、128、128、128、128、128、128、128、128}、
      {240、128、255、128、128、128、128、128、128、128、128}
     }、
     {{
      {1、134、252、255、255、128、128、128、128、128、128}、
      {213、62、250、255、255、128、128、128、128、128、128}、
      {55、93、255、128、128、128、128、128、128、128、128}
     }、
     {{
      {128、128、128、128、128、128、128、128、128、128、128}、
      {128、128、128、128、128、128、128、128、128、128、128}、
      {128、128、128、128、128、128、128、128、128、128、128}
     }
    }、
    {{
     {{
      {202、24、213、235、186、191、220、160、240、175、255}、
      {126、38、182、232、169、184、228、174、255、187、128}、
      {61、46、138、219、151、178、240、170、255、216、128}
     }、
        
     {{
      {1、112、230、250、199、191、247、159、255、255、128}、
      {166、109、228、252、211、215、255、174、128、128、128}、
      {39、77、162、232、172、180、245、178、255、255、128}
     }、
     {{
      {1、52、220、246、198、199、249、220、255、255、128}、
      {124、74、191、243、183、193、250、221、255、255、128}、
      {24、71、130、219、154、170、243、182、255、255、128}
     }、
     {{
      {1、182、225、249、219、240、255、224、128、128、128}、
      {149、150、226、252、216、205、255、171、128、128、128}、
      {28、108、170、242、183、194、254、223、255、255、128}
     }、
     {{
      {1、81、230、252、204、203、255、192、128、128、128}、
      {123、102、209、247、188、196、255、233、128、128、128}、
      {20、95、153、243、164、173、255、203、128、128、128}
     }、
     {{
      {1、222、248、255、216、213、128、128、128、128、128}、
      {168、175、246、252、235、205、255、255、128、128、128}、
      {47、116、215、255、211、212、255、255、128、128、128}
     }、
     {{
      {1、121、236、253、212、214、255、255、128、128、128}、
      {141、84、213、252、201、202、255、219、128、128、128}、
      {42、80、160、240、162、185、255、205、128、128、128}
     }、
     {{
      {1、1、255、128、128、128、128、128、128、128、128}、
      {244、1、255、128、128、128、128、128、128、128、128}、
      {238、1、255、128、128、128、128、128、128、128、128}
     }
    }
   };
        
   ----終了コードブロック----------------------------------------
        
14.DCTとWHTの反転とマクロブロックの再構築
14.1. 量子化解除
   上記のようにDCT/WHTをデコードした後、それぞれ（量子化）
   各サブブロックの係数は、6つのうちの1つで乗算されます
   量子化解除係数、平面に応じた係数の選択
   （Y2、Y、または彩度）および位置（DC =係数ゼロ、AC=任意
        
他の係数）. 現在のマクロブロックが量子化器レベルをオーバーライドした場合（セクション10で説明）、オーバーライドによって提供される単一のインデックスを使用して、適切なスケーリングとクランプを使用して2つの非量子化テーブルから6つの要素が検索されます. それ以外の場合は、フレームレベルの非量子化係数（セクション9.6で説明）が使用されます. いずれの場合も、乗算は16ビットの符号付き整数を使用して計算および保存されます. 

参照デコーダファイルdequant_data.h（セクション20.3）にもある2つの逆量子化テーブルは次のとおりです. 

   ----コードブロックを開始--------------------------------------
        
   static const int dc_qlookup [QINDEX_RANGE] =
   {{
       4、5、6、7、8、9、10、10、11、12、13、14、15
      16、17、17、18、19、20、20、21、21、22、22、23、23、
      24、25、25、26、27、28、29、30、31、32、33、34、35、
      36、37、37、38、39、40、41、42、43、44、45、46、46、
      47、48、49、50、51、52、53、54、55、56、57、58、59、
      60、61、62、63、64、65、66、67、68、69、70、71、72、
      73、74、75、76、76、77、78、79、80、81、82、83、84、
      85、86、87、88、89、91、93、95、96、98、100、101、102、
      104、106、108、110、112、114、116、118、122、124、126、128、130、
      132、134、136、138、140、143、145、148、151、154、157、
   };
        
   static const int ac_qlookup [QINDEX_RANGE] =
   {{
       4、5、6、7、8、9、10、11、12、13、14、15、16
      17、18、19、20、21、22、23、24、25、26、27、28、29、
      30、31、32、33、34、35、36、37、38、39、40、41、42、
      43、44、45、46、47、48、49、50、51、52、53、54、55、
      56、57、58、60、62、64、66、68、70、72、74、76、78、
      80、82、84、86、88、90、92、94、96、98、100、102、104、
     106、108、110、112、114、116、119、122、125、128、131、134、137、
     140、143、146、149、152、155、158、161、164、167、170、173、177、
     181、185、189、193、197、201、205、209、213、217、221、225、229、
     234、239、245、249、254、259、264、269、274、279、284、
   };
        
   ----終了コードブロック----------------------------------------
        
上記の2つの表からのルックアップ値は、それぞれY1のDC係数とAC係数で直接使用されます. Y2と彩度の場合、上記の表の値は、乗算の前にスケーリングまたはクランプのいずれかを受けます. これらのスケーリングおよびクランププロセスに関する詳細は、dixie.cの関連するルックアップ関数（セクション20.4）にあります. 

14.2. 逆変換
Y2残基ブロックが存在する場合（つまり、マクロブロック輝度モードがSPLITMVまたはB_PREDでない場合）、最初に反転され（逆WHTを使用）、行i、列jの結果の要素が0番目の係数として使用されます. 位置（i、j）のYサブブロック、つまり、インデックスが（i * 4）+jであるYサブブロック. セクション13で説明したように、輝度モードがB_PREDまたはSPLITMVの場合、0番目のY係数はサブブロック自体の残差信号の一部です. 

いずれの場合も、次に16個のYサブブロックと8個の彩度サブブロックの逆変換が計算されます. これらの24の反転はすべて互いに独立しています. それらの結果は（少なくとも概念的には）24の別々の4x4アレイに保存される可能性があります. 

参照デコーダーによって行われるように、実装では、予測バッファーと残差バッファーをマクロブロックサイズの配列（つまり、16x16 Yバッファーと2つの8x8クロマバッファー）として表現したい場合があります. 以下に示す逆DCTの実装に関しては、結果として得られる残差ピクセルのアドレス計算を簡単に調整する必要があります. 

14.3. WHT反転の実装
前に説明したように（セクション2および13を参照）、B_PREDおよびSPLITMV以外の予測モードを使用してエンコードされたマクロブロックの場合、16 YブロックのDCT変換から導出されたDC値が収集され、マクロブロックの25番目のブロック（16 Y、 4 U、4 Vは24ブロックを構成します）. この25番目のブロックは、ウォルシュ-アダマール変換（WHT）を使用して変換されます. 

逆WHTへの入力（つまり、逆量子化された係数）、中間の「水平方向に逆変換された」信号、および完全に逆変換された残差信号はすべて、16ビットの符号付き整数の配列として格納されます. 

デコードプロセスを使用してビットストリーム形式を指定するという伝統に従い、次のCスタイルのソースコードを使用して、デコードプロセスで逆WHTを指定します. 

   ----コードブロックを開始--------------------------------------
        
   void vp8_short_inv_walsh4x4_c（short * input、short * output）
   {{
     int i;
     int a1、b1、c1、d1;
     int a2、b2、c2、d2;
     短い*ip=入力;
     短い*op=出力;
     int temp1、temp2;
        
     for（i = 0; i <4; i ++）
     {{
       a1 = ip [0] + ip [12];
       b1 = ip [4] + ip [8];
       c1 = ip [4]-ip [8];
       d1 = ip [0]-ip [12];
        
       op [0] = a1 + b1;
       op [4] = c1 + d1;
       op [8] = a1-b1;
       op [12] = d1-c1;
       ip ++;
       op ++;
     }
     ip=出力;
     op=出力;
     for（i = 0; i <4; i ++）
     {{
       a1 = ip [0] + ip [3];
       b1 = ip [1] + ip [2];
       c1 = ip [1]-ip [2];
       d1 = ip [0]-ip [3];
        
       a2 = a1 + b1;
       b2 = c1 + d1;
       c2 = a1-b1;
       d2 = d1-c1;
        
       op [0] =（a2 + 3）>> 3;
       op [1] =（b2 + 3）>> 3;
       op [2] =（c2 + 3）>> 3;
       op [3] =（d2 + 3）>> 3;
        
       ip + = 4;
       op + = 4;
     }
   }
        
   ----終了コードブロック----------------------------------------
        
入力にゼロ以外のDC値が1つしかない場合、逆変換は次のように簡略化できます. 

   ----コードブロックを開始--------------------------------------
        
   void vp8_short_inv_walsh4x4_1_c（short * input、short * output）
   {{
     int i;
     int a1;
     短い*op= output;
        
     a1 =（（input [0] + 3）>> 3）;
        
     for（i = 0; i <4; i ++）
     {{
       op [0] = a1;
       op [1] = a1;
       op [2] = a1;
       op [3] = a1;
       op + = 4;
     }
   }
        
   ----終了コードブロック----------------------------------------
        
適合デコーダーは、上記のCソースコードで指定されたプロセスの出力にビット単位で一致する出力を実現するために、まったく同じ丸めを使用して逆変換を実装する必要があることに注意してください. 

参照デコーダーのWHT反転は、ファイルidct_add.c（セクション20.8）にあります. 

14.4. DCT反転の実装
すべてのDCT反転は、まったく同じ方法で計算されます. 原則として、VP8は、1次元逆DCTの2つのパスとして実装された、従来の2次元逆離散コサイン変換を使用します. 1次元逆DCTは、[Loeffler]で説明されているものと同様のアルゴリズムを使用して計算されました. ただし、このペーパーでは、アルゴリズムの8ポイントバージョンと16ポイントバージョンのみが提供されており、On2によって4ポイント1-DDCTを実行するように適合されています. 

上記のアルゴリズムの1-DDCTを正確に計算するには、無限の精度が必要です. もちろん、VP8は有限精度の近似しか使用できません. また、VP8で使用される逆DCTは、標準のユニタリ変換の正規化を処理します. つまり、すべての非量子化係数は、対応する単一係数の約2倍のサイズになります. ただし、最高のデータレートを除いて、送信された係数と理想的な係数の不一致は、ほぼ完全に（不可逆）圧縮によるものであり、有限精度の演算によって引き起こされるエラーによるものではありません. 

逆DCTへの入力（つまり、離散化された係数）、中間の「水平方向に逆変換された」信号、および完全に逆変換された残差信号はすべて、16ビットの符号付き整数の配列として格納されます. 計算の詳細は以下のとおりです. 

この実装では、2つの乗算定数の16ビット固定小数点バージョンを使用することにも注意してください. 

   sqrt（2）* cos（pi / 8）
        
   sqrt（2）* sin（pi / 8）
        
最初の定数は1より大きいため、2番目の定数と同じ16ビットの固定小数点精度を維持するために、次の事実を利用します. 

   x * a = x + x *（a-1）
        
したがって

   x * sqrt（2）* cos（pi / 8）= x + x *（sqrt（2）* cos（pi / 8）-1）
        
   ----コードブロックを開始--------------------------------------
        
   /*IDCTの実装*/
   static const int cospi8sqrt2minus1 = 20001;
   static const int sinpi8sqrt2 = 35468;
   void short_idct4x4llm_c（short * input、short * output、intピッチ）
   {{
     int i;
     int a1、b1、c1、d1;
        
     短い*ip= input;
     短い*op= output;
     int temp1、temp2;
     intshortpitch=ピッチ>>1;
        
     for（i = 0; i <4; i ++）
     {{
       a1 = ip [0] + ip [8];
       b1 = ip [0]-ip [8];
        
       temp1 =（ip [4] * sinpi8sqrt2）>> 16;
       temp2 = ip [12] +（（ip [12] * cospi8sqrt2minus1）>> 16）;
       c1 = temp1-temp2;
        
       temp1 = ip [4] +（（ip [4] * cospi8sqrt2minus1）>> 16）;
       temp2 =（ip [12] * sinpi8sqrt2）>> 16;
       d1 = temp1 + temp2;
        
       op [shortpitch * 0] = a1 + d1;
       op [shortpitch * 3] = a1-d1;
       op [shortpitch * 1] = b1 + c1;
       op [shortpitch * 2] = b1-c1;
        
       ip ++;
       op ++;
     }
     ip=出力;
     op=出力;
     for（i = 0; i <4; i ++）
     {{
       a1 = ip [0] + ip [2];
       b1 = ip [0]-ip [2];
        
       temp1 =（ip [1] * sinpi8sqrt2）>> 16;
       temp2 = ip [3] +（（ip [3] * cospi8sqrt2minus1）>> 16）;
       c1 = temp1-temp2;
        
       temp1 = ip [1] +（（ip [1] * cospi8sqrt2minus1）>> 16）;
        
       temp2 =（ip [3] * sinpi8sqrt2）>> 16;
       d1 = temp1 + temp2;
        
       op [0] =（a1 + d1 + 4）>> 3;
       op [3] =（a1-d1 + 4）>> 3;
       op [1] =（b1 + c1 + 4）>> 3;
       op [2] =（b1-c1 + 4）>> 3;
        
       ip + = shortpitch;
       op + = shortpitch;
     }
   }
        
   ----終了コードブロック----------------------------------------
        
参照デコーダーのDCT反転は、ファイルidct_add.c（セクション20.8）にあります. 

14.5. 予測子と残差の合計
最後に、予測信号と残差信号が合計されて再構築されたマクロブロックが形成されます. これは、ループフィルタリング（次に取り上げる）を除いて、デコードプロセスを完了します. 

合計手順はかなり簡単で、詳細は2、3しかありません. 予測バッファーと残差バッファーは、どちらも16ビットの符号付き整数の配列です. 各個々の（Y、U、およびVピクセル）結果は、最初に予測と残差の32ビットの合計として計算され、次に8ビットの符号なし範囲（たとえば、上記で定義されたclamp255関数を使用）に飽和されてから次のようになります.  8ビットの符号なしピクセル値として格納されます. 

VP8は、ビットストリームのエンコーディングが0〜255のすべての再構築されたピクセル値を保証するモードもサポートします. このような要件に準拠するビットストリームでは、フレームヘッダーのclamp_typeビットが1に設定されています. このような場合、clamp255関数は不要になります. 

マクロブロックに対して有効な（イントラまたはインター）予測モードに関係なく、合計プロセスは同じです. 再構築のリファレンスデコーダーの実装は、ファイルidct_add.cにあります. 

15.ループフィルター
ループフィルタリングは、フレーム再構築の最終段階であり、デコードプロセスの最後から2番目の段階です. セクション14で説明されているように、ループフィルタは、予測子と残差信号の合計後にフレーム全体に適用されます. 

ループフィルターの目的は、マクロブロックとその構成サブブロックのコーディングの半独立性に関連する視覚的に好ましくないアーティファクトを排除（または少なくとも削減）することです. 

セクション5で説明したように、ループフィルタは、ループフィルタリングの結果が後続のフレームの予測に使用されるという点で、デコードに「統合」されています. したがって、機能デコーダの実装は、ここで説明されているとおりにループフィルタリングを実行する必要があります. これは、表示直前の画像にのみ適用できる後処理とは異なります. このような後処理は、完全に実装者（および/またはユーザー）の選択であり、デコード自体には影響しません. 

ループフィルターを制御するベースラインフレームレベルのパラメーターは、マクロブロックの予測モードや参照フレームに基づいて調整するためのメカニズムとともに、フレームヘッダー（セクション9.4）で定義されます. 1つ目は、フィルターのタイプ（通常または単純）を選択するフラグ（filter_type）です. 他の2つは、フィルターの強度または感度を調整する数値（loop_filter_levelおよびsharpness_level）です. セクション9.3および10で説明されているように、loop_filter_levelは、セグメンテーションを使用してマクロブロックごとにオーバーライドすることもできます. 

ループフィルタリングは、VP8デコードのより計算量の多い側面の1つです. これが、オプションで要求の少ない単純なフィルタータイプが存在する理由です. 

フレームヘッダーレベルまたはマクロブロックオーバーライドレベルのいずれかでloop_filter_levelが0の場合、ループフィルタリングを完全にスキップする必要があることに注意してください. ループフィルターを値0で実行しないでください. 代わりにスキップする必要があります. 

まず、制御パラメーターや選択したフィルターのタイプに依存しないループフィルタリングの側面について説明します. 

15.1. フィルタの形状と全体的な手順
Y、U、およびV平面は、独立して同じように処理されます. 

ループフィルターは、隣接するマクロブロック間のエッジと、マクロブロックの隣接するサブブロック間のエッジに作用します. そのようなエッジはすべて水平または垂直です. エッジ上の各ピクセル位置について、位置のいずれかの側に隣接する少数（2つまたは3つ）のピクセルが検査され、場合によっては変更されます. これらのピクセルの変位は、エッジの向きに対して直角です. つまり、水平方向のエッジの場合、エッジ位置のすぐ上下のピクセルを処理し、垂直方向のエッジの場合、エッジのすぐ左右のピクセルを処理します. 

エッジ位置に関連付けられたこのピクセルのコレクションをセグメントと呼びます. セグメントの長さは2、4、6、または8です. 通常のフィルターがわずかに異なるアルゴリズムを使用し、いずれかのフィルターがマクロブロック間のエッジとサブブロック間のエッジに異なる制御パラメーターを適用する可能性があることを除いて、エッジの処理は次のとおりです. 非常に均一：エッジにまたがるすべてのセグメントは同じように扱われます. マクロブロック間でもサブブロック間でも、水平エッジと垂直エッジの処理に違いはありません. 

結果として、マクロブロック内の隣接するサブブロックエッジが連結され、全体が処理される場合があります. UブロックとVブロックのそれぞれの水平方向に中央に配置された長さ8ピクセルの垂直エッジが1つ（クロマサブブロック間の上下の4ピクセルエッジの連結）、水平位置に長さ16ピクセルの垂直エッジが3つあります1 / 4、1 / 2、および3/4は、輝度マクロブロックの幅であり、それぞれがYサブブロックのペア間の4つの4ピクセルサブエッジの連結を表します. 

フレームを構成するマクロブロックは、通常のラスタースキャン順序で処理されます. 各マクロブロックは、そのすぐ上と左にあるマクロブロック間エッジ（ただし、その下と右にあるエッジではない）と、そのサブブロック間のエッジに「責任を負います」. 

マクロブロックMごとに、4つのフィルタリングステップがあります. これらは（ほぼ）順番に行われます. 

1. Mがマクロブロックの左端の列にない場合は、Mの左（垂直）マクロブロック間エッジをフィルタリングします. 

2.M内の垂直サブブロックエッジ全体をフィルタリングします. 

3. Mがマクロブロックの最上行にない場合は、Mの最上部（水平）のマクロブロック間エッジをフィルタリングします. 

4.M内の水平サブブロックエッジ全体をフィルタリングします. 

Mの平面構成要素、つまり、Mを構成する16x16輝度ブロック、8x8 Uブロック、および8x8 Vブロックに対してMY、MU、およびMVを記述します. 

ステップ1では、MY、MU、およびMVの3つのブロックのそれぞれについて、ブロックをブロックのすぐ左にあるブロックから分離する列にまたがる（16ルマまたは8クロマ）セグメントのそれぞれを、インターloop_filter_levelとsharpness_levelに関連付けられたマクロブロックフィルターとコントロール. 

ステップ4では、上記の垂直サブブロックエッジ（サブブロック間フィルターとコントロールを使用して、3つの輝度とUとVにそれぞれ1つ）をフィルター処理します. 

次の2つの条件を満たすマクロブロックの場合、手順2と4はスキップされます. 

1.マクロブロックコーディングモードはB_PREDでもSPLITMVでもありません. と

2.マクロブロック全体に対してコード化されたDCT係数はありません. 

これらのマクロブロックの場合、マクロブロックの内部にあるサブブロック間のエッジのループフィルタリングは効果的にスキップされます. このスキップ戦略により、VP8ループフィルタリングの複雑さが大幅に軽減されます. 

マクロブロック間のエッジとサブブロック間のエッジは、異なる制御パラメーターで処理されます（通常のフィルターの場合は、異なるアルゴリズムで処理されます）. ピクセルアドレス指定を除いて、垂直エッジと水平エッジの処理に違いはありません. ルマエッジは常に16ピクセルの長さであり、クロマエッジは常に8ピクセルの長さであり、エッジにまたがるセグメントは同じように扱われます. もちろん、これによりベクトル処理が容易になります. 

多くのピクセルは2つ以上のエッジにまたがるセグメントに属し、複数回フィルタリングされるため、上記のエッジが処理される順序は、どの実装でも尊重する必要があります. ただし、単一のエッジ内では、そのエッジにまたがるセグメントは互いに素であり、これらのセグメントが処理される順序は重要ではありません. 

フィルタリングアルゴリズム自体を取り上げる前に、すでに述べた点を強調する必要があります. マクロブロックに関連付けられたピクセルセグメントがマクロブロックの前にある（つまり、マクロブロック内またはすでに構築されたマクロブロック内にある）場合でも、

マクロブロックは、その「再構築」（セクション14で説明）の直後にフィルタリングしてはなりません. むしろ、ループフィルターは、すべてのマクロブロックが「再構築」された後（つまり、予測子が残差と合計された後）に適用されます. 正しいデコードは、イントラ予測（セクション12で説明）を介して参照される現在のフレームのすでに構築された部分がまだフィルタリングされていないという事実に基づいています. 

15.2. シンプルフィルター
ループフィルターの全体的な手順と影響を受けるピクセルについて説明したので、エッジにまたがる個々のセグメントの処理に注意を向けます. まず、読者が推測するように、通常のフィルターよりもいくらか単純な単純なフィルターについて説明します. 

単純なフィルターは輝度エッジにのみ適用されることに注意してください. クロマエッジはフィルタリングされません. 

大まかに言えば、ループフィルタリングの考え方は、制限内で、エッジにまたがるピクセル間の差を減らすことです. （loop_filter_levelに関連付けられた）しきい値を超える差異は「自然」であると見なされ、変更されません. しきい値を下回る差異は、量子化のアーティファクトと（部分的に）ブロックの個別のコーディングであると見なされ、以下に説明する手順によって削減されます. loop_filter_levelは原則として任意ですが、VP8コンプレッサーによって選択されるレベルはクォンタイザーレベルと相関する傾向があります. 

フィルタリング演算のほとんどは、8ビットの符号付きオペランド（-128から+127までの範囲）を使用して実行され、乗算の結果を保持する16ビットの一時的なオペランドが追加されます. 

合計およびその他の一時値は、有効な符号付き8ビット範囲に「クランプ」する必要があります. 

   ----コードブロックを開始--------------------------------------
        
   int8 c（int v）
   {{
       return（int8）（v <-128？-128：（v <128？v：127））;
   }
        
   ----終了コードブロック----------------------------------------
        
ピクセル値自体は符号なし8ビット数であるため、符号付き値と符号なし値の間で変換する必要があります. 

   ----コードブロックを開始--------------------------------------
        
   / *ピクセル値（0 <= v <= 255）を8ビット符号付きに変換します
      番号. * /
   int8 u2s（Pixel v）{return（int8）（v --128）;}
        
   / *クランプしてから、符号付き数値をピクセル値に変換し直します. * /
   Pixel s2u（int v）{return（Pixel）（c（v）+ 128）;}
        
   ----終了コードブロック----------------------------------------
        
フィルタリングは、多くの場合、絶対値のしきい値に基づいています. 次の関数は、標準ライブラリ関数absと同等であり、そのプロトタイプは標準ヘッダーファイルstdlib.hにあります. 私たちにとって、引数vは常に2つのピクセル間の差であり、-255 <= v<=+255の範囲にあります. 

   ----コードブロックを開始--------------------------------------
        
   int abs（int v）{return v <0？-v：v;}
        
   ----終了コードブロック----------------------------------------
        
もちろん、実際の実装では、インライン関数またはマクロを使用して、これらの簡単な手順（通常のループフィルターと単純なループフィルターの両方で使用されます）を実行します. 最適な実装では、おそらく単一の命令、複数のデータ（SIMD）ベクトル命令を使用して、それらを機械語で表現します. 多くのSIMDプロセッサでは、上記のクランプ機能によって達成される飽和は、多くの場合、算術命令自体に組み込まれるため、ここで行う明示的な手順が不要になります. 

相対的なピクセル位置の指定を簡略化するために、「前」という単語を使用して、「すぐ上」（水平エッジにまたがる垂直セグメントの場合）または「すぐ左」（垂直エッジにまたがる水平セグメントの場合）を意味します.  、および「後」という単語は、「すぐ下」または「すぐ右」を意味します. 

エッジ、セグメント、および制限値が与えられると、単純なループフィルターは、エッジにまたがる4つのピクセル（両側に2つ）に基づいて値を計算します. その値が提供された制限を下回っている場合、非常に大まかに言えば、2つのピクセル値は互いに近づき、差の4分の1のようなものを「削り取り」ます. ザ

エッジの性質（マクロブロック間、サブブロック間、輝度、または彩度）に関係なく、あらゆるタイプのエッジにまたがるすべてのセグメントに同じ手順が使用されます. 制限値のみがエッジタイプに依存します. 

正確な手順（単一セグメントの場合）は次のとおりです. サブルーチンcommon_adjustは、ここに示されている単純なフィルターとセクション15.3で説明されている通常のフィルターの両方で使用されます. 

   ----コードブロックを開始--------------------------------------
        
   int8 common_adjust（
       int use_outer_taps、/*フィルターの幅は2または4タップです*/
       const Pixel * P1、/*P0の前のピクセル*/
       ピクセル*P0、/*エッジの前のピクセル*/
       ピクセル*Q0、/*エッジ後のピクセル*/
       const Pixel * Q1 /*Q0の後のピクセル*/
   ）{
       cint8 p1 = u2s（* P1）; /*4ピクセルすべてを取得して変換します*/
       cint8 p0 = u2s（* P0）;
       cint8 q0 = u2s（* Q0）;
       cint8 q1 = u2s（* Q1）;
        
       / *「use_outer_taps」がfalseの場合、クランプを無視して、
          「a」は3*（q0-p0）です. 「a」をで割ろうとしているので
          8、この場合、エッジを乗算することになります
          5/8の差. 
        
          「use_outer_taps」がtrueの場合（単純なフィルターの場合）、
          「a」はp1-3* p0 + 3 * q0-q1であり、次のように考えることができます. 
          2 *（q0 --p0）の改良であり、調整は
          （q0 --p0）/4のようなもの. * /
        
       int8 a = c（（use_outer_taps？c（p1-q1）：0）+ 3 *（q0 --p0））;
        
       / * bは、次の場合にa/8の丸めのバランスを取るために使用されます. 
          a/8の「小数」部分「f」は正確に1/2です. * /
        
       cint8 b =（c（a + 3））>> 3;
        
       / * aを8で割り、f>=1/2の場合は切り上げます. 
          厳密にはC言語の一部ではありませんが、
          右シフトは符号ビットを伝搬すると想定されます. * /
        
       a = c（a + 4）>> 3;
        
       / * q0から「a」を引き、「p0に近づけます」. * /
        
       * Q0 = s2u（q0-a）;
        
       / * p0に「a」（調整「b」を含む）を追加し、「近づけます」
          q0に. 
        
          「a+b」のクランプは、参照デコーダーに存在しますが、
          不要です. この時点で-16<=a<=15になります. * /
        
       * P0 = s2u（p0 + b）;
        
       返す;
   }
        
   ----終了コードブロック----------------------------------------
        
   ----コードブロックを開始--------------------------------------
        
   void simple_segment（
       uint8 edge_limit、/*エッジの違いがある場合は何もしません
                              制限を超えています*/
       const Pixel * P1、/*P0の前のピクセル*/
       ピクセル*P0、/*エッジの前のピクセル*/
       ピクセル*Q0、/*エッジ後のピクセル*/
       const Pixel * Q1 /*Q0の後のピクセル*/
   ）{
       if（（abs（* P0-* Q0）* 2 + abs（* P1-* Q1）/ 2）<= edge_limit））
           common_adjust（1、P1、P0、Q0、Q1）; /*外側のタップを使用します*/
   }
        
   ----終了コードブロック----------------------------------------
        
上記の丸め手順について、いくつかの注意を払います. bがゼロの場合（つまり、aの「小数部分」が1/2でない場合）、q0から減算するのと同じ数をp0に加算します（クランプを除く）. これにより、p0とq0の平均値が保持されますが、結果として生じるp0とq0の差は常に偶数になります. 特に、ここではゼロ以外の最小グラデーション+-1は使用できません. 

bが1の場合、p0に追加する値（ここでもクランプを除く）は、q0から減算する値より1つ小さくなります. この場合、結果として生じる差は常に奇数です（そして、小さなグラデーション+ -1が可能です）が、平均値は1/2減少し、たとえば、輝度面で非常にわずかな暗さをもたらします. （多数のインターフレームの後にかなりの暗くなるという非常にまれなイベントでは、コンプレッサーはもちろん、予測子および/または残差の選択でこれを最終的に補償します. ）

以下で通常のループフィルタリングアルゴリズムについて説明した後、loop_filter_levelとsharpness_level、および処理されるエッジのタイプに依存する、上記で使用されたedge_limit値の導出が取り上げられます. 

15.3. 通常のフィルター
通常のループフィルターは、単純なループフィルターを改良したものです. 上記の一般的な説明はすべて、ここでも当てはまります. 特に、関数c、u2s、s2u、abs、およびcommon_adjustは、通常のフィルターと単純なフィルターの両方で使用されます. 

上記のように、マクロブロック間エッジとサブブロック間エッジの通常のアルゴリズムは異なります. それにもかかわらず、それらには多くの共通点があります. それらは、同様のしきい値アルゴリズムを使用して、フィルターを無効にし、高い内部エッジ分散（フィルターアルゴリズムに影響を与える）を検出します. どちらのアルゴリズムも、少なくとも条件付きで、上記の簡単なフィルター調整手順を使用します. 

一般的なしきい値アルゴリズムは次のとおりです. 

   ----コードブロックを開始--------------------------------------
        
   / *すべての関数は（とりわけ）（長さの）セグメントを取ります
      最大で4+4 = 8）エッジを対称的にまたがります. 
        
      ピクセル値（またはポインタ）は常に順番に指定されます. 
      「最前」から「最後」へ. だから、
      水平エッジ（「|」と表記）、8ピクセルのセグメントは
      注文したp3p2p1 p0 | q0 q1q2q3. * /
        
   / * 2つの違いがある場合、フィルタリングは無効になります
      8ピクセルセグメント内の隣接する「内部」ピクセルが
      関連するしきい値（I）. より複雑なしきい値
      計算は、次の4つのピクセルのグループに対して行われます. 
      の計算に沿って、エッジにまたがる
      上記のsimple_segment（）. * /
        
   int filter_yes（
       uint8 I、/*内部の違いの制限*/
       uint8 E、/*エッジでの制限*/
        
       cint8 p3、cint8 p2、cint8 p1、cint8 p0、/*ピクセル前
                                                  縁 */
       cint8 q0、cint8 q1、cint8 q2、cint8 q3/*ピクセル後
                                                  縁 */
   ）{
       return（abs（p0-q0）* 2 + abs（p1-q1）/ 2）<= E
           && abs（p3-p2）<= I && abs（p2-p1）<= I &&
             abs（p1-p0）<= I
           && abs（q3-q2）<= I && abs（q2-q1）<= I &&
             abs（q1-q0）<= I;
   }
        
   ----終了コードブロック----------------------------------------
        
   ----コードブロックを開始--------------------------------------
        
   / *（少なくとも）違いの1つがあれば、フィルタリングが変更されます
      エッジのいずれかの側がしきい値を超えています（
      「高エッジ分散」）. * /
        
   int hev（
       uint8しきい値、
       cint8 p1、cint8 p0、/*エッジの前のピクセル*/
       cint8 q0、cint8 q1/*エッジ後のピクセル*/
   ）{
       abs（p1-p0）>しきい値を返す|| abs（q1-q0）>しきい値;
   }
        
   ----終了コードブロック----------------------------------------
        
サブブロックフィルターは、単純フィルターの変形です. 実際、エッジの分散が大きい場合、調整は単純なフィルターの場合とまったく同じです. それ以外の場合は、単純な調整（外側のタップなし）が適用され、エッジピクセルから1ステップ入った2つのピクセルは、2つのエッジピクセルが調整される量の約半分だけ調整されます. ここでのエッジ調整は基本的にエッジ差の3/8であるため、内部調整はエッジ差の約3/16です. 

   ----コードブロックを開始--------------------------------------
        
   void subblock_filter（
       uint8 hev_threshold、/*高エッジ分散を検出*/
       uint8 internal_limit、/*フィルターを無効にする可能性があります*/
       uint8 edge_limit、
       cint8 * P3、cint8 * P2、int8 * P1、int8 * P0、/*ピクセル前
                                                      縁 */
       int8 * Q0、int8 * Q1、cint8 * Q2、cint8 * Q3/*ピクセル後
                                                      縁 */
   ）{
       cint8 p3 = u2s（* P3）、p2 = u2s（* P2）、p1 = u2s（* P1）、
         p0 = u2s（* P0）;
       cint8 q0 = u2s（* Q0）、q1 = u2s（* Q1）、q2 = u2s（* Q2）、
         q3 = u2s（* Q3）;
        
       if（filter_yes（interior_limit、edge_limit、q3、q2、q1、q0、
         p0、p1、p2、p3））
       {{
           const int hv = hev（hev_threshold、p1、p0、q0、q1）;
        
           cint8 a =（common_adjust（hv、P1、P0、Q0、Q1）+ 1）>> 1;
        
           if（！hv）{
               * Q1 = s2u（q1-a）;
               * P1 = s2u（p1 + a）;
           }
       }
   }
        
   ----終了コードブロック----------------------------------------
        
マクロブロック間フィルターは、潜在的に広い範囲を持っています. エッジの分散が大きい場合は、単純な調整を実行します（単純なフィルターと、通常のサブブロックフィルターの対応するケースと同様に、外側のタップを使用します）. エッジの分散が小さい場合は、同じ基本的なフィルター計算から始めて、エッジに関して対称なピクセルペアにその倍数を適用します. 調整の大きさは、エッジから離れるにつれて減衰し、セグメント内の6つのピクセルが影響を受けます. 

   ----コードブロックを開始--------------------------------------
        
   void MBfilter（
       uint8 hev_threshold、/*高エッジ分散を検出*/
       uint8 internal_limit、/*フィルターを無効にする可能性があります*/
       uint8 edge_limit、
       cint8 * P3、int8 * P2、int8 * P1、int8 * P0、/*ピクセル前
                                                    縁 */
       int8 * Q0、int8 * Q1、int8 * Q2、cint8 * Q3/*ピクセル後
                                                    縁 */
   ）{
       cint8 p3 = u2s（* P3）、p2 = u2s（* P2）、p1 = u2s（* P1）、
         p0 = u2s（* P0）;
       cint8 q0 = u2s（* Q0）、q1 = u2s（* Q1）、q2 = u2s（* Q2）、
         q3 = u2s（* Q3）;
        
       if（filter_yes（interior_limit、edge_limit、q3、q2、q1、q0、
         p0、p1、p2、p3））
       {{
           if（！hev（hev_threshold、p1、p0、q0、q1））
           {{
               / *「common_adjust」の最初の計算と同じ、
                  wはエッジ差の2倍のようなものです*/
        
               const int8 w = c（c（p1-q1）+ 3 *（q0-p0））;
        
               /*9/64は約9/63=1/7、1 << 7 = 128 =
                  2*64. したがって、これは隣接するピクセルを調整するために使用されます
                  端まで、端の3/7のようなものです
                  違い. * /
        
               int8 a = c（（27 * w + 63）>> 7）;
        
               * Q0 = s2u（q0-a）; * P0 = s2u（p0 + a）;
        
               /*次の2つはエッジ差の2/7で調整されます*/
        
               a = c（（18 * w + 63）>> 7）;
        
               * Q1 = s2u（q1-a）; * P1 = s2u（p1 + a）;
        
               /*最後の2つはエッジの差の1/7で調整されます*/
        
               a = c（（9 * w + 63）>> 7）;
        
               * Q2 = s2u（q2-a）; * P2 = s2u（p2 + a）;
        
           } else / * hevの場合、単純なフィルターを実行します* /
               common_adjust（1、P1、P0、Q0、Q1）; /*アウターを使用
                                                       タップ*/
       }
   }
        
   ----終了コードブロック----------------------------------------
        
15.4. 制御パラメータの計算
上記の手順に提供されるしきい値が、2つの制御パラメーターsharpness_level（最大値7の符号なし3ビット数）とloop_filter_level（最大値63の符号なし6ビット数）からどのように導出されるかを示すことにより、ループフィルタリングの説明を締めくくります.  ）. 

Sharpness_levelはフレーム全体で一定ですが、個々のマクロブロックは、フレームヘッダーで提供される4つの可能性のいずれかでloop_filter_levelをオーバーライドできます（セクション10で説明）. 

単純フィルターと通常フィルターはどちらも、エッジにまたがる4つのピクセル（両側に2つ）から派生した値がしきい値/制限値を超えた場合にフィルタリングを無効にします. 

   ----コードブロックを開始--------------------------------------
        
   /*LumaとChromaは同じマクロブロック間エッジ制限を使用します*/
   uint8 mbedge_limit =（（loop_filter_level + 2）* 2）+
     internal_limit;
        
   /*LumaとChromaは同じサブブロック間エッジ制限を使用します*/
   uint8 sub_bedge_limit =（loop_filter_level * 2）+ internal_limit;
        
   ----終了コードブロック----------------------------------------
        
残りのしきい値は、通常のフィルターによってのみ使用されます. フィルタを無効にする内部差の制限は、すべてのエッジ（ルマ、クロマ、サブブロック間、マクロブロック間）で同じであり、次のように与えられます. 

   ----コードブロックを開始--------------------------------------
        
uint8 internal_limit = loop_filter_level;

   if（sharpness_level）
   {{
       internal_limit >> = Sharpness_level> 4？2：1;
       if（interior_limit> 9-sharpness_level）
           internal_limit =9-sharpness_level;
   }
   if（！interior_limit）
       internal_limit = 1;
        
   ----終了コードブロック----------------------------------------
        
最後に、すべてのエッジタイプで同じである高いエッジ分散しきい値の導出を示します. 

   ----コードブロックを開始--------------------------------------
        
uint8 hev_threshold = 0;

   if（we_are_decoding_akey_frame）/*現在のフレームがキーフレームである*/
   {{
       if（loop_filter_level> = 40）
           hev_threshold = 2;
       else if（loop_filter_level> = 15）
           hev_threshold = 1;
   }
   else/*現在のフレームはフレーム間です*/
   {{
       if（loop_filter_level> = 40）
           hev_threshold = 3;
       else if（loop_filter_level> = 20）
           hev_threshold = 2;
       else if（loop_filter_level> = 15）
           hev_threshold = 1;
   }
        
   ----終了コードブロック----------------------------------------
        
16.フレーム間マクロブロック予測レコード
フレーム間でのマクロブロックの予測レコードのレイアウトとセマンティクスについて説明します. 

機能仕様（セクション10で説明され、イントラフレームとインターフレームで同一）の後に、Bool（prob_intra）があります. これは、真の場合の相互予測（つまり、前のフレームからの予測）とイントラ予測（つまり、 falseの場合、現在のフレームのすでにコーディングされた部分からの予測）. ゼロ確率prob_intraは、フレームヘッダーのフィールドJによって設定されます. 

16.1. 予測されたマクロブロック
イントラ予測の場合、予測データのレイアウトは基本的にキーフレームのレイアウトと同じですが、デコードプロセスで使用されるコンテキストはわずかに異なります. 

セクション8で説明したように、ここでの「外部」Yモードは、キーフレームで使用されているものとは異なるツリーを使用します. 便宜上、ここで繰り返します. 

   ----コードブロックを開始--------------------------------------
        
   const tree_index ymode_tree [2 *（num_ymodes-1）] =
   {{
    -DC_PRED、2、/ *ルート：DC_PRED = "0"、"1"サブツリー*/
     4、6、/*"1"サブツリーには2つの子孫サブツリーがあります*/
      -V_PRED、-H_PRED、/ * "10"サブツリー：V_PRED = "100"、
                              H_PRED = "101" * /
      -TM_PRED、-B_PRED / * "11"サブツリー：TM_PRED = "110"、
                              B_PRED = "111" * /
   };
        
   ----終了コードブロック----------------------------------------
        
このツリーのデコードに使用される確率テーブルは可変です. セクション11で説明したように、（同様に処理されたUVテーブルとともに）フレームヘッダーのフィールドJによって更新できます. 係数デコードの確率と同様に、このような更新は累積的であり、次のキーフレームまたは明示的な更新まで後続のすべてのフレームに影響します. YテーブルとUVテーブルのデフォルトの確率は次のとおりです. 

   ----コードブロックを開始--------------------------------------
        
   Prob ymode_prob [num_ymodes-1] = {112、86、140、37};
   Prob uv_mode_prob [num_uv_modes-1] = {162、101、204};
        
   ----終了コードブロック----------------------------------------
        
これらのデフォルトは、キーフレームの検出後に復元する必要があります. 

キーフレームの場合と同様に、YモードがB_PREDの場合、次に、16個のYサブブロックのそれぞれで使用されるintra_bpredモードのエンコードが行われます. これらのエンコーディングは、キーフレームの場合と同じツリーを使用しますが、キーフレームで使用されるコンテキストの代わりに、単一の固定確率テーブルを使用します. 

   ----コードブロックを開始--------------------------------------
        
   const Prob bmode_prob [num_intra_bmodes-1] = {
       120、90、79、133、87、85、80、111、151
   };
        
   ----終了コードブロック----------------------------------------
        
最後に、クロマモードがあります. これも、キーフレームに使用されているのと同じツリーを使用してコーディングされています. 今回は、上記の動的uv_mode_probテーブルを使用しています. 

イントラ予測バッファの計算は、セクション12のキーフレームについて説明したものと同じです. 

16.2. 相互予測されたマクロブロック
それ以外の場合（上記のブール値が当てはまる場合）、相互予測（もちろん、フレーム間でのみ発生します）を使用しており、これに注意を制限しています. 

次のデータは、参照フレームを選択する別のブール値B（prob_last）です. 0の場合、参照フレームは前のフレーム（最後のフレーム）です. 1の場合、別のブール値（prob_gf）が、ゴールデンフレーム（0）とaltrefフレーム（1）の間の参照フレームを選択します. 確率prob_lastとprob_gfは、フレームヘッダーのフィールドJに設定されます. 

参照フレームの設定とともに、モード間デコードの目的は、現在のマクロブロックの16個のYサブブロックのそれぞれに動きベクトルを設定することです. 次に、これらの設定により、相互予測バッファーの計算が定義されます（セクション18で詳しく説明します）. モード間デコードの正味の効果は単純ですが、実装はやや複雑です. この方法で実現される（可逆）圧縮は、複雑さを正当化します. 

参照フレームセレクターの後に、マクロブロック全体に適用されるモード（または動きベクトル参照）があり、次の列挙とツリーを使用してコード化されます. mv_nearest = num_ymodesを設定すると、単一の変数が予測間モードまたは予測内モードを明確に保持できるようになります. 

   ----コードブロックを開始--------------------------------------
        
   typedef列挙型
   {{
       mv_nearest = num_ymodes、/*「最も近い」動きベクトルを使用
                                   MB全体*/
       mv_near、/*「次に近い」「」を使用*/
       mv_zero、/*ゼロを使用"" * /
       mv_new、/*からの明示的なオフセットを使用
                                   暗黙の""* /
       mv_split、/*複数の動きベクトルを使用*/
        
       num_mv_refs = mv_split +1-mv_nearest
   }
   mv_ref;
        
   const tree_index mv_ref_tree [2 *（num_mv_refs-1）] =
   {{
    -mv_zero、2、/*ゼロ="0" * /
     -mv_nearest、4、/*最も近い="10" * /
      -mv_near、6、/ * near = "110" * /
        -mv_new、-mv_split / * new = "1110"、split = "1111" * /
   };
        
   ----終了コードブロック----------------------------------------
        
16.3. モードと動きベクトルのコンテキスト
mv_refをデコードするために使用される確率テーブルは、選択されたモードで使用される3つの参照動きベクトルとともに、（最大）3つの近くのマクロブロック内のすでにデコードされた動きベクトルの調査によって計算されます. 

アルゴリズムは、検索サイトに隣接する個別の動きベクトルのソートされたリストを生成します. best_mvは、スコアが最も高いベクトルです. mv_nearestは、スコアが最も高いゼロ以外のベクトルです. mv_nearは、スコアが次に高いゼロ以外のベクトルです. SPLITMVモードを使用してコード化された動きベクトルの数は、同じ重み付けを使用してスコアリングされ、最良、最も近い、および最も近いベクトルのスコアとともに返されます. 

上、左、左上の3つの隣接するマクロブロックが順番に考慮されます. マクロブロックがイントラコード化されている場合、アクションは実行されません. それ以外の場合、動きベクトルは、以前に見つかった他の動きベクトルと比較されて、以前に見られたかどうかが判断され、見られた場合は、その重みがそのベクトルに寄与します. それ以外の場合は、リストに新しいベクトルを入力します. 上と左のベクトルは、左上のベクトルの2倍の重みを持ちます. 

VP8で使用される多くのコンテキストの場合と同様に、画像の上端または左端に近いマクロブロックが、表示されている画像の外側にあるブロックを参照する可能性があります. VP8は、左端の左側に0x0の動きベクトルで満たされた1つのマクロブロックの境界線と、上端の上の1つのマクロブロックの0,0の動きベクトルで満たされた境界線を提供します. 

プロセスの多くは、英語よりもCで簡単に説明できます. このための参照コードは、modemV.c（セクション20.11）にあります. 参照ベクトル、確率テーブル、そして最後に相互予測モード自体の計算は、次のように実装されます. 

   ----コードブロックを開始--------------------------------------
        
   typedef共用体
   {{
       unsigned int as_int;
       MV as_mv;
   } int_mv; /*迅速な同等性テストを容易にします*/
        
   static void mv_bias（MODE_INFO * x、int refframe、int_mv * mvp、
     int * ref_frame_sign_bias）
   {{
       MV xmv;
       xmv = x-> mbmi.mv.as_mv;
       if（ref_frame_sign_bias [x-> mbmi.ref_frame]！=
         ref_frame_sign_bias [refframe]）
       {{
           xmv.row * =-1;
           xmv.col * =-1;
       }
       mvp-> as_mv = xmv;
   }
        
   ----終了コードブロック----------------------------------------
        
   ----コードブロックを開始--------------------------------------
        
   void vp8_clamp_mv（MV * mv、const MACROBLOCKD * xd）
   {{
       if（mv-> col <（xd-> mb_to_left_edge --LEFT_TOP_MARGIN））
           mv-> col = xd-> mb_to_left_edge-LEFT_TOP_MARGIN;
       else if（mv-> col> xd-> mb_to_right_edge + RIGHT_BOTTOM_MARGIN）
           mv-> col = xd-> mb_to_right_edge + RIGHT_BOTTOM_MARGIN;
        
       if（mv-> row <（xd-> mb_to_top_edge --LEFT_TOP_MARGIN））
           mv-> row = xd-> mb_to_top_edge-LEFT_TOP_MARGIN;
       else if（mv-> row> xd-> mb_to_bottom_edge + RIGHT_BOTTOM_MARGIN）
           mv-> row = xd-> mb_to_bottom_edge + RIGHT_BOTTOM_MARGIN;
   }
        
   ----終了コードブロック----------------------------------------
        
関数vp8_find_near_mvs（）では、ベクトル「最も近い」と「近い」が対応するモードで使用されます. 

ベクトルbest_mvは、明示的にコード化されたモーションベクトルのベースとして使用されます. 

戻り値cntの最初の3つのエントリは、（順番に）「ゼロ」、「最も近い」、および「近い」ベクトルの加重国勢調査値です. 最終値は、SPLITMVが隣接するマクロブロックによって使用された程度を示します. いずれの場合も、可能な最大の「重み」値は5です. 

   ----コードブロックを開始--------------------------------------
        
void vp8_find_near_mvs（MACROBLOCKD * xd、const MODE_INFO * here、MV * nearest、MV * near、MV * best_mv、int cnt [4]、int refframe、int * ref_frame_sign_bias）

   {{
       const MODE_INFO * above = here --xd-> mode_info_stride;
       const MODE_INFO * left = here-1;
       const MODE_INFO * aboveleft = above-1;
       int_mv near_mvs [4];
       int_mv * mv = near_mvs;
       int * cntx = cnt;
       列挙型{CNT_ZERO、CNT_NEAREST、CNT_NEAR、CNT_SPLITMV};
        
       /*ゼロアキュムレータ*/
       mv [0] .as_int = mv [1] .as_int = mv [2] .as_int = 0;
       cnt [0] = cnt [1] = cnt [2] = cnt [3] = 0;
        
       /*上記のプロセス*/
       if（above-> mbmi.ref_frame！= INTRA_FRAME）{
           if（above-> mbmi.mv.as_int）{
               （++ mv）-> as_int = above-> mbmi.mv.as_int;
               mv_bias（above、refframe、mv、ref_frame_sign_bias）;
               ++ cntx;
           }
           * cntx + = 2;
       }
        
       /*プロセスが残っています*/
       if（left-> mbmi.ref_frame！= INTRA_FRAME）{
           if（left-> mbmi.mv.as_int）{
               int_mv this_mv;
        
               this_mv.as_int = left-> mbmi.mv.as_int;
               mv_bias（left、refframe、＆this_mv、ref_frame_sign_bias）;
        
               if（this_mv.as_int！= mv-> as_int）{
                   （++ mv）-> as_int = this_mv.as_int;
                   ++ cntx;
               }
               * cntx + = 2;
           } そうしないと
               cnt [CNT_ZERO] + = 2;
       }
        
       /*左上のプロセス*/
       if（aboveleft-> mbmi.ref_frame！= INTRA_FRAME）{
           if（aboveleft-> mbmi.mv.as_int）{
               int_mv this_mv;
        
               this_mv.as_int = aboveleft-> mbmi.mv.as_int;
               mv_bias（aboveleft、refframe、＆this_mv、
                 ref_frame_sign_bias）;
        
               if（this_mv.as_int！= mv-> as_int）{
                   （++ mv）-> as_int = this_mv.as_int;
                   ++ cntx;
               }
               * cntx + = 1;
           } そうしないと
               cnt [CNT_ZERO] + = 1;
       }
        
       /*3つの異なるMVがある場合...*/
       if（cnt [CNT_SPLITMV]）{
           /*左上のMVをNEARESTとマージできるかどうかを確認します*/
           if（mv-> as_int == near_mvs [CNT_NEAREST] .as_int）
               cnt [CNT_NEAREST] + = 1;
       }
        
       cnt [CNT_SPLITMV] =（（above-> mbmi.mode == SPLITMV）
                            +（左-> mbmi.mode == SPLITMV））* 2
                           +（左上-> mbmi.mode == SPLITMV）;
        
       /*必要に応じて近くと最も近い場所で交換します*/
       if（cnt [CNT_NEAR]> cnt [CNT_NEAREST]）{
           int tmp;
           tmp = cnt [CNT_NEAREST];
           cnt [CNT_NEAREST] = cnt [CNT_NEAR];
           cnt [CNT_NEAR] = tmp;
           tmp = near_mvs [CNT_NEAREST] .as_int;
           near_mvs [CNT_NEAREST] .as_int = near_mvs [CNT_NEAR] .as_int;
           near_mvs [CNT_NEAR] .as_int = tmp;
       }
        
       / * near_mvs [0]を使用して、「最高の」MVを保存します* /
       if（cnt [CNT_NEAREST]> = cnt [CNT_ZERO]）
           near_mvs [CNT_ZERO] = near_mvs [CNT_NEAREST];
        
       /*戻り値を設定します*/
       * best_mv = near_mvs [0] .as_mv;
       *最も近い=near_mvs[CNT_NEAREST] .as_mv;
       * near = near_mvs [CNT_NEAR] .as_mv;
        
       vp8_clamp_mv（最も近い、xd）;
       vp8_clamp_mv（near、xd）;
       vp8_clamp_mv（best_mv、xd）; // TODO：前にこれを上に移動します
                                    コピー
   }
        
   ----終了コードブロック----------------------------------------
        
次に、mv_ref確率テーブル（mv_ref_p）は、次のように国勢調査から導出されます. 

   ----コードブロックを開始--------------------------------------
        
   const int vp8_mode_contexts [6] [4] =
   {{
     {7、1、1、143、}、
     {14、18、14、107、}、
     {135、64、57、68、}、
     {60、56、128、65、}、
     {159、134、128、34、}、
     {234、188、128、28、}、
   }
        
   ----終了コードブロック----------------------------------------
        
   ----コードブロックを開始--------------------------------------
        
   vp8_prob * vp8_mv_ref_probs（vp8_prob mv_ref_p [VP8_MVREFS-1]、
     int cnt [4]）
   {{
       mv_ref_p [0] = vp8_mode_contexts [cnt [0]] [0];
       mv_ref_p [1] = vp8_mode_contexts [cnt [1]] [1];
       mv_ref_p [2] = vp8_mode_contexts [cnt [2]] [2];
       mv_ref_p [3] = vp8_mode_contexts [cnt [3]] [3];
       pを返します. 
   }
        
   ----終了コードブロック----------------------------------------
        
mv_ref_pが確立されると、mv_refは通常どおりデコードされます. 

   ----コードブロックを開始--------------------------------------
        
     mvr =（mv_ref）treed_read（d、mv_ref_tree、mv_ref_p）;
        
   ----終了コードブロック----------------------------------------
        
最初の4つのインターコーディングモードでは、すべてのYサブブロックに同じ動きベクトルが使用されます. 最初の3つのモードは、暗黙の動きベクトルを使用します. 

   + ------------ + ------------------------------------ ------------------ +
   | モード| 指示|
   + ------------ + ------------------------------------ ------------------ +
   | mv_nearest | |によって返される最も近いベクトルを使用します
   | | vp8_find_near_mvs. |
   | | |
   | mv_near | vp8_find_near_mvsによって返されるニアベクトルを使用します. |
   | | |
   | mv_zero | ゼロベクトルを使用します. つまり、現在の|を予測します. 
   | | |内の対応するマクロブロックからのマクロブロック
   | | 予測フレーム. |
   | | |
   | NEWMV | このモードの後に​​は、明示的にコード化されたモーションが続きます. 
   | | ベクトル（その形式については、次の|で説明します. 
   | | セクション）|に（コンポーネントごとに）追加されます
   | | find_near_mvsによって返されるbest_mv参照ベクトル|
   | | 16個のサブブロックすべてに適用されます. |
   + ------------ + ------------------------------------ ------------------ +
        
16.4. 分割予測
残りのモード（SPLITMV）により、複数のベクトルがYサブブロックに適用されます. その直後に、指定されるベクトルの数とサブブロックへの割り当て方法を決定するパーティション指定が続きます. 示された細分化とコーディングツリーを持つ可能なパーティションは次のとおりです. 

   ----コードブロックを開始--------------------------------------
        
   typedef列挙型
   {{
       mv_top_bottom、/*2つの部分{0...7}と{8...15} * /
       mv_left_right、/*{0,1,4,5,8,9,12,13}および
                           {2,3,6,7,10,11,14,15} * /
       mv_quarters、/ * {0,1,4,5}、{2,3,6,7}、{8,9,12,13}、
                          {10,11,14,15} * /
       MV_16、/*すべてのサブブロックは独自のベクトルを取得します
                          {0} ... {15} * /
        
       mv_num_partitions
   }
   MVpartition;
        
   const tree_index mvpartition_tree [2 *（mvnum_partition-1）] =
   {{
    -MV_16、2、/ * MV_16 = "0" * /
     -mv_quarters、4、/ * mv_quarters = "10" * /
      -mv_top_bottom、-mv_left_right / * top_bottom = "110"、
                                          left_right = "111" * /
   };
        
   ----終了コードブロック----------------------------------------
        
パーティションは、固定の一定確率テーブルを使用してデコードされます. 

   ----コードブロックを開始--------------------------------------
        
   const Prob mvpartition_probs [mvnum_partition-1] =
     {110、111、150};
   part =（MVpartition）treed_read（d、mvpartition_tree、
     mvpartition_probs）;
        
   ----終了コードブロック----------------------------------------
        
パーティションの後に、2つ（mv_top_bottomまたはmv_left_rightの場合）、4つ（mv_quartersの場合）、または16（MV_16の場合）のサブブロック相互予測モードがあります. これらのモードは、パーティションレイアウト（MVpartition列挙型へのコメントとして指定）で示される順序で発生し、次のようにコード化されます. （マクロブロックレベルのモードで行われたように、モードの列挙をオフセットして、単一の変数がサブブロック内モードまたはサブブロック間モードのいずれかを明確に保持できるようにします. ）

各サブブロックをデコードする前に、以下のコードスニペットに示すように、デコードツリーコンテキストが選択されます. コンテキストは、すぐ左と上のサブブロックネイバーに基づいており、それらが等しいか、ゼロであるか、またはそれらの組み合わせであるかどうかを示します. 

   ----コードブロックを開始--------------------------------------
        
   typedef列挙型
   {{
       LEFT4x4 = num_intra_bmodes、/*すでにコーディングされたMVを使用して
                                        私の左*/
       ABOVE4x4、/*すでにコーディングされているMVを使用します*/
       ZERO4x4、/*ゼロMVを使用*/
       NEW4x4、/*「最良」からの明示的なオフセット*/
        
       num_sub_mv_ref
   };
   sub_mv_ref;
        
   const tree_index sub_mv_ref_tree [2 *（num_sub_mv_ref-1）] =
   {{
    -LEFT4X4、2、/ * LEFT = "0" * /
     -ABOVE4X4、4、/ * ABOVE = "10" * /
      -ZERO4X4、-NEW4X4 / * ZERO = "110"、NEW = "111" * /
   };
        
   /*正しいデコードツリーコンテキストを選択します
    ※機能パラメータは左サブブロックネイバーMV以上
    *サブブロックネイバーMV*/
   int vp8_mvCont（MV * l、MV * a）
   {{
       int lez =（l-> row == 0 && l-> col == 0）; /*左隣
                                                    ゼロです*/
       int aez =（a-> row == 0 && a-> col == 0）; /*隣人の上
                                                    ゼロです*/
       int lea =（l-> row == a-> row && l-> col == a-> col）; /* 左
                                隣人は隣人の上に等しい*/
        
       if（lea && lez）
           SUBMVREF_LEFT_ABOVE_ZEDを返します. / * = 4 * /
        
       if（lea）
           SUBMVREF_LEFT_ABOVE_SAMEを返します. / * = 3 * /
        
       if（aez）
           SUBMVREF_ABOVE_ZEDを返します. / * = 2 * /
        
       if（lez）
           SUBMVREF_LEFT_ZEDを返します. / * = 1 * /
        
       SUBMVREF_NORMALを返します. / * = 0 * /
   }
        
   /*一定の確率とデコード手順. * /
        
   const Prob sub_mv_ref_prob [5] [num_sub_mv_ref-1] = {
       {147,136,18}、
       {106,145,1}、
       {179,121,1}、
       {223,1、34}、
       {208,1,1}
   };
        
       sub_ref =（sub_mv_ref）treed_read（d、sub_mv_ref_tree、
         sub_mv_ref_prob [context]）;
        
   ----終了コードブロック----------------------------------------
        
最初の2つのサブ予測モードは、現在のサブセットの左上隅にあるサブブロックの左上にあるブロックで使用される、すでにコード化されたモーションベクトルをコピーするだけです（つまり、予測されるサブブロックのコレクション）. これらの予測ブロックは現在のマクロブロックにある必要はなく、現在のサブセットがフレームの上端または左端にある場合は、フレームにある必要はありません. この後者の場合、イントラ予測マクロブロック内のサブブロック動きベクトルと同様に、それらの動きベクトルはゼロと見なされます. また、このマクロブロック内の予測の正確さを保証するために、現在のマクロブロックのすでにデコードされたサブセットにあるすべてのサブブロックには、動きベクトルを設定する必要があります. 

ZERO4x4はゼロ動きベクトルを使用し、予測フレームからの対応するサブセットを使用して現在のサブセットを予測します. 

NEW4x4は、NEW4x4が現在のサブセットにのみ適用されることを除いて、NEWMVとまったく同じです. その後に、2次元の動きベクトルオフセット（次のセクションで説明）が続きます. これは、サブセットに対して有効な動きベクトルを形成するために、find_near_mvsへの以前の呼び出しによって返された最良のベクトルに追加されます. 

相互予測モードと動きベクトル（次に説明）の両方の解析は、参照デコーダーファイルmodemV.c（セクション20.11）にあります. 

17.動きベクトルのデコード
上で説明したように、動きベクトルはVP8データストリームの2つの場所に表示されます. NEWMVモードではマクロブロック全体に適用され、NEW4x4モードではマクロブロックのサブセットに適用されます. ベクトルの形式はどちらの場合も同じです. 

各ベクトルには2つの部分があります. 垂直成分（行）とそれに続く水平成分（列）です. 行と列は別々のコーディング確率を使用しますが、それ以外は同じように表されます. 

17.1. 各コンポーネントのコーディング
各コンポーネントは、V 1/4ピクセルの垂直または水平輝度変位（およびV 8ピクセルの彩度変位）を表す符号付き整数Vです. Vの絶対値は、ゼロ以外の場合、ブール符号が続きます. Vは、-1023から+1023までの任意の値を取ることができます. 

絶対値Aは、そのサイズに応じて2つの異なる方法のいずれかでコード化されます. 0 <= A <= 7の場合、Aはツリーコード化され、8 <= A <= 1023の場合、Aのバイナリ展開のビットは独立したブール確率を使用してコード化されます. Aのコーディングは、有効な範囲を指定するブール値で始まります. 

次に、動きベクトルコンポーネントをデコードするには、19位置の確率テーブルが必要です. このテーブルのオフセットと、コンポーネントのデコードに使用される手順は次のとおりです. 

   ----コードブロックを開始--------------------------------------
        
   typedef列挙型
   {{
       mvpis_short、/ *短い（<= 7）vs長い（> = 8）* /
       MVPsign、/*ゼロ以外の符号*/
       MVPshort、/*8つの短い値=7つの位置のツリー*/
        
       MVPbits = MVPshort + 7、/*8つの長い値のビット
                                       独立した問題あり*/
        
       MVPcount = MVPbits + 10/*合計19の確率*/
   }
   MVPindices;
        
   typedef Prob MV_CONTEXT [MVPcount]; /*のデコード仕様
                                             単一のコンポーネント*/
        
   / *小さな絶対値に使用されるツリー（
      対応）. * /
        
   const tree_index small_mvtree [2 *（8-1）] =
   {{
    2、8、/ * "0"サブツリー、"1"サブツリー*/
     4、6、/ * "00"サブツリー、"01"サブツリー*/
      -0、-1、/ * 0 = "000"、1 = "001" * /
      -2、-3、/ * 2 = "010"、3 = "011" * /
     10、12、/ *「10」サブツリー、「11」サブツリー* /
      -4、-5、/ * 4 = "100"、5 = "101" * /
      -6、-7 / * 6 = "110"、7 = "111" * /
   };
        
   / *を使用して、現在のデコーダー位置でMVコンポーネントを読み取ります
      提供されたprobs. * /
        
   int read_mvcomponent（bool_decoder * d、const MV_CONTEXT * mvc）
   {{
       const Prob * const p =（const Prob *）mvc;
        
int A = 0;

       if（read_bool（d、p [mvpis_short]））/ * 8 <= A <= 1023 * /
       {{
           / *ビット0、1、2を読み取ります* /
        
           int i = 0;
           do {A + = read_bool（d、p [MVPbits + i]）<< i;}
             while（++ i <3）;
        
           / *ビット9、8、7、6、5、4を読み取ります* /
        
           i = 9;
           do {A + = read_bool（d、p [MVPbits + i]）<< i;}
             while（--i> 3）;
        
           / * A> = 8であることがわかっています. これは、長くコーディングされているためです. 
              したがって、A <= 15の場合、ビット3は1であり、そうではありません. 
              明示的にコーディングされています. * /
        
           if（！（A＆0xfff0）|| read_bool（d、p [MVPbits + 3]））
               A + = 8;
       }
       else / * 0 <= A <= 7 * /
           A = treed_read（d、small_mvtree、p + MVPshort）;
        
       A && read_bool（r、p [MVPsign]）を返しますか？-A：A;
   }
        
   ----終了コードブロック----------------------------------------
        
17.2. 確率の更新
デコーダーは、行と列のコンポーネントをそれぞれデコードするために、2つのMV_CONTEXTの配列を維持する必要があります. これらのMV_CONTEXTは、キーフレームごとにデフォルトに設定する必要があります. 個々の確率は、更新確率の定数テーブルを使用して、フレーム間ごとに（フレームヘッダーのフィールドJによって）更新される場合があります. オプションの各更新はBの形式ですか？P（7）、つまり、ブール値の後に、trueの場合は7ビットの確率指定が続きます. 

VP8で使用される他の動的確率と同様に、更新は次のキーフレームまで、または別の更新によって置き換えられるまで有効です. 

詳細には、確率は次のように管理する必要があります. 

   ----コードブロックを開始--------------------------------------
        
   /*それぞれの更新確率の変更されないテーブル
      動きベクトルのデコードに使用される個々の確率. * /
        
   const MV_CONTEXT vp8_mv_update_probs [2] =
   {{
     {{
       237、
       246、
       253、253、254、254、254、254、254、
       254、254、254、254、254、250、250、252、254、254
     }、
     {{
       231、
       243、
       245、253、254、254、254、254、254、
       254、254、254、254、254、251、251、254、254、254
     }
   };
        
   /*デフォルトのMVデコード確率. * /
        
const MV_CONTEXT default_mv_context [2] = {{//行162、//短い128、//符号225、146、172、147、214、39、156、//短いツリー128、129、132、75、145 、178、206、239、254、254 //ロングビット}、

     {//列についても同じ
       164、//短い
       128、
       204、170、119、235、140、230、228、
       128、130、130、74、148、180、203、236、254、254//ロングビット
        
     }
   };
        
   / *現在のMVデコード確率、デフォルトより上に設定
      すべてのキーフレーム. * /
        
   MV_CONTEXT mvc [2]; / *常に行、次に列* /
        
   /*完全な動きベクトルをデコードするための手順. * /
        
   typedef struct {int16 row、col;} MV; /*前のセクションと同様*/
        
   MV read_mv（bool_decoder * d）
   {{
       MV v;
       v.row =（int16）read_mvcomponent（d、mvc）;
       v.col =（int16）read_mvcomponent（d、mvc + 1）;
       vを返す;
   }
        
   /*MVデコード確率を更新するための手順. 
      の適切な位置に「d」が付いたすべてのインターフレーム
      フレームヘッダー. * /
        
   void update_mvcontexts（bool_decoder * d）
   {{
       int i = 0;
       do {/ *コンポーネント=行、次に列* /
           const Prob * up = mv_update_probs [i]; /*プローブを更新します
                                                      コンポーネントの場合*/
           確率*p= mvc [i]; /*デコードtbl""を開始します*/
           Prob * const pstop = p + MVPcount; /*デコードtbl""を終了します*/
           行う {
               if（read_bool（d、* up ++））/*この位置を更新します*/
               {{
                   const Prob x = read_literal（d、7）;
        
                   * p = x？x << 1：1;
               }
           } while（++ p <pstop）; /*次の位置*/
       } while（++ i <2）; /*次のコンポーネント*/
   }
        
   ----終了コードブロック----------------------------------------
        
これで、動きベクトルのデコード手順と、フレーム間マクロブロック予測レコードをデコードする手順の説明が完了しました. 

18.フレーム間予測
現在のマクロブロックの相互予測仕様、つまり、16個のYサブブロックのそれぞれの動きベクトルとともに参照フレームが与えられた場合、マクロブロックの予測バッファーの計算について説明します. 次に、フレームの再構築は、前述の残差の合計（セクション14）とループフィルタリング（セクション15）のプロセスを介して完了します. 

相互予測されたサブブロックとサブピクセル補間の管理は、参照デコーダーファイルpredict.c（セクション20.14）に記載されています. 

18.1. 動きベクトルの境界と調整
各動きベクトルは隣接するブロックまたはマクロブロックから差分エンコードされ、参照される動きベクトルが参照フレームバッファー内の有効な位置を表すことを保証することが唯一のクランプであるため、VP8形式内でブロックまたはマクロブロックが持つことは技術的に可能です. 入力画像と拡張境界領域のサイズまでの任意の大きさの動きベクトル. 実用上の理由から、VP8は、画像サイズに関係なく、-4096〜4095フルピクセルの動きベクトルサイズ範囲制限を課します（VP8は、幅と高さに対して14 rawビットを定義します. 16383x16383が可能な最大画像サイズです）. ビットストリーム準拠のエンコーダーおよびデコーダーは、この制限を適用する必要があります. 

クロマサブブロックに適用される動きベクトルの解像度は1/8ピクセルであるため、セクション5で概説し、以下で詳しく説明する合成ピクセル計算では、輝度サブブロックにもこの解像度を使用します. それに応じて、格納された輝度動きベクトルはすべて2倍になり、各輝度ベクトルの各コンポーネントは、-2046〜+2046の範囲の偶数の整数になります. 

各クロマサブブロックに適用されるベクトルは、通常の対応でクロマサブブロックと同じ可視領域を占める4つの輝度サブブロックのベクトルを平均することによって計算されます. つまり、UおよびVブロック0のベクトルは、Yサブブロック{0、1、4、5}のベクトルの平均であり、クロマブロック1はYブロック{2、3、6、7}、クロマブロックに対応します.  2からYブロック{8、9、12、13}、および彩度ブロック3からYブロック{10、11、14、15}. 

詳細には、各クロマサブブロックのベクトルの2つの成分のそれぞれは、対応する輝度ベクトル成分から次のように計算されます. 

   ----コードブロックを開始--------------------------------------
        
   int avg（int c1、int c2、int c3、int c4）
   {{
       int s = c1 + c2 + c3 + c4;
        
       / *クロマピクセルのため、シフトは8（4ではなく）で除算されます
          輝度ピクセルの2倍の直径を持っています. 取り扱い
          負の動きベクトル成分の
          厳密に言えば、右シフトするので面倒です
          負の数の数はCでは明確に定義されていません. */
        
       s> = 0を返しますか？（s + 4）>> 3：-（（-s + 4）>> 3）;
   }
        
   ----終了コードブロック----------------------------------------
        
さらに、フレームタグのバージョン番号がフルペルクロマモーションベクトルのみを指定している場合、次の擬似コードに示すように、ベクトルの両方のコンポーネントの小数部分がゼロに切り捨てられます（輝度と両方の小数が3ビットであると想定）クロマベクトル）：

   ----コードブロックを開始--------------------------------------
        
       x = x＆（〜7）;
       y = y＆（〜7）;
        
   ----終了コードブロック----------------------------------------
        
このドキュメントの前半で、フレーム境界内の指定されたマージン内の「最も近い」および「近い」動きベクトル予測子を制限するvp8_clamp_mv（）関数について説明しました. NEWMVマクロブロックに対して追加のクランプが実行され、「最良の」予測子とストリームからデコードされた微分ベクトルを組み合わせた後、最終的な動きベクトルが再度クランプされます. 

ただし、二次クランプはSPLITMVマクロブロックに対しては実行されません. つまり、SPLITMVマクロブロック内のサブブロックの動きベクトルはクランプゾーンの外側を指す場合があります. これらのクランプされていないベクトルは、vp8_mvCont（）関数で後続のサブブロックのモードのデコードツリーコンテキストを決定するときにも使用されます. 

18.2. 予測サブブロック
各サブブロックの予測計算は次のようになります. 動きベクトルの小数部分を一時的に無視し（つまり、各コンポーネントを符号伝播で3ビット右シフトして「上」または「左」に丸める）、（16x16輝度または8x8彩度）の原点（左上位置）を追加します.  ）現在のマクロブロックは、予測フレーム（ゴールデンフレームまたは前のフレームのいずれか）のY、U、またはV平面の原点を示します. 

その原点が（ルマまたはクロマ）マクロブロックの左上隅であることを考慮して、そのサブブロックに関連付けられたピクセル、つまり、サブピクセル補間プロセスに関与する可能性のあるピクセルの相対位置を指定する必要があります. サブブロック. 

18.3. サブピクセル補間
サブピクセル補間は、2つの1次元畳み込みを介して実行されます. これらの畳み込みは、原点がサブブロックの原点、つまり上記の予測マクロブロックの原点にサブブロックへのオフセットを加えたものであるピクセルの2次元配列で動作していると考えることができます. 動きベクトルは任意であるため、これらの「予測サブブロックの原点」も任意です. 

動きベクトルの整数部分は、予測サブブロックの原点に含まれます. 構築する必要のある16個の（合成）ピクセルは、原点からの16個のオフセットによって与えられます. これらの各オフセットの整数部分は、サブブロックの原点からの対応するピクセルのオフセットです（垂直ストライドを使用）. これらの整数部分に一定の小数部分が追加されます. これは、実際の動きベクトルと、予測マクロブロックおよびサブブロックの原点を計算するために使用される整数の切り捨てとの差です. この小数部分の各コンポーネントは、0〜7の整数であり、8分の1ピクセルの前方変位を表します. 

フィルタリングプロセスを決定するのは、これらの部分変位です. それらが両方ともゼロである場合（つまり、「ピクセル全体」の動きベクトルがあった場合）、予測サブブロックは、現在のマクロブロックの予測バッファーの対応する部分に単純にコピーされます. セクション14で説明したように、マクロブロックの予測バッファのレイアウトは、選択した再構築の実装の詳細に依存する可能性があります. もちろん、ここで使用されるすべての垂直変位と同様に、予測サブブロックの線間の垂直変位はストライドによって与えられます. 

それ以外の場合、分数変位の少なくとも1つはゼロ以外です. 次に、欠落しているピクセルを水平方向に合成し、続いて垂直方向の1次元補間を行います. 

2つの補間は本質的に同じです. それぞれが（最大で）6タップのフィルターを使用します（もちろん、どちらを選択するかは1次元のオフセットに依存します）. したがって、計算されたすべてのピクセルは、その前（上または左）に最大3ピクセル、後（下または右）に最大3ピクセルを参照します. 水平補間は、垂直補間を続行するのに十分なサンプルを提供するために、4x4ブロックの上に2行、下に3行を計算する必要があります. 

フレームタグのバージョン番号フィールドに指定された再構成フィルタータイプに応じて、バイキュービックまたはバイリニアタップセットのいずれかが使用されます. 

サブサンプリングの正確な実装は次のとおりです. 

   ----コードブロックを開始--------------------------------------
        
   /*7ビットの精度で取得されたフィルタータップ. 
      DCは常に渡されるため、タップの合計は常に128になります. * /
        
   const int BilinearFilters [8] [6] =
   {{
       {0、0、128、0、0、0}、
       {0、0、112、16、0、0}、
       {0、0、96、32、0、0}、
       {0、0、80、48、0、0}、
       {0、0、64、64、0、0}、
       {0、0、48、80、0、0}、
       {0、0、32、96、0、0}、
       {0、0、16、112、0、0}
   };
        
   const int filter [8] [6] ={/*変位によってインデックス付けされます*/
       {0、0、128、0、0、0}、/*ピクセル全体を縮退*/
       {0、-6、123、12、-1、0}、/ * 1/8 * /
       {2、-11、108、36、-8、1}、/ * 1/4 * /
       {0、-9、93、50、-6、0}、/ * 3/8 * /
       {3、-16、77、77、-16、3}、/*1/2は対称です*/
       {0、-6、50、93、-9、0}、/ * 5/8=3/8の逆*/
       {1、-8、36、108、-11、2}、/ * 3/4=1/4の逆*/
       {0、-1、12、123、-6、0} / * 7/8=1/8の逆*/
   };
        
   /*単一サンプルの一次元合成. 
      フィルタは、分数変位によって決定されます* /
        
   ピクセルinterp（
       const int fil [6]、/*適用するフィルター*/
       const Pixel * p、/ * origin（「前」に丸められます）
                              予測エリア*/
       const int s /*1つの前進ステップのサイズ""* /
   ）{
       int32 a = 0;
       int i = 0;
       p-= s + s; /*2つの位置に戻ります*/
        
       行う {
           a + = * p * fil [i];
           p + = s;
       } while（++ i <6）;
        
       リターンクランプ255（（a + 64）>> 7）; /*最も近い値に丸めます
                                              8ビット値*/
   }
        
   / *最初に水平補間を実行し、中間を生成します
      バッファ. * /
        
   void Hinterp（
       ピクセル温度[9][4]、/ * 4行9行（中級）
                              宛先値*/
       const Pixel * p、/*予測のサブブロックの原点
                              フレーム */
       int s、/*で使用される垂直ストライド
                              予測フレーム*/
       uint hfrac、/ *0<=水平変位<=7* /
       uintバイキュービック/*1 =バイキュービックフィルター、0=バイキュービック*/
   ）{
       const int * const fil = bicubic？フィルタ[hfrac]：
         BilinearFilters [hfrac];
        
       int r = 0; 各行に対して/*を実行します*/
       {{
           int c = 0; 宛先サンプルごとに/*を実行します*/
           {{
               /*ピクセル間隔=1水平ステップ=1* /
        
               temp [r] [c] = interp（fil、p + c、1）;
           }
        
           while（++ c <4）;
       }
       while（p + = s、++ r <9）; /*pを次の行に進めます*/
   }
        
   / *垂直補間で終了し、最終結果を生成します. 
      もちろん、入力配列「temp」は上記で計算されたものです. * /
        
   void Vinterp（
       Pixel final [4] [4]、/ * 4行の4（最終）宛先値* /
       const Pixel temp [9] [4]、
       uint vfrac、/ *0<=垂直変位<=7* /
       uintバイキュービック/*1 =バイキュービックフィルター、0=バイキュービック*/
   ）{
       const int * const fil = bicubic？フィルタ[vfrac]：
         BilinearFilters [vfrac];
        
       int r = 0; 各行に対して/*を実行します*/
       {{
           int c = 0; 宛先サンプルごとに/*を実行します*/
           {{
               /*ピクセル間隔=1垂直ステップ=幅
                  配列の=4* /
        
               final [r] [c] = interp（fil、temp [r] + c、4）;
           }
           while（++ c <4）;
       }
       while（++ r <4）;
   }
        
   ----終了コードブロック----------------------------------------
        
18.4. フィルタのプロパティ
フィルタの選択の背後にある理論的根拠について簡単に説明します. 私たちのアプローチは必然的に大雑把です. 真に正確な議論には数冊の本が必要です. 信号処理に不慣れな読者は、これをスキップしたいかもしれません. 

もちろん、すべてのデジタル信号は何らかの方法でサンプリングされます. サンプル間の間隔（たとえば、オーディオサンプルの場合は時間内、ピクセルの場合はスペース）が均一である、つまりすべての位置で同じである場合は、特に一般的であり、分析に適しています. このような信号の処理の多くの側面は、フーリエ解析を介して周波数領域で最もよく理解されます. 特に、位置のシフトによって変化しない信号の側面は、特にそれらの位置のシフトが整数のサンプルによって与えられない場合によく理解されます. 

サンプリングされた信号の非積分変換は、前述の教科書の例です. 非積分の動きベクトルの場合、これらのピクセルでの基礎となる画像が「実際に」何であるかを言いたいと思います. それらの価値はありませんが、それらについて話すことは理にかなっていると感じています. この感覚の正しさは、帯域制限されている、つまり、自由に使えるピクセル解像度で忠実にレンダリングできない空間周波数のエネルギーを含まない、基礎となる信号に基づいています. 一次元では、この「OK」周波数の範囲はナイキスト帯域と呼ばれます. 整数グリッドサンプルの2次元の場合、この範囲はナイキスト長方形と呼ばれることがあります. グリッドが細かいほど、画像についての知識が豊富になり、ナイキストの長方形が広くなります. 

このような帯域制限された信号の場合、任意のポイントで正しいサンプル値を生成するための正確な数式が実際に存在することがわかります. 残念ながら、この計算では、画像内のすべてのサンプルを考慮する必要があり、無限の精度で操作する必要があります. また、厳密に言えば、すべての帯域制限信号は無限の空間的（または時間的）範囲を持っているので、私たちが議論しているすべては実際にはある種の近似です. 

理論的に正しいサブサンプリング手順とその近似は、VP8で使用されるものと同様の並進不変の加重和（またはフィルター）によって常に与えられることは事実です. このようなフィルターによって発生する再構成誤差は、周波数領域の乗数として簡単に表すことができることも事実です. つまり、このようなフィルターは、フィルターに関連付けられた固定関数によって、適用される信号のフーリエ変換を単純に乗算します. この固定関数は通常、周波数応答（または伝達関数）と呼ばれます. 理想的なサブサンプリングフィルターの周波数応答は、ナイキスト長方形では1に等しく、それ以外の場合はゼロです. 

「真に正しい」サブサンプリングの近似に関するもう1つの基本的な事実は、空間周波数のサブ長方形（ナイキスト長方形内）が「通過」（つまり、正しくレンダリング）したい、またはより正確に言えば、より近くしたいということです. 理想的な伝達関数を近似すると、サブサンプリングで元の信号のサンプルをより多く考慮する必要があり、必要な計算精度が広くなります. 

VP8によって選択されたフィルターは、4または6タップと7ビットの精度の制約内で、共振を導入せずに（絶対値が周波数応答の1を超えています）. 

前述の理由は2つの部分に分かれています. まず、実際の圧縮ビデオストリームでよくあるように、フィルターが繰り返し適用されると、共振によって非常に不快な目に見えるアーティファクトが生成される可能性があります. 第二に、実世界の画像のエネルギーの大部分はDCの近くにあり、ハイエンドではありません. 

もう少し具体的に言うと、VP8で選択されたフィルターは、可能な限り最高の共振のない4タップまたは6タップのフィルターです. ここで、「最高」は原点付近の周波数応答を表します. 0での応答は1である必要があり、 0での応答のグラフは可能な限りフラットです. 

直感的でより明白な参照ポイントを提供するために、「最良の」2タップフィルターは、周囲の実際のピクセル間の単純な線形補間によって与えられます. 

最後に、動きベクトルの計算方法のため、（短い）4タップフィルター（奇数の分数変位に使用）は彩度平面にのみ適用されることに注意してください. 人間の色覚は、特により高い空間周波数が関係している場合、悪名高いほど貧弱です. 短いフィルターは数学的に理解しやすく、彩度が関係する場合、それらと理論的にわずかに優れた6タップフィルターとの違いは無視できます. 

19.付録A：ビットストリーム構文
この付録では、ビットストリーム構文を表形式で示しています. すべての情報要素は前のセクションで紹介および説明されていますが、クイックリファレンスとしてここに集められています. 各構文要素は、表形式の表現の後に、メインドキュメントの対応する段落への参照とともに簡単に説明されています. 各構文要素の値の意味は、ここでは繰り返されません. 

ビットストリームの最上位階層はセクション4で紹介されています. 

構文要素のコーディングタイプの定義はセクション8にあります. この付録の表現で使用されるタイプは次のとおりです. 

of（n）、ストリームからのnビット値（n個の連続するビット、ブールエンコードされていない）

o L（n）、n個のブール値としてエンコードされたnビット数（0または1になる確率が等しい）

o B（p）、確率pが0であるブール

o T、ツリーでエンコードされた値

19.1. 非圧縮データチャンク
   | フレームタグ| タイプ|
   | ------------------------------------------------- | ----- |
   | frame_tag | f（24）|
   | if（key_frame）{| |
   | start_code | f（24）|
   | horizo​​ntal_size_code | f（16）|
   | vertical_size_code | f（16）|
   | } | |
        
3バイトのフレームタグは次のように解析できます. 

   ----コードブロックを開始--------------------------------------
        
   unsigned char * c = pbi-> source;
   unsigned int tmp;
        
   tmp =（c [2] << 16）| （c [1] << 8）| c [0];
        
   key_frame = tmp＆0x1;
   バージョン=（tmp >> 1）＆0x7;
   show_frame =（tmp >> 4）＆0x1;
   first_part_size =（tmp >> 5）＆0x7FFFF;
        
   ----終了コードブロック----------------------------------------
        
どこ：

o key_frameは、現在のフレームがキーフレームであるかどうかを示します. 

oバージョンはビットストリームバージョンを決定します. 

o show_frameは、現在のフレームを表示するかどうかを示します. 

o first_part_sizeは、非圧縮データチャンクを除く最初のパーティション（制御パーティション）のサイズを決定します. 

start_codeは、値が0x9d012aの定数3バイトパターンです. 非圧縮チャンクの後半部分（start_codeの後）は、次のように解析できます. 

   ----コードブロックを開始--------------------------------------
        
   unsigned char * c = pbi-> source + 6;
   unsigned int tmp;
        
   tmp =（c [1] << 8）| c [0];
        
   幅=tmp＆0x3FFF;
   horizo​​ntal_scale = tmp >> 14;
        
   tmp =（c [3] << 8）| c [2];
        
   高さ=tmp＆0x3FFF;
   vertical_scale = tmp >> 14;
        
   ----終了コードブロック----------------------------------------
        
19.2. フレームヘッダー
   | フレームヘッダー| タイプ|
   | ------------------------------------------------- | ----- |
   | if（key_frame）{| |
   | color_space | L（1）|
   | クランプタイプ| L（1）|
   | } | |
   | segmentation_enabled | L（1）|
   | if（segmentation_enabled）| |
   | update_segmentation（）| |
   | filter_type | L（1）|
   | loop_filter_level | L（6）|
   | Sharpness_level | L（3）|
   | mb_lf_adjustments（）| |
   | log2_nbr_of_dct_partitions | L（2）|
   | quant_indices（）| |
   | if（key_frame）| |
   | refresh_entropy_probs | L（1）|
        
   | else {| |
   | refresh_golden_frame | L（1）|
   | refresh_alternate_frame | L（1）|
   | if（！refresh_golden_frame）| |
   | copy_buffer_to_golden | L（2）|
   | if（！refresh_alternate_frame）| |
   | copy_buffer_to_alternate | L（2）|
   | sign_bias_golden | L（1）|
   | sign_bias_alternate | L（1）|
   | refresh_entropy_probs | L（1）|
   | refresh_last | L（1）|
   | } | |
   | token_prob_update（）| |
   | mb_no_skip_coeff | L（1）|
   | if（mb_no_skip_coeff）| |
   | prob_skip_false | L（8）|
   | if（！key_frame）{| |
   | prob_intra | L（8）|
   | prob_last | L（8）|
   | prob_gf | L（8）|
   | intra_16x16_prob_update_flag | L（1）|
   | if（intra_16x16_prob_update_flag）{| |
   | for（i = 0; i <4; i ++）| |
   | intra_16x16_prob | L（8）|
   | } | |
   | intra_chroma prob_update_flag | L（1）|
   | if（intra_chroma_prob_update_flag）{| |
   | for（i = 0; i <3; i ++）| |
   | intra_chroma_prob | L（8）|
   | } | |
   | mv_prob_update（）| |
   | } | |
        
o color_spaceは、シーケンスのYUV色空間を定義します（セクション9.2）

oclamping_typeは、再構築されたピクセル値をクランプするためにデコーダーが必要かどうかを指定します（セクション9.2）

o segmentation_enabledは、現在のフレームのセグメンテーション機能を有効にします（セクション9.3）

o filter_typeは、通常のループフィルターと単純なループフィルターのどちらを使用するかを決定します（セクション9.4、15）

o loop_filter_levelは、非ブロック化フィルターを制御します（セクション9.4、15）

o Sharpness_levelは非ブロック化フィルターを制御します（セクション9.4、15）

o log2_nbr_of_dct_partitionsは、マクロブロックのDCT係数を含む個別のパーティションの数を決定します（セクション9.5）

o refresh_entropy_probsは、更新されたトークン確率がこのフレームにのみ使用されるか、さらに更新されるまで使用されるかを決定します

o refresh_golden_frameは、現在デコードされているフレームがゴールデンフレームを更新するかどうかを決定します（セクション9.7）

o refresh_alternate_frameは、現在デコードされているフレームが代替参照フレームを更新するかどうかを決定します（セクション9.7）

o copy_buffer_to_goldenは、ゴールデン参照を別の参照に置き換えるかどうかを決定します（セクション9.7）

o copy_buffer_to_alternateは、代替参照を別の参照に置き換えるかどうかを決定します（セクション9.7）

o sign_bias_goldenは、ゴールデンフレームが参照されるときの動きベクトルの符号を制御します（セクション9.7）

o sign_bias_alternateは、代替フレームが参照されるときの動きベクトルの符号を制御します（セクション9.7）

o refresh_lastは、現在デコードされているフレームが最後のフレーム参照バッファーを更新するかどうかを決定します（セクション9.8）

o mb_no_skip_coeffは、ゼロ以外の係数を含まないマクロブロックのスキップを有効または無効にします（セクション9.10）. 

o prob_skip_falseは、マクロブロックがスキップされない確率を示します（スキップされたマクロブロックがfalseであることを示すフラグ）（セクション9.10）

o prob_intraは、マクロブロック内の確率を示します（セクション9.10）

o prob_lastは、最後の参照フレームが相互予測に使用される確率を示します（セクション9.10）

o prob_gfは、ゴールデンリファレンスフレームが相互予測に使用される確率を示します（セクション9.10）

o intra_16x16_prob_update_flagは、輝度イントラ予測モードのデコードで使用される分岐確率が更新されているかどうかを示します（セクション9.10）. 

o intra_16x16_probは、輝度イントラ予測モードデコードツリーの分岐確率を示します

o intra_chroma_prob_update_flagは、クロマイントラ予測モードのデコードで使用される分岐確率が更新されているかどうかを示します（セクション9.10）. 

o intra_chroma_probは、クロマイントラ予測モードデコードツリーの分岐確率を示します

   | update_segmentation（）| タイプ|
   | ------------------------------------------------- | ----- |
   | update_mb_segmentation_map | L（1）|
   | update_segment_feature_data | L（1）|
   | if（update_segment_feature_data）{| |
   | segment_feature_mode | L（1）|
   | for（i = 0; i <4; i ++）{| |
   | Quantizer_update | L（1）|
   | if（quantizer_update）{| |
   | Quantizer_update_value | L（7）|
   | Quantizer_update_sign | L（1）|
   | } | |
   | } | |
   | for（i = 0; i <4; i ++）{| |
   | loop_filter_update | L（1）|
   | if（loop_filter_update）{| |
   | lf_update_value | L（6）|
   | lf_update_sign | L（1）|
   | } | |
   | } | |
   | } | |
   | if（update_mb_segmentation_map）{| |
   | for（i = 0; i <3; i ++）{| |
   | segment_prob_update | L（1）|
   | if（segment_prob_update）| |
   | segment_prob | L（8）|
   | } | |
   | } | |
        
o update_mb_segmentation_mapは、MBセグメンテーションマップが現在のフレームで更新されるかどうかを決定します（セクション9.3）

o update_segment_feature_dataは、セグメント機能データが現在のフレームで更新されているかどうかを示します（セクション9.3）

o segment_feature_modeは、機能データの更新モードを示します. 0はデルタ、1は絶対値です（セクション9.3）

o Quantizer_updateは、i ^（th）セグメントのクォンタイザー値が更新されるかどうかを示します（セクション9.3）

o Quantizer_update_valueは、セグメントQuantizerの更新値を示します（セクション9.3）

o Quantizer_update_signは、セグメント量子化器の更新記号を示します（セクション9.3）

o loop_filter_updateは、i ^（th）セグメントのループフィルターレベル値が更新されるかどうかを示します（セクション9.3）

o lf_update_valueは、ループフィルターレベルの更新値を示します（セクション9.3）

o lf_update_signは、ループフィルターレベルの更新記号を示します（セクション9.3）

o segment_prob_updateは、MBヘッダーのsegment_idをデコードするために使用されるブランチ確率がストリームからデコードされるか、デフォルト値の255を使用するかを示します（セクション9.3）

o segment_probは、segment_idデコードツリーの分岐確率を示します（セクション9.3）

   | mb_lf_adjustments（）| タイプ|
   | ------------------------------------------------- | ----- |
   | loop_filter_adj_enable | L（1）|
   | if（loop_filter_adj_enable）{| |
   | mode_ref_lf_delta_update | L（1）|
   | if（mode_ref_lf_delta_update）{| |
   | for（i = 0; i <4; i ++）{| |
   | ref_frame_delta_update_flag | L（1）|
   | if（ref_frame_delta_update_flag）{| |
   | delta_magnitude | L（6）|
   | delta_sign | L（1）|
   | } | |
   | } | |
   | for（i = 0; i <4; i ++）{| |
   | mb_mode_delta_update_flag | L（1）|
   | if（mb_mode_delta_update_flag）{| |
   | delta_magnitude | L（6）|
   | delta_sign | L（1）|
   | } | |
   | } | |
   | } | |
   | } | |
        
o loop_filter_adj_enableは、MBレベルのループフィルター調整（使用されている参照フレームとコーディングモードに基づく）が現在のフレームに対してオンになっているかどうかを示します（セクション9.4）

o mode_ref_lf_delta_updateは、調整で使用されるデルタ値が現在のフレームで更新されるかどうかを示します（セクション9.4）

o ref_frame_delta_update_flagは、特定の使用済み参照フレームに対応する調整デルタ値が更新されているかどうかを示します（セクション9.4）

o delta_magnitudeは、デルタ値の絶対値です. 

o delta_signは、デルタ値の符号です. 

o mb_mode_delta_update_flagは、特定のMB予測モードに対応する調整デルタ値が更新されているかどうかを示します（セクション9.4）

   | quant_indices（）| タイプ|
   | ------------------------------------------------- | ----- |
   | y_ac_qi | L（7）|
   | y_dc_delta_present | L（1）|
   | if（y_dc_delta_present）{| |
   | y_dc_delta_magnitude | L（4）|
   | y_dc_delta_sign | L（1）|
   | } | |
   | y2_dc_delta_present | L（1）|
   | if（y2_dc_delta_present）{| |
   | y2_dc_delta_magnitude | L（4）|
   | y2_dc_delta_sign | L（1）|
   | } | |
   | y2_ac_delta_present | L（1）|
   | if（y2_ac_delta_present）{| |
   | y2_ac_delta_magnitude | L（4）|
   | y2_ac_delta_sign | L（1）|
   | } | |
   | uv_dc_delta_present | L（1）|
   | if（uv_dc_delta_present）{| |
   | uv_dc_delta_magnitude | L（4）|
   | uv_dc_delta_sign | L（1）|
   | } | |
   | uv_ac_delta_present | L（1）|
   | if（uv_ac_delta_present）{| |
   | uv_ac_delta_magnitude | L（4）|
   | uv_ac_delta_sign | L（1）|
   | } | |
        
o y_ac_qiは、輝度AC係数（およびデルタ値が存在しない場合は他の係数グループ）に使用される逆量子化テーブルインデックスです（セクション9.6）

o y_dc_delta_presentは、ストリームにデルタ値が含まれているかどうかを示します. このデルタ値は、輝度DC係数の非量子化インデックスを取得するためにベースラインインデックスに追加されます（セクション9.6）. 

o y_dc_delta_magnitudeは、デルタ値の大きさです（セクション9.6）

o y_dc_delta_signは、デルタ値の符号です（セクション9.6）

o y2_dc_delta_presentは、Y2ブロックDC係数逆量子化インデックスを取得するためにベースラインインデックスに追加されるデルタ値がストリームに含まれているかどうかを示します（セクション9.6）

o y2_ac_delta_presentは、Y2ブロックAC係数逆量子化インデックスを取得するためにベースラインインデックスに追加されるデルタ値がストリームに含まれているかどうかを示します（セクション9.6）

o uv_dc_delta_presentは、クロマDC係数逆量子化インデックスを取得するためにベースラインインデックスに追加されるデルタ値がストリームに含まれているかどうかを示します（セクション9.6）

o uv_ac_delta_presentは、クロマAC係数逆量子化インデックスを取得するためにベースラインインデックスに追加されるデルタ値がストリームに含まれているかどうかを示します（セクション9.6）

   | token_prob_update（）| タイプ|
   | ------------------------------------------------- | ----- |
   | for（i = 0; i <4; i ++）{| |
   | for（j = 0; j <8; j ++）{| |
   | for（k = 0; k <3; k ++）{| |
   | for（l = 0; l <11; l ++）{| |
   | coeff_prob_update_flag | L（1）|
   | if（coeff_prob_update_flag）| |
   | coeff_prob | L（8）|
   | } | |
   | } | |
   | } | |
   | } | |
        
o coeff_prob_update_flagは、対応する分岐確率が現在のフレームで更新されるかどうかを示します（セクション13.4）

o coeff_probは新しい分岐確率です（セクション13.4）

   | mv_prob_update（）| タイプ|
   | ------------------------------------------------- | ----- |
   | for（i = 0; i <2; i ++）{| |
   | for（j = 0; j <19; j ++）{| |
   | mv_prob_update_flag | L（1）|
   | if（mv_prob_update_flag）| |
   | 確率| L（7）|
   | } | |
   | } | |
        
o mv_prob_update_flagは、対応するMVデコード確率が現在のフレームで更新されるかどうかを示します（セクション17.2）

o確率は更新された確率です（セクション17.2）

19.3. マクロブロックデータ
   | マクロブロックデータ| タイプ|
   | ------------------------------------------------- | ----- |
   | macroblock_header（）| |
   | Residual_data（）| |
        
   | macroblock_header（）| タイプ|
   | ------------------------------------------------- | ----- |
   | if（update_mb_segmentation_map）| |
   | segment_id | T |
   | if（mb_no_skip_coeff）| |
   | mb_skip_coeff | B（p）|
   | if（！key_frame）| |
   | is_inter_mb | B（p）|
   | if（is_inter_mb）{| |
   | mb_ref_frame_sel1 | B（p）|
   | if（mb_ref_frame_sel1）| |
   | mb_ref_frame_sel2 | B（p）|
   | mv_mode | T |
   | if（mv_mode == SPLITMV）{| |
   | mv_split_mode | T |
   | for（i = 0; i <numMvs; i ++）{| |
   | sub_mv_mode | T |
   | if（sub_mv_mode == NEWMV4x4）{| |
   | read_mvcomponent（）| |
   | read_mvcomponent（）| |
   | } | |
   | } | |
   | } else if（mv_mode == NEWMV）{| |
   | read_mvcomponent（）| |
   | read_mvcomponent（）| |
   | } | |
   | } else{/*イントラmb*/ | |
   | intra_y_mode | T |
   | if（intra_y_mode == B_PRED）{| |
   | for（i = 0; i <16; i ++）| |
   | intra_b_mode | T |
   | } | |
   | intra_uv_mode | T |
   | } | |
        
o segment_idは、マクロブロックが属するセグメントを示します（セクション10）

o mb_skip_coeffは、マクロブロックにコード化された係数が含まれているかどうかを示します（セクション11.1）

o is_inter_mbは、マクロブロックがイントラコーディングされているかインターコーディングされているかを示します（セクション16）

o mb_ref_frame_sel1は、使用する参照フレームを選択します. 最後のフレーム（0）、ゴールデン/オルタネート（1）（セクション16.2）

o mb_ref_frame_sel2は、ゴールデン（0）または代替参照フレーム（1）のどちらを使用するかを選択します（セクション16.2）

o mv_modeは、マクロブロックの動きベクトルモードを決定します（セクション16.2）

o mv_split_modeは、マクロブロック分割仕様を提供し、使用される動きベクトルの数（numMvs）を決定します（セクション16.2）

o sub_mv_modeは、SPLITMV動きベクトルモードを使用してコード化されたマクロブロックのサブマクロブロック動きベクトルモードを決定します（セクション16.2）. 

o intra_y_modeは、輝度イントラ予測モードを選択します（セクション16.1）

o intra_b_modeは、B_PREDモードを使用してコード化されたマクロブロックのサブマクロブロック輝度予測モードを選択します（セクション16.1）. 

o intra_uv_modeは、クロミナンスイントラ予測モードを選択します（セクション16.1）

   | Residual_data（）| タイプ|
   | ------------------------------------------------- | ----- |
   | if（！mb_skip_coeff）{| |
   | if（（is_inter_mb && mv_mode！= SPLITMV）|| | |
   | （！is_inter_mb && intra_y_mode！= B_PRED））| |
   | Residual_block（）/ * Y2 * / | |
   | for（i = 0; i <24; i ++）| |
   | Residual_block（）/ * 16 Y、4 U、4 V * / | |
   | } | |
        
   | Residual_block（）| タイプ|
   | ------------------------------------------------- | ----- |
   | for（i = firstCoeff; i <16; i ++）{| |
   | トークン| T |
   | if（token == EOB）break; | |
   | if（token_has_extra_bits）| |
   | extra_bits | L（n）|
   | if（係数！= 0）| |
   | サイン| L（1）|
   | } | |
        
o firstCoeffは、Y2サブブロックを含むマクロブロックの輝度ブロックの場合は1です. それ以外の場合は0

oトークンは、係数の値、係数の値の範囲、またはブロックの終わりを定義します（セクション13.2）

o extra_bitsは、トークンで定義された値の範囲内の係数の値を決定します（セクション13.2）

o符号は、係数の符号を示します（セクション13.2）

20.添付資料1：リファレンスデコーダーのソースコード
20.1. bit_ops.h
   ----コードブロックを開始--------------------------------------
        
   / *
    * Copyright（c）2010、2011、Google Inc.無断複写・転載を禁じます. 
    *
    *このソースコードの使用はBSDスタイルのライセンスによって管理されています
    *ソースのルートにあるLICENSEファイルにあります
    * 木. 追加の知的財産権の付与は
    *ファイルPATENTSにあります. 貢献しているすべてのプロジェクト作成者は
    *ソースツリーのルートにあるAUTHORSファイルにあります. 
    * /
   #ifndef BIT_OPS_H
   #define BIT_OPS_H
        
   /*nビットが設定されたマスクに評価されます*/
   #define BITS_MASK（n）（（1 <<（n））-1）
        
   /*LSBがビットの位置にあるlenビットを返します*/
   #define BITS_GET（val、bit、len）（（（val）>>（bit））＆BITS_MASK（len））
        
#endif

   ----終了コードブロック----------------------------------------
        
20.2. bool_decoder.h
   ----コードブロックを開始--------------------------------------
        
   / *
    * Copyright（c）2010、2011、Google Inc.無断複写・転載を禁じます. 
    *
    *このソースコードの使用はBSDスタイルのライセンスによって管理されています
    *ソースのルートにあるLICENSEファイルにあります
    * 木. 追加の知的財産権の付与は
    *ファイルPATENTSにあります. 貢献しているすべてのプロジェクト作成者は
    *ソースツリーのルートにあるAUTHORSファイルにあります. 
    * /
   #ifndef BOOL_DECODER_H
   #define BOOL_DECODER_H
   #include <stddef.h>
        
   struct bool_decoder
   {{
       const unsigned char * input; /*次の圧縮データバイト*/
       size_t input_len; /*入力バッファの長さ*/
       unsignedint範囲; /*エンコーダーと同じ
                                         * 範囲 */
       unsignedint値; /*少なくとも8つ含まれています
                                         *重要なビット*/
       int bit_count; /*シフトアウトされたビット数
                                         *値、最大7 * /
   };
        
   静的ボイド
   init_bool_decoder（struct bool_decoder * d、
                     const unsigned char * start_partition、
                     size_t sz）
   {{
       if（sz> = 2）
       {{
           d-> value =（start_partition [0] << 8）/*最初の2つの入力
                                                 *バイト*/
                      | start_partition [1];
           d-> input = start_partition + 2; /*次のバイトへのptr*/
           d-> input_len = sz-2;
       }
       そうしないと
       {{
           d->値=0;
           d-> input = NULL;
           d-> input_len = 0;
       }
        
       d->範囲=255; /*初期範囲がいっぱいです*/
       d-> bit_count = 0; /*まだビットをシフトアウトしていません*/
   }
        
   static int bool_get（struct bool_decoder * d、int確率）
   {{
       /*範囲と分割は対応する値と同じです
          このブール値が書き込まれたときにエンコーダーによって使用されました*/
        
       unsigned int split = 1 +（（（d-> range-1）*確率）>> 8）;
       unsigned int SPLIT = split << 8;
       int retval; /*0または1になります*/
        
       if（d-> value> = SPLIT）/*1をエンコード*/
       {{
           retval = 1;
           d->範囲-=分割; /*範囲を狭める*/
           d-> value-= SPLIT; /*の左端を減算します
                                *間隔*/
       }
       それ以外の場合/*ゼロをエンコードしました*/
       {{
           retval = 0;
           d->範囲=分割; / *範囲を縮小し、左に変更はありません
                              * 終点 */
       }
        
       while（d-> range <128）/*無関係な値のビットをシフトアウトします*/
       {{
           d->値<<=1;
           d->範囲<<=1;
        
           if（++ d-> bit_count == 8）/*一度に新しいビット8をシフトイン*/
           {{
               d-> bit_count = 0;
        
               if（d-> input_len）
               {{
                   d-> value | = * d-> input ++;
                   d-> input_len--;
               }
           }
       }
        
       retvalを返します. 
   }
        
   static int bool_get_bit（struct bool _decoder * br）
   {{
       bool_get（br、128）;を返します. 
   }
        
   static int bool_get_uint（struct bool_decoder * br、intビット）
   {{
       int z = 0;
       intビット;
        
       for（ビット=ビット-1;ビット> = 0;ビット-）
       {{
           z | =（bool_get_bit（br）<<ビット）;
       }
        
       zを返す;
   }
        
   static int bool_get_int（struct bool_decoder * br、intビット）
   {{
       int z = 0;
       intビット;
        
       for（ビット=ビット-1;ビット> = 0;ビット-）
       {{
           z | =（bool_get_bit（br）<<ビット）;
       }
        
       bool_get_bit（br）を返しますか？-グーグー;
   }
        
   static int bool_maybe_get_int（struct bool_decoder * br、intビット）
   {{
       bool_get_bit（br）を返しますか？bool_get_int（br、bits）：0;
   }
        
   static int
   bool_read_tree（struct bool_decoder * bool、
                  const int * t、
                  const unsigned char * p）
   {{
       int i = 0;
        
       while（（i = t [i + bool_get（bool、p [i >> 1]）]）> 0）;
        
       -iを返します. 
   }
   #endif
        
   ----終了コードブロック----------------------------------------
        
20.3. dequant_data.h
   ----コードブロックを開始--------------------------------------
        
   / *
    * Copyright（c）2010、2011、Google Inc.無断複写・転載を禁じます. 
    *
    *このソースコードの使用はBSDスタイルのライセンスによって管理されています
    *ソースのルートにあるLICENSEファイルにあります
    * 木. 追加の知的財産権の付与は
    *ファイルPATENTSにあります. 貢献しているすべてのプロジェクト作成者は
    *ソースツリーのルートにあるAUTHORSファイルにあります. 
    * /
        
   static const int dc_q_lookup [128] =
   {{
       4、5、6、7、8、9、10、10
       11、12、13、14、15、16、17、17
       18、19、20、20、21、21、22、22
       23、23、24、25、25、26、27、28、
       29、30、31、32、33、34、35、36、
       37、37、38、39、40、41、42、43、
       44、45、46、46、47、48、49、50、
       51、52、53、54、55、56、57、58、
       59、60、61、62、63、64、65、66、
       67、68、69、70、71、72、73、74、
       75、76、76、77、78、79、80、81、
       82、83、84、85、86、87、88、89、
       91、93、95、96、98、100、101、102、
       104、106、108、110、112、114、116、118、
       122、124、126、128、130、132、134、136、
       138、140、143、145、148、151、154、157
   };
        
static const int ac_q_lookup [128] = {4、5、6、7、8、9、10、11、12、13、14、15、16、17、18、19、20、21、22、23、24 、25、26、27、28、29、30、31、32、33、34、35、36、37、38、39、40、41、42、43、44、45、46、47、48、49 、50、51、52、53、54、55、56、57、58、60、62、64、66、68、70、72、74、76、78、80、82、84、86、88、90 、92、94、96、98、100、102、104、106、108、110、112、114、116、119、122、125、128、131、134、137、140、143、146、149、152 、

155、158、161、164、167、170、173、177、181、185、189、193、197、201、205、209、213、217、221、225、229、234、239、245、249、 254、259、264、269、274、279、284};

   ----終了コードブロック----------------------------------------
        
20.4. dixie.c
   ----コードブロックを開始--------------------------------------
        
   / *
    * Copyright（c）2010、2011、Google Inc.無断複写・転載を禁じます. 
    *
    *このソースコードの使用はBSDスタイルのライセンスによって管理されています
    *ソースのルートにあるLICENSEファイルにあります
    * 木. 追加の知的財産権の付与は
    *ファイルPATENTSにあります. 貢献しているすべてのプロジェクト作成者は
    *ソースツリーのルートにあるAUTHORSファイルにあります. 
    * /
   #include "vpx_codec_internal.h"
   #include "bit_ops.h"
   #include "dixie.h"
   #include "vp8_prob_data.h"
   #include "dequant_data.h"
   #include "modemv.h"
   #include "tokens.h"
   #include "predict.h"
   #include "dixie_loopfilter.h"
   #include <string.h>
   #include <assert.h>
        
   列挙型
   {{
       FRAME_HEADER_SZ = 3、
       KEYFRAME_HEADER_SZ = 7
   };
        
   #define ARRAY_COPY（a、b）{\
       assert（sizeof（a）== sizeof（b））; memcpy（a、b、sizeof（a））;}
   静的ボイド
   decode_entropy_header（struct vp8_decoder_ctx * ctx、
                         struct bool_decoder * bool、
                         struct vp8_entropy_hdr * hdr）
        
   {{
       int i、j、k、l;
        
       /*係数確率の更新を読み取ります*/
       for（i = 0; i <BLOCK_TYPES; i ++）
           for（j = 0; j <COEFF_BANDS; j ++）
               for（k = 0; k <PREV_COEFF_CONTEXTS; k ++）
                   for（l = 0; l <ENTROPY_NODES; l ++）
                       if（bool_get（bool、
                                    k_coeff_entropy_update_probs
                                        [i] [j] [k] [l]））
                           hdr-> coeff_probs [i] [j] [k] [l] =
                               bool_get_uint（bool、8）;
        
       /*係数スキップモード確率の読み取り*/
       hdr-> coeff_skip_enabled = bool_get_bit（bool）;
        
       if（hdr-> coeff_skip_enabled）
           hdr-> coeff_skip_prob = bool_get_uint（bool、8）;
        
       /*フレーム間確率の更新を解析します*/
       if（！ctx-> frame_hdr.is_keyframe）
       {{
           hdr-> prob_inter = bool_get_uint（bool、8）;
           hdr-> prob_last = bool_get_uint（bool、8）;
           hdr-> prob_gf = bool_get_uint（bool、8）;
        
           if（bool_get_bit（bool））
               for（i = 0; i <4; i ++）
                   hdr-> y_mode_probs [i] = bool_get_uint（bool、8）;
        
           if（bool_get_bit（bool））
               for（i = 0; i <3; i ++）
                   hdr-> uv_mode_probs [i] = bool_get_uint（bool、8）;
        
           for（i = 0; i <2; i ++）
               for（j = 0; j <MV_PROB_CNT; j ++）
                   if（bool_get（bool、k_mv_entropy_update_probs [i] [j]））
                   {{
                       int x = bool_get_uint（bool、7）;
                       hdr-> mv_probs [i] [j] = x？x << 1：1;
                   }
       }
   }
        
   静的ボイド
   decode_reference_header（struct vp8_decoder_ctx * ctx、
                           struct bool_decoder * bool、
                           struct vp8_reference_hdr * hdr）
   {{
       unsigned int key = ctx-> frame_hdr.is_keyframe;
        
       hdr-> refresh_gf =キー？1：bool_get_bit（bool）;
       hdr-> refresh_arf =キー？1：bool_get_bit（bool）;
       hdr-> copy_gf = key？0：！hdr-> refresh_gf
                            ？bool_get_uint（bool、2）：0;
       hdr-> copy_arf = key？0：！hdr-> refresh_arf
                            ？bool_get_uint（bool、2）：0;
       hdr-> sign_bias [GOLDEN_FRAME] =キー？0：bool_get_bit（bool）;
       hdr-> sign_bias [ALTREF_FRAME] =キー？0：bool_get_bit（bool）;
       hdr-> refresh_entropy = bool_get_bit（bool）;
       hdr-> refresh_last = key？1：bool_get_bit（bool）;
   }
        
   静的ボイド
   decode_quantizer_header（struct vp8_decoder_ctx * ctx、
                           struct bool_decoder * bool、
                           struct vp8_quant_hdr * hdr）
   {{
       int更新;
       int last_q = hdr-> q_index;
        
       hdr-> q_index = bool_get_uint（bool、7）;
       update = last_q！= hdr-> q_index;
       更新|=（hdr-> y1_dc_delta_q = bool_maybe_get_int（bool、4））;
       更新|=（hdr-> y2_dc_delta_q = bool_maybe_get_int（bool、4））;
       更新|=（hdr-> y2_ac_delta_q = bool_maybe_get_int（bool、4））;
       更新|=（hdr-> uv_dc_delta_q = bool_maybe_get_int（bool、4））;
       更新|=（hdr-> uv_ac_delta_q = bool_maybe_get_int（bool、4））;
       hdr-> delta_update = update;
   }
        
static void decode_and_init_token_partitions（struct vp8_decoder_ctx * ctx、struct bool_decoder * bool、const unsigned char * data、unsigned int sz、struct vp8_token_hdr * hdr）

   {{
       int i;
        
       hdr-> partition = 1 << bool_get_uint（bool、2）;
        
       if（sz <3 *（hdr-> partition-1））
           vpx_internal_error（＆ctx-> error、VPX_CODEC_CORRUPT_FRAME、
                              「切り捨てられたパケットが解析パーティションを検出しました」
                              "長さ. "）;
        
       sz-= 3 *（hdr-> partition-1）;
        
       for（i = 0;i<hdr->パーティション;i++）
       {{
           if（i <hdr-> partition-1）
           {{
               hdr-> partition_sz [i] =（data [2] << 16）
                                      | （data [1] << 8）| data [0];
               データ+=3;
           }
           そうしないと
               hdr-> partition_sz [i] = sz;
        
           if（sz <hdr-> partition_sz [i]）
               vpx_internal_error（＆ctx-> error、VPX_CODEC_CORRUPT_FRAME、
                                  "切り捨てられたパーティション％d"、i）;
        
           sz-= hdr-> partition_sz [i];
       }
        
       for（i = 0; i <ctx-> token_hdr.partitions; i ++）
       {{
           init_bool_decoder（＆ctx-> tokens [i] .bool、data、
                             ctx-> token_hdr.partition_sz [i]）;
           データ+=ctx-> token_hdr.partition_sz [i];
       }
   }
        
static void decode_loopfilter_header（struct vp8_decoder_ctx * ctx、struct bool_decoder * bool、struct vp8_loopfilter_hdr * hdr）

   {{
       if（ctx-> frame_hdr.is_keyframe）
           memset（hdr、0、sizeof（* hdr））;
        
       hdr-> use_simple = bool_get_bit（bool）;
       hdr-> level = bool_get_uint（bool、6）;
       hdr-> Sharpness = bool_get_uint（bool、3）;
       hdr-> delta_enabled = bool_get_bit（bool）;
        
       if（hdr-> delta_enabled && bool_get_bit（bool））
       {{
           int i;
        
           for（i = 0; i <BLOCK_CONTEXTS; i ++）
               hdr-> ref_delta [i] = bool_maybe_get_int（bool、6）;
        
           for（i = 0; i <BLOCK_CONTEXTS; i ++）
               hdr-> mode_delta [i] = bool_maybe_get_int（bool、6）;
       }
   }
        
   静的ボイド
   decode_segmentation_header（struct vp8_decoder_ctx * ctx、
                              struct bool_decoder * bool、
                              struct vp8_segment_hdr * hdr）
   {{
       if（ctx-> frame_hdr.is_keyframe）
           memset（hdr、0、sizeof（* hdr））;
        
       hdr-> enabled = bool_get_bit（bool）;
        
       if（hdr-> enabled）
       {{
           int i;
        
           hdr-> update_map = bool_get_bit（bool）;
           hdr-> update_data = bool_get_bit（bool）;
        
           if（hdr-> update_data）
           {{
               hdr-> abs = bool_get_bit（bool）;
        
               for（i = 0; i <MAX_MB_SEGMENTS; i ++）
                   hdr-> quant_idx [i] = bool_maybe_get_int（bool、7）;
        
               for（i = 0; i <MAX_MB_SEGMENTS; i ++）
                   hdr-> lf_level [i] = bool_maybe_get_int（bool、6）;
           }
        
           if（hdr-> update_map）
           {{
               for（i = 0; i <MB_FEATURE_TREE_PROBS; i ++）
                   hdr-> tree_probs [i] = bool_get_bit（bool）
                                        ？bool_get_uint（bool、8）
                                        ：255;
           }
       }
       そうしないと
       {{
           hdr-> update_map = 0;
           hdr-> update_data = 0;
       }
   }
        
   静的ボイド
   dequant_global_init（struct dequant_factors dqf [MAX_MB_SEGMENTS]）
   {{
       int i;
        
       for（i = 0; i <MAX_MB_SEGMENTS; i ++）
           dqf [i] .quant_idx = -1;
   }
        
   static int
   クランプ_q（int q）
   {{
       if（q <0）return 0;
       それ以外の場合（q> 127）は127を返します. 
        
       qを返します. 
   }
        
   static int
   dc_q（int q）
   {{
       dc_q_lookup [clamp_q（q）]を返します. 
   }
        
   static int
   ac_q（int q）
   {{
       ac_q_lookup [clamp_q（q）]を返します. 
   }
        
   静的ボイド
   dequant_init（struct dequant_factors factor [MAX_MB_SEGMENTS]、
                const struct vp8_segment_hdr * seg、
                const struct vp8_quant_hdr * quant_hdr）
   {{
       int i、q;
       struct dequant_factors *dqf=ファクター;
        
       for（i = 0; i <（seg-> enabled？MAX_MB_SEGMENTS：1）; i ++）
       {{
           q = quant_hdr-> q_index;
        
           if（seg-> enabled）
               q =（！seg-> abs）？q + seg-> quant_idx [i]
                               ：seg-> quant_idx [i];
        
           if（dqf-> quant_idx！= q || quant_hdr-> delta_update）
           {{
               dqf-> factor [TOKEN_BLOCK_Y1] [0] =
                   dc_q（q + quant_hdr-> y1_dc_delta_q）;
               dqf-> factor [TOKEN_BLOCK_Y1] [1] =
                   ac_q（q）;
               dqf-> factor [TOKEN_BLOCK_UV] [0] =
                   dc_q（q + quant_hdr-> uv_dc_delta_q）;
               dqf-> factor [TOKEN_BLOCK_UV] [1] =
                   ac_q（q + quant_hdr-> uv_ac_delta_q）;
               dqf-> factor [TOKEN_BLOCK_Y2] [0] =
                   dc_q（q + quant_hdr-> y2_dc_delta_q）* 2;
               dqf-> factor [TOKEN_BLOCK_Y2] [1] =
                   ac_q（q + quant_hdr-> y2_ac_delta_q）* 155/100;
        
               if（dqf-> factor [TOKEN_BLOCK_Y2] [1] <8）
                   dqf-> factor [TOKEN_BLOCK_Y2] [1] = 8;
        
               if（dqf-> factor [TOKEN_BLOCK_UV] [0]> 132）
                   dqf-> factor [TOKEN_BLOCK_UV] [0] = 132;
        
               dqf-> quant_idx = q;
           }
        
           dqf ++;
       }
   }
        
   静的ボイド
   decode_frame（struct vp8_decoder_ctx * ctx、
                const unsigned char * data、
                unsigned int sz）
   {{
       vpx_codec_err_t res;
       struct bool_decoder bool;
       int i、行、パーティション;
        
       ctx-> saved_entropy_valid = 0;
        
       if（（res = vp8_parse_frame_header（data、sz、＆ctx-> frame_hdr）））
           vpx_internal_error（＆ctx-> error、res、
                              "フレームヘッダーの解析に失敗しました"）;
        
       if（ctx-> frame_hdr.is_experimental）
           vpx_internal_error（＆ctx-> error、VPX_CODEC_UNSUP_BITSTREAM、
                              "実験的なビットストリームはサポートされていません. "）;
        
       データ+=FRAME_HEADER_SZ;
       sz-= FRAME_HEADER_SZ;
        
       if（ctx-> frame_hdr.is_keyframe）
       {{
           データ+=KEYFRAME_HEADER_SZ;
           sz-= KEYFRAME_HEADER_SZ;
           ctx-> mb_cols =（ctx-> frame_hdr.kf.w + 15）/ 16;
           ctx-> mb_rows =（ctx-> frame_hdr.kf.h + 15）/ 16;
       }
        
       /*ヘッダー/エントロピーパーティションのビットリーダーを開始します*/
       init_bool_decoder（＆bool、data、ctx-> frame_hdr.part0_sz）;
        
       /*色空間とクランプビットをスキップします*/
       if（ctx-> frame_hdr.is_keyframe）
           if（bool_get_uint（＆bool、2））
               vpx_internal_error（
                   ＆ctx->エラー、VPX_CODEC_UNSUP_BITSTREAM、
                   "予約済みビットはサポートされていません. "）;
        
       decode_segmentation_header（ctx、＆bool、＆ctx-> segment_hdr）;
       decode_loopfilter_header（ctx、＆bool、＆ctx-> loopfilter_hdr）;
       decode_and_init_token_partitions（ctx、
                                        ＆bool、
                                        データ+ctx->frame_hdr.part0_sz、
                                        sz --ctx-> frame_hdr.part0_sz、
                                        ＆ctx-> token_hdr）;
       decode_quantizer_header（ctx、＆bool、＆ctx-> quant_hdr）;
       decode_reference_header（ctx、＆bool、＆ctx-> reference_hdr）;
        
       /*キーフレームエントロピーのデフォルトを設定します. これらはキーフレームで更新されます
        *refresh_entropyの設定に関係なく. 
        * /
       if（ctx-> frame_hdr.is_keyframe）
       {{
           ARRAY_COPY（ctx-> entropy_hdr.coeff_probs、
                      k_default_coeff_probs）;
           ARRAY_COPY（ctx-> entropy_hdr.mv_probs、
                      k_default_mv_probs）;
           ARRAY_COPY（ctx-> entropy_hdr.y_mode_probs、
                      k_default_y_mode_probs）;
           ARRAY_COPY（ctx-> entropy_hdr.uv_mode_probs、
                      k_default_uv_mode_probs）;
       }
        
       if（！ctx-> reference_hdr.refresh_entropy）
       {{
           ctx-> saved_entropy = ctx-> entropy_hdr;
           ctx-> saved_entropy_valid = 1;
       }
        
       decode_entropy_header（ctx、＆bool、＆ctx-> entropy_hdr）;
        
       vp8_dixie_modemv_init（ctx）;
       vp8_dixie_tokens_init（ctx）;
       vp8_dixie_predict_init（ctx）;
       dequant_init（ctx-> dequant_factors、＆ctx-> segment_hdr、
                    ＆ctx-> quant_hdr）;
        
       for（row = 0、partition = 0; row <ctx-> mb_rows; row ++）
       {{
           vp8_dixie_modemv_process_row（
               ctx、＆bool、row、0、ctx-> mb_cols）;
           vp8_dixie_tokens_process_row（ctx、partition、row、0、
                                        ctx-> mb_cols）;
           vp8_dixie_predict_process_row（ctx、row、0、ctx-> mb_cols）;
        
           if（ctx-> loopfilter_hdr.level && row）
               vp8_dixie_loopfilter_process_row（ctx、行-1、0、
                                                ctx-> mb_cols）;
        
           if（++ partition == ctx-> token_hdr.partitions）
               パーティション=0;
       }
        
       if（ctx-> loopfilter_hdr.level）
           vp8_dixie_loopfilter_process_row（
               ctx、行-1、0、ctx-> mb_cols）;
        
       ctx-> frame_cnt ++;
        
       if（！ctx-> reference_hdr.refresh_entropy）
       {{
           ctx-> entropy_hdr = ctx-> saved_entropy;
           ctx-> saved_entropy_valid = 0;
       }
        
       /*参照フレームの更新を処理します*/
       if（ctx-> reference_hdr.copy_arf == 1）
       {{
           vp8_dixie_release_ref_frame（ctx-> ref_frames [ALTREF_FRAME]）;
           ctx-> ref_frames [ALTREF_FRAME] =
               vp8_dixie_ref_frame（ctx-> ref_frames [LAST_FRAME]）;
       }
       else if（ctx-> reference_hdr.copy_arf == 2）
       {{
           vp8_dixie_release_ref_frame（ctx-> ref_frames [ALTREF_FRAME]）;
           ctx-> ref_frames [ALTREF_FRAME] =
               vp8_dixie_ref_frame（ctx-> ref_frames [GOLDEN_FRAME]）;
       }
        
       if（ctx-> reference_hdr.copy_gf == 1）
       {{
           vp8_dixie_release_ref_frame（ctx-> ref_frames [GOLDEN_FRAME]）;
           ctx-> ref_frames [GOLDEN_FRAME] =
               vp8_dixie_ref_frame（ctx-> ref_frames [LAST_FRAME]）;
       }
        
       else if（ctx-> reference_hdr.copy_gf == 2）
       {{
           vp8_dixie_release_ref_frame（ctx-> ref_frames [GOLDEN_FRAME]）;
           ctx-> ref_frames [GOLDEN_FRAME] =
               vp8_dixie_ref_frame（ctx-> ref_frames [ALTREF_FRAME]）;
       }
        
       if（ctx-> reference_hdr.refresh_gf）
       {{
           vp8_dixie_release_ref_frame（ctx-> ref_frames [GOLDEN_FRAME]）;
           ctx-> ref_frames [GOLDEN_FRAME] =
               vp8_dixie_ref_frame（ctx-> ref_frames [CURRENT_FRAME]）;
       }
        
       if（ctx-> reference_hdr.refresh_arf）
       {{
           vp8_dixie_release_ref_frame（ctx-> ref_frames [ALTREF_FRAME]）;
           ctx-> ref_frames [ALTREF_FRAME] =
               vp8_dixie_ref_frame（ctx-> ref_frames [CURRENT_FRAME]）;
       }
        
       if（ctx-> reference_hdr.refresh_last）
       {{
           vp8_dixie_release_ref_frame（ctx-> ref_frames [LAST_FRAME]）;
           ctx-> ref_frames [LAST_FRAME] =
               vp8_dixie_ref_frame（ctx-> ref_frames [CURRENT_FRAME]）;
       }
        
}

   空所
   vp8_dixie_decode_init（struct vp8_decoder_ctx * ctx）
   {{
       dequant_global_init（ctx-> dequant_factors）;
   }
        
   #define CHECK_FOR_UPDATE（lval、rval、update_flag）do {\
           unsigned int old = lval; \
           update_flag | =（old！=（lval = rval））; \
       } while（0）
        
   vpx_codec_err_t
   vp8_parse_frame_header（const unsigned char * data、
                          unsigned int sz、
                          struct vp8_frame_hdr * hdr）
   {{
       unsigned long raw;
        
if（sz <10）return VPX_CODEC_CORRUPT_FRAME;

       /*フレームヘッダーは3バイトのリトルエンディアンとして定義されています
        * 価値
        * /
       raw = data [0] | （data [1] << 8）| （data [2] << 16）;
       hdr-> is_keyframe =！BITS_GET（raw、0、1）;
       hdr-> version = BITS_GET（raw、1、2）;
       hdr-> is_experimental = BITS_GET（raw、3、1）;
       hdr-> is_shown = BITS_GET（raw、4、1）;
       hdr-> part0_sz = BITS_GET（raw、5、19）;
        
       if（sz <= hdr-> part0_sz +（hdr-> is_keyframe？10：3））
           VPX_CODEC_CORRUPT_FRAMEを返します. 
        
       hdr-> frame_size_updated = 0;
        
       if（hdr-> is_keyframe）
       {{
           unsigned int update = 0;
        
           /*キーフレームヘッダーは3バイトの同期コードで構成されます
            *その後に幅と高さ、および関連するスケーリングが続きます
            *要因. 
            * /
           if（data [3]！= 0x9d || data [4]！= 0x01 || data [5]！= 0x2a）
               VPX_CODEC_UNSUP_BITSTREAMを返します. 
        
           raw = data [6] | （data [7] << 8）
                 | （data [8] << 16）| （data [9] << 24）;
           CHECK_FOR_UPDATE（hdr-> kf.w、BITS_GET（raw、0、14）、
                            アップデート）;
           CHECK_FOR_UPDATE（hdr-> kf.scale_w、BITS_GET（raw、14、2）、
                            アップデート）;
           CHECK_FOR_UPDATE（hdr-> kf.h、BITS_GET（raw、16、14）、
                            アップデート）;
           CHECK_FOR_UPDATE（hdr-> kf.scale_h、BITS_GET（raw、30、2）、
                            アップデート）;
        
           hdr->frame_size_updated=更新;
        
           if（！hdr-> kf.w ||！hdr-> kf.h）
               VPX_CODEC_UNSUP_BITSTREAMを返します. 
       }
        
       VPX_CODEC_OKを返します. 
   }
        
   vpx_codec_err_t
   vp8_dixie_decode_frame（struct vp8_decoder_ctx * ctx、
                          const unsigned char * data、
                          unsigned int sz）
   {{
       volatile struct vp8_decoder_ctx * ctx_ = ctx;
        
       ctx-> error.error_code = VPX_CODEC_OK;
       ctx-> error.has_detail = 0;
        
       if（！setjmp（ctx-> error.jmp））
           decode_frame（ctx、data、sz）;
        
       ctx_->error.error_codeを返します. 
   }
        
   空所
   vp8_dixie_decode_destroy（struct vp8_decoder_ctx * ctx）
   {{
       vp8_dixie_predict_destroy（ctx）;
       vp8_dixie_tokens_destroy（ctx）;
       vp8_dixie_modemv_destroy（ctx）;
   }
        
   ----終了コードブロック----------------------------------------
        
20.5. dixie.h
   ----コードブロックを開始--------------------------------------
        
   / *
    * Copyright（c）2010、2011、Google Inc.無断複写・転載を禁じます. 
    *
    *このソースコードの使用はBSDスタイルのライセンスによって管理されています
    *ソースのルートにあるLICENSEファイルにあります
    * 木. 追加の知的財産権の付与は
    *ファイルPATENTSにあります. 貢献しているすべてのプロジェクト作成者は
    *ソースツリーのルートにあるAUTHORSファイルにあります. 
    * /
   #ifndef DIXIE_H
   #define DIXIE_H
   #include "vpx_codec_internal.h"
   #include "bool_decoder.h"
        
   struct vp8_frame_hdr
   {{
       unsigned int is_keyframe; /*フレームはキーフレームです*/
       unsigned int is_experimental; /*フレームはキーフレームです*/
       unsignedintバージョン. /*ビットストリームバージョン*/
       unsigned int is_shown; /*フレームが表示されます. * /
       unsigned int part0_sz; / *パーティション0の長さ（バイト単位）* /
        
       struct vp8_kf_hdr
       {{
           unsigned int w; /* 幅 */
           unsigned int h; /* 身長 */
           unsigned int scale_w; / *スケーリング係数、幅* /
           unsigned int scale_h; / *スケーリング係数、高さ* /
       } kf;
        
       unsigned int frame_size_updated; /*解像度を示すフラグ
                                         * アップデート. 
                                         * /
   };
        
   列挙型
   {{
       MB_FEATURE_TREE_PROBS = 3、
       MAX_MB_SEGMENTS = 4
   };
        
   struct vp8_segment_hdr
   {{
       unsignedintが有効です. 
       unsigned int update_data;
       unsigned int update_map;
       unsigned int abs; / * 0 =デルタ、1=絶対値*/
       unsigned int tree_probs [MB_FEATURE_TREE_PROBS];
       int lf_level [MAX_MB_SEGMENTS];
       int quant_idx [MAX_MB_SEGMENTS];
        
};

   列挙型
   {{
       BLOCK_CONTEXTS = 4
   };
        
   struct vp8_loopfilter_hdr
   {{
       unsigned int use_simple;
       unsignedintレベル. 
       unsignedintシャープネス;
       unsigned int delta_enabled;
       int ref_delta [BLOCK_CONTEXTS];
       int mode_delta [BLOCK_CONTEXTS];
   };
        
   列挙型
   {{
       MAX_PARTITIONS = 8
   };
        
   struct vp8_token_hdr
   {{
       unsignedintパーティション. 
       unsigned int partition_sz [MAX_PARTITIONS];
   };
        
   struct vp8_quant_hdr
   {{
       unsigned int q_index;
       int delta_update;
       int y1_dc_delta_q;
       int y2_dc_delta_q;
       int y2_ac_delta_q;
       int uv_dc_delta_q;
       int uv_ac_delta_q;
   };
        
   struct vp8_reference_hdr
   {{
       unsigned int refresh_last;
       unsigned int refresh_gf;
       unsigned int refresh_arf;
       unsigned int copy_gf;
       unsigned int copy_arf;
       unsigned int sign_bias [4];
       unsigned int refresh_entropy;
   };
        
   列挙型
   {{
       BLOCK_TYPES = 4、
       PREV_COEFF_CONTEXTS = 3、
       COEFF_BANDS = 8、
       ENTROPY_NODES = 11、
   };
   typedef unsigned char coeff_probs_table_t [BLOCK_TYPES] [COEFF_BANDS]
   [PREV_COEFF_CONTEXTS]
   [ENTROPY_NODES];
        
   列挙型
   {{
       MV_PROB_CNT = 2 + 8-1 + 10 /*entropymv.hから*/
   };
   typedef unsigned char mv_component_probs_t [MV_PROB_CNT];
        
   struct vp8_entropy_hdr
   {{
       coeff_probs_table_t coeff_probs;
       mv_component_probs_t mv_probs [2];
       unsigned int coeff_skip_enabled;
       unsigned char coeff_skip_prob;
       unsigned char y_mode_probs [4];
       unsigned char uv_mode_probs [3];
       unsigned char prob_inter;
       unsigned char prob_last;
       unsigned char prob_gf;
   };
        
   列挙型reference_frame
   {{
       CURRENT_FRAME、
       LAST_FRAME、
       GOLDEN_FRAME、
       ALTREF_FRAME、
       NUM_REF_FRAMES
   };
        
   列挙型prediction_mode
   {{
       /*16x16イントラモード*/
       DC_PRED、V_PRED、H_PRED、TM_PRED、B_PRED、
        
       /*16x16インターモード*/
       NEARESTMV、NEARMV、ZEROMV、NEWMV、SPLITMV、
        
MB_MODE_COUNT、

       /*4x4イントラモード*/
       B_DC_PRED = 0、B_TM_PRED、B_VE_PRED、B_HE_PRED、B_LD_PRED、
       B_RD_PRED、B_VR_PRED、B_VL_PRED、B_HD_PRED、B_HU_PRED、
        
       /*4x4インターモード*/
       LEFT4X4、ABOVE4X4、ZERO4X4、NEW4X4、
        
B_MODE_COUNT};

   列挙型splitmv_partitioning
   {{
       SPLITMV_16X8、
       SPLITMV_8X16、
       SPLITMV_8X8、
       SPLITMV_4X4
   };
        
typedef short filter_t [6];

   typedef union mv
   {{
       構造体
       {{
           int16_t x、y;
       } d;
       uint32_t raw;
   } mv_t;
        
   struct mb_base_info
   {{
       unsigned char y_mode：4;
       unsigned char uv_mode：4;
       unsigned char segment_id：2;
       unsigned char ref_frame：2;
       unsigned char skip_coeff：1;
       unsigned char need_mc_border：1;
       列挙型splitmv_partitioningパーティショニング：2;
       ユニオンmvmv;
       unsigned int eob_mask;
   };
        
   struct mb_info
   {{
       struct mb_base_info base;
       連合
       {{
           ユニオンmvmvs[16];
           列挙型prediction_modeモード[16];
       } スプリット;
   };
        
   / *「トークンエントロピーコンテキスト」には、4つのY値、2つのU、2つのV、および1つのY2があります* /
   typedef int token_entropy_ctx_t [4 + 2 + 2 + 1];
        
   struct token_decoder
   {{
       struct bool_decoder bool;
       token_entropy_ctx_t left_token_entropy_ctx;
       短い*係数;
   };
        
   列挙型token_block_type
   {{
       TOKEN_BLOCK_Y1、
       TOKEN_BLOCK_UV、
       TOKEN_BLOCK_Y2、
       TOKEN_BLOCK_TYPES、
   };
        
   struct dequant_factors
   {{
       int quant_idx;
       ショートファクター[TOKEN_BLOCK_TYPES][2]; / * [Y1、UV、Y2]
                                            * [DC、AC] * /
   };
        
   struct ref_cnt_img
   {{
       vpx_image_t img;
       unsigned int ref_cnt;
   };
        
   struct vp8_decoder_ctx
   {{
       structvpx_internal_error_infoエラー;
       unsigned int frame_cnt;
        
       struct vp8_frame_hdr frame_hdr;
       struct vp8_segment_hdr segment_hdr;
       struct vp8_loopfilter_hdr loopfilter_hdr;
       struct vp8_token_hdr token_hdr;
       struct vp8_quant_hdr quant_hdr;
       struct vp8_reference_hdr reference_hdr;
       struct vp8_entropy_hdr entropy_hdr;
        
       struct vp8_entropy_hdr saved_entropy;
       unsigned int saved_entropy_valid;
        
       unsigned int mb_rows;
       unsigned int mb_cols;
       struct mb_info * mb_info_storage;
       struct mb_info ** mb_info_rows_storage;
       struct mb_info ** mb_info_rows;
        
       token_entropy_ctx_t * above_token_entropy_ctx;
       struct token_decoder tokens [MAX_PARTITIONS];
       struct dequant_factors dequant_factors [MAX_MB_SEGMENTS];
        
       struct ref_cnt_img frame_strg [NUM_REF_FRAMES];
       struct ref_cnt_img * ref_frames [NUM_REF_FRAMES];
       ptrdiff_t ref_frame_offsets [4];
        
       const filter_t * subpixel_filters;
   };
        
   空所
   vp8_dixie_decode_init（struct vp8_decoder_ctx * ctx）;
        
   空所
   vp8_dixie_decode_destroy（struct vp8_decoder_ctx * ctx）;
        
vpx_codec_err_t vp8_parse_frame_header（const unsigned char * data、unsigned int sz、struct vp8_frame_hdr * hdr）;

vpx_codec_err_t vp8_dixie_decode_frame（struct vp8_decoder_ctx * ctx、const unsigned char * data、unsigned int sz）;

   #define CLAMP_255（x）（（x）<0？0：（（x）> 255？255：（x）））
        
#endif

   ----終了コードブロック----------------------------------------
        
20.6. dixie_loopfilter.c
   ----コードブロックを開始--------------------------------------
        
   / *
    * Copyright（c）2010、2011、Google Inc.無断複写・転載を禁じます. 
    *
    *このソースコードの使用はBSDスタイルのライセンスによって管理されています
    *ソースのルートにあるLICENSEファイルにあります
    * 木. 追加の知的財産権の付与は
    *ファイルPATENTSにあります. 貢献しているすべてのプロジェクト作成者は
    *ソースツリーのルートにあるAUTHORSファイルにあります. 
    * /
   #include "dixie.h"
   #include "dixie_loopfilter.h"
        
   #define ABS（x）（（x）> = 0？（x）：-（x））
        
   #definep3ピクセル[-4*ストライド]
   #definep2ピクセル[-3*stride]
   #definep1ピクセル[-2*ストライド]
   #definep0ピクセル[-1*ストライド]
   #defineq0ピクセル[0*ストライド]
   #defineq1ピクセル[1*ストライド]
   #defineq2ピクセル[2*ストライド]
   #defineq3ピクセル[3*ストライド]
        
#define static static int

   saturate_int8（int x）
   {{
       if（x <-128）
           -128を返します. 
        
if（x> 127）return 127;

       xを返します. 
   }
        
   static int
   saturate_uint8（int x）
   {{
       if（x <0）
           0を返します. 
        
if（x> 255）は255を返します. 

       xを返します. 
   }
        
   static int
   high_edge_variance（unsigned char * pixel、
                      intストライド、
                      int hev_threshold）
   {{
       ABS（p1-p0）>hev_threshold||を返します
              ABS（q1-q0）> hev_threshold;
   }
        
   static int
   simple_threshold（unsigned char * pixel、
                    intストライド、
                    int filter_limit）
   {{
       return（ABS（p0-q0）* 2 +（ABS（p1-q1）>> 1））<= filter_limit;
   }
        
   static int
   normal_threshold（unsigned char * pixel、
                    intストライド、
                    int edge_limit、
                    int internal_limit）
   {{
       int E = edge_limit;
       int I = internal_limit;
        
       simple_threshold（pixels、stride、2 * E + I）を返します
              && ABS（p3-p2）<= I && ABS（p2-p1）<= I
              && ABS（p1-p0）<= I && ABS（q3-q2）<= I
              && ABS（q2-q1）<= I && ABS（q1-q0）<= I;
   }
        
   静的ボイド
   filter_common（unsigned char * pixel、
                 intストライド、
                 int use_outer_taps）
   {{
       int a、f1、f2;
        
       a = 3 *（q0-p0）;
        
       if（use_outer_taps）
           a + = saturate_int8（p1-q1）;
        
       a = saturate_int8（a）;
        
       f1 =（（a + 4> 127）？127：a + 4）>> 3;
       f2 =（（a + 3> 127）？127：a + 3）>> 3;
        
       p0 = saturate_uint8（p0 + f2）;
       q0 = saturate_uint8（q0 --f1）;
        
       if（！use_outer_taps）
       {{
           / *これはsubblock_filter（）の場合を処理します
            *（ビットストリームガイドから. 
            * /
           a =（f1 + 1）>> 1;
           p1 = saturate_uint8（p1 + a）;
           q1 = saturate_uint8（q1-a）;
       }
   }
        
   静的ボイド
   filter_mb_edge（unsigned char * pixel、
                  intストライド）
   {{
       int w、a;
        
       w = saturate_int8（saturate_int8（p1-q1）+ 3 *（q0-p0））;
        
       a =（27 * w + 63）>> 7;
       p0 = saturate_uint8（p0 + a）;
       q0 = saturate_uint8（q0-a）;
        
       a =（18 * w + 63）>> 7;
       p1 = saturate_uint8（p1 + a）;
       q1 = saturate_uint8（q1-a）;
        
       a =（9 * w + 63）>> 7;
       p2 = saturate_uint8（p2 + a）;
       q2 = saturate_uint8（q2-a）;
   }
        
   静的ボイド
   filter_mb_v_edge（unsigned char * src、
                    intストライド、
                    int edge_limit、
                    int internal_limit、
                    int hev_threshold、
                    intサイズ）
   {{
       int i;
        
       for（i = 0; i<8*サイズ;i++）
       {{
           if（normal_threshold（src、1、edge_limit、interior_limit））
           {{
               if（high_edge_variance（src、1、hev_threshold））
                   filter_common（src、1、1）;
               そうしないと
                   filter_mb_edge（src、1）;
           }
        
           src+=ストライド;
       }
   }
        
   静的ボイド
   filter_subblock_v_edge（unsigned char * src、
                          intストライド、
                          int edge_limit、
                          int internal_limit、
                          int hev_threshold、
                          intサイズ）
   {{
       int i;
        
       for（i = 0; i<8*サイズ;i++）
       {{
           if（normal_threshold（src、1、edge_limit、interior_limit））
               filter_common（src、1、
                             high_edge_variance（src、1、hev_threshold））;
        
           src+=ストライド;
       }
   }
        
   静的ボイド
   filter_mb_h_edge（unsigned char * src、
                    intストライド、
                    int edge_limit、
                    int internal_limit、
                    int hev_threshold、
                    intサイズ）
   {{
       int i;
        
       for（i = 0; i<8*サイズ;i++）
       {{
           if（normal_threshold（src、stride、edge_limit、
                                internal_limit））
           {{
               if（high_edge_variance（src、stride、hev_threshold））
                   filter_common（src、stride、1）;
               そうしないと
                   filter_mb_edge（src、stride）;
           }
        
           src + = 1;
       }
   }
        
   静的ボイド
   filter_subblock_h_edge（unsigned char * src、
                          intストライド、
                          int edge_limit、
                          int internal_limit、
                          int hev_threshold、
                          intサイズ）
   {{
       int i;
        
       for（i = 0; i<8*サイズ;i++）
       {{
           if（normal_threshold（src、stride、edge_limit、
                                internal_limit））
               filter_common（src、stride、
                             high_edge_variance（src、stride、
                                                hev_threshold））;
        
           src + = 1;
       }
   }
        
   静的ボイド
   filter_v_edge_simple（unsigned char * src、
                        intストライド、
                        int filter_limit）
   {{
       int i;
        
       for（i = 0; i <16; i ++）
       {{
           if（simple_threshold（src、1、filter_limit））
               filter_common（src、1、1）;
        
           src+=ストライド;
       }
   }
        
   静的ボイド
   filter_h_edge_simple（unsigned char * src、
                        intストライド、
                        int filter_limit）
   {{
       int i;
        
       for（i = 0; i <16; i ++）
       {{
           if（simple_threshold（src、stride、filter_limit））
               filter_common（src、stride、1）;
        
           src + = 1;
       }
   }
        
   静的ボイド
   calculate_filter_parameters（struct vp8_decoder_ctx * ctx、
                               struct mb_info * mbi、
                               int * edge_limit_、
                               int * internal_limit_、
                               int * hev_threshold_）
   {{
       int filter_level、interior_limit、hev_threshold;
        
       /*参照コード/仕様はfilter_levelと
        * edge_limit
        * /
        
       filter_level = ctx-> loopfilter_hdr.level;
        
       if（ctx-> segment_hdr.enabled）
       {{
           if（！ctx-> segment_hdr.abs）
               filter_level + =
                   ctx-> segment_hdr.lf_level [mbi-> base.segment_id];
           そうしないと
               filter_level =
                   ctx-> segment_hdr.lf_level [mbi-> base.segment_id];
       }
        
       if（filter_level> 63）
           filter_level = 63;
       else if（filter_level <0）
           filter_level = 0;
        
       if（ctx-> loopfilter_hdr.delta_enabled）
       {{
           filter_level + =
               ctx-> loopfilter_hdr.ref_delta [mbi-> base.ref_frame];
        
           if（mbi-> base.ref_frame == CURRENT_FRAME）
           {{
               if（mbi-> base.y_mode == B_PRED）
                   filter_level + = ctx-> loopfilter_hdr.mode_delta [0];
           }
           else if（mbi-> base.y_mode == ZEROMV）
               filter_level + = ctx-> loopfilter_hdr.mode_delta [1];
           else if（mbi-> base.y_mode == SPLITMV）
               filter_level + = ctx-> loopfilter_hdr.mode_delta [3];
           そうしないと
               filter_level + = ctx-> loopfilter_hdr.mode_delta [2];
       }
        
       if（filter_level> 63）
           filter_level = 63;
       else if（filter_level <0）
           filter_level = 0;
        
internal_limit = filter_level;

       if（ctx-> loopfilter_hdr.sharpness）
       {{
           internal_limit >> = ctx-> loopfilter_hdr.sharpness> 4？2：1;
        
           if（interior_limit> 9-ctx-> loopfilter_hdr.sharpness）
               internal_limit = 9-ctx-> loopfilter_hdr.sharpness;
       }
        
       if（interior_limit <1）
           internal_limit = 1;
        
       hev_threshold =（filter_level> = 15）;
        
       if（filter_level> = 40）
           hev_threshold ++;
        
       if（filter_level> = 20 &&！ctx-> frame_hdr.is_keyframe）
           hev_threshold ++;
        
       * edge_limit_ = filter_level;
       * internal_limit_ = internal_limit;
       * hev_threshold_ = hev_threshold;
   }
        
   静的ボイド
   filter_row_normal（struct vp8_decoder_ctx * ctx、
                     unsigned int行、
                     unsigned int start_col、
                     unsigned int num_cols）
   {{
       unsigned char * y、* u、* v;
       int stride、uv_stride;
       struct mb_info * mbi;
       unsigned int col;
        
       / *行、start_colに基づいてポインタを調整します* /
        
       stride = ctx-> ref_frames [CURRENT_FRAME]-> img.stride [PLANE_Y];
       uv_stride = ctx-> ref_frames [CURRENT_FRAME]-> img.stride [PLANE_U];
       y = ctx-> ref_frames [CURRENT_FRAME]-> img.planes [PLANE_Y];
       u = ctx-> ref_frames [CURRENT_FRAME]-> img.planes [PLANE_U];
       v = ctx-> ref_frames [CURRENT_FRAME]-> img.planes [PLANE_V];
       y + =（ストライド*行+ start_col）* 16;
       u + =（uv_stride * row + start_col）* 8;
       v + =（uv_stride * row + start_col）* 8;
       mbi = ctx-> mb_info_rows [row] + start_col;
        
       for（col = start_col; col <start_col + num_cols; col ++）
       {{
           int edge_limit、interior_limit、hev_threshold;
        
           / * TODO：セグメンテーションが
            *有効. 
            * /
           calculate_filter_parameters（ctx、mbi、＆edge_limit、
                                       ＆interior_limit、＆hev_threshold）;
        
           if（edge_limit）
           {{
               if（col）
               {{
                   filter_mb_v_edge（y、stride、edge_limit + 2、
                                    internal_limit、hev_threshold、2）;
                   filter_mb_v_edge（u、uv_stride、edge_limit + 2、
                                    internal_limit、hev_threshold、1）;
                   filter_mb_v_edge（v、uv_stride、edge_limit + 2、
                                    internal_limit、hev_threshold、1）;
               }
        
               / *注：この条件は実際には
                *デコードされた係数の数、スキップフラグではありません
                *ビットストリームでコード化されています. トークンタスクが期待されます
                *ゼロ以外のデータがある場合は31を設定します. 
                * /
               if（mbi-> base.eob_mask
                   || mbi-> base.y_mode == SPLITMV
                   || mbi-> base.y_mode == B_PRED）
               {{
                   filter_subblock_v_edge（y + 4、ストライド、edge_limit、
                                          internal_limit、hev_threshold、
                                          2）;
                   filter_subblock_v_edge（y + 8、ストライド、edge_limit、
                                          internal_limit、hev_threshold、
                                          2）;
                   filter_subblock_v_edge（y + 12、ストライド、edge_limit、
                                          internal_limit、hev_threshold、
                                          2）;
                   filter_subblock_v_edge（u + 4、uv_stride、edge_limit、
                                          internal_limit、hev_threshold、
                                          1）;
                   filter_subblock_v_edge（v + 4、uv_stride、edge_limit、
                                          internal_limit、hev_threshold、
                                          1）;
               }
        
               if（行）
               {{
                   filter_mb_h_edge（y、stride、edge_limit + 2、
                                    internal_limit、hev_threshold、2）;
                   filter_mb_h_edge（u、uv_stride、edge_limit + 2、
                                    internal_limit、hev_threshold、1）;
                   filter_mb_h_edge（v、uv_stride、edge_limit + 2、
                                    internal_limit、hev_threshold、1）;
               }
        
               if（mbi-> base.eob_mask
                   || mbi-> base.y_mode == SPLITMV
                   || mbi-> base.y_mode == B_PRED）
               {{
                   filter_subblock_h_edge（y + 4 *ストライド、ストライド、
                                          edge_limit、interior_limit、
                                          hev_threshold、2）;
                   filter_subblock_h_edge（y + 8 *ストライド、ストライド、
                                          edge_limit、interior_limit、
                                          hev_threshold、2）;
                   filter_subblock_h_edge（y + 12 *ストライド、ストライド、
                                          edge_limit、interior_limit、
                                          hev_threshold、2）;
                   filter_subblock_h_edge（u + 4 * uv_stride、uv_stride、
                                          edge_limit、interior_limit、
                                          hev_threshold、1）;
                   filter_subblock_h_edge（v + 4 * uv_stride、uv_stride、
                                          edge_limit、interior_limit、
                                          hev_threshold、1）;
               }
           }
        
           y + = 16;
           u + = 8;
           v + = 8;
           mbi ++;
       }
   }
        
   静的ボイド
   filter_row_simple（struct vp8_decoder_ctx * ctx、
                     unsigned int行、
                     unsigned int start_col、
                     unsigned int num_cols）
   {{
       unsigned char * y;
       intストライド;
       struct mb_info * mbi;
       unsigned int col;
        
       / *行、start_colに基づいてポインタを調整します* /
       stride = ctx-> ref_frames [CURRENT_FRAME]-> img.stride [PLANE_Y];
       y = ctx-> ref_frames [CURRENT_FRAME]-> img.planes [PLANE_Y];
       y + =（ストライド*行+ start_col）* 16;
       mbi = ctx-> mb_info_rows [row] + start_col;
        
       for（col = start_col; col <start_col + num_cols; col ++）
       {{
           int edge_limit、interior_limit、hev_threshold;
        
           / * TODO：セグメンテーションが
            *有効. 
            * /
           calculate_filter_parameters（ctx、mbi、＆edge_limit、
                                       ＆interior_limit、＆hev_threshold）;
        
if（edge_limit）{

               / *注：この条件は実際には
                *デコードされた係数の数、スキップフラグではありません
                *ビットストリームでコード化されています. トークンタスクが期待されます
                *ゼロ以外のデータがある場合は31を設定します. 
                * /
               int filter_subblocks =（mbi-> base.eob_mask
                                       || mbi-> base.y_mode == SPLITMV
                                       || mbi-> base.y_mode == B_PRED）;
               int mb_limit =（edge_limit + 2）* 2 + internal_limit;
               int b_limit = edge_limit * 2 + internal_limit;
        
               if（col）
                   filter_v_edge_simple（y、stride、mb_limit）;
        
               if（filter_subblocks）
               {{
                   filter_v_edge_simple（y + 4、ストライド、b_limit）;
                   filter_v_edge_simple（y + 8、ストライド、b_limit）;
                   filter_v_edge_simple（y + 12、ストライド、b_limit）;
               }
        
               if（行）
                   filter_h_edge_simple（y、stride、mb_limit）;
        
               if（filter_subblocks）
               {{
                   filter_h_edge_simple（y + 4 *ストライド、ストライド、
                                        b_limit）;
                   filter_h_edge_simple（y + 8 *ストライド、ストライド、
                                        b_limit）;
                   filter_h_edge_simple（y + 12 *ストライド、ストライド、
                                        b_limit）;
               }
           }
        
           y + = 16;
           mbi ++;
       }
   }
        
   空所
   vp8_dixie_loopfilter_process_row（struct vp8_decoder_ctx * ctx、
                                    unsigned int行、
                                    unsigned int start_col、
                                    unsigned int num_cols）
   {{
       if（ctx-> loopfilter_hdr.use_simple）
           filter_row_simple（ctx、row、start_col、num_cols）;
       そうしないと
           filter_row_normal（ctx、row、start_col、num_cols）;
   }
        
   ----終了コードブロック----------------------------------------
        
20.7. dixie_loopfilter.h
   ----コードブロックを開始--------------------------------------
        
   / *
    * Copyright（c）2010、2011、Google Inc.無断複写・転載を禁じます. 
    *
    *このソースコードの使用はBSDスタイルのライセンスによって管理されています
    *ソースのルートにあるLICENSEファイルにあります
    * 木. 追加の知的財産権の付与は
    *ファイルPATENTSにあります. 貢献しているすべてのプロジェクト作成者は
    *ソースツリーのルートにあるAUTHORSファイルにあります. 
    * /
   #ifndef DIXIE_LOOPFILTER_H
   #define DIXIE_LOOPFILTER_H
        
void vp8_dixie_loopfilter_process_row（struct vp8_decoder_ctx * ctx、unsigned int row、unsigned int start_col、unsigned int num_cols）;

#endif

   ----終了コードブロック----------------------------------------
        
20.8. idct_add.c
   ----コードブロックを開始--------------------------------------
        
   / *
    * Copyright（c）2010、2011、Google Inc.無断複写・転載を禁じます. 
    *
    *このソースコードの使用はBSDスタイルのライセンスによって管理されています
    *ソースのルートにあるLICENSEファイルにあります
    * 木. 追加の知的財産権の付与は
    *ファイルPATENTSにあります. 貢献しているすべてのプロジェクト作成者は
    *ソースツリーのルートにあるAUTHORSファイルにあります. 
    * /
   #include "dixie.h"
   #include "idct_add.h"
   #include <assert.h>
        
   空所
   vp8_dixie_walsh（const short * input、short * output）
   {{
       int i;
       int a1、b1、c1、d1;
       int a2、b2、c2、d2;
       const short * ip = input;
       短い*op=出力;
        
       for（i = 0; i <4; i ++）
       {{
           a1 = ip [0] + ip [12];
           b1 = ip [4] + ip [8];
           c1 = ip [4]-ip [8];
           d1 = ip [0]-ip [12];
        
           op [0] = a1 + b1;
           op [4] = c1 + d1;
           op [8] = a1-b1;
           op [12] = d1-c1;
           ip ++;
           op ++;
       }
        
       ip=出力;
       op=出力;
        
       for（i = 0; i <4; i ++）
       {{
           a1 = ip [0] + ip [3];
           b1 = ip [1] + ip [2];
           c1 = ip [1]-ip [2];
           d1 = ip [0]-ip [3];
        
           a2 = a1 + b1;
           b2 = c1 + d1;
           c2 = a1-b1;
           d2 = d1-c1;
        
           op [0] =（a2 + 3）>> 3;
           op [1] =（b2 + 3）>> 3;
           op [2] =（c2 + 3）>> 3;
           op [3] =（d2 + 3）>> 3;
        
           ip + = 4;
           op + = 4;
       }
   }
        
   #define cospi8sqrt2minus1 20091
   #define sinpi8sqrt2 35468
   #define rounding 0
   静的ボイド
   idct_columns（const short * input、short * output）
   {{
       int i;
       int a1、b1、c1、d1;
        
       const short * ip = input;
       短い*op=出力;
       int temp1、temp2;
       int shortpitch = 4;
        
       for（i = 0; i <4; i ++）
       {{
           a1 = ip [0] + ip [8];
           b1 = ip [0]-ip [8];
        
           temp1 =（ip [4] * sinpi8sqrt2 +丸め）>> 16;
           temp2 = ip [12] +
               （（ip [12] * cospi8sqrt2minus1 +丸め）>> 16）;
           c1 = temp1-temp2;
        
           temp1 = ip [4] +
               （（ip [4] * cospi8sqrt2minus1 +丸め）>> 16）;
           temp2 =（ip [12] * sinpi8sqrt2 +丸め）>> 16;
           d1 = temp1 + temp2;
        
           op [shortpitch * 0] = a1 + d1;
           op [shortpitch * 3] = a1--d1;
        
           op [shortpitch * 1] = b1 + c1;
           op [shortpitch * 2] = b1-c1;
        
           ip ++;
           op ++;
       }
   }
        
   空所
   vp8_dixie_idct_add（unsigned char * recon、
                      const unsigned char * predict、
                      intストライド、
                      const short * coeffs）
   {{
       int i;
       int a1、b1、c1、d1、temp1、temp2;
       短いtmp[16];
       idct_columns（coeffs、tmp）;
       coeffs = tmp;
        
       for（i = 0; i <4; i ++）
       {{
           a1 = coeffs [0] + coeffs [2];
           b1 = coeffs [0]-coeffs [2];
        
           temp1 =（coeffs [1] * sinpi8sqrt2 +丸め）>> 16;
           temp2 = coeffs [3] +
               （（coeffs [3] * cospi8sqrt2minus1 +丸め）>> 16）;
           c1 = temp1-temp2;
        
           temp1 = coeffs [1] +
               （（coeffs [1] * cospi8sqrt2minus1 +丸め）>> 16）;
           temp2 =（coeffs [3] * sinpi8sqrt2 +丸め）>> 16;
           d1 = temp1 + temp2;
        
           recon [0] = CLAMP_255（predict [0] +（（a1 + d1 + 4）>> 3））;
           recon [3] = CLAMP_255（predict [3] +（（a1--d1 + 4）>> 3））;
           recon [1] = CLAMP_255（predict [1] +（（b1 + c1 + 4）>> 3））;
           recon [2] = CLAMP_255（predict [2] +（（b1-c1 + 4）>> 3））;
        
           係数+=4;
           偵察+=ストライド;
           +=ストライドを予測します. 
       }
   }
        
   ----終了コードブロック----------------------------------------
        
20.9. idct_add.h
   ----コードブロックを開始--------------------------------------
        
   / *
    * Copyright（c）2010、2011、Google Inc.無断複写・転載を禁じます. 
    *
    *このソースコードの使用はBSDスタイルのライセンスによって管理されています
    *ソースのルートにあるLICENSEファイルにあります
    * 木. 追加の知的財産権の付与は
    *ファイルPATENTSにあります. 貢献しているすべてのプロジェクト作成者は
    *ソースツリーのルートにあるAUTHORSファイルにあります. 
    * /
   #ifndef IDCT_ADD_H
   #define IDCT_ADD_H
        
   空所
   vp8_dixie_idct_add_init（struct vp8_decoder_ctx * ctx）;
        
void vp8_dixie_idct_add（unsigned char * recon、const unsigned char * predict、int stride、const short * coeffs）;

   空所
   vp8_dixie_walsh（const short * in、short * out）;
        
void vp8_dixie_idct_add_process_row（struct vp8_decoder_ctx * ctx、short * coeffs、unsigned int row、unsigned int start_col、unsigned int num_cols）; #endif

   ----終了コードブロック----------------------------------------
        
20.10. mem.h
   ----コードブロックを開始--------------------------------------
        
   / *
    * Copyright（c）2010、2011、Google Inc.無断複写・転載を禁じます. 
    *
    *このソースコードの使用はBSDスタイルのライセンスによって管理されています
    *ソースのルートにあるLICENSEファイルにあります
    * 木. 追加の知的財産権の付与は
    *ファイルPATENTSにあります. 貢献しているすべてのプロジェクト作成者は
    *ソースツリーのルートにあるAUTHORSファイルにあります. 
    * /
   #ifndef VPX_PORTS_MEM_H
   #define VPX_PORTS_MEM_H
   #include "vpx_config.h"
   #include "vpx_integer.h"
        
   #if defined（__ GNUC__）&& __GNUC__
   #define DECLARE_ALIGNED（n、typ、val）typ val __attribute__ \
       （（整列（n）））
   #elif defined（_MSC_VER）
   #define DECLARE_ALIGNED（n、typ、val）__declspec（align（n））typ val
   ＃そうしないと
   #warningこのコンパイラで認識されているアライメントディレクティブはありません. 
   #define DECLARE_ALIGNED（n、typ、val）typ val
   #endif
   #endif
        
   /*スタック上で整列された配列を宣言します. 
    *スタックポインタが期待どおりの配置になっていない可能性があります. を作成します
    *名前が変更された配列、次にvalをポインタとして定義し、
    *そのポインタを配列内に配置します. 
    * /
   #define DECLARE_ALIGNED_ARRAY（a、typ、val、n）\
   typ val ## _ [（n）+（a）/ sizeof（typ）+1]; \
   typ * val =（typ *）（（（（intptr_t）val ## _）+（a）-1）＆（（intptr_t）-（a）））
        
   /*指定された変数の使用が行われたことを示します
    *初期化されていない状態で安全に使用できることを確認するために監査されました. 沈黙
    *'gccで初期化されていない'警告が使用される場合があります. 
    * /
   #if defined（__ GNUC__）&& __GNUC__
   #define UNINITIALIZED_IS_SAFE（x）x = x
   ＃そうしないと
   #define UNINITIALIZED_IS_SAFE（x）x
   #endif
        
   ----終了コードブロック----------------------------------------
        
20.11. modemv.c
   ----コードブロックを開始--------------------------------------
        
   / *
    * Copyright（c）2010、2011、Google Inc.無断複写・転載を禁じます. 
    *
    *このソースコードの使用はBSDスタイルのライセンスによって管理されています
    *ソースのルートにあるLICENSEファイルにあります
    * 木. 追加の知的財産権の付与は
    *ファイルPATENTSにあります. 貢献しているすべてのプロジェクト作成者は
    *ソースツリーのルートにあるAUTHORSファイルにあります. 
    * /
   #include "dixie.h"
   #include "modemv_data.h"
   #include <stdlib.h>
   #include <assert.h>
        
   struct mv_clamp_rect
   {{
       int to_left、to_right、to_top、to_bottom;
   };
        
   静的ユニオンmv
           クランプ_mv（union mv raw、const struct mv_clamp_rect * bounds）
   {{
       ユニオンmvnewmv;
        
       newmv.dx =（raw.dx <bounds-> to_left）
                   ？bounds-> to_left：raw.dx;
       newmv.dx =（raw.dx> bounds-> to_right）
                   ？bounds-> to_right：newmv.dx;
       newmv.dy =（raw.dy <bounds-> to_top）
                   ？bounds-> to_top：raw.dy;
       newmv.dy =（raw.dy> bounds-> to_bottom）
                   ？bounds-> to_bottom：newmv.dy;
       newmvを返します. 
   }
        
   static int
   read_segment_id（struct bool_decoder * bool、
                   struct vp8_segment_hdr * seg）
   {{
       bool_get（bool、seg-> tree_probs [0]）を返します
              ？2 + bool_get（bool、seg-> tree_probs [2]）
              ：bool_get（bool、seg-> tree_probs [1]）;
   }
        
   静的列挙型prediction_mode
   above_block_mode（const struct mb_info * this、
                    const struct mb_info *上記、
                    unsigned int b）
   {{
       if（b <4）
       {{
           スイッチ（above-> base.y_mode）
           {{
           ケースDC_PRED：
               B_DC_PREDを返します. 
           ケースV_PRED：
               B_VE_PREDを返します. 
           ケースH_PRED：
               B_HE_PREDを返します. 
        
           ケースTM_PRED：
               B_TM_PREDを返します. 
           ケースB_PRED：
               上に戻る->split.modes[b + 12];
           デフォルト：
               assert（0）;
           }
       }
        
       これを返す->split.modes[b-4];
   }
        
   静的列挙型prediction_mode
   left_block_mode（const struct mb_info * this、
                   const struct mb_info * left、
                   unsigned int b）
   {{
       if（！（b＆3））
       {{
           スイッチ（左-> base.y_mode）
           {{
           ケースDC_PRED：
               B_DC_PREDを返します. 
           ケースV_PRED：
               B_VE_PREDを返します. 
           ケースH_PRED：
               B_HE_PREDを返します. 
           ケースTM_PRED：
               B_TM_PREDを返します. 
           ケースB_PRED：
               左に戻る->split.modes[b + 3];
           デフォルト：
               assert（0）;
           }
       }
        
       これを返す->split.modes[b-1];
   }
        
   静的ボイド
   decode_kf_mb_mode（struct mb_info * this、
                     struct mb_info * left、
                     struct mb_info *上記、
                     struct bool_decoder * bool）
   {{
       int y_mode、uv_mode;
        
       y_mode = bool_read_tree（bool、kf_y_mode_tree、kf_y_mode_probs）;
        
       if（y_mode == B_PRED）
       {{
           unsigned int i;
        
           for（i = 0; i <16; i ++）
           {{
               列挙型prediction_modea= above_block_mode（this、above、
                                                         私）;
               列挙型prediction_model= left_block_mode（this、left、i）;
               列挙型prediction_modeb;
        
               b = bool_read_tree（bool、b_mode_tree、
                                  kf_b_mode_probs [a] [l]）;
               this-> split.modes [i] = b;
           }
       }
        
       uv_mode = bool_read_tree（bool、uv_mode_tree、kf_uv_mode_probs）;
        
       this-> base.y_mode = y_mode;
       this-> base.uv_mode = uv_mode;
       this-> base.mv.raw = 0;
       this-> base.ref_frame = 0;
   }
        
   静的ボイド
   decode_intra_mb_mode（struct mb_info * this、
                        struct vp8_entropy_hdr * hdr、
                        struct bool_decoder * bool）
   {{
       / * decode_kf_mb_modeに似ていますが、確率が送信されます
        *ビットストリームと上記/左ブロックモードのコンテキストなし. 
        * /
       int y_mode、uv_mode;
        
       y_mode = bool_read_tree（bool、y_mode_tree、hdr-> y_mode_probs）;
        
       if（y_mode == B_PRED）
       {{
           unsigned int i;
        
           for（i = 0; i <16; i ++）
           {{
               列挙型prediction_modeb;
        
               b = bool_read_tree（bool、b_mode_tree、
                                  default_b_mode_probs）;
               this-> split.modes [i] = b;
           }
       }
        
       uv_mode = bool_read_tree（bool、uv_mode_tree、hdr-> uv_mode_probs）;
        
       this-> base.y_mode = y_mode;
       this-> base.uv_mode = uv_mode;
       this-> base.mv.raw = 0;
       this-> base.ref_frame = CURRENT_FRAME;
   }
        
   static int
   read_mv_component（struct bool_decoder * bool、
                     const unsigned char mvc [MV_PROB_CNT]）
   {{
       列挙型{IS_SHORT、SIGN、SHORT、BITS = SHORT + 8-1、
             LONG_WIDTH = 10};
       int x = 0;
        
       if（bool_get（bool、mvc [IS_SHORT]））/*大*/
       {{
           int i = 0;
        
           for（i = 0; i <3; i ++）
               x + = bool_get（bool、mvc [BITS + i]）<< i;
        
           /*ビット3をスキップします. これは暗黙的な場合があります*/
           for（i = LONG_WIDTH-1; i> 3; i--）
               x + = bool_get（bool、mvc [BITS + i]）<< i;
        
           if（！（x＆0xFFF0）|| bool_get（bool、mvc [BITS + 3]））
               x + = 8;
       }
       else/*小さい*/
           x = bool_read_tree（bool、small_mv_tree、mvc + SHORT）;
        
       if（x && bool_get（bool、mvc [SIGN]））
           x = -x;
        
       x<<1を返します. 
   }
        
   静的mv_t
   above_block_mv（const struct mb_info * this、
                  const struct mb_info *上記、
                  unsigned int b）
   {{
       if（b <4）
       {{
           if（above-> base.y_mode == SPLITMV）
               上に戻る->split.mvs[b + 12];
        
           上記を返す->base.mv;
       }
        
       これを返す->split.mvs[b-4];
   }
        
   静的mv_t
   left_block_mv（const struct mb_info * this、
                 const struct mb_info * left、
                 unsigned int b）
   {{
       if（！（b＆3））
       {{
           if（left-> base.y_mode == SPLITMV）
               左に戻る->split.mvs[b + 3];
        
           左に戻る->base.mv;
       }
        
       これを返す->split.mvs[b-1];
   }
        
   静的列挙型prediction_mode
   submv_ref（struct bool_decoder * bool、union mv l、union mv a）
   {{
       列挙型subblock_mv_ref
       {{
           SUBMVREF_NORMAL、
           SUBMVREF_LEFT_ZED、
           SUBMVREF_ABOVE_ZED、
           SUBMVREF_LEFT_ABOVE_SAME、
           SUBMVREF_LEFT_ABOVE_ZED
       };
        
       int lez =！（l.raw）;
       int aez =！（a.raw）;
       int lea = l.raw == a.raw;
       列挙型subblock_mv_refctx= SUBMVREF_NORMAL;
        
       if（lea && lez）
           ctx = SUBMVREF_LEFT_ABOVE_ZED;
       それ以外の場合（リー）
           ctx = SUBMVREF_LEFT_ABOVE_SAME;
       そうでなければ（aez）
           ctx = SUBMVREF_ABOVE_ZED;
       else if（lez）
           ctx = SUBMVREF_LEFT_ZED;
        
       bool_read_tree（bool、submv_ref_tree、
                             submv_ref_probs2 [ctx]）;
   }
        
   静的ボイド
   read_mv（struct bool_decoder * bool、
           ユニオンmv*mv、
           mv_component_probs_t mvc [2]）
   {{
       mv-> dy = read_mv_component（bool、mvc [0]）;
       mv-> dx = read_mv_component（bool、mvc [1]）;
   }
        
   静的ボイド
   mv_bias（const struct mb_info * mb、
           const unsigned int sign_bias [3]、
           列挙型reference_frameref_frame、
           ユニオンmv*mv）
   {{
       if（sign_bias [mb-> base.ref_frame] ^ sign_bias [ref_frame]）
       {{
           mv-> dx * = -1;
           mv-> dy * = -1;
       }
   }
        
   列挙型near_mv_v
   {{
       CNT_BEST = 0、
       CNT_ZEROZERO = 0、
       CNT_NEAREST、
       CNT_NEAR、
       CNT_SPLITMV
   };
        
   静的ボイド
   find_near_mvs（const struct mb_info * this、
                 const struct mb_info * left、
                 const struct mb_info *上記、
                 const unsigned int sign_bias [3]、
                 union mv near_mvs [4]、
                 int cnt [4]）
   {{
       const struct mb_info * aboveleft = above-1;
       ユニオンmv*mv = near_mvs;
       int * cntx = cnt;
        
       /*ゼロアキュムレータ*/
       mv [0] .raw = mv [1] .raw = mv [2] .raw = 0;
       cnt [0] = cnt [1] = cnt [2] = cnt [3] = 0;
        
       /*上記のプロセス*/
       if（above-> base.ref_frame！= CURRENT_FRAME）
       {{
           if（above-> base.mv.raw）
           {{
               （++ mv）-> raw = above-> base.mv.raw;
               mv_bias（above、sign_bias、this-> base.ref_frame、mv）;
               ++ cntx;
           }
        
           * cntx + = 2;
       }
        
       /*プロセスが残っています*/
       if（left-> base.ref_frame！= CURRENT_FRAME）
       {{
           if（left-> base.mv.raw）
           {{
               ユニオンmvthis_mv;
        
               this_mv.raw = left-> base.mv.raw;
               mv_bias（left、sign_bias、this-> base.ref_fra me、＆this_mv）;
        
               if（this_mv.raw！= mv-> raw）
               {{
                   （++ mv）-> raw = this_mv.raw;
                   ++ cntx;
               }
        
               * cntx + = 2;
           }
           そうしないと
               cnt [CNT_ZEROZERO] + = 2;
       }
        
       /*左上のプロセス*/
       if（aboveleft-> base.ref_frame！= CURRENT_FRAME）
       {{
           if（aboveleft-> base.mv.raw）
           {{
               ユニオンmvthis_mv;
        
               this_mv.raw = aboveleft-> base.mv.raw;
               mv_bias（aboveleft、sign_bias、this-> base.ref_frame、
                       ＆this_mv）;
        
               if（this_mv.raw！= mv-> raw）
               {{
                   （++ mv）-> raw = this_mv.raw;
                   ++ cntx;
               }
        
               * cntx + = 1;
           }
           そうしないと
               cnt [CNT_ZEROZERO] + = 1;
       }
        
       /*3つの異なるMVがある場合...*/
        
       if（cnt [CNT_SPLITMV]）
       {{
           /*左上のMVをNEARESTとマージできるかどうかを確認します*/
           if（mv-> raw == near_mvs [CNT_NEAREST] .raw）
               cnt [CNT_NEAREST] + = 1;
       }
        
       cnt [CNT_SPLITMV] =（（above-> base.y_mode == SPLITMV）
                           +（左-> base.y_mode == SPLITMV））* 2
                          +（左上-> base.y_mode == SPLITMV）;
        
       /*必要に応じて近くと最も近い場所で交換します*/
       if（cnt [CNT_NEAR]> cnt [CNT_NEAREST]）
       {{
           int tmp;
           tmp = cnt [CNT_NEAREST];
           cnt [CNT_NEAREST] = cnt [CNT_NEAR];
           cnt [CNT_NEAR] = tmp;
           tmp = near_mvs [CNT_NEAREST] .raw;
           near_mvs [CNT_NEAREST] .raw = near_mvs [CNT_NEAR] .raw;
           near_mvs [CNT_NEAR] .raw = tmp;
       }
        
       / * near_mvs [CNT_BEST]を使用して、「最良の」MVを保存します. これに注意してください
        *ストレージはnear_mvs[CNT_ZEROZERO]と同じアドレスを共有します. 
        * /
       if（cnt [CNT_NEAREST]> = cnt [CNT_BEST]）
           near_mvs [CNT_BEST] = near_mvs [CNT_NEAREST];
   }
        
   静的ボイド
   decode_split_mv（struct mb_info * this、
                   const struct mb_info * left、
                   const struct mb_info *上記、
                   struct vp8_entropy_hdr * hdr、
                   ユニオンmv*best_mv、
                   struct bool_decoder * bool）
   {{
       const int * partition;
       int j、k、mask、partition_id;
        
       partition_id = bool_read_tree（bool、split_mv_tree、
                                     split_mv_probs）;
       パーティション=mv_partitions[partition_id];
       this-> base.partitioning = partition_id;
        
       for（j = 0、mask = 0; mask <65535; j ++）
       {{
           ユニオンmvmv、left_mv、above_mv;
           列挙型prediction_modesubblock_mode;
        
           /*このパーティションの最初のサブブロックを見つけます. * /
           for（k = 0; j！= partition [k]; k ++）;
        
           /*次のMVをデコードします*/
           left_mv = left_block_mv（this、left、k）;
           above_mv = above_block_mv（this、above、k）;
           subblock_mode = submv_ref（bool、left_mv、above_mv）;
        
           スイッチ（subblock_mode）
           {{
           ケースLEFT4X4：
               mv = left_mv;
               壊す;
           ケースABOVE4X4：
               mv = above_mv;
               壊す;
           ケースZERO4X4：
               mv.raw = 0;
               壊す;
           ケースNEW4X4：
               read_mv（bool、＆mv、hdr-> mv_probs）;
               mv.dx + = best_mv-> dx;
               mv.dy + = best_mv-> dy;
               壊す;
           デフォルト：
               assert（0）;
           }
        
           /*このパーティションのMVを埋めます*/
           for（; k <16; k ++）
               if（j == partition [k]）
               {{
                   this-> split.mvs [k] = mv;
                   マスク|=1 << k;
               }
       }
   }
        
   static int
   need_mc_border（union mv mv、int l、int t、int b_w、int w、int h）
   {{
       int b、r;
        
       /*左上のピクセルのエッジまでの距離を取得します*/
       l + =（mv.dx >> 3）;
       t + =（mv.dy >> 3）;
        
       /*右下のピクセルのエッジまでの距離を取得します*/
       r = w-（l + b_w）;
       b = h-（t + b_w）;
        
       return（l >> 1 <2 || r >> 1 <3 || t >> 1 <2 || b >> 1 <3）;
   }
        
   静的ボイド
   decode_mvs（struct vp8_decoder_ctx * ctx、
              struct mb_info * this、
              const struct mb_info * left、
              const struct mb_info *上記、
              const struct mv_clamp_rect * bounds、
              struct bool_decoder * bool）
   {{
       struct vp8_entropy_hdr * hdr =＆ctx-> entropy_hdr;
       union mv near_mvs [4];
       ユニオンmvclamped_best_mv;
       int mv_cnts [4];
       unsigned char probs [4];
       列挙型{BEST、NEAREST、NEAR};
       int x、y、w、h、b;
        
       this-> base.ref_frame = bool_get（bool、hdr-> prob_last）
                              ？2 + bool_get（bool、hdr-> prob_gf）
                              ：1;
        
       find_near_mvs（this、this-1、above、
                     ctx-> reference_hdr.sign_bias、near_mvs、mv_cnts）;
       probs [0] = mv_counts_to_probs [mv_cnts [0]] [0];
       probs [1] = mv_counts_to_probs [mv_cnts [1]] [1];
       probs [2] = mv_counts_to_probs [mv_cnts [2]] [2];
       probs [3] = mv_counts_to_probs [mv_cnts [3]] [3];
        
       this-> base.y_mode = bool_read_tree（bool、mv_ref_tree、probs）;
       this-> base.uv_mode = this-> base.y_mode;
        
       this-> base.need_mc_border = 0;
       x =（-bounds-> to_left --128）>> 3;
       y =（-bounds-> to_top --128）>> 3;
       w = ctx-> mb_cols * 16;
       h = ctx-> mb_rows * 16;
        
       スイッチ（this-> base.y_mode）
       {{
       ケースNEARESTMV：
           this-> base.mv =クランプ_mv（near_mvs [NEAREST]、境界）;
           壊す;
       ケースNEARMV：
           this-> base.mv =クランプ_mv（near_mvs [NEAR]、境界）;
           壊す;
       ケースZEROMV：
           this-> base.mv.raw = 0;
           戻る; //need_mc_borderチェックをスキップします
       ケースNEWMV：
           クランプされたベスト_mv=クランプ_mv（near_mvs [BEST]、境界）;
           read_mv（bool、＆this-> base.mv、hdr-> mv_probs）;
           this-> base.mv.dx + = clamped_best_mv.dx;
           this-> base.mv.dy + = clamped_best_mv.dy;
           壊す;
       ケースSPLITMV：
       {{
           union mv chroma_mv [4] = {{{0}}};
        
           クランプされたベスト_mv=クランプ_mv（near_mvs [BEST]、境界）;
           decode_split_mv（this、left、above、hdr、＆clamped_best_mv、
                           bool）;
           this-> base.mv = this-> split.mvs [15];
        
           for（b = 0; b <16; b ++）
           {{
               chroma_mv [（b >> 1＆1）+（b >> 2＆2）]. dx + =
                   this-> split.mvs [b] .dx;
               chroma_mv [（b >> 1＆1）+（b >> 2＆2）]. dy + =
                   this-> split.mvs [b] .dy;
        
               if（need_mc_border（this-> split.mvs [b]、
               x +（b＆3）* 4、y +（b＆〜3）、4、w、h））
               {{
                   this-> base.need_mc_border = 1;
                   壊す;
               }
           }
        
           for（b = 0; b <4; b ++）
           {{
               chroma_mv [b] .dx + = 4 + 8 *（chroma_mv [b] .dx >> 31）;
               chroma_mv [b] .dy + = 4 + 8 *（chroma_mv [b] .dy >> 31）;
               chroma_mv [b] .dx / = 4;
               chroma_mv [b] .dy / = 4;
        
//サブサンプリングされていない座標を渡していることに注意してください

               if（need_mc_border（chroma_mv [b]、
               x +（b＆1）* 8、y +（b >> 1）* 8、16、w、h））
               {{
                   this-> base.need_mc_border = 1;
                   壊す;
               }
           }
        
           戻る; //need_mc_borderチェックをスキップします
       }
       デフォルト：
           assert（0）;
       }
        
       if（need_mc_border（this-> base.mv、x、y、16、w、h））
           this-> base.need_mc_border = 1;
   }
        
   空所
   vp8_dixie_modemv_process_row（struct vp8_decoder_ctx * ctx、
   struct bool_decoder * bool、
   int行、
   int start_col、
   int num_cols）
   {{
       struct mb_info *上記、* this;
       unsigned int col;
       struct mv_clamp_rect bounds;
        
       this = ctx-> mb_info_rows [row] + start_col;
       上記=ctx->mb_info_rows [row-1] + start_col;
        
       / *1MBの境界線を使用して8番目のペルのMV境界を計算します. * /
       bounds.to_left =-（（start_col + 1）<< 7）;
       bounds.to_right =（ctx-> mb_cols --start_col）<< 7;
       bounds.to_top =-（（row + 1）<< 7）;
       bounds.to_bottom =（ctx-> mb_rows --row）<< 7;
        
       for（col = start_col; col <start_col + num_cols; col ++）
       {{
           if（ctx-> segment_hdr.update_map）
               this-> base.segment_id = read_segment_id（bool、
               ＆ctx-> segment_hdr）;
        
           if（ctx-> entropy_hdr.coeff_skip_enabled）
               this-> base.skip_coeff = bool_get（bool、
               ctx-> entropy_hdr.coeff_skip_prob）;
        
           if（ctx-> frame_hdr.is_keyframe）
           {{
               if（！ctx-> segment_hdr.update_map）
                   this-> base.segment_id = 0;
        
               decode_kf_mb_mode（this、this-1、above、bool）;
           }
           そうしないと
           {{
               if（bool_get（bool、ctx-> entropy_hdr.prob_inter））
                   decode_mvs（ctx、this、this-1、above、＆bounds、
                              bool）;
               そうしないと
                   decode_intra_mb_mode（this、＆ctx-> entropy_hdr、bool）;
        
               bounds.to_left-= 16 << 3;
               bounds.to_right-= 16 << 3;
           }
        
           /*次のmbに進みます*/
           this ++;
           上記++;
       }
   }
        
   空所
   vp8_dixie_modemv_init（struct vp8_decoder_ctx * ctx）
   {{
       unsigned int mbi_w、mbi_h、i;
       struct mb_info * mbi;
        
       mbi_w = ctx-> mb_cols + 1; /*左ボーダー列の場合*/
       mbi_h = ctx-> mb_rows + 1; /*境界上の行の場合*/
        
       if（ctx-> frame_hdr.frame_size_updated）
       {{
           free（ctx-> mb_info_storage）;
           ctx-> mb_info_storage = NULL;
           free（ctx-> mb_info_rows_storage）;
           ctx-> mb_info_rows_storage = NULL;
       }
        
       if（！ctx-> mb_info_storage）
           ctx-> mb_info_storage = calloc（mbi_w * mbi_h、
           sizeof（* ctx-> mb_info_storage））;
        
       if（！ctx-> mb_info_rows_storage）
        
           ctx-> mb_info_rows_storage = calloc（mbi_h、
           sizeof（* ctx-> mb_info_rows_storage））;
        
       /*行ポインタを設定します*/
       mbi = ctx-> mb_info_storage + 1;
        
       for（i = 0; i <mbi_h; i ++）
       {{
           ctx-> mb_info_rows_storage [i] = mbi;
           mbi + = mbi_w;
       }
        
       ctx-> mb_info_rows = ctx-> mb_info_rows_storage + 1;
   }
        
   空所
   vp8_dixie_modemv_destroy（struct vp8_decoder_ctx * ctx）
   {{
       free（ctx-> mb_info_storage）;
       ctx-> mb_info_storage = NULL;
       free（ctx-> mb_info_rows_storage）;
       ctx-> mb_info_rows_storage = NULL;
   }
        
   ----終了コードブロック----------------------------------------
        
20.12. modemv.h
   ----コードブロックを開始--------------------------------------
        
   / *
    * Copyright（c）2010、2011、Google Inc.無断複写・転載を禁じます. 
    *
    *このソースコードの使用はBSDスタイルのライセンスによって管理されています
    *ソースのルートにあるLICENSEファイルにあります
    * 木. 追加の知的財産権の付与は
    *ファイルPATENTSにあります. 貢献しているすべてのプロジェクト作成者は
    *ソースツリーのルートにあるAUTHORSファイルにあります. 
    * /
   #ifndef MODEMV_H
   #define MODEMV_H
        
   空所
   vp8_dixie_modemv_init（struct vp8_decoder_ctx * ctx）;
        
   空所
   vp8_dixie_modemv_destroy（struct vp8_decoder_ctx * ctx）;
        
void vp8_dixie_modemv_process_row（struct vp8_decoder_ctx * ctx、struct bool_decoder * bool、int row、int start_col、int num_cols）;

#endif

   ----終了コードブロック----------------------------------------
        
20.13. modemv_data.h
   ----コードブロックを開始--------------------------------------
        
   / *
    * Copyright（c）2010、2011、Google Inc.無断複写・転載を禁じます. 
    *
    *このソースコードの使用はBSDスタイルのライセンスによって管理されています
    *ソースのルートにあるLICENSEファイルにあります
    * 木. 追加の知的財産権の付与は
    *ファイルPATENTSにあります. 貢献しているすべてのプロジェクト作成者は
    *ソースツリーのルートにあるAUTHORSファイルにあります. 
    * /
        
   static const unsigned char kf_y_mode_probs [] = {145、156、163、128};
   static const unsigned char kf_uv_mode_probs [] = {142、114、183};
   static const unsigned char kf_b_mode_probs [10] [10] [9] =
   {{
     {/*モード0より上*/
       {/*左モード0*/ 231、120、48、89、115、113、120、152、112}、
       {/*左モード1*/ 152、179、64、126、170、118、46、70、95}、
       {/*左モード2*/ 175、69、143、80、85、82、72、155、103}、
       {/*左モード3*/ 56、58、10、171、218、189、17、13、152}、
       {/*左モード4*/ 144、71、10、38、171、213、144、34、26}、
       {/*左モード5*/ 114、26、17、163、44、195、21、10、173}、
       {/*左モード6*/ 121、24、80、195、26、62、44、64、85}、
       {/*左モード7*/ 170、46、55、19、136、160、33、206、71}、
       {/*左モード8*/ 63、20、8、114、114、208、12、9、226}、
       {/*左モード9*/ 81、40、11、96、182、84、29、16、36}
     }、
     {/*モード1より上*/
       {/*左モード0*/ 134、183、89、137、98、101、106、165、148}、
       {/*左モード1*/ 72、187、100、130、157、111、32、75、80}、
       {/*左モード2*/ 66、102、167、99、74、62、40、234、128}、
       {/*左モード3*/ 41、53、9、178、241、141、26、8、107}、
       {/*左モード4*/ 104、79、12、27、217、255、87、17、7}、
       {/*左モード5*/ 74、43、26、146、73、166、49、23、157}、
       {/*左モード6*/ 65、38、105、160、51、52、31、115、128}、
       {/*左モード7*/ 87、68、71、44、114、51、15、186、23}、
       {/*左モード8*/ 47、41、14、110、182、183、21、17、194}、
       {/*左モード9*/ 66、45、25、102、197、189、23、18、22}
     }、
     {/*モード2より上*/
       {/*左モード0*/ 88、88、147、150、42、46、45、196、205}、
       {/*左モード1*/ 43、97、183、117、85、38、35、179、61}、
       {/*左モード2*/ 39、53、200、87、26、21、43、232、171}、
       {/*左モード3*/ 56、34、51、104、114、102、29、93、77}、
       {/*左モード4*/ 107、54、32、26、51、1、81、43、31}、
        
       {/*左モード5*/ 39、28、85、171、58、165、90、98、64}、
       {/*左モード6*/ 34、22、116、206、23、34、43、166、73}、
       {/*左モード7*/ 68、25、106、22、64、171、36、225、114}、
       {/*左モード8*/ 34、19、21、102、132、188、16、76、124}、
       {/*左モード9*/ 62、18、78、95、85、57、50、48、51}
     }、
     {/*モード3より上*/
       {/*左モード0*/ 193、101、35、159、215、111、89、46、111}、
       {/*左モード1*/ 60、148、31、172、219、228、21、18、111}、
       {/*左モード2*/ 112、113、77、85、179、255、38、120、114}、
       {/*左モード3*/ 40、42、1、196、245、209、10、25、109}、
       {/*左モード4*/ 100、80、8、43、154、1、51、26、71}、
       {/*左モード5*/ 88、43、29、140、166、213、37、43、154}、
       {/*左モード6*/ 61、63、30、155、67、45、68、1、209}、
       {/*左モード7*/ 142、78、78、16、255、128、34、197、171}、
       {/*左モード8*/ 41、40、5、102、211、183、4、1、221}、
       {/*左モード9*/ 51、50、17、168、209、192、23、25、82}
     }、
     {/*モード4より上*/
       {/*左モード0*/ 125、98、42、88、104、85、117、175、82}、
       {/*左モード1*/ 95、84、53、89、128、100、113、101、45}、
       {/*左モード2*/ 75、79、123、47、51、128、81、171、1}、
       {/*左モード3*/ 57、17、5、71、102、57、53、41、49}、
       {/*左モード4*/ 115、21、2、10、102、255、166、23、6}、
       {/*左モード5*/ 38、33、13、121、57、73、26、1、85}、
       {/*左モード6*/ 41、10、67、138、77、110、90、47、114}、
       {/*左モード7*/ 101、29、16、10、85、128、101、196、26}、
       {/*左モード8*/ 57、18、10、102、102、213、34、20、43}、
       {/*左モード9*/ 117、20、15、36、163、128、68、1、26}
     }、
     {/*モード5より上*/
       {/*左モード0*/ 138、31、36、171、27、166、38、44、229}、
       {/*左モード1*/ 67、87、58、169、82、115、26、59、179}、
       {/*左モード2*/ 63、59、90、180、59、166、93、73、154}、
       {/*左モード3*/ 40、40、21、116、143、209、34、39、175}、
       {/*左モード4*/ 57、46、22、24、128、1、54、17、37}、
       {/*左モード5*/ 47、15、16、183、34、223、49、45、183}、
       {/*左モード6*/ 46、17、33、183、6、98、15、32、183}、
       {/*左モード7*/ 65、32、73、115、28、128、23、128、205}、
       {/*左モード8*/ 40、3、9、115、51、192、18、6、223}、
       {/*左モード9*/ 87、37、9、115、59、77、64、21、47}
     }、
     {/*モード6より上*/
       {/*左モード0*/ 104、55、44、218、9、54、53、130、226}、
       {/*左モード1*/ 64、90、70、205、40、41、23、26、57}、
       {/*左モード2*/ 54、57、112、184、5、41、38、166、213}、
       {/*左モード3*/ 30、34、26、133、152、116、10、32、134}、
       {/*左モード4*/ 75、32、12、51、192、255、160、43、51}、
        
       {/*左モード5*/ 39、19、53、221、26、114、32、73、255}、
       {/*左モード6*/ 31、9、65、234、2、15、1、118、73}、
       {/*左モード7*/ 88、31、35、67、102、85、55、186、85}、
       {/*左モード8*/ 56、21、23、111、59、205、45、37、192}、
       {/*左モード9*/ 55、38、70、124、73、102、1、34、98}
     }、
     {/*モード7より上*/
       {/*左モード0*/ 102、61、71、37、34、53、31、243、192}、
       {/*左モード1*/ 69、60、71、38、73、119、28、222、37}、
       {/*左モード2*/ 68、45、128、34、1、47、11、245、171}、
       {/*左モード3*/ 62、17、19、70、146、85、55、62、70}、
       {/*左モード4*/ 75、15、9、9、64、255、184、119、16}、
       {/*左モード5*/ 37、43、37、154、100、163、85、160、1}、
       {/*左モード6*/ 63、9、92、136、28、64、32、201、85}、
       {/*左モード7*/ 86、6、28、5、64、255、25、248、1}、
       {/*左モード8*/ 56、8、17、132、137、255、55、116、128}、
       {/*左モード9*/ 58、15、20、82、135、57、26、121、40}
     }、
     {/*モード8より上*/
       {/*左モード0*/ 164、50、31、137、154、133、25、35、218}、
       {/*左モード1*/ 51、103、44、131、131、123、31、6、158}、
       {/*左モード2*/ 86、40、64、135、148、224、45、183、128}、
       {/*左モード3*/ 22、26、17、131、240、154、14、1、209}、
       {/*左モード4*/ 83、12、13、54、192、255、68、47、28}、
       {/*左モード5*/ 45、16、21、91、64、222、7、1、197}、
       {/*左モード6*/ 56、21、39、155、60、138、23、102、213}、
       {/*左モード7*/ 85、26、85、85、128、128、32、146、171}、
       {/*左モード8*/ 18、11、7、63、144、171、4、4、246}、
       {/*左モード9*/ 35、27、10、146、174、171、12、26、128}
     }、
     {/*モード9より上*/
       {/*左モード0*/ 190、80、35、99、180、80、126、54、45}、
       {/*左モード1*/ 85、126、47、87、176、51、41、20、32}、
       {/*左モード2*/ 101、75、128、139、118、146、116、128、85}、
       {/*左モード3*/ 56、41、15、176、236、85、37、9、62}、
       {/*左モード4*/ 146、36、19、30、171、255、97、27、20}、
       {/*左モード5*/ 71、30、17、119、118、255、17、18、138}、
       {/*左モード6*/ 101、38、60、138、55、70、43、26、142}、
       {/*左モード7*/ 138、45、61、62、219、1、81、188、64}、
       {/*左モード8*/ 32、41、20、117、151、142、20、21、163}、
       {/*左モード9*/ 112、19、12、61、195、128、48、4、24}
     }
   };
        
   static const int kf_y_mode_tree [] =
   {{
     -B_PRED、2、
     4、6、
     -DC_PRED、-V_PRED、
     -H_PRED、-TM_PRED
   };
   static const int y_mode_tree [] =
   {{
     -DC_PRED、2、
     4、6、
     -V_PRED、-H_PRED、
     -TM_PRED、-B_PRED
   };
   static const int uv_mode_tree [6] =
   {{
     -DC_PRED、2、
     -V_PRED、4、
     -H_PRED、-TM_PRED
   };
   static const int b_mode_tree [18] =
   {{
     -B_DC_PRED、2、/ * 0 = DC_NODE * /
     -B_TM_PRED、4、/ * 1 = TM_NODE * /
     -B_VE_PRED、6、/ * 2 = VE_NODE * /
     8、12、/ * 3 = COM_NODE * /
     -B_HE_PRED、10、/ * 4 = HE_NODE * /
     -B_RD_PRED、-B_VR_PRED、/ * 5 = RD_NODE * /
     -B_LD_PRED、14、/ * 6 = LD_NODE * /
     -B_VL_PRED、16、/ * 7 = VL_NODE * /
     -B_HD_PRED、-B_HU_PRED / * 8 = HD_NODE * /
   };
   static const int small_mv_tree [14] =
   {{
     2、8、
     4、6、
     -0、-1
     -2、-3、
     10、12、
     -4、-5、
     -6、-7
   };
        
   static const int mv_ref_tree [8] =
   {{
     -ZEROMV、2、
     -NEARESTMV、4、
     -NEARMV、6、
     -NEWMV、-SPLITMV
   };
   static const int submv_ref_tree [6] =
   {{
     -LEFT4X4、2、
     -ABOVE4X4、4、
     -ZERO4X4、-NEW4X4
   };
   static const int split_mv_tree [6] =
   {{
     -3、2、
     -2、4、
     -0、-1
   };
   static const unsigned char default_b_mode_probs [] =
   {120、90、79、133、87、85、80、111、151};
   static const unsigned char mv_counts_to_probs [6] [4] =
   {{
     {7、1、1、143}、
     {14、18、14、107}、
     {135、64、57、68}、
     {60、56、128、65}、
     {159、134、128、34}、
     {234、188、128、28}
        
   };
   static const unsigned char split_mv_probs [3] =
   {110、111、150};
        
   static const unsigned char submv_ref_probs2 [5] [3] =
   {{
     {147、136、18}、
     {106、145、1}、
     {179、121、1}、
     {223、1、34}、
     {208、1、1}
   };
        
   const static int mv_partitions [4] [16] =
   {{
     {0、0、0、0、0、0、0、0、1、1、1、1、1、1、1、1}、
     {0、0、1、1、0、0、1、1、0、0、1、1、0、0、1、1}、
     {0、0、1、1、0、0、1、1、2、2、3、3、2、2、3、3}、
     {0、1、2、3、4、5、6、7、8、9、10、11、12、13、14、15}
   };
        
   ----終了コードブロック----------------------------------------
        
20.14. 予測.c
   ----コードブロックを開始--------------------------------------
        
   / *
    * Copyright（c）2010、2011、Google Inc.無断複写・転載を禁じます. 
    *
    *このソースコードの使用はBSDスタイルのライセンスによって管理されています
    *ソースのルートにあるLICENSEファイルにあります
    * 木. 追加の知的財産権の付与は
    *ファイルPATENTSにあります. 貢献しているすべてのプロジェクト作成者は
    *ソースツリーのルートにあるAUTHORSファイルにあります. 
    * /
   #include "dixie.h"
   #include "predict.h"
   #include "idct_add.h"
   #include "mem.h"
   #include <assert.h>
   #include <string.h>
        
   列挙型
   {{
       BORDER_PIXELS = 16、
   };
        
   static const filter_t sixtap_filters [8] =
   {{
       {0、0、128、0、0、0}、
       {0、-6、123、12、-1、0}、
       {2、-11、108、36、-8、1}、
       {0、-9、93、50、-6、0}、
       {3、-16、77、77、-16、3}、
       {0、-6、50、93、-9、0}、
       {1、-8、36、108、-11、2}、
       {0、-1、12、123、-6、0}
   };
        
   static const filter_t bilinear_filters [8] =
   {{
       {0、0、128、0、0、0}、
       {0、0、112、16、0、0}、
       {0、0、96、32、0、0}、
       {0、0、80、48、0、0}、
       {0、0、64、64、0、0}、
       {0、0、48、80、0、0}、
       {0、0、32、96、0、0}、
       {0、0、16、112、0、0}
   };
        
   静的ボイド
   prefix_h_nxn（unsigned char * predict、
                 intストライド、
                 int n）
   {{
       unsigned char *left=予測-1;
       int i、j;
        
       for（i = 0; i <n; i ++）
           for（j = 0; j <n; j ++）
               予測[i*ストライド+j]=左[i*ストライド];
   }
        
   静的ボイド
   prefix_v_nxn（unsigned char * predict、
                 intストライド、
                 int n）
   {{
       unsigned char * above=predict-ストライド;
       int i、j;
        
       for（i = 0; i <n; i ++）
           for（j = 0; j <n; j ++）
               予測[i*ストライド+j]=上記[j];
   }
        
   静的ボイド
   prefix_tm_nxn（unsigned char * predict、
                  intストライド、
                  int n）
   {{
       /*後で使用するために左側の列を一番上の行に置き換えます
        * idct/reconステージによる消費
        * /
       unsigned char *left=予測-1;
       unsigned char * above=predict-ストライド;
       unsigned char p = above [-1];
       int i、j;
        
       for（j = 0; j <n; j ++）
       {{
           for（i = 0; i <n; i ++）
               予測[i]=CLAMP_255（*左+上[i]-p）;
        
           +=ストライドを予測します. 
           左+=ストライド;
       }
   }
        
   静的ボイド
   prefix_dc_nxn（unsigned char * predict、
                  intストライド、
                  int n）
   {{
       unsigned char *left=予測-1;
       unsigned char * above=predict-ストライド;
       int i、j、dc = 0;
        
       for（i = 0; i <n; i ++）
       {{
           dc +=*左+上[i];
           左+=ストライド;
       }
        
       スイッチ（n）
       {{
       ケース16：
           dc =（dc + 16）>> 5;
           壊す;
       ケース8：
           dc =（dc + 8）>> 4;
           壊す;
       ケース4：
           dc =（dc + 4）>> 3;
           壊す;
       }
        
       for（i = 0; i <n; i ++）
           for（j = 0; j <n; j ++）
               予測[i*ストライド+j]= dc;
   }
        
   静的ボイド
   prefix_ve_4x4（unsigned char * predict、
                  intストライド）
   {{
       unsigned char * above=predict-ストライド;
       int i、j;
        
       予測[0]=（上[-1] +2*上[0]+上[1]+2）>> 2;
       予測[1]=（上[0] +2*上[1]+上[2]+2）>> 2;
       予測[2]=（上[1] +2*上[2]+上[3]+2）>> 2;
       予測[3]=（上[2] +2*上[3]+上[4]+2）>> 2;
        
       for（i = 1; i <4; i ++）
           for（j = 0; j <4; j ++）
               予測[i*ストライド+j]=予測[j];
   }
        
   静的ボイド
   prefix_he_4x4（unsigned char * predict、
                  intストライド）
   {{
       unsigned char *left=予測-1;
        
       予測[0]=
       予測[1]=
       予測[2]=
       予測[3]=（左[-ストライド] +2*左[0]+
                     left[ストライド]+2）>> 2;
       +=ストライドを予測します. 
       左+=ストライド;
        
       予測[0]=
       予測[1]=
       予測[2]=
       予測[3]=（左[-ストライド] +2*左[0]+
                     left[ストライド]+2）>> 2;
       +=ストライドを予測します. 
       左+=ストライド;
        
       予測[0]=
       予測[1]=
       予測[2]=
       予測[3]=（左[-ストライド] +2*左[0]+
                     left[ストライド]+2）>> 2;
       +=ストライドを予測します. 
       左+=ストライド;
        
       予測[0]=
       予測[1]=
       予測[2]=
       予測[3]=（左[-ストライド] +2*左[0]+左[0]+2）>> 2;
   }
        
   静的ボイド
   prefix_ld_4x4（unsigned char * predict、
                  intストライド）
   {{
       unsigned char * above=predict-ストライド;
       int pred0、pred1、pred2、pred3、pred4、pred5、pred6;
        
       予測[0]=pred0 =（above [0] + 2 * above [1] +
                             上記[2]+2）>> 2;
       予測[1]=pred1 =（上[1] +2*上[2]+
                             上記[3]+2）>> 2;
       予測[2]=pred2 =（上[2] +2*上[3]+
                             上記[4]+2）>> 2;
       予測[3]=pred3 =（上[3] +2*上[4]+
                             上記[5]+2）>> 2;
       +=ストライドを予測します. 
        
       予測[0]=pred1;
       予測[1]=pred2;
       予測[2]=pred3;
       予測[3]=pred4 =（上[4] +2*上[5]+
                             上記[6]+2）>> 2;
       +=ストライドを予測します. 
        
       予測[0]=pred2;
       予測[1]=pred3;
       予測[2]=pred4;
       予測[3]=pred5 =（上[5] +2*上[6]+
                             上記[7]+2）>> 2;
       +=ストライドを予測します. 
        
       予測[0]=pred3;
       予測[1]=pred4;
       予測[2]=pred5;
       予測[3]=pred6 =（上[6] +2*上[7]+
                             上記[7]+2）>> 2;
   }
        
   静的ボイド
   prefix_rd_4x4（unsigned char * predict、
                  intストライド）
   {{
       unsigned char *left=予測-1;
       unsigned char * above=predict-ストライド;
       int pred0、pred1、pred2、pred3、pred4、pred5、pred6;
        
       予測[0]=pred0 =
           （左[0] +2*上[-1]+上[0]+2）>> 2;
       予測[1]=pred1 =
           （above [-1] + 2 * above [0] + above [1] + 2）>> 2;
       予測[2]=pred2 =
           （above [0] + 2 * above [1] + above [2] + 2）>> 2;
       予測[3]=pred3 =
           （上[1] +2*上[2]+上[3]+2）>> 2;
       +=ストライドを予測します. 
        
       予測[0]=pred4 =
           （左[ストライド] +2*左[0]+上[-1]+2）>> 2;
       予測[1]=pred0;
       予測[2]=pred1;
       予測[3]=pred2;
       +=ストライドを予測します. 
        
       予測[0]=pred5 =
           （左[ストライド* 2] +2*左[ストライド]+左[0]+2）>> 2;
       予測[1]=pred4;
       予測[2]=pred0;
       予測[3]=pred1;
       +=ストライドを予測します. 
        
       予測[0]=pred6 =（左[ストライド* 3] +2*左[ストライド*2]+
                             left[ストライド]+2）>> 2;
       予測[1]=pred5;
       予測[2]=pred4;
       予測[3]=pred0;
   }
        
   静的ボイド
   prefix_vr_4x4（unsigned char * predict、
                  intストライド）
   {{
       unsigned char *left=予測-1;
       unsigned char * above=predict-ストライド;
       int pred0、pred1、pred2、pred3、pred4、pred5、pred6、
                      pred7、pred8、pred9;
        
       予測[0]=pred0 =（上[-1]+上[0]+ 1）>> 1;
       予測[1]=pred1 =（above [0] + above [1] + 1）>> 1;
       予測[2]=pred2 =（上[1]+上[2]+ 1）>> 1;
       予測[3]=pred3 =（上[2]+上[3]+ 1）>> 1;
       +=ストライドを予測します. 
        
       予測[0]=pred4 =（左[0] +2*上[-1]+
                             上記[0]+2）>> 2;
       予測[1]=pred5 =（上[-1] +2*上[0]+
                             上記[1]+2）>> 2;
       予測[2]=pred6 =（上[0] +2*上[1]+
                             上記[2]+2）>> 2;
       予測[3]=pred7 =（上[1] +2*上[2]+
                             上記[3]+2）>> 2;
       +=ストライドを予測します. 
        
       予測[0]=pred8 =
           （左[ストライド] +2*左[0]+上[-1]+2）>> 2;
       予測[1]=pred0;
       予測[2]=pred1;
       予測[3]=pred2;
       +=ストライドを予測します. 
        
       予測[0]=pred9 =
           （左[ストライド* 2] +2*左[ストライド]+左[0]+2）>> 2;
       予測[1]=pred4;
       予測[2]=pred5;
       予測[3]=pred6;
   }
        
   静的ボイド
   prefix_vl_4x4（unsigned char * predict、
                  intストライド）
   {{
       unsigned char * above=predict-ストライド;
       int pred0、pred1、pred2、pred3、pred4、pred5、pred6、
                      pred7、pred8、pred9;
        
       予測[0]=pred0 =（above [0] + above [1] + 1）>> 1;
       予測[1]=pred1 =（上[1]+上[2]+ 1）>> 1;
       予測[2]=pred2 =（上[2]+上[3]+ 1）>> 1;
       予測[3]=pred3 =（上[3]+上[4]+ 1）>> 1;
       +=ストライドを予測します. 
        
       予測[0]=pred4 =（上[0] +2*上[1]+
                             上記[2]+2）>> 2;
       予測[1]=pred5 =（上[1] +2*上[2]+
                             上記[3]+2）>> 2;
       予測[2]=pred6 =（上[2] +2*上[3]+
                             上記[4]+2）>> 2;
       予測[3]=pred7 =（上[3] +2*上[4]+
                             上記[5]+2）>> 2;
       +=ストライドを予測します. 
        
       予測[0]=pred1;
       予測[1]=pred2;
       予測[2]=pred3;
       予測[3]=pred8 =（上[4] +2*上[5]+
                             上記[6]+2）>> 2;
       +=ストライドを予測します. 
        
       予測[0]=pred5;
       予測[1]=pred6;
       予測[2]=pred7;
       予測[3]=pred9 =（上[5] +2*上[6]+
                             上記[7]+2）>> 2;
   }
        
   静的ボイド
   prefix_hd_4x4（unsigned char * predict、
                  intストライド）
   {{
       unsigned char *left=予測-1;
       unsigned char * above=predict-ストライド;
       int pred0、pred1、pred2、pred3、pred4、pred5、pred6、
                      pred7、pred8、pred9;
        
       予測[0]=pred0 =（左[0]+上[-1]+ 1）>> 1;
       予測[1]=pred1 =（左[0] +2*上[-1]+
                             上記[0]+2）>> 2;
       予測[2]=pred2 =（上[-1] +2*上[0]+
                             上記[1]+2）>> 2;
       予測[3]=pred3 =（上[0] +2*上[1]+
                             上記[2]+2）>> 2;
       +=ストライドを予測します. 
        
       予測[0]=pred4 =（左[ストライド]+左[0]+ 1）>> 1;
       予測[1]=pred5 =（左[ストライド] +2*左[0]+
                             上記[-1]+2）>> 2;
       予測[2]=pred0;
       予測[3]=pred1;
       +=ストライドを予測します. 
        
       予測[0]=pred6 =（左[ストライド*2]+左[ストライド]+1）>> 1;
       予測[1]=pred7 =（左[ストライド* 2] +2*左[ストライド]+
                             left [0] + 2）>> 2;
       予測[2]=pred4;
       予測[3]=pred5;
       +=ストライドを予測します. 
        
       予測[0]=pred8 =（左[ストライド*3]+左[ストライド*2]+ 1）>> 1;
       予測[1]=pred9 =（左[ストライド* 3] +2*左[ストライド*2]+
                             left[ストライド]+2）>> 2;
       予測[2]=pred6;
       予測[3]=pred7;
   }
        
   静的ボイド
   prefix_hu_4x4（unsigned char * predict、
                  intストライド）
   {{
       unsigned char *left=予測-1;
       int pred0、pred1、pred2、pred3、pred4、pred5、pred6;
        
       予測[0]=pred0 =（左[ストライド* 0] +
                             left [stride * 1] + 1）>> 1;
       予測[1]=pred1 =（左[ストライド* 0] +2*左[ストライド*1]+
                             left [stride * 2] + 2）>> 2;
       予測[2]=pred2 =（左[ストライド*1]+左[ストライド*2]+ 1）>> 1;
       予測[3]=pred3 =（左[ストライド* 1] +2*左[ストライド*2]+
                             left [stride * 3] + 2）>> 2;
       +=ストライドを予測します. 
        
       予測[0]=pred2;
       予測[1]=pred3;
       予測[2]=pred4 =（左[ストライド*2]+左[ストライド*3]+ 1）>> 1;
       予測[3]=pred5 =（左[ストライド* 2] +2*左[ストライド*3]+
                             left [stride * 3] + 2）>> 2;
       +=ストライドを予測します. 
        
       予測[0]=pred4;
       予測[1]=pred5;
       予測[2]=pred6=左[ストライド*3];
       予測[3]=pred6;
       +=ストライドを予測します. 
        
       予測[0]=pred6;
       予測[1]=pred6;
       予測[2]=pred6;
       予測[3]=pred6;
   }
        
   静的ボイド
   prefix_h_16x16（unsigned char * predict、int stride）
   {{
       予測_h_nxn（予測、ストライド、16）;
   }
        
   静的ボイド
   prefix_v_16x16（unsigned char * predict、int stride）
   {{
       予測_v_nxn（予測、ストライド、16）;
   }
        
   静的ボイド
   prefix_tm_16x16（unsigned char * predict、int stride）
   {{
       予測_tm_nxn（予測、ストライド、16）;
   }
        
   静的ボイド
   prefix_h_8x8（unsigned char * predict、int stride）
   {{
       予測_h_nxn（予測、ストライド、8）;
   }
        
   静的ボイド
   prefix_v_8x8（unsigned char * predict、int stride）
   {{
       予測_v_nxn（予測、ストライド、8）;
   }
        
   静的ボイド
   prefix_tm_8x8（unsigned char * predict、int stride）
   {{
       予測_tm_nxn（予測、ストライド、8）;
   }
        
   静的ボイド
   prefix_tm_4x4（unsigned char * predict、int stride）
   {{
       予測_tm_nxn（予測、ストライド、4）;
   }
        
   静的ボイド
   copy_down（unsigned char * recon、
             intストライド）
   {{
       /*サブブロック3の右上の4つのピクセルをにコピーします
        *サブブロック7、11、および15の右上
        * /
       uint32_t tmp、* copy =（void *）（recon + 16-ストライド）;
        
       stride = stride / sizeof（unsigned int）;
       tmp=*コピー;
       コピー+=ストライド*4;
       * copy = tmp;
       コピー+=ストライド*4;
       * copy = tmp;
       コピー+=ストライド*4;
       * copy = tmp;
   }
        
   静的ボイド
   b_pred（unsigned char * predict、
          intストライド、
          struct mb_info * mbi、
          短い*係数）
   {{
       int i;
        
       copy_down（predict、stride）;
        
       for（i = 0; i <16; i ++）
       {{
           unsigned char * b_predict = Forecast +（i＆3）* 4;
        
           スイッチ（mbi-> split.modes [i]）
           {{
           ケースB_DC_PRED：
               予測_dc_nxn（b_predict、ストライド、4）;
               壊す;
           ケースB_TM_PRED：
               予測_tm_4x4（b_predict、ストライド）;
               壊す;
           ケースB_VE_PRED：
               予測_ve_4x4（b_predict、ストライド）;
               壊す;
           ケースB_HE_PRED：
               予測_he_4x4（b_predict、ストライド）;
               壊す;
           ケースB_LD_PRED：
               予測_ld_4x4（b_predict、ストライド）;
               壊す;
           ケースB_RD_PRED：
               予測_rd_4x4（b_predict、ストライド）;
               壊す;
           ケースB_VR_PRED：
               予測_vr_4x4（b_predict、ストライド）;
               壊す;
        
           ケースB_VL_PRED：
               予測_vl_4x4（b_predict、ストライド）;
               壊す;
           ケースB_HD_PRED：
               予測_hd_4x4（b_predict、ストライド）;
               壊す;
           ケースB_HU_PRED：
               予測_hu_4x4（b_predict、ストライド）;
               壊す;
           デフォルト：
               assert（0）;
           }
        
           vp8_dixie_idct_add（b_predict、b_predict、stride、coeffs）;
           係数+=16;
        
           if（（i＆3）== 3）
           {{
               予測+=ストライド*4;
           }
       }
   }
        
静的ボイド

   fixup_dc_coeffs（struct mb_info * mbi、
                   短い*係数）
   {{
       短いy2[16];
       int i;
        
       vp8_dixie_walsh（coeffs + 24 * 16、y2）;
        
       for（i = 0; i <16; i ++）
           coeffs [i * 16] = y2 [i];
   }
        
   静的ボイド
   prefix_intra_luma（unsigned char * predict、
                      intストライド、
                      struct mb_info * mbi、
                      短い*係数）
   {{
       if（mbi-> base.y_mode == B_PRED）
           b_pred（predict、stride、mbi、coeffs）;
       そうしないと
        
       {{
           int i;
        
           スイッチ（mbi-> base.y_mode）
           {{
           ケースDC_PRED：
               予測_dc_nxn（予測、ストライド、16）;
               壊す;
           ケースV_PRED：
               予測_v_16x16（予測、ストライド）;
               壊す;
           ケースH_PRED：
               予測_h_16x16（予測、ストライド）;
               壊す;
           ケースTM_PRED：
               予測_tm_16x16（予測、ストライド）;
               壊す;
           デフォルト：
               assert（0）;
           }
        
           fixup_dc_coeffs（mbi、coeffs）;
        
           for（i = 0; i <16; i ++）
           {{
               vp8_dixie_idct_add（predict、predict、stride、coeffs）;
               係数+=16;
               予測+=4;
        
               if（（i＆3）== 3）
                   予測+=ストライド*4-16;
           }
       }
   }
        
   静的ボイド
   prefix_intra_chroma（unsigned char * prefix_u、
                        unsigned char * predict_v、
                        intストライド、
                        struct mb_info * mbi、
                        短い*係数）
   {{
       int i;
        
       スイッチ（mbi-> base.uv_mode）
       {{
       ケースDC_PRED：
           予測_dc_nxn（予測_u、ストライド、8）;
           予測_dc_nxn（予測_v、ストライド、8）;
           壊す;
       ケースV_PRED：
           予測_v_8x8（予測_u、ストライド）;
           予測_v_8x8（予測_v、ストライド）;
           壊す;
       ケースH_PRED：
           予測_h_8x8（予測_u、ストライド）;
           予測_h_8x8（予測_v、ストライド）;
           壊す;
       ケースTM_PRED：
           予測_tm_8x8（予測_u、ストライド）;
           予測_tm_8x8（予測_v、ストライド）;
           壊す;
       デフォルト：
           assert（0）;
       }
        
       係数+=16 * 16;
        
       for（i = 16; i <20; i ++）
       {{
           vp8_dixie_idct_add（predict_u、predict_u、stride、coeffs）;
           係数+=16;
           予測_u+= 4;
        
           if（i＆1）
               予測_u+=ストライド*4-8;
       }
        
       for（i = 20; i <24; i ++）
       {{
           vp8_dixie_idct_add（predict_v、predict_v、stride、coeffs）;
           係数+=16;
           Forecast_v + = 4;
        
           if（i＆1）
               Forecast_v+=ストライド*4-8;
       }
   }
        
   静的ボイド
   sixtap_horiz（unsigned char * output、
                int output_stride、
                const unsigned char * reference、
                int reference_stride、
                int cols、
                int行、
                const filter_t filter
               ）. 
   {{
       int r、c、temp;
        
       for（r = 0;r<行;r++）
       {{
           for（c = 0; c <cols; c ++）
           {{
               temp =（reference [-2] * filter [0]）+
                      （参照[-1] *フィルター[1]）+
                      （参照[0] *フィルター[2]）+
                      （参照[1] *フィルター[3]）+
                      （参照[2] *フィルター[4]）+
                      （参照[3] *フィルター[5]）+
                      64;
               temp >> = 7;
               output [c] = CLAMP_255（temp）;
               参照++;
           }
        
           参照+=reference_stride-列;
           出力+=output_stride;
       }
   }
        
   静的ボイド
   sixtap_vert（unsigned char * output、
               int output_stride、
               const unsigned char * reference、
               int reference_stride、
               int cols、
               int行、
               const filter_t filter
              ）. 
   {{
       int r、c、temp;
        
       for（r = 0;r<行;r++）
       {{
        
           for（c = 0; c <cols; c ++）
           {{
               temp =（reference [-2 * reference_stride] * filter [0]）+
                      （reference [-1 * reference_stride] * filter [1]）+
                      （reference [0 * reference_stride] * filter [2]）+
                      （reference [1 * reference_stride] * filter [3]）+
                      （reference [2 * reference_stride] * filter [4]）+
                      （reference [3 * reference_stride] * filter [5]）+
                      64;
               temp >> = 7;
               output [c] = CLAMP_255（temp）;
               参照++;
           }
        
           参照+=reference_stride-列;
           出力+=output_stride;
       }
   }
        
   静的ボイド
   sixtap_2d（unsigned char * output、
             int output_stride、
             const unsigned char * reference、
             int reference_stride、
             int cols、
             int行、
             int mx、
             int my、
             const filter_tfilters [8]
            ）. 
   {{
       DECLARE_ALIGNED（16、unsigned char、temp [16 *（16 + 5）]）;
        
       sixtap_horiz（temp、16、
                    参照-2*reference_stride、reference_stride、
                    cols、rows + 5、filters [mx]）;
       sixtap_vert（output、output_stride、
                   温度+2* 16、16、
                   cols、rows、filters [my]）;
   }
        
   struct img_index
   {{
       unsigned char * y、* u、* v;
       int stride、uv_stride;
   };
        
   static const unsigned char *
   filter_block（unsigned char * output、
                const unsigned char * reference、
                intストライド、
                const union mv * mv、
                const filter_tfilters [8]）
   {{
       int mx、my;
        
       /*特殊なケースとして0,0を処理します. TODO：これは何かになりますか
        * もっと早く？
        * /
       if（！mv-> raw）
           参照を返します. 
        
       mx = mv-> dx＆7;
       my = mv-> dy＆7;
       参照+=（（mv-> dy >> 3）*ストライド）+（mv-> dx >> 3）;
        
       if（mx | my）
       {{
           sixtap_2d（出力、ストライド、リファレンス、ストライド、4、4、mx、my、
                     フィルタ）;
           参照=出力;
       }
        
       参照を返します. 
   }
        
   静的ボイド
   recon_1_block（unsigned char * output、
                 const unsigned char * reference、
                 intストライド、
                 const union mv * mv、
                 const filter_t filter [8]、
                 短い*係数、
                 struct mb_info * mbi、
                 int b
                ）. 
   {{
       const unsigned char * predict;
        
       予測=filter_block（出力、参照、ストライド、mv、フィルター）;
       vp8_dixie_idct_add（output、predict、stride、coeffs + 16 * b）;
   }
        
   静的mv_t
   calculate_chroma_splitmv（struct mb_info * mbi、
                            int b、
                            int full_pixel）
   {{
       int temp;
       ユニオンmvmv;
        
       temp = mbi-> split.mvs [b] .dx +
              mbi-> split.mvs [b + 1] .dx +
              mbi-> split.mvs [b + 4] .dx +
              mbi-> split.mvs [b + 5] .dx;
        
       if（temp <0）
           temp-= 4;
       そうしないと
           temp + = 4;
        
       mv.dx = temp / 8;
        
       temp = mbi-> split.mvs [b] .dy +
              mbi-> split.mvs [b + 1] .dy +
              mbi-> split.mvs [b + 4] .dy +
              mbi-> split.mvs [b + 5] .dy;
        
       if（temp <0）
           temp-= 4;
       そうしないと
           temp + = 4;
        
       mv.dy = temp / 8;
        
       if（full_pixel）
       {{
           mv.dx＆=〜7;
           mv.dy＆=〜7;
       }
        
       mvを返します. 
   }
        
   / *注：同じストライドを持つ再構築された境界線に依存しています
    * filter_blockは調整できないため、参照バッファーとして
    *戻り値、参照ポインタのみでストライドします. 
    * /
   静的ボイド
   build_mc_border（unsigned char * dst、
                   const unsigned char * src、
                   intストライド、
                   int x、
                   int y、
                   int b_w、
                   int b_h、
                   int w、
                   inth
                  ）. 
   {{
       const unsigned char * ref_row;
        
       /*この行の実際のデータの先頭へのポインタを取得します*/
       ref_row = src --x--y*ストライド;
        
       if（y> = h）
           ref_row + =（h --1）*ストライド;
       else if（y> 0）
           ref_row + =y*ストライド;
        
       行う
       {{
           int左、右= 0、コピー;
        
           左=x<0？-x：0;
        
           if（左> b_w）
               左=b_w;
        
           if（x + b_w> w）
               右=x+ b_w --w;
        
           if（right> b_w）
               右=b_w;
        
           コピー=b_w-左-右;
        
           if（左）
               memset（dst、ref_row [0]、左）;
        
           if（コピー）
               memcpy（dst +左、ref_row + x +左、コピー）;
        
           if（右）
               memset（dst +左+コピー、ref_row [w-1]、右）;
        
           dst+=ストライド;
           y ++;
        
           if（y <h && y> 0）
               ref_row+=ストライド;
       }
       while（--b_h）;
   }
        
   静的ボイド
   recon_1_edge_block（unsigned char * output、
                      unsigned char * emul_block、
                      const unsigned char * reference、
                      intストライド、
                      const union mv * mv、
                      const filter_t filter [8]、
                      短い*係数、
                      struct mb_info * mbi、
                      int x、
                      int y、
                      int w、
                      int h、
                      int start_b
                     ）. 
   {{
       const unsigned char * predict;
       int b = start_b;
       const int b_w = 4;
       const int b_h = 4;
        
       x + = mv-> dx >> 3;
       y + = mv-> dy >> 3;
        
       / * 6タップの場合、左/上に2ピクセル、右/下に3ピクセル必要です* /
       if（x <2 || x + b_w --1 + 3> = w || y <2 ||
           y + b_h-1 + 3> = h）
       {{
           参照+=（mv-> dx >> 3）+（mv-> dy >> 3）*ストライド;
           build_mc_border（emul_block、
                           参照-2-2*ストライド、ストライド、
                           x-2、y-2、b_w + 5、b_h + 5、w、h）;
           参照=emul_block+2*ストライド+2;
           参照-=（mv-> dx >> 3）+（mv-> dy >> 3）*ストライド;
       }
        
       予測=filter_block（出力、参照、ストライド、mv、フィルター）;
       vp8_dixie_idct_add（output、predict、stride、coeffs + 16 * b）;
   }
        
   静的ボイド
   Forecast_inter_emulated_edge（struct vp8_decoder_ctx * ctx、
                               struct img_index * img、
                               短い*係数、
                               struct mb_info * mbi、
                               int mb_col、
                               int mb_row）
   {{
       / * TODO：これを独自のバッファーに移動します. これが機能するのは
        *まだ境界線が割り当てられています. 
        * /
       unsigned char * emul_block = ctx-> frame_strg [0] .img.img_data;
       unsigned char * reference;
       unsigned char * output;
       ptrdiff_t reference_offset;
       int w、h、x、y、b;
       ユニオンmvchroma_mv[4];
       unsigned char * u = img-> u、* v = img-> v;
       int full_pixel = ctx-> frame_hdr.version == 3;
        
       x = mb_col * 16;
       y = mb_row * 16;
       w = ctx-> mb_cols * 16;
       h = ctx-> mb_rows * 16;
        
       出力=img->y;
       reference_offset = ctx-> ref_frame_offsets [mbi-> base.ref_frame];
       参照=出力+reference_offset;
        
       if（mbi-> base.y_mode！= SPLITMV）
       {{
           ユニオンmvuvmv;
        
           uvmv = mbi-> base.mv;
           uvmv.dx =（uvmv.dx + 1 +（uvmv.dx >> 31）* 2）/ 2;
           uvmv.dy =（uvmv.dy + 1 +（uvmv.dy >> 31）* 2）/ 2;
        
           if（full_pixel）
           {{
               uvmv.dx＆=〜7;
               uvmv.dy＆=〜7;
           }
        
           chroma_mv [0] = uvmv;
           chroma_mv [1] = uvmv;
           chroma_mv [2] = uvmv;
           chroma_mv [3] = uvmv;
       }
       そうしないと
       {{
           chroma_mv [0] =calculate_chroma_splitmv（mbi、0、full_pixel）;
           chroma_mv [1] =calculate_chroma_splitmv（mbi、2、full_pixel）;
           chroma_mv [2] =calculate_chroma_splitmv（mbi、8、full_pixel）;
           chroma_mv [3] =calculate_chroma_splitmv（mbi、10、full_pixel）;
       }
        
       /*ルマ*/
       for（b = 0; b <16; b ++）
       {{
           ユニオンmv*ymv;
        
           if（mbi-> base.y_mode！= SPLITMV）
               ymv =＆mbi-> base.mv;
           そうしないと
               ymv = mbi-> split.mvs + b;
        
           recon_1_edge_block（output、emul_block、reference、
               img-> stride、ymv、ctx-> subpixel_filters、coeffs、
               mbi、x、y、w、h、b）;
        
           x + = 4;
           出力+=4;
           参照+=4;
        
           if（（b＆3）== 3）
           {{
               x-= 16;
               y + = 4;
               出力+=4 * img-> stride-16;
               参照+=4 * img-> stride-16;
           }
       }
        
       x = mb_col * 16;
       y = mb_row * 16;
        
       /*クロマ*/
       x >> = 1;
       y >> = 1;
       w >> = 1;
       h >> = 1;
        
       for（b = 0; b <4; b ++）
       {{
           recon_1_edge_block（u、emul_block、u + reference_offset、
                              img-> uv_stride、
                              ＆chroma_mv [b]、ctx-> subpixel_filters、
                              coeffs、mbi、x、y、w、h、b + 16）;
           recon_1_edge_block（v、emul_block、v + reference_offset、
                              img-> uv_stride、
                              ＆chroma_mv [b]、ctx-> subpixel_filters、
                              coeffs、mbi、x、y、w、h、b + 20）;
           u + = 4;
           v + = 4;
           x + = 4;
        
           if（b＆1）
           {{
               x-= 8;
               y + = 4;
               u + = 4 * img-> uv_stride-8;
               v + = 4 * img-> uv_stride-8;
           }
       }
        
}

static voidpredict_inter（struct vp8_decoder_ctx * ctx、struct img_index * img、short * coeffs、struct mb_info * mbi）

   {{
       unsigned char * y = img-> y;
       unsigned char * u = img-> u;
       unsigned char * v = img-> v;
       ptrdiff_t reference_offset;
       ユニオンmvchroma_mv[4];
       int full_pixel = ctx-> frame_hdr.version == 3;
       int b;
        
       if（mbi-> base.y_mode！= SPLITMV）
       {{
           ユニオンmvuvmv;
        
           uvmv = mbi-> base.mv;
           uvmv.dx =（uvmv.dx + 1 +（uvmv.dx >> 31）* 2）/ 2;
           uvmv.dy =（uvmv.dy + 1 +（uvmv.dy >> 31）* 2）/ 2;
        
           if（full_pixel）
           {{
               uvmv.dx＆=〜7;
               uvmv.dy＆=〜7;
           }
        
           chroma_mv [0] =
               chroma_mv [1] =
                   chroma_mv [2] =
                       chroma_mv [3] = uvmv;
       }
       そうしないと
       {{
           chroma_mv [0] =calculate_chroma_splitmv（mbi、0、full_pixel）;
           chroma_mv [1] =calculate_chroma_splitmv（mbi、2、full_pixel）;
           chroma_mv [2] =calculate_chroma_splitmv（mbi、8、full_pixel）;
           chroma_mv [3] =calculate_chroma_splitmv（mbi、10、full_pixel）;
       }
        
       reference_offset = ctx-> ref_frame_offsets [mbi-> base.ref_frame];
        
       for（b = 0; b <16; b ++）
       {{
           ユニオンmv*ymv;
        
           if（mbi-> base.y_mode！= SPLITMV）
               ymv =＆mbi-> base.mv;
           そうしないと
               ymv = mbi-> split.mvs + b;
           recon_1_block（y、y + reference_offset、img-> stride、
                         ymv、ctx-> subpixel_filters、coeffs、mbi、b）;
        
           y + = 4;
        
           if（（b＆3）== 3）
               y + = 4 * img-> stride-16;
       }
        
       for（b = 0; b <4; b ++）
       {{
           recon_1_block（u、u + reference_offset、
                         img-> uv_stride、＆chroma_mv [b]、
                         ctx-> subpixel_filters、coeffs、mbi、b + 16）;
           recon_1_block（v、v + reference_offset、
                         img-> uv_stride、＆chroma_mv [b]、
                         ctx-> subpixel_filters、coeffs、mbi、b + 20）;
           u + = 4;
           v + = 4;
        
           if（b＆1）
           {{
               u + = 4 * img-> uv_stride-8;
               v + = 4 * img-> uv_stride-8;
           }
       }
   }
        
   空所
   vp8_dixie_release_ref_frame（struct ref_cnt_img * rcimg）
   {{
       if（rcimg）
       {{
           assert（rcimg-> ref_cnt）;
           rcimg-> ref_cnt--;
       }
   }
        
   struct ref_cnt_img *
   vp8_dixie_ref_frame（struct ref_cnt_img * rcimg）
   {{
       rcimg-> ref_cnt ++;
       rcimgを返します. 
   }
        
   struct ref_cnt_img *
   vp8_dixie_find_free_ref_frame（struct ref_cnt_img * frames）
   {{
       int i;
        
       for（i = 0; i <NUM_REF_FRAMES; i ++）
           if（frames [i] .ref_cnt == 0）
           {{
               frame [i] .ref_cnt = 1;
               ＆frames[i]を返す;
           }
        
       assert（0）;
       NULLを返します. 
   }
        
   静的ボイド
   fixup_left（unsigned char * predict、
              int幅、
              intストライド、
              unsigned int行、
              列挙型prediction_modeモード）
   {{
       / *フレーム外ピクセルの左側の列は129と見なされ、
        * DC_PREDを実行している場合を除き、DC_PREDを実行している場合は、
        *これが行0でもない限り、行の上. この場合、
        *129. 
        * /
       unsigned char *left=予測-1;
       int i;
        
       if（mode == DC_PRED && row）
       {{
           unsigned char * above=predict-ストライド;
        
           for（i = 0;i<幅;i++）
           {{
               *左=上[i];
               左+=ストライド;
           }
       }
       そうしないと
       {{
           /*上記のMBが
            *DC_PRED. 
            * /
           左-=ストライド;
        
           for（i = -1;i<幅;i++）
           {{
               *左=129;
               左+=ストライド;
           }
       }
   }
        
   静的ボイド
   fixup_above（unsigned char * predict、
               int幅、
               intストライド、
               unsigned int col、
               列挙型prediction_modeモード）
   {{
       / *上記のフレーム外ピクセルの行は127と見なされ、
        * DC_PREDを実行している場合を除き、DC_PREDを実行している場合は、
        *これが列0でもない限り、左の列. この場合、
        *127. 
        * /
       unsigned char * above=predict-ストライド;
       int i;
        
       if（mode == DC_PRED && col）
       {{
           unsigned char *left=予測-1;
        
           for（i = 0;i<幅;i++）
           {{
               上記[i]=*左;
               左+=ストライド;
           }
       }
       そうしないと
           / *最後のMBがだった場合は、左の列をリセットする必要があります
            *DC_PRED. 
            * /
           memset（上記-1、127、幅+ 1）;
        
       memset（上記+幅、127、4）; //右上のサブブロックモードの場合
   }
        
void vp8_dixie_predict_init（struct vp8_decoder_ctx * ctx）{

       int i;
       unsigned char * this_frame_base;
        
       if（ctx-> frame_hdr.frame_size_updated）
       {{
           for（i = 0; i <NUM_REF_FRAMES; i ++）
           {{
               unsigned int w = ctx-> mb_cols * 16 + BORDER_PIXELS * 2;
               unsigned int h = ctx-> mb_rows * 16 + BORDER_PIXELS * 2;
        
               vpx_img_free（＆ctx-> frame_strg [i] .img）;
               ctx-> frame_strg [i] .ref_cnt = 0;
               ctx-> ref_frames [i] = NULL;
        
               if（！vpx_img_alloc（＆ctx-> frame_strg [i] .img、
                                  IMG_FMT_I420、w、h、16））
                   vpx_internal_error（＆ctx-> error、VPX_CODEC_MEM_ERROR、
                                      「％dx％dの割り当てに失敗しました」
                                      " フレームバッファ"、
                                      w、h）;
        
               vpx_img_set_rect（＆ctx-> frame_strg [i] .img、BORDER_PIXELS、
                   BORDER_PIXELS、ctx-> frame_hdr.kf.w、
                   ctx-> frame_hdr.kf.h）;
        
}

           if（ctx-> frame_hdr.version）
               ctx-> subpixel_filters = bilinear_filters;
           そうしないと
               ctx-> subpixel_filters = sixtap_filters;
       }
        
       /*予測する空きフレームバッファを見つけます*/
       if（ctx-> ref_frames [CURRENT_FRAME]）
           vp8_dixie_release_ref_frame（ctx-> ref_frames [CURRENT_FRAME]）;
        
       ctx-> ref_frames [CURRENT_FRAME] =
           vp8_dixie_find_free_ref_frame（ctx-> frame_strg）;
       this_frame_base = ctx-> ref_frames [CURRENT_FRAME]-> img.img_data;
        
       /*他の参照フレームへのオフセットを計算します*/
       for（i = 0; i <NUM_REF_FRAMES; i ++）
       {{
           struct ref_cnt_img * ref = ctx-> ref_frames [i];
        
           ctx-> ref_frame_offsets [i] =
               ref？ref-> img.img_data --this_frame_base：0;
       }
        
       / * TODO：すべてのフレームでこれを行う必要はありません... * /
   }
        
   空所
   vp8_dixie_predict_destroy（struct vp8_decoder_ctx * ctx）
   {{
       int i;
        
       for（i = 0; i <NUM_REF_FRAMES; i ++）
       {{
           vpx_img_free（＆ctx-> frame_strg [i] .img）;
           ctx-> frame_strg [i] .ref_cnt = 0;
           ctx-> ref_frames [i] = NULL;
       }
   }
        
   空所
   vp8_dixie_predict_process_row（struct vp8_decoder_ctx * ctx、
                                 unsigned int行、
                                 unsigned int start_col、
                                 unsigned int num_cols）
   {{
       struct img_index img;
       struct mb_info * mbi;
       unsigned int col;
       短い*係数;
        
       / *行、start_colに基づいてポインタを調整します* /
       img.stride =
           ctx-> ref_frames [CURRENT_FRAME]-> img.stride [PLANE_Y];
       img.uv_stride =
           ctx-> ref_frames [CURRENT_FRAME]-> img.stride [PLANE_U];
       img.y = ctx-> ref_frames [CURRENT_FRAME]-> img.planes [PLANE_Y];
       img.u = ctx-> ref_frames [CURRENT_FRAME]-> img.planes [PLANE_U];
       img.v = ctx-> ref_frames [CURRENT_FRAME]-> img.planes [PLANE_V];
       img.y + =（img.stride * row + start_col）* 16;
       img.u + =（img.uv_stride * row + start_col）* 8;
       img.v + =（img.uv_stride * row + start_col）* 8;
       mbi = ctx-> mb_info_rows [row] + start_col;
       coeffs = ctx-> tokens [row＆
           （ctx-> token_hdr.partitions-1）]. coeffs +
           25 * 16 * start_col;
        
       /*フレーム外のピクセルを修正します*/
        
       if（start_col == 0）
       {{
           fixup_left（img.y、16、img.stride、row、mbi-> base.y_mode）;
           fixup_left（img.u、8、img.uv_stride、row、mbi-> base.uv_mode）;
           fixup_left（img.v、8、img.uv_stride、row、mbi-> base.uv_mode）;
        
           if（row == 0）
               *（img.y --img.stride-1）= 127;
       }
        
       for（col = start_col; col <start_col + num_cols; col ++）
       {{
           if（row == 0）
           {{
               fixup_above（img.y、16、img.stride、col、
                           mbi-> base.y_mode）;
               fixup_above（img.u、8、img.uv_stride、col、
                           mbi-> base.uv_mode）;
               fixup_above（img.v、8、img.uv_stride、col、
                           mbi-> base.uv_mode）;
           }
        
           if（mbi-> base.y_mode <= B_PRED）
           {{
               Forecast_intra_luma（img.y、img.stride、mbi、coeffs）;
               予測_intra_chroma（img.u、img.v、img.uv_stride、mbi、
                                    coeffs）;
           }
        
           そうしないと
           {{
               if（mbi-> base.y_mode！= SPLITMV）// &&！= BPRED
                   fixup_dc_coeffs（mbi、coeffs）;
        
               if（mbi-> base.need_mc_border）
                   Forecast_inter_emulated_edge（ctx、＆img、coeffs、mbi、
                                               col、row）;
               そうしないと
                   Forecast_inter（ctx、＆img、coeffs、mbi）;
           }
        
           /*次のマクロブロックに進みます*/
           mbi ++;
           img.y + = 16;
           img.u + = 8;
           img.v + = 8;
           係数+=25 * 16;
       }
        
       if（col == ctx-> mb_cols）
       {{
           / *イントラ予測のために、最後の行を4ピクセル拡張します. 
            *これは後でcopy_downによって伝播されます. 
            * /
           uint32_t * extend =（uint32_t *）（img.y + 15 * img.stride）;
           uint32_t val = 0x01010101 * img.y [-1 + 15 * img.stride];
           * extend = val;
       }
   }
        
   ----終了コードブロック----------------------------------------
        
20.15. 予測.h
   ----コードブロックを開始--------------------------------------
        
   / *
    * Copyright（c）2010、2011、Google Inc.無断複写・転載を禁じます. 
    *
    *このソースコードの使用はBSDスタイルのライセンスによって管理されています
    *ソースのルートにあるLICENSEファイルにあります
    * 木. 追加の知的財産権の付与は
    *ファイルPATENTSにあります. 貢献しているすべてのプロジェクト作成者は
    *ソースツリーのルートにあるAUTHORSファイルにあります. 
    * /
   #ifndef PREDICT_H
   #define PREDICT_H
        
   空所
   vp8_dixie_predict_init（struct vp8_decoder_ctx * ctx）;
        
   空所
   vp8_dixie_predict_destroy（struct vp8_decoder_ctx * ctx）;
        
void vp8_dixie_predict_process_row（struct vp8_decoder_ctx * ctx、unsigned int row、unsigned int start_col、unsigned int num_cols）;

   空所
   vp8_dixie_release_ref_frame（struct ref_cnt_img * rcimg）;
        
   struct ref_cnt_img *
   vp8_dixie_ref_frame（struct ref_cnt_img * rcimg）;
        
   struct ref_cnt_img *
   vp8_dixie_find_free_ref_frame（struct ref_cnt_img * frames）;
        
#endif

   ----終了コードブロック----------------------------------------
        
20.16. tokens.c
   ----コードブロックを開始--------------------------------------
        
   / *
    * Copyright（c）2010、2011、Google Inc.無断複写・転載を禁じます. 
    *
    *このソースコードの使用はBSDスタイルのライセンスによって管理されています
    *ソースのルートにあるLICENSEファイルにあります
    * 木. 追加の知的財産権の付与は
    *ファイルPATENTSにあります. 貢献しているすべてのプロジェクト作成者は
    *ソースツリーのルートにあるAUTHORSファイルにあります. 
    * /
   #include "vpx_codec_internal.h"
   #include "dixie.h"
   #include "tokens.h"
   #include <stdlib.h>
   #include <string.h>
   #include <malloc.h>
        
   列挙型
   {{
       EOB_CONTEXT_NODE、
       ZERO_CONTEXT_NODE、
       ONE_CONTEXT_NODE、
       LOW_VAL_CONTEXT_NODE、
       TWO_CONTEXT_NODE、
       THREE_CONTEXT_NODE、
       HIGH_LOW_CONTEXT_NODE、
       CAT_ONE_CONTEXT_NODE、
       CAT_THREEFOUR_CONTEXT_NODE、
       CAT_THREE_CONTEXT_NODE、
       CAT_FIVE_CONTEXT_NODE
   };
   列挙型
   {{
       ZERO_TOKEN、
       ONE_TOKEN、
       TWO_TOKEN、
       THREE_TOKEN、
       FOUR_TOKEN、
       DCT_VAL_CATEGORY1、
       DCT_VAL_CATEGORY2、
       DCT_VAL_CATEGORY3、
        
       DCT_VAL_CATEGORY4、
       DCT_VAL_CATEGORY5、
       DCT_VAL_CATEGORY6、
       DCT_EOB_TOKEN、
       MAX_ENTROPY_TOKENS
   };
   構造体エクストラビット
   {{
       短いmin_val;
       短い長さ;
       unsigned char probs [12];
   };
   static const unsigned int left_context_index [25] =
   {{
       0、0、0、0、1、1、1、1、2、2、2、2、3、3、3、3、3
       4、4、5、5、6、6、7、7、8
   };
   static const unsigned int above_context_index [25] =
   {{
       0、1、2、3、0、1、2、3、0、1、2、3、0、1、2、3
       4、5、4、5、6、7、6、7、8
   };
   #define X（n）（（n）* PREV_COEFF_CONTEXTS * ENTROPY_NODES）
   static const unsigned int band_x [16] =
   {{
       X（0）、X（1）、X（2）、X（3）、X（6）、X（4）、X（5）、X（6）、
       X（6）、X（6）、X（6）、X（6）、X（6）、X（6）、X（6）、X（7）
   };
   #undef X
   static const struct extrabits extrabits [MAX_ENTROPY_TOKENS] =
   {{
       {0、-1、{0、0、0、0、0、0、
                   0、0、0、0、0、0}}、// ZERO_TOKEN
       {1、0、{0、0、0、0、0、0、
                   0、0、0、0、0、0}}、// ONE_TOKEN
       {2、0、{0、0、0、0、0、0、
                   0、0、0、0、0、0}}、// TWO_TOKEN
       {3、0、{0、0、0、0、0、0、
                   0、0、0、0、0、0}}、// THREE_TOKEN
       {4、0、{0、0、0、0、0、0、
                   0、0、0、0、0、0}}、// FOUR_TOKEN
       {5、0、{159、0、0、0、0、0、
                   0、0、0、0、0、0}}、// DCT_VAL_CATEGORY1
       {7、1、{145、165、0、0、0、0、
                   0、0、0、0、0、0}}、// DCT_VAL_CATEGORY2
       {11、2、{140、148、173、0、0、0、
                   0、0、0、0、0、0}}、// DCT_VAL_CATEGORY3
        
       {19、3、{135、140、155、176、0、0、
                   0、0、0、0、0、0}}、// DCT_VAL_CATEGORY4
       {35、4、{130、134、141、157、180、0、
                   0、0、0、0、0、0}}、// DCT_VAL_CATEGORY5
       {67、10、{129、130、133、140、153、177、
                 196、230、243、254、254、0}}、// DCT_VAL_CATEGORY6
       {0、-1、{0、0、0、0、0、0、
                   0、0、0、0、0、0}}、//EOBトークン
   };
        
   static const unsigned int zigzag [16] =
   {{
       0、1、4、8、5、2、3、6、9、12、13、10、7、11、14、15
   };
        
   #define DECODE_AND_APPLYSIGN（value_to_sign）\
       v =（bool_get_bit（bool）？-value_to_sign \
                               ：value_to_sign）* dqf [!! c];
        
   #define DECODE_AND_BRANCH_IF_ZERO（probability、branch）\
       if（！bool_get（bool、probability））goto branch;
        
   #define DECODE_AND_LOOP_IF_ZERO（probability、branch）\
       if（！bool_get（bool、probability））\
       {\
           prob = type_probs; \
           if（c <15）{\
               ++ c; \
               確率+=band_x [c]; \
               後藤支店; \
           } \
           そうしないと \
               goto BLOCK_FINISHED; /*不正な入力の場合*/\
       }
        
   #define DECODE_SIGN_WRITE_COEFF_AND_CHECK_EXIT（val）\
       DECODE_AND_APPLYSIGN（val）\
       prob = type_probs +（ENTROPY_NODES * 2）; \
       if（c <15）{\
           b_tokens [zigzag [c]] = v; \
           ++ c; \
           goto DO_WHILE; } \
       b_tokens [zigzag [15]] = v; \
       goto BLOCK_FINISHED;
        
   #define DECODE_EXTRABIT_AND_ADJUST_VAL（t、bits_count）\
       val + = bool_get（bool、extrabits [t] .probs [bits_count]）<< \
       ビット数;
        
   static int
   decode_mb_tokens（struct bool_decoder * bool、
                    token_entropy_ctx_t左、
                    上記のtoken_entropy_ctx_t、
                    短い*トークン、
                    列挙型prediction_modeモード、
                    coeff_probs_table_t probs、
                    ショートファクター[TOKEN_BLOCK_TYPES][2]）
   {{
       int i、stop、type;
       int c、t、v;
       int val、bits_count;
       int eob_mask;
       短い*b_tokens; //このブロックのトークン
       unsigned char * type_probs; //このブロックタイプの確率
       unsigned char * prob;
       短い*dqf;
        
eob_mask = 0;

       if（mode！= B_PRED && mode！= SPLITMV）
       {{
           i = 24;
           停止=24;
           タイプ=1;
           b_tokens=トークン+24* 16;
           dqf = factor [TOKEN_BLOCK_Y2];
       }
       そうしないと
       {{
           i = 0;
           停止=16;
           タイプ=3;
           b_tokens=トークン;
           dqf = factor [TOKEN_BLOCK_Y1];
       }
        
       /*現在のタイプの係数確率へのポインタを保存します. 
        *タイプが変更されるたびにこれを繰り返す必要があります. 
        * /
       type_probs = probs [type] [0] [0];
        
   BLOCK_LOOP：
       t = left [left_context_index [i]] + above [above_context_index [i]];
       c =！type; / *タイプ0を除いて、すべてのブロックは0から始まります. 
                   *1で. */
        
       prob = type_probs;
       確率+=t * ENTROPY_NODES;
        
   一方を行います：
       確率+=band_x [c];
       DECODE_AND_BRANCH_IF_ZERO（prob [EOB_CONTEXT_NODE]、
         BLOCK_FINISHED）;
        
   CHECK_0_：
       DECODE_AND_LOOP_IF_ZERO（prob [ZERO_CONTEXT_NODE]、CHECK_0_）;
       DECODE_AND_BRANCH_IF_ZERO（prob [ONE_CONTEXT_NODE]、
                                 ONE_CONTEXT_NODE_0_）;
       DECODE_AND_BRANCH_IF_ZERO（prob [LOW_VAL_CONTEXT_NODE]、
                                 LOW_VAL_CONTEXT_NODE_0_）;
       DECODE_AND_BRANCH_IF_ZERO（prob [HIGH_LOW_CONTEXT_NODE]、
                                 HIGH_LOW_CONTEXT_NODE_0_）;
       DECODE_AND_BRANCH_IF_ZERO（prob [CAT_THREEFOUR_CONTEXT_NODE]、
                                 CAT_THREEFOUR_CONTEXT_NODE_0_）;
       DECODE_AND_BRANCH_IF_ZERO（prob [CAT_FIVE_CONTEXT_NODE]、
                                 CAT_FIVE_CONTEXT_NODE_0_）;
       val = extrabits [DCT_VAL_CATEGORY6] .min_val;
       bits_count = extrabits [DCT_VAL_CATEGORY6] .length;
        
       行う
       {{
           DECODE_EXTRABIT_AND_ADJUST_VAL（DCT_VAL_CATEGORY6、
             ビット数）;
           ビット数-;
       }
       while（bits_count> = 0）;
        
       DECODE_SIGN_WRITE_COEFF_AND_CHECK_EXIT（val）;
        
   CAT_FIVE_CONTEXT_NODE_0_：
       val = extrabits [DCT_VAL_CATEGORY5] .min_val;
       DECODE_EXTRABIT_AND_ADJUST_VAL（DCT_VAL_CATEGORY5、4）;
       DECODE_EXTRABIT_AND_ADJUST_VAL（DCT_VAL_CATEGORY5、3）;
       DECODE_EXTRABIT_AND_ADJUST_VAL（DCT_VAL_CATEGORY5、2）;
       DECODE_EXTRABIT_AND_ADJUST_VAL（DCT_VAL_CATEGORY5、1）;
       DECODE_EXTRABIT_AND_ADJUST_VAL（DCT_VAL_CATEGORY5、0）;
       DECODE_SIGN_WRITE_COEFF_AND_CHECK_EXIT（val）;
        
   CAT_THREEFOUR_CONTEXT_NODE_0_：
       DECODE_AND_BRANCH_IF_ZERO（prob [CAT_THREE_CONTEXT_NODE]、
                                 CAT_THREE_CONTEXT_NODE_0_）;
       val = extrabits [DCT_VAL_CATEGORY4] .min_val;
       DECODE_EXTRABIT_AND_ADJUST_VAL（DCT_VAL_CATEGORY4、3）;
       DECODE_EXTRABIT_AND_ADJUST_VAL（DCT_VAL_CATEGORY4、2）;
       DECODE_EXTRABIT_AND_ADJUST_VAL（DCT_VAL_CATEGORY4、1）;
       DECODE_EXTRABIT_AND_ADJUST_VAL（DCT_VAL_CATEGORY4、0）;
       DECODE_SIGN_WRITE_COEFF_AND_CHECK_EXIT（val）;
        
   CAT_THREE_CONTEXT_NODE_0_：
       val = extrabits [DCT_VAL_CATEGORY3] .min_val;
       DECODE_EXTRABIT_AND_ADJUST_VAL（DCT_VAL_CATEGORY3、2）;
       DECODE_EXTRABIT_AND_ADJUST_VAL（DCT_VAL_CATEGORY3、1）;
       DECODE_EXTRABIT_AND_ADJUST_VAL（DCT_VAL_CATEGORY3、0）;
       DECODE_SIGN_WRITE_COEFF_AND_CHECK_EXIT（val）;
        
HIGH_LOW_CONTEXT_NODE_0_：DECODE_AND_BRANCH_IF_ZERO（prob [CAT_ONE_CONTEXT_NODE]、CAT_ONE_CONTEXT_NODE_0_）;

       val = extrabits [DCT_VAL_CATEGORY2] .min_val;
       DECODE_EXTRABIT_AND_ADJUST_VAL（DCT_VAL_CATEGORY2、1）;
       DECODE_EXTRABIT_AND_ADJUST_VAL（DCT_VAL_CATEGORY2、0）;
       DECODE_SIGN_WRITE_COEFF_AND_CHECK_EXIT（val）;
        
   CAT_ONE_CONTEXT_NODE_0_：
       val = extrabits [DCT_VAL_CATEGORY1] .min_val;
       DECODE_EXTRABIT_AND_ADJUST_VAL（DCT_VAL_CATEGORY1、0）;
       DECODE_SIGN_WRITE_COEFF_AND_CHECK_EXIT（val）;
        
   LOW_VAL_CONTEXT_NODE_0_：
       DECODE_AND_BRANCH_IF_ZERO（prob [TWO_CONTEXT_NODE]、
                                 TWO_CONTEXT_NODE_0_）;
       DECODE_AND_BRANCH_IF_ZERO（prob [THREE_CONTEXT_NODE]、
                                 THREE_CONTEXT_NODE_0_）;
       DECODE_SIGN_WRITE_COEFF_AND_CHECK_EXIT（4）;
        
   THREE_CONTEXT_NODE_0_：
       DECODE_SIGN_WRITE_COEFF_AND_CHECK_EXIT（3）;
        
   TWO_CONTEXT_NODE_0_：
       DECODE_SIGN_WRITE_COEFF_AND_CHECK_EXIT（2）;
        
   ONE_CONTEXT_NODE_0_：
       DECODE_AND_APPLYSIGN（1）;
       prob = type_probs + ENTROPY_NODES;
        
       if（c <15）
       {{
           b_tokens [zigzag [c]] = v;
           ++ c;
           goto DO_WHILE;
       }
        
       b_tokens [zigzag [15]] = v;
   BLOCK_FINISHED：
       eob_mask | =（c> 1）<< i;
       t =（c！=！type）; //ゼロ以外のデータはありますか？
       eob_mask | = t << 31;
        
       left [left_context_index [i]] = above [above_context_index [i]] = t;
       b_tokens + = 16;
        
       i ++;
        
if（i <stop）goto BLOCK_LOOP;

       if（i == 25）
       {{
           タイプ=0;
           i = 0;
           停止=16;
           type_probs = probs [type] [0] [0];
           b_tokens=トークン;
           dqf = factor [TOKEN_BLOCK_Y1];
           goto BLOCK_LOOP;
       }
        
       if（i == 16）
       {{
           タイプ=2;
           type_probs = probs [type] [0] [0];
           停止=24;
           dqf = factor [TOKEN_BLOCK_UV];
           goto BLOCK_LOOP;
       }
        
       eob_maskを返します. 
   }
        
   静的ボイド
   reset_row_context（token_entropy_ctx_t * left）
   {{
       memset（left、0、sizeof（* left））;
   }
        
   静的ボイド
   reset_above_context（token_entropy_ctx_t * above、unsigned int cols）
   {{
       memset（above、0、cols * sizeof（* above））;
   }
        
   静的ボイド
   reset_mb_context（token_entropy_ctx_t * left、
                    token_entropy_ctx_t *上記、
                    列挙型prediction_modeモード）
   {{
       /*左右のマクロブロックコンテキストをリセットします. 我々は持っています
        *このモードの場合、2次ブロックのコンテキストを保持します
        *それを更新しなかったでしょう. 
        * /
       memset（left、0、sizeof（（* left）[0]）* 8）;
       memset（above、0、sizeof（（* above）[0]）* 8）;
        
       if（mode！= B_PRED && mode！= SPLITMV）
       {{
           （*左）[8] = 0;
           （*上記）[8] = 0;
       }
   }
        
   空所
   vp8_dixie_tokens_process_row（struct vp8_decoder_ctx * ctx、
                                unsigned intパーティション、
                                unsigned int行、
                                unsigned int start_col、
                                unsigned int num_cols）
   {{
       struct token_decoder * tokens =＆ctx-> tokens [partition];
       短い係数=トークン->係数+25* 16 * start_col;
       unsigned int col;
       token_entropy_ctx_t * above = ctx-> above_token_entropy_ctx
                                     + start_col;
       token_entropy_ctx_t * left =＆tokens-> left_token_entropy_ctx;
       struct mb_info * mbi = ctx-> mb_info_rows [row] + start_col;
        
       if（row == 0）
           reset_above_context（above、num_cols）;
        
       if（start_col == 0）
           reset_row_context（left）;
        
       for（col = start_col; col <start_col + num_cols; col ++）
       {{
           memset（coeffs、0、25 * 16 * sizeof（short））;
        
           if（mbi-> base.skip_coeff）
           {{
               reset_mb_context（左、上、mbi-> base.y_mode）;
               mbi-> base.eob_mask = 0;
           }
           そうしないと
           {{
               struct dequant_factors * dqf;
        
               dqf = ctx-> dequant_factors + mbi-> base.segment_id;
               mbi-> base.eob_mask =
                   decode_mb_tokens（＆tokens-> bool、
                                    *左、*上、
                                    coeffs、
                                    mbi-> base.y_mode、
                                    ctx-> entropy_hdr.coeff_probs、
                                    dqf-> factor）;
           }
        
           上記++;
           mbi ++;
           係数+=25 * 16;
       }
   }
        
   空所
   vp8_dixie_tokens_init（struct vp8_decoder_ctx * ctx）
   {{
       unsignedintパーティション=ctx->token_hdr.partitions;
        
       if（ctx-> frame_hdr.frame_size_updated）
       {{
           unsigned int i;
           unsigned int coeff_row_sz =
               ctx-> mb_cols * 25 * 16 * sizeof（short）;
        
           for（i = 0;i<パーティション;i++）
           {{
               free（ctx-> tokens [i] .coeffs）;
               ctx-> tokens [i] .coeffs = memalign（16、coeff_row_sz）;
        
               if（！ctx-> tokens [i] .coeffs）
                   vpx_internal_error（＆ctx-> error、VPX_CODEC_MEM_ERROR、
                                      ヌル）;
           }
        
           free（ctx-> above_token_entropy_ctx）;
           ctx-> above_token_entropy_ctx =
               calloc（ctx-> mb_cols、
               sizeof（* ctx-> above_token_entropy_ctx））;
        
           if（！ctx-> above_token_entropy_ctx）
               vpx_internal_error（＆ctx-> error、
               VPX_CODEC_MEM_ERROR、NULL）;
       }
   }
        
   空所
   vp8_dixie_tokens_destroy（struct vp8_decoder_ctx * ctx）
   {{
       int i;
        
       for（i = 0; i <MAX_PARTITIONS; i ++）
           free（ctx-> tokens [i] .coeffs）;
        
       free（ctx-> above_token_entropy_ctx）;
   }
        
   ----終了コードブロック----------------------------------------
        
20.17. tokens.h
   ----コードブロックを開始--------------------------------------
        
   / *
    * Copyright（c）2010、2011、Google Inc.無断複写・転載を禁じます. 
    *
    *このソースコードの使用はBSDスタイルのライセンスによって管理されています
    *ソースのルートにあるLICENSEファイルにあります
    * 木. 追加の知的財産権の付与は
    *ファイルPATENTSにあります. 貢献しているすべてのプロジェクト作成者は
    *ソースツリーのルートにあるAUTHORSファイルにあります. 
    * /
   #ifndef TOKENS_H
   #define TOKENS_H
        
   空所
   vp8_dixie_tokens_init（struct vp8_decoder_ctx * ctx）;
        
   空所
   vp8_dixie_tokens_destroy（struct vp8_decoder_ctx * ctx）;
        
void vp8_dixie_tokens_process_row（struct vp8_decoder_ctx * ctx、unsigned int partition、unsigned int row、unsigned int start_col、unsigned int num_cols）;

#endif

   ----終了コードブロック----------------------------------------
        
20.18. vp8_prob_data.h
   ----コードブロックを開始--------------------------------------
        
   / *
    * Copyright（c）2010、2011、Google Inc.無断複写・転載を禁じます. 
    *
    *このソースコードの使用はBSDスタイルのライセンスによって管理されています
    *ソースのルートにあるLICENSEファイルにあります
    * 木. 追加の知的財産権の付与は
    *ファイルPATENTSにあります. 貢献しているすべてのプロジェクト作成者は
    *ソースツリーのルートにあるAUTHORSファイルにあります. 
    * /
        
   静的定数
   unsigned char k_coeff_entropy_update_probs [BLOCK_TYPES] [COEFF_BANDS]
   [PREV_COEFF_CONTEXTS]
   [ENTROPY_NODES] =
   {{
       {{
           {{
               {255、255、255、255、255、255、255、255、255、255、255}、
               {255、255、255、255、255、255、255、255、255、255、255}、
               {255、255、255、255、255、255、255、255、255、255、255}、
           }、
           {{
               {176、246、255、255、255、255、255、255、255、255、255}、
               {223、241、252、255、255、255、255、255、255、255、255}、
               {249、253、253、255、255、255、255、255、255、255、255}、
           }、
           {{
               {255、244、252、255、255、255、255、255、255、255、255}、
               {234、254、254、255、255、255、255、255、255、255、255}、
               {253、255、255、255、255、255、255、255、255、255、255}、
           }、
           {{
               {255、246、254、255、255、255、255、255、255、255、255}、
               {239、253、254、255、255、255、255、255、255、255、255}、
               {254、255、254、255、255、255、255、255、255、255、255}、
           }、
           {{
               {255、248、254、255、255、255、255、255、255、255、255}、
               {251、255、254、255、255、255、255、255、255、255、255}、
               {255、255、255、255、255、255、255、255、255、255、255}、
           }、
        
           {{
               {255、253、254、255、255、255、255、255、255、255、255}、
               {251、254、254、255、255、255、255、255、255、255、255}、
               {254、255、254、255、255、255、255、255、255、255、255}、
           }、
           {{
               {255、254、253、255、254、255、255、255、255、255、255}、
               {250、255、254、255、254、255、255、255、255、255、255}、
               {254、255、255、255、255、255、255、255、255、255、255}、
           }、
           {{
               {255、255、255、255、255、255、255、255、255、255、255}、
               {255、255、255、255、255、255、255、255、255、255、255}、
               {255、255、255、255、255、255、255、255、255、255、255}、
           }、
       }、
       {{
           {{
               {217、255、255、255、255、255、255、255、255、255、255}、
               {225、252、241、253、255、255、254、255、255、255、255}、
               {234、250、241、250、253、255、253、254、255、255、255}、
           }、
           {{
               {255、254、255、255、255、255、255、255、255、255、255}、
               {223、254、254、255、255、255、255、255、255、255、255}、
               {238、253、254、254、255、255、255、255、255、255、255}、
           }、
           {{
               {255、248、254、255、255、255、255、255、255、255、255}、
               {249、254、255、255、255、255、255、255、255、255、255}、
               {255、255、255、255、255、255、255、255、255、255、255}、
           }、
           {{
               {255、253、255、255、255、255、255、255、255、255、255}、
               {247、254、255、255、255、255、255、255、255、255、255}、
               {255、255、255、255、255、255、255、255、255、255、255}、
           }、
           {{
               {255、253、254、255、255、255、255、255、255、255、255}、
               {252、255、255、255、255、255、255、255、255、255、255}、
               {255、255、255、255、255、255、255、255、255、255、255}、
           }、
           {{
               {255、254、254、255、255、255、255、255、255、255、255}、
               {253、255、255、255、255、255、255、255、255、255、255}、
               {255、255、255、255、255、255、255、255、255、255、255}、
           }、
        
           {{
               {255、254、253、255、255、255、255、255、255、255、255}、
               {250、255、255、255、255、255、255、255、255、255、255}、
               {254、255、255、255、255、255、255、255、255、255、255}、
           }、
           {{
               {255、255、255、255、255、255、255、255、255、255、255}、
               {255、255、255、255、255、255、255、255、255、255、255}、
               {255、255、255、255、255、255、255、255、255、255、255}、
           }、
       }、
       {{
           {{
               {186、251、250、255、255、255、255、255、255、255、255}、
               {234、251、244、254、255、255、255、255、255、255、255}、
               {251、251、243、253、254、255、254、255、255、255、255}、
           }、
           {{
               {255、253、254、255、255、255、255、255、255、255、255}、
               {236、253、254、255、255、255、255、255、255、255、255}、
               {251、253、253、254、254、255、255、255、255、255、255}、
           }、
           {{
               {255、254、254、255、255、255、255、255、255、255、255}、
               {254、254、254、255、255、255、255、255、255、255、255}、
               {255、255、255、255、255、255、255、255、255、255、255}、
           }、
           {{
               {255、254、255、255、255、255、255、255、255、255、255}、
               {254、254、255、255、255、255、255、255、255、255、255}、
               {254、255、255、255、255、255、255、255、255、255、255}、
           }、
           {{
               {255、255、255、255、255、255、255、255、255、255、255}、
               {254、255、255、255、255、255、255、255、255、255、255}、
               {255、255、255、255、255、255、255、255、255、255、255}、
           }、
           {{
               {255、255、255、255、255、255、255、255、255、255、255}、
               {255、255、255、255、255、255、255、255、255、255、255}、
               {255、255、255、255、255、255、255、255、255、255、255}、
           }、
           {{
               {255、255、255、255、255、255、255、255、255、255、255}、
               {255、255、255、255、255、255、255、255、255、255、255}、
               {255、255、255、255、255、255、255、255、255、255、255}、
           }、
        
           {{
               {255、255、255、255、255、255、255、255、255、255、255}、
               {255、255、255、255、255、255、255、255、255、255、255}、
               {255、255、255、255、255、255、255、255、255、255、255}、
           }、
       }、
       {{
           {{
               {248、255、255、255、255、255、255、255、255、255、255}、
               {250、254、252、254、255、255、255、255、255、255、255}、
               {248、254、249、253、255、255、255、255、255、255、255}、
           }、
           {{
               {255、253、253、255、255、255、255、255、255、255、255}、
               {246、253、253、255、255、255、255、255、255、255、255}、
               {252、254、251、254、254、255、255、255、255、255、255}、
           }、
           {{
               {255、254、252、255、255、255、255、255、255、255、255}、
               {248、254、253、255、255、255、255、255、255、255、255}、
               {253、255、254、254、255、255、255、255、255、255、255}、
           }、
           {{
               {255、251、254、255、255、255、255、255、255、255、255}、
               {245、251、254、255、255、255、255、255、255、255、255}、
               {253、253、254、255、255、255、255、255、255、255、255}、
           }、
           {{
               {255、251、253、255、255、255、255、255、255、255、255}、
               {252、253、254、255、255、255、255、255、255、255、255}、
               {255、254、255、255、255、255、255、255、255、255、255}、
           }、
           {{
               {255、252、255、255、255、255、255、255、255、255、255}、
               {249、255、254、255、255、255、255、255、255、255、255}、
               {255、255、254、255、255、255、255、255、255、255、255}、
           }、
           {{
               {255、255、253、255、255、255、255、255、255、255、255}、
               {250、255、255、255、255、255、255、255、255、255、255}、
               {255、255、255、255、255、255、255、255、255、255、255}、
           }、
        
           {{
               {255、255、255、255、255、255、255、255、255、255、255}、
               {254、255、255、255、255、255、255、255、255、255、255}、
               {255、255、255、255、255、255、255、255、255、255、255}、
           }、
       }、
   };
        
static const unsigned char k_default_y_mode_probs [] = {112、86、140、37};

static const unsigned char k_default_uv_mode_probs [] = {162、101、204};

   静的定数
   unsigned char k_default_coeff_probs [BLOCK_TYPES] [COEFF_BANDS]
   [PREV_COEFF_CONTEXTS] [ENTROPY_NODES] =
   {{
       {/*ブロックタイプ0*/
           {/*係数バンド0*/
               {128、128、128、128、128、128、128、128、128、128、128}、
               {128、128、128、128、128、128、128、128、128、128、128}、
               {128、128、128、128、128、128、128、128、128、128、128}
           }、
           {/*係数バンド1*/
               {253、136、254、255、228、219、128、128、128、128、128}、
               {189、129、242、255、227、213、255、219、128、128、128}、
               {106、126、227、252、214、209、255、255、128、128、128}
           }、
           {/*係数バンド2*/
               {1、98、248、255、236、226、255、255、128、128、128}、
               {181、133、238、254、221、234、255、154、128、128、128}、
               {78、134、202、247、198、180、255、219、128、128、128}
           }、
           {/*係数バンド3*/
               {1、185、249、255、243、255、128、128、128、128、128}、
               {184、150、247、255、236、224、128、128、128、128、128}、
               {77、110、216、255、236、230、128、128、128、128、128}
           }、
        
           {/*係数バンド4*/
               {1、101、251、255、241、255、128、128、128、128、128}、
               {170、139、241、252、236、209、255、255、128、128、128}、
               {37、116、196、243、228、255、255、255、128、128、128}
           }、
           {/*係数バンド5*/
               {1、204、254、255、245、255、128、128、128、128、128}、
               {207、160、250、255、238、128、128、128、128、128、128}、
               {102、103、231、255、211、171、128、128、128、128、128}
           }、
           {/*係数バンド6*/
               {1、152、252、255、240、255、128、128、128、128、128}、
               {177、135、243、255、234、225、128、128、128、128、128}、
               {80、129、211、255、194、224、128、128、128、128、128}
           }、
           {/*係数バンド7*/
               {1、1、255、128、128、128、128、128、128、128、128}、
               {246、1、255、128、128、128、128、128、128、128、128}、
               {255、128、128、128、128、128、128、128、128、128、128}
           }
       }、
       {/*ブロックタイプ1*/
           {/*係数バンド0*/
               {198、35、237、223、193、187、162、160、145、155、62}、
               {131、45、198、221、172、176、220、157、252、221、1}、
               {68、47、146、208、149、167、221、162、255、223、128}
           }、
           {/*係数バンド1*/
               {1、149、241、255、221、224、255、255、128、128、128}、
               {184、141、234、253、222、220、255、199、128、128、128}、
               {81、99、181、242、176、190、249、202、255、255、128}
           }、
           {/*係数バンド2*/
               {1、129、232、253、214、197、242、196、255、255、128}、
               {99、121、210、250、201、198、255、202、128、128、128}、
               {23、91、163、242、170、187、247、210、255、255、128}
           }、
           {/*係数バンド3*/
               {1、200、246、255、234、255、128、128、128、128、128}、
               {109、178、241、255、231、245、255、255、128、128、128}、
               {44、130、201、253、205、192、255、255、128、128、128}
           }、
           {/*係数バンド4*/
               {1、132、239、251、219、209、255、165、128、128、128}、
               {94、136、225、251、218、190、255、255、128、128、128}、
               {22、100、174、245、186、161、255、199、128、128、128}
           }、
        
           {/*係数バンド5*/
               {1、182、249、255、232、235、128、128、128、128、128}、
               {124、143、241、255、227、234、128、128、128、128、128}、
               {35、77、181、251、193、211、255、205、128、128、128}
           }、
           {/*係数バンド6*/
               {1、157、247、255、236、231、255、255、128、128、128}、
               {121、141、235、255、225、227、255、255、128、128、128}、
               {45、99、188、251、195、217、255、224、128、128、128}
           }、
           {/*係数バンド7*/
               {1、1、251、255、213、255、128、128、128、128、128}、
               {203、1、248、255、255、128、128、128、128、128、128}、
               {137、1、177、255、224、255、128、128、128、128、128}
           }
       }、
       {/*ブロックタイプ2*/
           {/*係数バンド0*/
               {253、9、248、251、207、208、255、192、128、128、128}、
               {175、13、224、243、193、185、249、198、255、255、128}、
               {73、17、171、221、161、179、236、167、255、234、128}
           }、
           {/*係数バンド1*/
               {1、95、247、253、212、183、255、255、128、128、128}、
               {239、90、244、250、211、209、255、255、128、128、128}、
               {155、77、195、248、188、195、255、255、128、128、128}
           }、
           {/*係数バンド2*/
               {1、24、239、251、218、219、255、205、128、128、128}、
               {201、51、219、255、196、186、128、128、128、128、128}、
               {69、46、190、239、201、218、255、228、128、128、128}
           }、
           {/*係数バンド3*/
               {1、191、251、255、255、128、128、128、128、128、128}、
               {223、165、249、255、213、255、128、128、128、128、128}、
               {141、124、248、255、255、128、128、128、128、128、128}
           }、
           {/*係数バンド4*/
               {1、16、248、255、255、128、128、128、128、128、128}、
               {190、36、230、255、236、255、128、128、128、128、128}、
               {149、1、255、128、128、128、128、128、128、128、128}
           }、
           {/*係数バンド5*/
               {1、226、255、128、128、128、128、128、128、128、128}、
               {247、192、255、128、128、128、128、128、128、128、128}、
               {240、128、255、128、128、128、128、128、128、128、128}
           }、
        
           {/*係数バンド6*/
               {1、134、252、255、255、128、128、128、128、128、128}、
               {213、62、250、255、255、128、128、128、128、128、128}、
               {55、93、255、128、128、128、128、128、128、128、128}
           }、
           {/*係数バンド7*/
               {128、128、128、128、128、128、128、128、128、128、128}、
               {128、128、128、128、128、128、128、128、128、128、128}、
               {128、128、128、128、128、128、128、128、128、128、128}
           }
       }、
       {/*ブロックタイプ3*/
           {/*係数バンド0*/
               {202、24、213、235、186、191、220、160、240、175、255}、
               {126、38、182、232、169、184、228、174、255、187、128}、
               {61、46、138、219、151、178、240、170、255、216、128}
           }、
           {/*係数バンド1*/
               {1、112、230、250、199、191、247、159、255、255、128}、
               {166、109、228、252、211、215、255、174、128、128、128}、
               {39、77、162、232、172、180、245、178、255、255、128}
           }、
           {/*係数バンド2*/
               {1、52、220、246、198、199、249、220、255、255、128}、
               {124、74、191、243、183、193、250、221、255、255、128}、
               {24、71、130、219、154、170、243、182、255、255、128}
           }、
           {/*係数バンド3*/
               {1、182、225、249、219、240、255、224、128、128、128}、
               {149、150、226、252、216、205、255、171、128、128、128}、
               {28、108、170、242、183、194、254、223、255、255、128}
           }、
           {/*係数バンド4*/
               {1、81、230、252、204、203、255、192、128、128、128}、
               {123、102、209、247、188、196、255、233、128、128、128}、
               {20、95、153、243、164、173、255、203、128、128、128}
           }、
           {/*係数バンド5*/
               {1、222、248、255、216、213、128、128、128、128、128}、
               {168、175、246、252、235、205、255、255、128、128、128}、
               {47、116、215、255、211、212、255、255、128、128、128}
           }、
           {/*係数バンド6*/
               {1、121、236、253、212、214、255、255、128、128、128}、
               {141、84、213、252、201、202、255、219、128、128、128}、
               {42、80、160、240、162、185、255、205、128、128、128}
           }、
        
           {/*係数バンド7*/
               {1、1、255、128、128、128、128、128、128、128、128}、
               {244、1、255、128、128、128、128、128、128、128、128}、
               {238、1、255、128、128、128、128、128、128、128、128}
           }
       }
   };
        
   静的定数
   unsigned char k_mv_entropy_update_probs [2] [MV_PROB_CNT] =
   {{
       {{
           237、
           246、
           253、253、254、254、254、254、254、
           254、254、254、254、254、250、250、252、254、254
       }、
       {{
           231、
           243、
           245、253、254、254、254、254、254、
           254、254、254、254、254、251、251、254、254、254
       }
   };
        
   静的定数
   unsigned char k_default_mv_probs [2] [MV_PROB_CNT] =
   {{
       { // 行
           162、//短い
           128、//署名
           225、146、172、147、214、39、156、//短いツリー
           128、129、132、75、145、178、206、239、254、254//ロングビット
       }、
       {{
           164、
           128、
           204、170、119、235、140、230、228、
           128、130、130、74、148、180、203、236、254、254
        
       }
   };
        
   ----終了コードブロック----------------------------------------
        
20.19. vpx_codec_internal.h
   ----コードブロックを開始--------------------------------------
        
   / *
    * Copyright（c）2010、2011、Google Inc.無断複写・転載を禁じます. 
    *
    *このソースコードの使用はBSDスタイルのライセンスによって管理されています
    *ソースのルートにあるLICENSEファイルにあります
    * 木. 追加の知的財産権の付与は
    *ファイルPATENTSにあります. 貢献しているすべてのプロジェクト作成者は
    *ソースツリーのルートにあるAUTHORSファイルにあります. 
    * /
        
   / *！\ file vpx_codec_internal.h
    *\briefアルゴリズムのデコーダーアルゴリズムインターフェイスについて説明します
    *実装. 
    *
    *このファイルは、プライベート構造とデータ型を定義します
    *を使用するのではなく、アルゴリズムの実装にのみ関連します
    * それ. 
    *
    *デコーダーアルゴリズムクラスを作成するために、インターフェイス構造が配置されます
    *グローバル名前空間に：
    * <pre>
    * my_codec.c：
    * vpx_codec_iface_t my_codec = {
    *「MyCodecv1.0」、
    * VPX_CODEC_ALG_ABI_VERSION、
    *... 
    *};
    * </ pre>
    *
    *アプリケーションは、を使用して特定のデコーダインスタンスをインスタンス化します
    * vpx_codec_init（）およびアルゴリズムのインターフェースへのポインター
    * 構造：
    * <pre>
    * my_app.c：
    * extern vpx_codec_iface_t my_codec;
    * {
    * vpx_codec_ctx_t algo;
    * res = vpx_codec_init（＆algo、＆my_codec）;
    *}
    * </ pre>
    *
        
    *初期化されると、インスタンスは他の機能を使用して管理されます
    *vpx_codec_*ファミリから. 
    * /
   #ifndef VPX_CODEC_INTERNAL_H
   #define VPX_CODEC_INTERNAL_H
   #include "vpx_decoder.h"
   #include <stdarg.h>
        
   / *！\brief現在のABIバージョン番号
    *
    * \内部
    *このファイルがアプリケーションを変更するような方法で変更された場合
    *バイナリインターフェイス（ABI）、この値はバンプする必要があります. 例
    *タイプの変更、削除、または
    *列挙型の再割り当て、フィールドの追加/削除/再配置
    *構造. 
    * /
   #define VPX_CODEC_INTERNAL_ABI_VERSION（3）
        
typedef struct vpx_codec_alg_priv vpx_codec_alg_priv_t;

   / *！\briefinit関数ポインタのプロトタイプ
    *
    *デコーダコンテキストのアルゴリズム固有の初期化を実行します. 
    *この関数は、汎用のvpx_codec_init（）ラッパーによって呼び出されます
    *関数なので、このインターフェースを実装するプラグインは
    *適切に初期化される入力パラメータ. 
    *
    * \ param[in]ctxこのインスタンスのコンテキストへのポインタ
    * \ retval #VPX_CODEC_OK
    *入力ストリームが認識され、デコーダーが初期化されました. 
    * \ retval #VPX_CODEC_MEM_ERROR
    *メモリ操作に失敗しました. 
    * /
   typedef vpx_codec_err_t（* vpx_codec_init_fn_t）（vpx_codec_ctx_t * ctx）;
        
   / *！\brief関数ポインタのプロトタイプを破棄します
    *
    *デコーダコンテキストのアルゴリズム固有の破棄を実行します. 
    *この関数は、汎用のvpx_codec_destroy（）ラッパーによって呼び出されます
    *関数なので、このインターフェースを実装するプラグインは
    *適切に初期化される入力パラメータ. 
    *
    * \ param[in]ctxこのインスタンスのコンテキストへのポインタ
    * \ retval #VPX_CODEC_OK
    *入力ストリームが認識され、デコーダーが初期化されました. 
    * \ retval #VPX_CODEC_MEM_ERROR
    *メモリ操作に失敗しました. 
    * /
   typedef vpx_codec_err_t（* vpx_codec_destroy_fn_t）（
       vpx_codec_alg_priv_t * ctx）;
        
   / *！\brief解析ストリーム情報関数ポインタプロトタイプ
    *
    *ビットストリームの高レベルの解析を実行します. この関数は
    *汎用のvpx_codec_parse_stream（）ラッパー関数によって呼び出されます. 
    *したがって、このインターフェースを実装するプラグインは入力を信頼する可能性があります
    *適切に初期化されるパラメータ. 
    *
    * \ param[in]data解析するデータのブロックへのポインタ
    * \ param[in]data_szデータバッファのサイズ
    * \ param [in、out]si更新する情報をストリーミングするためのポインタ. ザ
    *サイズメンバー\refは適切である必要があります
    *初期化されましたが、\refはによって破壊される可能性があります
    *アルゴリズム. このパラメータ\refMAY
    *NULLになります. 
    *
    * \ retval #VPX_CODEC_OK
    *ビットストリームは解析可能であり、ストリーム情報が更新されます
    * /
   typedef vpx_codec_err_t（* vpx_codec_peek_si_fn_t）（
       const uint8_t * data、
       unsigned int data_sz、
       vpx_codec_stream_info_t * si）;
        
   / *！\brief現在のストリームに関する情報を返します. 
    *
    *中に解析されたストリームに関する情報を返します
    *デコード. 
    *
    * \ param[in]ctxこのインスタンスのコンテキストへのポインタ
    * \ param [in、out]si更新する情報をストリーミングするためのポインタ. ザ
    *サイズメンバー\refは適切である必要があります
    *初期化されましたが、\refはによって破壊される可能性があります
    *アルゴリズム. このパラメータ\refMAY
    *NULLになります. 
    *
    * \ retval #VPX_CODEC_OK
    *ビットストリームは解析可能であり、ストリーム情報が更新されます
    * /
   typedef vpx_codec_err_t（* vpx_codec_get_si_fn_t）（
       vpx_codec_alg_priv_t * ctx、
       vpx_codec_stream_info_t * si）;
        
   / *！\brief制御関数ポインタのプロトタイプ
    *
    *この関数は、アルゴリズム固有のデータを
    *デコーダーインスタンス. これは、特定の機能を実装するために使用できます
    *特定のアルゴリズムに. 
    *
    *この関数は、汎用のvpx_codec_control（）ラッパーによって呼び出されます
    *関数なので、このインターフェースを実装するプラグインは
    *適切に初期化される入力パラメータ. しかし、これは
    *インターフェースは、交換されたデータまたは
    *制御コードに意味を割り当てます. それらの詳細は
    *アルゴリズムのヘッダーファイルで指定されています. 特に、
    * ctrl_idパラメータは、アルゴリズムの
    *マッピングテーブルを制御します. データパラメータはNULLの場合があります. 
    *
    *
    * \ param[in]ctxこのインスタンスのコンテキストへのポインタ
    * \ param[in]ctrl_idアルゴリズム固有の制御識別子
    * \ param [in、out]dataアルゴリズムインスタンスと交換するデータ. 
    *
    * \ retval #VPX_CODEC_OK
    *内部状態データは逆シリアル化されました. 
    * /
   typedef vpx_codec_err_t（* vpx_codec_control_fn_t）（
       vpx_codec_alg_priv_t * ctx、
       int ctrl_id、
       va_list ap）;
        
   / *！\brief制御関数ポインタマッピング
    *
    *この構造は、コントロール識別子と
    *機能の実装. 各アルゴリズムは、これらのリストを提供します
    *マッピング. このリストはvpx_codec_control（）によって検索されます
    *呼び出す関数を決定するラッパー関数. ザ
    *特別な値{0、NULL}はリストの終わりを示すために使用され、
    *存在する. 特別な値{0、<non-null>}は、
    *キャッチオールマッピング. これは、によって選択されたctrl_id値を意味します
    *アルゴリズム\refはゼロ以外でなければなりません. 
    * /
   typedef const struct
   {{
       int ctrl_id;
       vpx_codec_control_fn_t fn;
   } vpx_codec_ctrl_fn_map_t;
        
   / *！\briefデコードデータ関数ポインタプロトタイプ
    *
    *コード化されたデータのバッファを処理します. 処理の結果、
    *新しいデコードされたフレームが利用可能になります. ＃VPX_CODEC_CB_PUT_SLICEおよび
    *#VPX_CODEC_CB_PUT_FRAMEイベントは必要に応じて生成されます. 
    *この関数は、汎用のvpx_codec_decode（）ラッパーによって呼び出されます
    *関数なので、このインターフェースを実装するプラグインは
    *適切に初期化される入力パラメータ. 
    *
    * \ param[in]ctxこのインスタンスのコンテキストへのポインタ
    * \ param[in]data新しいコード化データのこのブロックへのポインター. 
    * NULLの場合、＃VPX_CODEC_CB_PUT_FRAMEイベントは
    *以前にデコードされたフレームに対して投稿されました. 
    * \ param [in] data_szコード化されたデータのサイズ（バイト単位）. 
    *
    * \ returnコード化されたデータが処理された場合、＃VPX_CODEC_OKを返します
    *完全にそして将来の写真はなしでデコードすることができます
    * エラー. それ以外の場合は、他のエラーの説明を参照してください
    *回復可能性のための::vpx_codec_err_tのコード
    *機能. 
    * /
   typedef vpx_codec_err_t（* vpx_codec_decode_fn_t）（
       vpx_codec_alg_priv_t * ctx、
       const uint8_t * data、
       unsigned int data_sz、
       void * user_priv、
       長い締め切り）;
        
   / *！\briefデコードされたフレームイテレータ
    *
    *表示可能なフレームのリストを繰り返します. ザ
    *イテレータストレージを開始するには、NULLに初期化する必要があります
    *反復. この関数がNULLを返すと、反復が完了します. 
    *
    *使用可能なフレームのリストは、完了時に有効になります. 
    * vpx_codec_decode呼び出し、および次の呼び出しまで有効なまま
    *vpx_codec_decode. 
    *
    * \ param[in]ctxこのインスタンスのコンテキストへのポインタ
    * \ param [in out] iterイテレータストレージ、NULLに初期化
    *
    * \ return準備ができている場合は、画像へのポインタを返します
    * 画面. 生成されるフレームは常にPTSになります
    *（プレゼンテーションタイムスタンプ）注文. 
    * /
   typedef vpx_image_t *（* vpx_codec_get_frame_fn_t）（
       vpx_codec_alg_priv_t * ctx、
       vpx_codec_iter_t * iter）;
        
   / *\brief外部メモリ割り当てメモリマップgetイテレータ
    *
    *デコーダーによって要求されたメモリマップのリストを繰り返します. 
    *イテレータストレージを開始するには、NULLに初期化する必要があります
    *反復. この関数がNULLを返すと、反復が完了します. 
    *
    * \ param [in out] iterイテレータストレージ、NULLに初期化
    *
    * \ returnメモリセグメント記述子へのポインタ、またはNULLを返します
    *リストの終わりを示します. 
    * /
   typedef vpx_codec_err_t（* vpx_codec_get_mmap_fn_t）（
       const vpx_codec_ctx_t * ctx、
       vpx_codec_mmap_t * mmap、
       vpx_codec_iter_t * iter）;
        
   / *\brief外部メモリ割り当てメモリマップセットイテレータ
    *
    *デコーダインスタンス内にメモリ記述子を設定します. 
    *
    * \ param[in]ctxこのインスタンスのコンテキストへのポインタ
    * \ param[in]mmap保存するメモリマップ. 
    *
    * \ retval #VPX_CODEC_OK
    *メモリマップが受け入れられ、保存されました. 
    * \ retval #VPX_CODEC_MEM_ERROR
    *メモリマップは拒否されました. 
    * /
   typedef vpx_codec_err_t（* vpx_codec_set_mmap_fn_t）（
       vpx_codec_ctx_t * ctx、
       const vpx_codec_mmap_t * mmap）;
        
   typedef vpx_codec_err_t（* vpx_codec_encode_fn_t）（
       vpx_codec_alg_priv_t * ctx、
       const vpx_image_t * img、
       vpx_codec_pts_t pts、
       署名されていない長い期間、
       vpx_enc_frame_flags_tフラグ、
       署名されていない長い期限）;
   typedef const vpx_codec_cx_pkt_t *（* vpx_codec_get_cx_data_fn_t）（
       vpx_codec_alg_priv_t * ctx、
       vpx_codec_iter_t * iter）;
        
   typedef vpx_codec_err_t
   （* vpx_codec_enc_config_set_fn_t）（
       vpx_codec_alg_priv_t * ctx、
       const vpx_codec_enc_cfg_t * cfg）;
   typedef vpx_fixed_buf_t *
   （* vpx_codec_get_global_headers_fn_t）（vpx_codec_alg_priv_t * ctx）;
        
   typedef vpx_image_t *
   （* vpx_codec_get_preview_frame_fn_t）（vpx_codec_alg_priv_t * ctx）;
        
   / *！\brief使用法構成マッピング
    *
    *この構造は、使用IDと
    *構成構造. 各アルゴリズムは、これらのリストを提供します
    *マッピング. このリストはによって検索されます
    * vpx_codec_enc_config_default（）ラッパー関数でどちらを判別するか
        
    *返す構成. 特別な値{-1、{0}}は、を示すために使用されます
    *リストの終わりであり、存在する必要があります. 少なくとも1つのマッピングは
    *リストの終わりに加えて存在します. 
    *
    * /
   typedef const struct
   {{
       intの使用法;
       vpx_codec_enc_cfg_t cfg;
   } vpx_codec_enc_cfg_map_t;
        
#define NOT_IMPLEMENTED 0

   / *！\briefデコーダーアルゴリズムインターフェース
    *
    *すべてのデコーダー\refは、このタイプの変数を公開する必要があります. 
    * /
   struct vpx_codec_iface
   {{
       const char * name;
       int abi_version;
       vpx_codec_caps_t caps;
       vpx_codec_init_fn_t init;
       vpx_codec_destroy_fn_t destroy;
       vpx_codec_ctrl_fn_map_t * ctrl_maps;
       vpx_codec_get_mmap_fn_t get_mmap;
       vpx_codec_set_mmap_fn_t set_mmap;
       構造体
       {{
           vpx_codec_peek_si_fn_t peek_si;
           vpx_codec_get_si_fn_t get_si;
           vpx_codec_decode_fn_tデコード;
           vpx_codec_get_frame_fn_t get_frame;
       } dec;
       構造体
       {{
           vpx_codec_enc_cfg_map_t * cfg_maps;
           vpx_codec_encode_fn_tエンコード;
           vpx_codec_get_cx_data_fn_t get_cx_data;
           vpx_codec_enc_config_set_fn_t cfg_set;
           vpx_codec_get_global_headers_fn_t get_glob_hdrs;
           vpx_codec_get_preview_frame_fn_t get_preview;
       } enc;
   };
        
   / *！\briefコールバック関数ポインタ/ユーザーデータペアストレージ*/
   typedef struct vpx_codec_priv_cb_pair
   {{
       連合
       {{
           vpx_codec_put_frame_cb_fn_t put_frame;
           vpx_codec_put_slice_cb_fn_t put_slice;
       };
       void * user_priv;
   } vpx_codec_priv_cb_pair_t;
        
   / *！\briefインスタンスのプライベートストレージ
    *
    *この構造は、アルゴリズムのinit関数によって割り当てられます. それ
    *2つの方法のいずれかで拡張できます. まず、2番目のアルゴリズム
    *特定の構造を割り当てることができ、privメンバーがポイントすることができます
    * それ. または、この構造をの最初のメンバーにすることもできます
    *アルゴリズム固有の構造、およびにキャストされたポインタ
    *適切なタイプ. 
    * /
   struct vpx_codec_priv
   {{
       unsigned int sz;
       vpx_codec_iface_t * iface;
       struct vpx_codec_alg_priv * alg_priv;
       const char * err_detail;
       vpx_codec_flags_t init_flags;
       構造体
       {{
           vpx_codec_priv_cb_pair_t put_frame_cb;
           vpx_codec_priv_cb_pair_t put_slice_cb;
       } dec;
       構造体
       {{
           struct vpx_fixed_buf cx_data_dst_buf;
           unsigned int cx_data_pad_before;
           unsigned int cx_data_pad_after;
           vpx_codec_cx_pkt_t cx_data_pkt;
       } enc;
   };
        
   #undef VPX_CTRL_USE_TYPE
   #define VPX_CTRL_USE_TYPE（id、typ）\
       static typ id ## __ value（va_list args）\
       {return va_arg（args、typ）;} \
       static typ id ## __ convert（void * x）\
       {\
        
           連合\
           {\
               void * x; \
               typ d; \
           } u; \
           ux = x; \
           udを返す;\
       }
        
   #undef VPX_CTRL_USE_TYPE_DEPRECATED
   #define VPX_CTRL_USE_TYPE_DEPRECATED（id、typ）\
       static typ id ## __ value（va_list args）\
       {return va_arg（args、typ）;} \
       static typ id ## __ convert（void * x）\
       {\
           連合\
           {\
               void * x; \
               typ d; \
           } u; \
           ux = x; \
           udを返す;\
       }
        
   #define CAST（id、arg）id ## __ value（arg）
   #define RECAST（id、x）id ## __ convert（x）
        
   /*内部ユーティリティ関数
    *
    *以下の関数は、アルゴリズム内で使用することを目的としています
    *vpx_codec_*データ構造を操作するためのユーティリティとして. 
    * /
   struct vpx_codec_pkt_list
   {{
       unsigned int cnt;
       unsigned int max;
       struct vpx_codec_cx_pkt pkts [1];
   };
        
   #define vpx_codec_pkt_list_decl（n）\
       共用体{structvpx_codec_pkt_listhead; \
           struct {struct vpx_codec_pkt_list head; \
               struct vpx_codec_cx_pkt pkts [n];} alloc;}
        
   #define vpx_codec_pkt_list_init（m）\
       （m）-> alloc.head.cnt = 0、\
       （m）-> alloc.head.max = \
       sizeof（（m）-> alloc.pkts）/ sizeof（（m）-> alloc.pkts [0]）
        
   int
   vpx_codec_pkt_list_add（struct vpx_codec_pkt_list *、
                          const struct vpx_codec_cx_pkt *）;
        
   const vpx_codec_cx_pkt_t *
   vpx_codec_pkt_list_get（struct vpx_codec_pkt_list * list、
                          vpx_codec_iter_t * iter）;
        
   #include <stdio.h>
   #include <setjmp.h>
   struct vpx_internal_error_info
   {{
       vpx_codec_err_t error_code;
       int has_detail;
       char detail [80];
       int setjmp;
       jmp_buf jmp;
   };
        
   static void vpx_internal_error（struct vpx_internal_error_info * info、
                                  vpx_codec_err_tエラー、
                                  const char * fmt、
                                  ...）
   {{
       va_list ap;
        
       info->error_code=エラー;
       info-> has_detail = 0;
        
       if（fmt）
       {{
           size_t sz = sizeof（info-> detail）;
        
           info-> has_detail = 1;
           va_start（ap、fmt）;
           vsnprintf（info-> detail、sz-1、fmt、ap）;
           va_end（ap）;
           info-> detail [sz-1] ='\ 0';
       }
        
       if（info-> setjmp）
           longjmp（info-> jmp、info-> error_code）;
   }
   #endif
        
   ----終了コードブロック----------------------------------------
        
20.20. vpx_decoder.h
   ----コードブロックを開始--------------------------------------
        
   / *
    * Copyright（c）2010、2011、Google Inc.無断複写・転載を禁じます. 
    *
    *このソースコードの使用はBSDスタイルのライセンスによって管理されています
    *ソースのルートにあるLICENSEファイルにあります
    * 木. 追加の知的財産権の付与は
    *ファイルPATENTSにあります. 貢献しているすべてのプロジェクト作成者は
    *ソースツリーのルートにあるAUTHORSファイルにあります. 
    * /
        
   / *！\defgroupデコーダーデコーダーアルゴリズムインターフェース
    * \ ingroup codec
    *この抽象化により、このデコーダーを使用するアプリケーションは簡単に
    *最小限のコード重複で複数のビデオフォーマットをサポートします. 
    *このセクションでは、すべてのデコーダーに共通のインターフェースについて説明します. 
    * @ {
    * /
        
   /*!\file vpx_decoder.h
    *\briefアプリケーションへのデコーダーアルゴリズムインターフェイスについて説明します. 
    *
    *このファイルは、アプリケーションと
    *ビデオデコーダアルゴリズム. 
    *
    * /
   #ifdef __cplusplus
   extern "C" {
   #endif
   #ifndef VPX_DECODER_H
   #define VPX_DECODER_H
   #include "vpx_codec.h"
        
       / *！\brief現在のABIバージョン番号
        *
        * \内部
        *このファイルがABIを変更するような方法で変更された場合、これは
        *値を上げる必要があります. 例には以下が含まれますが、これに限定されません
        * to、タイプの変更、列挙の削除または再割り当て、
        *構造体へのフィールドの追加/削除/再配置
        * /
   #define VPX_DECODER_ABI_VERSION（2 + VPX_CODEC_ABI_VERSION）
        
       / *！\briefデコーダー機能ビットフィールド
        *
        *各デコーダーは、サポートする機能を一部としてアドバタイズします
        *その::vpx_codec_iface_tインターフェース構造の. 機能
        *追加のインターフェースまたは機能であり、必須ではありません
        *デコーダーでサポートされます. 
        *
        *使用可能なフラグは、VPX_CODEC_CAP_*定義によって指定されます. 
        * /
   #define VPX_CODEC_CAP_PUT_SLICE 0x10000 / **<put_sliceを発行します
       コールバック*/
   #define VPX_CODEC_CAP_PUT_FRAME 0x20000 /**<put_frameを発行します
       コールバック*/
   #define VPX_CODEC_CAP_POSTPROC 0x40000 /**<後処理でデコードできます
       フレーム */
        
       / *！\brief初期化時機能の有効化
        *
        *特定のコーデック機能は初期化時に認識されている必要があります. 
        *適切なメモリ割り当てを可能にするため. 
        *
        *使用可能なフラグは、VPX_CODEC_USE_*定義によって指定されます. 
        * /
   #define VPX_CODEC_USE_POSTPROC 0x10000 /**<後処理がデコードされました
       フレーム */
        
       / *！\briefストリームのプロパティ
        *
        *この構造は、プロパティのクエリまたは設定に使用されます
        *デコードされたストリーム. アルゴリズムはこの構造を次のように拡張できます
        *szメンバーを設定することによるビットストリームに固有のデータ
        *適切に. 
        * /
        
       typedef struct vpx_codec_stream_info
       {{
           unsigned int sz; /**<この構造のサイズ*/
           unsigned int w; / ** <幅（または不明/デフォルトの場合は0）* /
           unsigned int h; / ** <高さ（または不明/デフォルトの場合は0）* /
           unsigned int is_kf; /**<現在のフレームはキーフレームです*/
       } vpx_codec_stream_info_t;
        
       /*必要な機能
        *
        ※以下の機能は、すべてに実装する必要があります
        *デコーダー. これらは、期待されるベースケース機能を表します
        *すべてのデコーダーの. 
        * /
        
       / *！\brief初期化構成
        *
        *この構造は、初期化時間構成オプションを渡すために使用されます
        *デコーダーに. 
        * /
       typedef struct vpx_codec_dec_cfg
       {{
           unsignedintスレッド; / ** <使用するスレッドの最大数、
               デフォルト1*/
           unsigned int w; /**<幅*/
           unsigned int h; /**<高さ*/
       } vpx_codec_dec_cfg_t; / **<structvpx_codec_dec_cfgのエイリアス*/
        
       / *！\briefデコーダーインスタンスを初期化します
        *
        *指定されたインターフェイスを使用してデコーダコンテキストを初期化します. 
        *アプリケーションはvpx_codec_dec_initコンビニエンスを呼び出す必要があります
        *この関数の代わりにマクロを直接使用して、
        *ABIバージョン番号パラメータが正しく初期化されています. 
        *
        * XMAモードの場合（VPX_CODEC_USE_XMAを設定することでアクティブになります
        *フラグパラメーター）、cfgパラメーターが指すストレージ
        *すべてのメモリマップが
        *設定されています. 
        *
        * \ param[in]ctxこのインスタンスのコンテキストへのポインタ. 
        * \ param[in]ifaceアルゴリズムインターフェイスへのポインタ
        * 使用する. 
        * \ param [in] cfg使用する構成（わかっている場合）. 多分
        * ヌル. 
        
        * \param[in]フラグVPX_CODEC_USE_のビットフィールド*フラグ
        * \ param [in]verABIバージョン番号. 次のように設定する必要があります
        * VPX_DECODER_ABI_VERSION
        * \ retval #VPX_CODEC_OK
        *デコーダーアルゴリズムが初期化されました. 
        * \ retval #VPX_CODEC_MEM_ERROR
        *メモリの割り当てに失敗しました. 
        * /
       vpx_codec_err_t vpx_codec_dec_init_ver（
           vpx_codec_ctx_t * ctx、
           vpx_codec_iface_t * iface、
           vpx_codec_dec_cfg_t * cfg、
           vpx_codec_flags_tフラグ、
           int ver）;
        
       / *！\ brief vpx_codec_dec_init_ver（）のコンビニエンスマクロ
        *
        *ABIバージョンパラメータが正しく設定されていることを確認します. 
        * /
   #define vpx_codec_dec_init（ctx、iface、cfg、flags）\
       vpx_codec_dec_init_ver（ctx、iface、cfg、flags、\
       VPX_DECODER_ABI_VERSION）
        
       / *！\briefバッファからストリーム情報を解析します
        *
        *ビットストリームの高レベルの解析を実行します. の建設
        *デコーダーコンテキストは必要ありません. 決定するために使用することができます
        *ビットストリームが適切な形式である場合、および抽出する
        *ストリームからの情報. 
        *
        * \ param[in]ifaceアルゴリズムインターフェースへのポインタ
        * \ param[in]data解析するデータのブロックへのポインタ
        * \ param[in]data_szデータバッファのサイズ
        * \ param [in、out]si更新する情報をストリーミングするためのポインタ. ザ
        *サイズメンバー
        * \ refは適切に初期化する必要がありますが、
        * \ refは、
        *アルゴリズム. このパラメータ\refは次のようになります
        * ヌル. 
        *
        * \ retval #VPX_CODEC_OK
        *ビットストリームは解析可能であり、ストリーム情報が更新されます
        * /
        
vpx_codec_err_t vpx_codec_peek_stream_info（vpx_codec_iface_t * iface、const uint8_t * data、unsigned int data_sz、vpx_codec_stream_info_t * si）;

       / *！\brief現在のストリームに関する情報を返します. 
        *
        *解析されたストリームに関する情報を返します
        *デコード中. 
        *
        * \ param[in]ctxこのインスタンスのコンテキストへのポインタ
        * \ param [in、out]si更新する情報をストリーミングするためのポインタ. ザ
        *サイズメンバー\refは適切である必要があります
        *初期化されましたが、\refが破壊される可能性があります
        *アルゴリズムによる. このパラメータ\ref
        *NULLになる場合があります. 
        *
        * \ retval #VPX_CODEC_OK
        *ビットストリームは解析可能であり、ストリーム情報が更新されます
        * /
       vpx_codec_err_t vpx_codec_get_stream_info（
           vpx_codec_ctx_t * ctx、
           vpx_codec_stream_info_t * si）;
        
       / *！\briefデータのデコード
        *
        *コード化されたデータのバッファを処理します. 処理結果が
        *新しいデコードされたフレームが利用可能になると、PUT_SLICEと
        *必要に応じて、PUT_FRAMEイベントが生成される場合があります. エンコードされた
        *データ\refはDTS（タイムスタンプのデコード）の順序で渡される必要があります. 
        *作成されるフレームは常にPTS（プレゼンテーション時間）になります
        *スタンプ）注文. 
        *
        * \ param[in]ctxこのインスタンスのコンテキストへのポインタ
        * \ param[in]data新しいコード化されたこのブロックへのポインタ
        * データ. NULLの場合、
        *VPX_CODEC_CB_PUT_FRAMEイベントが投稿されました
        *以前にデコードされたフレームの場合. 
        * \ param [in] data_szコード化されたデータのサイズ（バイト単位）. 
        * \ param[in]user_priv関連付けるアプリケーション固有のデータ
        *このフレームで. 
        * \param[in]期限デコーダーがすべきソフト期限
        *私たちの中で会おうとします. ゼロに設定
        *無制限. 
        *
        
        * \ returnコード化されたデータが処理された場合、＃VPX_CODEC_OKを返します
        *完全にそして将来の写真はなしでデコードすることができます
        * エラー. それ以外の場合は、他の説明を参照してください
        *回復可能性のための::vpx_codec_err_tのエラーコード
        *機能. 
        * /
       vpx_codec_err_t vpx_codec_decode（vpx_codec_ctx_t * ctx、
                                        const uint8_t * data、
                                        unsigned int data_sz、
                                        void * user_priv、
                                        長い締め切り）;
        
       / *！\briefデコードされたフレームイテレータ
        *
        *表示可能なフレームのリストを繰り返します. ザ
        *イテレータストレージを開始するには、NULLに初期化する必要があります
        *反復. この関数が戻ると反復が完了します
        * ヌル. 
        *
        *利用可能なフレームのリストは、完了時に有効になります
        * vpx_codec_decode呼び出しであり、次の呼び出しまで有効です
        *vpx_codec_decodeを呼び出します. 
        *
        * \ param[in]ctxこのインスタンスのコンテキストへのポインタ
        * \ param [in、out] iterイテレータストレージ、NULLに初期化
        *
        * \ return準備ができている場合は、画像へのポインタを返します
        * 画面. 生成されるフレームは常にPTSになります
        *（プレゼンテーションタイムスタンプ）注文. 
        * /
       vpx_image_t * vpx_codec_get_frame（vpx_codec_ctx_t * ctx、
                                        vpx_codec_iter_t * iter）;
        
       / *！\defgroupcap_put_frameフレームベースのデコード関数
        *
        ※以下の機能は、すべてに実装する必要があります
        *VPX_CODEC_CAP_PUT_FRAMEをアドバタイズするデコーダー
        * 容量. これらの関数を、そうでないコーデックに対して呼び出す
        *この機能をアドバタイズすると、エラーコードが発生します
        *返され、通常はVPX_CODEC_ERROR
        * @ {
        * /
        
       / *！\briefputフレームコールバックプロトタイプ
        *
        *このコールバックは、デコーダーによって呼び出され、
        *デコードされた画像データの可用性のアプリケーション. 
        * /
       typedef void（* vpx_codec_put_frame_cb_fn_t）（
           void * user_priv、
           const vpx_image_t * img）;
        
       / *！\briefフレーム完了の通知用に登録します. 
        *
        *デコードされたフレームのときに呼び出される特定の関数を登録します
        * 利用可能です. 
        *
        * \ param[in]ctxこのインスタンスのコンテキストへのポインタ
        * \ param[in]cbコールバック関数へのポインタ
        * \ param[in]user_privユーザーのプライベートデータ
        *
        * \ retval #VPX_CODEC_OK
        *コールバックは正常に登録されました. 
        * \ retval #VPX_CODEC_ERROR
        *デコーダーコンテキストが初期化されていないか、アルゴリズムに対応していません
        *スライス完了の投稿. 
        * /
       vpx_codec_err_t vpx_codec_register_put_frame_cb（
           vpx_codec_ctx_t * ctx、
           vpx_codec_put_frame_cb_fn_t cb、
           void * user_priv）;
        
       / *！@}-defgroupcap_put_frameを終了します*/
        
       / *！\defgroupcap_put_sliceスライスベースのデコード関数
        *
        ※以下の機能は、すべてに実装する必要があります
        *VPX_CODEC_CAP_PUT_SLICEをアドバタイズするデコーダー
        * 容量. これらの関数を、そうでないコーデックに対して呼び出す
        *この機能をアドバタイズすると、エラーコードが発生します
        *返され、通常はVPX_CODEC_ERROR
        * @ {
        * /
        
       / *！\briefputスライスコールバックプロトタイプ
        *
        *このコールバックは、デコーダーによって呼び出され、
        *部分的にデコードされた画像の可用性の適用
        * データ. 
        * /
        
       typedef void（* vpx_codec_put_slice_cb_fn_t）（
           void * user_priv、
           const vpx_image_t * img、
           const vpx_image_rect_t *有効、
           const vpx_image_rect_t * update）;
        
       / *！\briefスライス完了の通知用に登録します. 
        *
        *デコードされたスライス時に呼び出される特定の関数を登録します
        * 利用可能です. 
        *
        * \ param[in]ctxこのインスタンスのコンテキストへのポインタ
        * \ param[in]cbコールバック関数へのポインタ
        * \ param[in]user_privユーザーのプライベートデータ
        *
        * \ retval #VPX_CODEC_OK
        *コールバックは正常に登録されました. 
        * \ retval #VPX_CODEC_ERROR
        *デコーダーコンテキストが初期化されていないか、アルゴリズムに対応していません
        *スライス完了の投稿. 
        * /
       vpx_codec_err_t vpx_codec_register_put_slice_cb（
           vpx_codec_ctx_t * ctx、
           vpx_codec_put_slice_cb_fn_t cb、
           void * user_priv）;
        
       / *！@}-defgroup cap_put_slice*/を終了します
        
       / *！@}-defgroupデコーダーを終了します* /
        
#endif

   #ifdef __cplusplus
   }
   #endif
        
   #if！defined（VPX_CODEC_DISABLE_COMPAT）|| ！VPX_CODEC_DISABLE_COMPAT
   #include "vpx_decoder_compat.h"
   #endif
        
   ----終了コードブロック----------------------------------------
        
20.21. vpx_decoder_compat.h
   ----コードブロックを開始--------------------------------------
        
   / *
    * Copyright（c）2010、2011、Google Inc.無断複写・転載を禁じます. 
    *
    *このソースコードの使用はBSDスタイルのライセンスによって管理されています
    *ソースのルートにあるLICENSEファイルにあります
    * 木. 追加の知的財産権の付与は
    *ファイルPATENTSにあります. 貢献しているすべてのプロジェクト作成者は
    *ソースツリーのルートにあるAUTHORSファイルにあります. 
    * /
        
   / *！\defgroupデコーダー共通デコーダーアルゴリズムインターフェース
    *この抽象化により、このデコーダーを使用するアプリケーションは簡単に
    *最小限のコード重複で複数のビデオフォーマットをサポートします. 
    *このセクションでは、すべてのコーデックに共通のインターフェイスについて説明します. 
    * @ {
    * /
        
   /*！\ファイル
    *\briefバージョン1とバージョン2の間の互換性レイヤーを提供します
    *このAPI. 
    *
    *このインターフェースは非推奨になりました. 既存のコードのみが必要です
    *このインターフェースを利用するため、薄くなります
    *文書化. 既存のコードはvpx_codec_*に移植する必要があります
    *API. 
    * /
   #ifdef __cplusplus
   extern "C" {
   #endif
        
#ifndef VPX_DECODER_COMPAT_H #define VPX_DECODER_COMPAT_H

       / *！\briefデコーダーアルゴリズムの戻りコード*/
       typedef列挙型{
           / *！\brief操作はエラーなしで完了しました*/
           VPX_DEC_OK = VPX_CODEC_OK、
        
           / *！\brief不特定のエラー*/
           VPX_DEC_ERROR = VPX_CODEC_ERROR、
        
           / *！\briefメモリ操作に失敗しました*/
           VPX_DEC_MEM_ERROR = VPX_CODEC_MEM_ERROR、
        
           / *！\briefABIバージョンの不一致*/
           VPX_DEC_ABI_MISMATCH = VPX_CODEC_ABI_MISMATCH、
        
           / *！\brief指定されたビットストリームはサポートされていません. 
            *
            *ビットストリームを最高で解析できませんでした
            * レベル. デコーダーは続行できません. このエラー\ref
            *ストリームにとって致命的なものとして扱われるべきです. 
            * /
           VPX_DEC_UNSUP_BITSTREAM = VPX_CODEC_UNSUP_BITSTREAM、
        
           / *！\ briefエンコードされたビットストリームは、サポートされていない機能を使用します
            *
            *デコーダーは必要な機能を実装していません
            *エンコーダ. この戻りコードは、次の目的でのみ使用する必要があります. 
            *将来の写真が適切に表示されないようにする機能
            *デコードされました. このエラー\refは、致命的なものとして扱われる場合があります
            *ストリームまたは\refは、現在の致命的なものとして扱われる場合があります
            * Group of Pictures（GOP）. 
            * /
           VPX_DEC_UNSUP_FEATURE = VPX_CODEC_UNSUP_FEATURE、
        
           / *！\ briefこのストリームのコード化されたデータが壊れているか、
            * 不完全な
            *
            *現在のフレームのデコードに問題がありました. これ
            *戻りコードは、次のことを防ぐ障害にのみ使用する必要があります
            *将来の写真が適切にデコードされないようにします. このエラー
            * \ refはストリームにとって致命的として扱われる場合があります、または\refは
            *現在のGOPにとって致命的なものとして扱われます. デコードが
            *現在のGOPで継続、アーティファクトが存在する可能性があります. 
            * /
           VPX_DEC_CORRUPT_FRAME = VPX_CODEC_CORRUPT_FRAME、
        
           / *！\briefアプリケーション提供のパラメーターが無効です. 
            *
            * /
           VPX_DEC_INVALID_PARAM = VPX_CODEC_INVALID_PARAM、
        
           / *！\briefイテレータがリストの最後に到達しました. 
            *
            * /
           VPX_DEC_LIST_END = VPX_CODEC_LIST_END
        
       }
       vpx_dec_err_t;
        
       / *！\briefデコーダー機能ビットフィールド
        *
        *各デコーダーは、サポートする機能を一部としてアドバタイズします
        *その::vpx_dec_iface_tインターフェース構造の. 機能
        *追加のインターフェースまたは機能であり、必須ではありません
        *デコーダーでサポートされます. 
        *
        *使用可能なフラグは、VPX_DEC_CAP_*定義によって指定されます. 
        * /
       typedef int vpx_dec_caps_t;
   #define VPX_DEC_CAP_PUT_SLICE 0x0001 / **<put_sliceを発行します
                                            コールバック*/
   #define VPX_DEC_CAP_PUT_FRAME 0x0002 /**<put_frameを発行します
                                            コールバック*/
        
   #define VPX_DEC_CAP_XMA 0x0004 /**<外部メモリをサポート
                                            割り当て*/
        
       / *！\briefストリームのプロパティ
        *
        *この構造は、プロパティのクエリまたは設定に使用されます
        *デコードされたストリーム. アルゴリズムはこの構造を次のように拡張できます
        *szメンバーを設定することによるビットストリームに固有のデータ
        *適切に. 
        * /
   #if 1
       typedef vpx_codec_stream_info_t vpx_dec_stream_info_t;
   ＃そうしないと
       typedef struct
       {{
           unsigned int sz; /**<この構造のサイズ*/
           unsigned int w; / ** <幅（または不明/デフォルトの場合は0）* /
           unsigned int h; / ** <高さ（または不明/デフォルトの場合は0）* /
           unsigned int is_kf; /**<現在のフレームはキーフレームです*/
       } vpx_dec_stream_info_t;
        
#endif

       / *！\briefデコーダーのインターフェース構造. 
        *
        *関数ポインタおよびその他のプライベートデータが含まれています
        *デコーダーの実装. この構造は、
        * 応用. 
        * /
       typedef const struct vpx_codec_iface vpx_dec_iface_t;
       typedef struct vpx_codec_priv vpx_dec_priv_t;
        
       / *！\ brief Iterator
        *
        *リストの反復に使用される不透明なストレージ. 
        * /
       typedef vpx_codec_iter_t vpx_dec_iter_t;
        
       / *！\briefDecoderコンテキスト構造
        *
        *すべてのデコーダー\refは、このコンテキスト構造を完全にサポートする必要があります. 
        *一般に、このデータは非公開と見なす必要があります
        *デコーダーアルゴリズム、およびによって操作または検査されない
        *アプリケーションを呼び出します. アプリケーションは「名前」を参照できます
        *アルゴリズムの印刷可能な説明を取得するメンバー. 
        * /
   #if 1
       typedef vpx_codec_ctx_t vpx_dec_ctx_t;
   ＃そうしないと
       typedef struct
       {{
           const char * name; /**<印刷可能なインターフェース名*/
           vpx_dec_iface_t * iface; /**<インターフェイスポインタ*/
           vpx_dec_err_t err; /**<最後に返されたエラー*/
           vpx_dec_priv_t * priv; /**<アルゴリズムプライベートストレージ*/
       } vpx_dec_ctx_t;
   #endif
        
       / *！\briefビルド構成を返します
        *
        *のエンコードされたバージョンを含む印刷可能な文字列を返します
        *ビルド構成. これは、vpxのサポートに役立つ場合があります. 
        *
        * /
       const char * vpx_dec_build_config（void）非推奨;
        
       / *！\brief指定されたインターフェースの名前を返します
        *
        *指定されたデコーダーの名前の人間が読める文字列を返します
        * インターフェース. 
        *
        * \ param[in]ifaceインターフェイスポインタ
        *
        * /
       const char * vpx_dec_iface_name（
           vpx_dec_iface_t * iface）非推奨;
        
       / *！\briefエラー番号を印刷可能な文字列に変換します
        *
        *返された最後のエラーの人間が読める文字列を返します
        *アルゴリズムによる. 返されるエラーは1行で
        *改行文字は含まれません. 
        *
        *
        * \ param[in]errエラー番号. 
        *
        * /
       const char * vpx_dec_err_to_string（vpx_dec_err_t err）非推奨;
        
       / *！\briefデコーダコンテキストのエラー概要を取得します
        *
        *によって返された最後のエラーの人間が読める文字列を返します
        *アルゴリズム. 返されるエラーは1行で、
        *改行文字は含まれません. 
        *
        *
        * \ param[in]ctxこのインスタンスのコンテキストへのポインタ. 
        *
        * /
       const char * vpx_dec_error（vpx_dec_ctx_t * ctx）非推奨;
        
       / *！\briefデコーダコンテキストの詳細なエラー情報を取得します
        *
        *詳細情報を提供する人間が読める文字列を返します
        *最後のエラーについて. 
        *
        * \ param[in]ctxこのインスタンスのコンテキストへのポインタ. 
        *
        
        * \ retval NULL
        *詳細情報はありません. 
        * /
       const char * vpx_dec_error_detail（vpx_dec_ctx_t * ctx）非推奨;
        
       /*必要な機能
        *
        ※以下の機能は、すべてに実装する必要があります
        *デコーダー. これらは、期待されるベースケース機能を表します
        *すべてのデコーダーの. 
        * /
        
       / *！\briefデコーダーインスタンスを初期化します
        *
        *指定されたインターフェイスを使用してデコーダコンテキストを初期化します. 
        *アプリケーションはvpx_dec_initコンビニエンスマクロを呼び出す必要があります
        *この関数の代わりに、ABIを確実にするために
        *バージョン番号パラメータは正しく初期化されています. 
        *
        * \ param[in]ctxこのインスタンスのコンテキストへのポインタ. 
        * \ param[in]iface使用するアルゴリズムインターフェイスへのポインタ. 
        * \ param [in]verABIバージョン番号. 次のように設定する必要があります
        * VPX_DECODER_ABI_VERSION
        * \ retval #VPX_DEC_OK
        *デコーダーアルゴリズムが初期化されました. 
        * \ retval #VPX_DEC_MEM_ERROR
        *メモリの割り当てに失敗しました. 
        * /
       vpx_dec_err_t vpx_dec_init_ver（
           vpx_dec_ctx_t * ctx、
           vpx_dec_iface_t * iface、
           int ver）非推奨;
        
   #define vpx_dec_init（ctx、iface）\
       vpx_dec_init_ver（ctx、iface、VPX_DECODER_ABI_VERSION）
        
       / *！\briefデコーダーインスタンスを破棄します
        *
        *デコーダコンテキストを破棄し、関連するメモリを解放します
        *バッファ. 
        *
        * \ param[in]ctxこのインスタンスのコンテキストへのポインタ
        *
        * \ retval #VPX_DEC_OK
        *デコーダーアルゴリズムが初期化されました. 
        
        * \ retval #VPX_DEC_MEM_ERROR
        *メモリの割り当てに失敗しました. 
        * /
       vpx_dec_err_t vpx_dec_destroy（vpx_dec_ctx_t * ctx）非推奨;
        
       / *！\briefアルゴリズムの機能を取得します. 
        *
        *アルゴリズムの機能ビットフィールドを取得します
        * インターフェース. 
        *
        * \ param[in]ifaceアルゴリズムインターフェースへのポインタ
        *
        * /
       vpx_dec_caps_t vpx_dec_get_caps（
           vpx_dec_iface_t * iface）非推奨;
        
       / *！\briefバッファからストリーム情報を解析します
        *
        *ビットストリームの高レベルの解析を実行します. の建設
        *デコーダーコンテキストは必要ありません. 決定するために使用することができます
        *ビットストリームが適切な形式である場合、および抽出する
        *ストリームからの情報. 
        *
        * \ param[in]ifaceアルゴリズムインターフェースへのポインタ
        * \ param[in]data解析するデータのブロックへのポインタ
        * \ param[in]data_szデータバッファのサイズ
        * \ param [in、out]si更新する情報をストリーミングするためのポインタ. ザ
        *サイズメンバー\refは適切である必要があります
        *初期化されていますが、\refは
        *アルゴリズムによって破壊されました. これ
        *パラメータ\refはNULLである可能性があります. 
        *
        * \ retval #VPX_DEC_OK
        *ビットストリームは解析可能であり、ストリーム情報が更新されます
        * /
       vpx_dec_err_t vpx_dec_peek_stream_info（
                                vpx_dec_iface_t * iface、
                                const uint8_t * data、
                                unsigned int data_sz、
                                vpx_dec_stream_info_t * si）非推奨;
        
       / *！\brief現在のストリームに関する情報を返します. 
        *
        *解析されたストリームに関する情報を返します
        *デコード中. 
        *
        * \ param[in]ctxこのインスタンスのコンテキストへのポインタ
        * \ param [in、out]si更新する情報をストリーミングするためのポインタ. 
        *サイズメンバー\refは適切である必要があります
        *初期化されましたが、\refが破壊される可能性があります
        *アルゴリズムによる. このパラメータ\ref
        *NULLになる場合があります. 
        *
        * \ retval #VPX_DEC_OK
        *ビットストリームは解析可能であり、ストリーム情報が更新されます
        * /
       vpx_dec_err_t vpx_dec_get_stream_info（
           vpx_dec_ctx_t * ctx、
           vpx_dec_stream_info_t * si）非推奨;
        
       / *！\brief制御アルゴリズム
        *
        *この関数は、アルゴリズム固有のデータをと交換するために使用されます
        *デコーダーインスタンス. これは、機能を実装するために使用できます
        *特定のアルゴリズムに固有. 
        *
        *このラッパー関数はリクエストをヘルパーにディスパッチします
        *指定されたctrl_idに関連付けられた関数. 電話をかけようとします
        *この関数は透過的に機能しますが、次の場合は#VPX_DEC_ERRORを返します. 
        *リクエストをディスパッチできませんでした. 
        *
        * \ param[in]ctxこのインスタンスのコンテキストへのポインタ
        * \ param[in]ctrl_idアルゴリズム固有の制御
        *識別子
        * \ param [in、out]dataアルゴリズムと交換するデータ
        * 実例. 
        *
        * \ retval #VPX_DEC_OK
        *制御要求が処理されました. 
        * \ retval #VPX_DEC_ERROR
        *制御要求は処理されませんでした. 
        * \ retval #VPX_DEC_INVALID_PARAM
        *データが無効でした. 
        * /
       vpx_dec_err_t vpx_dec_control（vpx_dec_ctx_t * ctx、
                                     int ctrl_id、
                                     void * data）非推奨;
        
       / *！\briefデータのデコード
        *
        *コード化されたデータのバッファを処理します. 処理結果が
        *新しいデコードされたフレームが利用可能になり、
        *#VPX_DEC_CB_PUT_SLICEおよび#VPX_DEC_CB_PUT_FRAMEイベントは
        *必要に応じて生成されます. エンコードされたデータ\refを渡す必要があります
        * DTS（タイムスタンプのデコード）順. 生成されるフレームは常に
        * PTS（プレゼンテーションタイムスタンプ）の順序である. 
        *
        * \ param[in]ctxこのインスタンスのコンテキストへのポインタ
        * \ param[in]data新しいコード化されたこのブロックへのポインタ
        * データ. NULLの場合、VPX_DEC_CB_PUT_FRAME
        *以前のイベントが投稿されました
        *デコードされたフレーム. 
        * \ param [in] data_szコード化されたデータのサイズ（バイト単位）. 
        * \ param[in]user_priv関連付けるアプリケーション固有のデータ
        *このフレームで. 
        * \ param [in] rel_pts前のフレームを基準にしたPTS、
        * 我ら. 不明または利用できない場合は、
        * 零. 
        *
        * \ returnコード化されたデータが処理された場合、＃VPX_DEC_OKを返します
        *完全にそして将来の写真はなしでデコードすることができます
        * エラー. それ以外の場合は、他の説明を参照してください
        *回復可能性のための::vpx_dec_err_tのエラーコード
        *機能. 
        * /
       vpx_dec_err_t vpx_dec_decode（
           vpx_dec_ctx_t * ctx、
           uint8_t * data、
           unsigned int data_sz、
           void * user_priv、
           int rel_pts）非推奨;
        
       / *！\briefデコードされたフレームイテレータ
        *
        *表示可能なフレームのリストを繰り返します. ザ
        *イテレータストレージを開始するには、NULLに初期化する必要があります
        *反復. この関数が戻ると反復が完了します
        * ヌル. 
        *
        *利用可能なフレームのリストは、完了時に有効になります
        * vpx_dec_decode呼び出しであり、次の呼び出しまで有効です. 
        *vpx_dec_decodeに. 
        *
        * \ param[in]ctxこのインスタンスのコンテキストへのポインタ
        * \ param [in out] iterイテレータストレージ、NULLに初期化
        
        *
        * \ return準備ができている場合は、画像へのポインタを返します
        * 画面. 生成されるフレームは常にPTSになります
        *（プレゼンテーションタイムスタンプ）注文. 
        * /
       vpx_image_t * vpx_dec_get_frame（vpx_dec_ctx_t * ctx、
                                      vpx_dec_iter_t * iter）非推奨;
        
       / *！\defgroupcap_put_frameフレームベースのデコード関数
        *
        ※以下の機能は、すべてに実装する必要があります
        *VPX_DEC_CAP_PUT_FRAME機能をアドバタイズするデコーダー. 
        *これをアドバタイズしないコーデックに対してこれらの関数を呼び出す
        *機能により、エラーコードが返されます. 
        *通常はVPX_DEC_ERROR@{
        * /
        
       / *！\briefputフレームコールバックプロトタイプ
        *
        *このコールバックは、デコーダーによって呼び出され、
        *デコードされた画像データの可用性のアプリケーション. 
        * /
       typedef void（* vpx_dec_put_frame_cb_fn_t）（
               void * user_priv、
               const vpx_image_t * img）;
        
       / *！\briefフレーム完了の通知用に登録します. 
        *
        *デコードされたフレームのときに呼び出される特定の関数を登録します
        * 利用可能です. 
        *
        * \ param[in]ctxこのインスタンスのコンテキストへのポインタ
        * \ param[in]cbコールバック関数へのポインタ
        * \ param[in]user_privユーザーのプライベートデータ
        *
        * \ retval #VPX_DEC_OK
        *コールバックは正常に登録されました. 
        * \ retval #VPX_DEC_ERROR
        *デコーダーコンテキストが初期化されていないか、アルゴリズムに対応していません
        *スライス完了の投稿. 
        * /
       vpx_dec_err_t vpx_dec_register_put_frame_cb（
               vpx_dec_ctx_t * ctx、
               vpx_dec_put_frame_cb_fn_t cb、
               void * user_priv）非推奨;
        
       / *！@}-defgroupcap_put_frameを終了します*/
        
       / *！\defgroupcap_put_sliceスライスベースのデコード関数
        *
        ※以下の機能は、すべてに実装する必要があります
        *VPX_DEC_CAP_PUT_SLICE機能をアドバタイズするデコーダー. 
        *これをアドバタイズしないコーデックに対してこれらの関数を呼び出す
        *機能により、エラーコードが返されます. 
        *通常はVPX_DEC_ERROR
        * @ {
        * /
        
       / *！\briefputスライスコールバックプロトタイプ
        *
        *このコールバックは、デコーダーによって呼び出され、
        *部分的にデコードされた画像の可用性の適用
        * データ. 
        * /
       typedef void（* vpx_dec_put_slice_cb_fn_t）（void * user_priv、
               const vpx_image_t * img、
               const vpx_image_rect_t *有効、
               const vpx_image_rect_t * update）;
        
       / *！\briefスライス完了の通知用に登録します. 
        *
        *デコードされたスライス時に呼び出される特定の関数を登録します
        * 利用可能です. 
        *
        * \ param[in]ctxこのインスタンスのコンテキストへのポインタ
        * \ param[in]cbコールバック関数へのポインタ
        * \ param[in]user_privユーザーのプライベートデータ
        *
        * \ retval #VPX_DEC_OK
        *コールバックは正常に登録されました. 
        * \ retval #VPX_DEC_ERROR
        *デコーダーコンテキストが初期化されていないか、アルゴリズムに対応していません
        *スライス完了の投稿. 
        * /
       vpx_dec_err_t vpx_dec_register_put_slice_cb（vpx_dec_ctx_t * ctx、
               vpx_dec_put_slice_cb_fn_t cb、
               void * user_priv）非推奨;
        
       / *！@}-defgroup cap_put_slice*/を終了します
        
       / *！\defgroupcap_xma外部メモリ割り当て関数
        *
        ※以下の機能は、すべてに実装する必要があります
        *VPX_DEC_CAP_XMA機能をアドバタイズするデコーダー. 
        *これをアドバタイズしないコーデックに対してこれらの関数を呼び出す
        *機能により、エラーコードが返されます. 
        *通常はVPX_DEC_ERROR
        * @ {
        * /
        
       / *！\briefメモリマップエントリ
        *
        *この構造は、メモリのプロパティを含むために使用されます
        *セグメント. リクエストフェーズでデコーダーによって入力されます. 
        *要求された割り当てが行われると、アプリケーションを呼び出すことによって
        *実行されました. 
        * /
   #if 1
   #define VPX_DEC_MEM_ZERO 0x1 /**<セグメントは次のようにゼロ化する必要があります
                                          割り当て*/
   #define VPX_DEC_MEM_WRONLY 0x2 /**<セグメントは
                                          読み取り可能*/
   #define VPX_DEC_MEM_FAST 0x4 / ** <場合は、高速メモリに配置します
                                          利用可能 */
       typedef struct vpx_codec_mmap vpx_dec_mmap_t;
   ＃そうしないと
       typedef struct vpx_dec_mmap
       {{
           / *
            ※以下のメンバーは、リクエスト時にコーデックによって設定されます
            *セグメント
            * /
           unsigned int id; /**<セグメントの識別子
                                       コンテンツ */
           unsigned long sz; / ** <セグメントのサイズ（バイト単位）* /
           unsigned int align; /**<必要な位置合わせ
                                       セグメント、バイト単位* /
           unsignedintフラグ; /**<セグメントを含むビットフィールド
                                       プロパティ */
   #define VPX_DEC_MEM_ZERO 0x1 /**<セグメントは次のようにゼロ化する必要があります
                                          割り当て*/
   #define VPX_DEC_MEM_WRONLY 0x2 /**<セグメントは
                                          読み取り可能*/
   #define VPX_DEC_MEM_FAST 0x4 / ** <場合は、高速メモリに配置します
                                          利用可能 */
        
           /*以下のメンバーは
            *割り当て機能*/
           void * base; /**<割り当てられたポインタへのポインタ
                                       セグメント*/
           void（* dtor）（struct vpx_dec_mmap * map）; /**<デストラクタから
                                                         電話 */
           void * priv; /**<アロケータプライベートストレージ*/
       } vpx_dec_mmap_t;
   #endif
        
       / *！\brief外部割り当てでデコーダーインスタンスを初期化します
        *モード
        *
        *指定されたインターフェイスを使用してデコーダコンテキストを初期化します. 
        *アプリケーションはvpx_dec_xma_initコンビニエンスを呼び出す必要があります
        *この関数の代わりにマクロを直接使用して、
        *ABIバージョン番号パラメータが正しく初期化されています. 
        *
        * \ param[in]ctxこのインスタンスのコンテキストへのポインタ. 
        * \ param[in]ifaceアルゴリズムインターフェイスへのポインタ
        * 使用する. 
        * \ param [in]verABIバージョン番号. 次のように設定する必要があります
        * VPX_DECODER_ABI_VERSION
        * \ retval #VPX_DEC_OK
        *デコーダーアルゴリズムが初期化されました. 
        * \ retval #VPX_DEC_ERROR
        *デコーダーはXMAモードをサポートしていません. 
        * /
       vpx_dec_err_t vpx_dec_xma_init_ver（vpx_dec_ctx_t * ctx、
                                          vpx_dec_iface_t * iface、
                                          int ver）非推奨;
   #define vpx_dec_xma_init（ctx、iface）\
       vpx_dec_xma_init_ver（ctx、iface、VPX_DECODER_ABI_VERSION）
        
       / *！\brief割り当てるセグメントのリストを繰り返し処理します. 
        *
        *割り当てるセグメントのリストを繰り返し処理します. ザ
        *イテレータストレージを開始するには、NULLに初期化する必要があります
        *反復. この関数が戻ると反復が完了します
        *VPX_DEC_LIST_END. 割り当てるのに必要なメモリの量は
        *エンコードされたストリームのサイズによって異なります. これの意味は
        *ストリーム情報構造は割り当て時に認識されている必要があります
        * 時間. vpx_dec_peek_stream_info（）を入力できます
        * 働き. デコードするストリームが
        *割り当て時に利用可能で、固定サイズを要求する必要があります. 
        *デコーダーは、より大きなストリームをデコードできなくなります
        *割り当て時に使用されるサイズ. 
        
        *
        * \ param[in]ctxこのインスタンスのコンテキストへのポインタ. 
        * \ param[out]mmapメモリマップエントリへのポインタ
        *入力します. 
        * \ param[in]siストリーム情報へのポインタ. 
        * \ param [in out] iterイテレータストレージ、NULLに初期化
        *
        * \ retval #VPX_DEC_OK
        *メモリマップエントリが入力されました. 
        * \ retval #VPX_DEC_ERROR
        *デコーダーはXMAモードをサポートしていません. 
        * \ retval #VPX_DEC_MEM_ERROR
        *ストリーム情報からセグメントサイズを判別できません. 
        * /
       vpx_dec_err_t vpx_dec_get_mem_map（
           vpx_dec_ctx_t * ctx、
           vpx_dec_mmap_t * mmap、
           const vpx_dec_stream_info_t * si、
           vpx_dec_iter_t * iter）非推奨;
        
       / *！\briefデコーダーインスタンスに割り当てられたセグメントを特定します
        *
        *割り当てられたセグメントのリストをデコーダーに格納します. セグメント
        * \ refは、読み取られた順序で渡される必要があります
        * vpx_dec_get_mem_map（）、ただし、任意のグループで渡すことができます
        * サイズ. セグメント\refは1回だけ設定する必要があります. 割り当て
        *関数\refは、vpx_dec_mmap_t::baseメンバーであることを確認する必要があります
        *はNULLではありません. セグメントにクリーンアップ処理が必要な場合（例：
        * free（）またはclose（））を呼び出してから、vpx_dec_mmap_t :: dtor
        *メンバー\refを入力する必要があります. 
        *
        * \ param[in]ctxこのインスタンスのコンテキストへのポインタ. 
        * \ param[in]mmaps最初のメモリマップへのポインタ
        *リストのエントリ. 
        * \ param[in]num_mapsこれで設定されているエントリの数
        * 時間
        *
        * \ retval #VPX_DEC_OK
        *セグメントはデコーダーコンテキストに保存されました. 
        * \ retval #VPX_DEC_ERROR
        *デコーダーはXMAモードをサポートしていません. 
        * \ retval #VPX_DEC_MEM_ERROR
        *セグメントのベースアドレスが設定されていないか、セグメントがすでに設定されている
        *保存されます. 
        
* /

vpx_dec_err_t vpx_dec_set_mem_map（vpx_dec_ctx_t * ctx、vpx_dec_mmap_t * mmaps、unsigned int num_maps）非推奨;

       / *！@}-defgroup cap_xma*/を終了します
       / *！@}-defgroupデコーダーを終了します* /
        
   #endif
   #ifdef __cplusplus
   }
   #endif
        
   ----終了コードブロック----------------------------------------
        
20.22. vpx_image.c
   ----コードブロックを開始--------------------------------------
        
   / *
    * Copyright（c）2010、2011、Google Inc.無断複写・転載を禁じます. 
    *
    *このソースコードの使用はBSDスタイルのライセンスによって管理されています
    *ソースのルートにあるLICENSEファイルにあります
    * 木. 追加の知的財産権の付与は
    *ファイルPATENTSにあります. 貢献しているすべてのプロジェクト作成者は
    *ソースツリーのルートにあるAUTHORSファイルにあります. 
    * /
        
   #include <stdlib.h>
   #include <string.h>
   #include "vpx / vpx_image.h"
        
static vpx_image_t * img_alloc_helper（vpx_image_t * img、vpx_img_fmt_t fmt、unsigned int d_w、unsigned int d_h、unsigned int stride_align、unsigned char * img_data）{

       unsigned int h、w、s、xcs、ycs、bps;
       int align;
        
       / * align==0をalign==1のように扱います*/
       if（！stride_align）
           stride_align = 1;
        
       / *アライメントを検証します（2の累乗である必要があります）* /
       if（stride_align＆（stride_align-1））
           goto失敗;
        
       /*この形式のサンプルサイズを取得します*/
       スイッチ（fmt）
       {{
       ケースVPX_IMG_FMT_RGB32：
       ケースVPX_IMG_FMT_RGB32_LE：
       ケースVPX_IMG_FMT_ARGB：
       ケースVPX_IMG_FMT_ARGB_LE：
           bps = 32;
           壊す;
       ケースVPX_IMG_FMT_RGB24：
       ケースVPX_IMG_FMT_BGR24：
           bps = 24;
           壊す;
       ケースVPX_IMG_FMT_RGB565：
       ケースVPX_IMG_FMT_RGB565_LE：
       ケースVPX_IMG_FMT_RGB555：
       ケースVPX_IMG_FMT_RGB555_LE：
       ケースVPX_IMG_FMT_UYVY：
       ケースVPX_IMG_FMT_YUY2：
       ケースVPX_IMG_FMT_YVYU：
           bps = 16;
           壊す;
       ケースVPX_IMG_FMT_I420：
       ケースVPX_IMG_FMT_YV12：
       ケースVPX_IMG_FMT_VPXI420：
       ケースVPX_IMG_FMT_VPXYV12：
           bps = 12;
           壊す;
       デフォルト：
           bps = 16;
           壊す;
       }
        
       /*このフォーマットのクロマシフト値を取得します*/
       スイッチ（fmt）
       {{
       ケースVPX_IMG_FMT_I420：
       ケースVPX_IMG_FMT_YV12：
       ケースVPX_IMG_FMT_VPXI420：
       ケースVPX_IMG_FMT_VPXYV12：
           xcs = 1;
           壊す;
       デフォルト：
           xcs = 0;
           壊す;
       }
        
       スイッチ（fmt）
       {{
       ケースVPX_IMG_FMT_I420：
       ケースVPX_IMG_FMT_YV12：
       ケースVPX_IMG_FMT_VPXI420：
       ケースVPX_IMG_FMT_VPXYV12：
           ycs = 1;
           壊す;
       デフォルト：
           ycs = 0;
           壊す;
       }
        
       /*クロマサブサンプリングを前提としてストレージサイズを計算します*/
       align =（1 << xcs）-1;
       w =（d_w + align）＆〜align;
       align =（1 << ycs）-1;
       h =（d_h + align）＆〜align;
       s =（fmt＆VPX_IMG_FMT_PLANAR）？w：bps * w / 8;
       s =（s + stride_align-1）＆〜（stride_align-1）;
        
       /*新しい画像を割り当てます*/
       if（！img）
       {{
           img =（vpx_image_t *）calloc（1、sizeof（vpx_image_t））;
        
（！img）gotoが失敗した場合;

           img-> self_allocd = 1;
       }
        
       そうしないと
       {{
           memset（img、0、sizeof（vpx_image_t））;
       }
        
       img-> img_data = img_data;
        
       if（！img_data）
       {{
           img-> img_data = malloc（（fmt＆VPX_IMG_FMT_PLANAR）？
             h * w * bps / 8：h * s）;
           img-> img_data_owner = 1;
       }
        
       if（！img-> img_data）
           goto失敗;
        
       img-> fmt = fmt;
       img-> w = w;
       img-> h = h;
       img-> x_chroma_shift = xcs;
       img-> y_chroma_shift = ycs;
       img-> bps = bps;
        
       /*歩幅を計算します*/
       img-> stride [VPX_PLANE_Y] = img-> stride [VPX_PLANE_ALPHA] = s;
       img-> stride [VPX_PLANE_U] = img-> stride [VPX_PLANE_V] = s >> xcs;
        
       /*画像全体のデフォルトのビューポート*/
       if（！vpx_img_set_rect（img、0、0、d_w、d_h））
           imgを返す;
        
   不合格：
       vpx_img_free（img）;
       NULLを返します. 
   }
        
   vpx_image_t * vpx_img_alloc（vpx_image_t * img、
                              vpx_img_fmt_t fmt、
                              unsigned int d_w、
                              unsigned int d_h、
                              unsigned int stride_align）
   {{
       img_alloc_helper（img、fmt、d_w、d_h、stride_align、NULL）;を返します. 
   }
        
   vpx_image_t * vpx_img_wrap（vpx_image_t * img、
                             vpx_img_fmt_t fmt、
                             unsigned int d_w、
                             unsigned int d_h、
                             unsigned int stride_align、
                             unsigned char * img_data）
   {{
       img_alloc_helper（img、fmt、d_w、d_h、stride_align、
         img_data）;
   }
        
   int vpx_img_set_rect（vpx_image_t * img、
                        unsigned int x、
                        unsigned int y、
                        unsigned int w、
                        unsigned int h）
   {{
       unsigned char * data;
        
       if（x + w <= img-> w && y + h <= img-> h）
       {{
           img-> d_w = w;
           img-> d_h = h;
        
           /*平面ポインタを計算します*/
           if（！（img-> fmt＆VPX_IMG_FMT_PLANAR））
           {{
               img-> planets [VPX_PLANE_PACKED] =
                   img-> img_data + x * img-> bps / 8 + y *
                     img-> stride [VPX_PLANE_PACKED];
           }
           そうしないと
           {{
               data = img-> img_data;
        
               if（img-> fmt＆VPX_IMG_FMT_HAS_ALPHA）
               {{
                   img-> planets [VPX_PLANE_ALPHA] =
                       データ+x+ y * img-> stride [VPX_PLANE_ALPHA];
                   データ+=img-> h * img-> stride [VPX_PLANE_ALPHA];
               }
        
               img-> planets [VPX_PLANE_Y] =
                 データ+x+ y * img-> stride [VPX_PLANE_Y];
               データ+=img-> h * img-> stride [VPX_PLANE_Y];
        
               if（！（img-> fmt＆VPX_IMG_FMT_UV_FLIP））
               {{
                   img-> planets[VPX_PLANE_U]=データ
                                          +（x >> img-> x_chroma_shift）
                                          +（y >> img-> y_chroma_shift）*
                                            img-> stride [VPX_PLANE_U];
                   データ+=（img-> h >> img-> y_chroma_shift）*
                                            img-> stride [VPX_PLANE_U];
                   img-> planets[VPX_PLANE_V]=データ
                                          +（x >> img-> x_chroma_shift）
                                          +（y >> img-> y_chroma_shift）*
                                            img-> stride [VPX_PLANE_V];
               }
               そうしないと
               {{
                   img-> planets[VPX_PLANE_V]=データ
                                          +（x >> img-> x_chroma_shift）
                                          +（y >> img-> y_chroma_shift）*
                                            img-> stride [VPX_PLANE_V];
                   データ+=（img-> h >> img-> y_chroma_shift）*
                                            img-> stride [VPX_PLANE_V];
                   img-> planets[VPX_PLANE_U]=データ
                                          +（x >> img-> x_chroma_shift）
                                          +（y >> img-> y_chroma_shift）*
                                            img-> stride [VPX_PLANE_U];
               }
           }
        
           0を返します. 
       }
        
       -1を返します. 
   }
        
   void vpx_img_flip（vpx_image_t * img）
   {{
       / *注：計算ポインタ調整計算では、
        *rhsを署名付きタイプに昇格させたい. セクション6.3.1.8
        * ISO C99規格[ISO-C99]のは、
        *調整パラメータは符号なし、ストライドパラメータは
        * unsignedにプロモートされ、lhsが大きい場合にエラーが発生します
        *rhsよりもタイプします. 
        * /
       img-> planets [VPX_PLANE_Y] + =（署名済み）
         （img-> d_h-1）* img-> stride [VPX_PLANE_Y];
       img-> stride [VPX_PLANE_Y] = -img-> stride [VPX_PLANE_Y];
        
       img-> planets [VPX_PLANE_U] + =（署名済み）
         （（img-> d_h >> img-> y_chroma_shift）-1）
                               * img-> stride [VPX_PLANE_U];
       img-> stride [VPX_PLANE_U] = -img-> stride [VPX_PLANE_U];
        
       img-> planets [VPX_PLANE_V] + =（署名済み）
                               （（img-> d_h >> img-> y_chroma_shift）-1）*
                               img-> stride [VPX_PLANE_V];
       img-> stride [VPX_PLANE_V] = -img-> stride [VPX_PLANE_V];
        
       img-> planets [VPX_PLANE_ALPHA] + =（署名済み）
         （img-> d_h-1）* img-> stride [VPX_PLANE_ALPHA];
       img-> stride [VPX_PLANE_ALPHA] = -img-> stride [VPX_PLANE_ALPHA];
   }
        
   void vpx_img_free（vpx_image_t * img）
   {{
       if（img）
       {{
           if（img-> img_data && img-> img_data_owner）
               free（img-> img_data）;
        
           if（img-> self_allocd）
               free（img）;
       }
   }
        
   ----終了コードブロック----------------------------------------
        
20.23. vpx_image.h
   ----コードブロックを開始--------------------------------------
        
   / *
    * Copyright（c）2010、2011、Google Inc.無断複写・転載を禁じます. 
    *
    *このソースコードの使用はBSDスタイルのライセンスによって管理されています
    *ソースのルートにあるLICENSEファイルにあります
    * 木. 追加の知的財産権の付与は
    *ファイルPATENTSにあります. 貢献しているすべてのプロジェクト作成者は
    *ソースツリーのルートにあるAUTHORSファイルにあります. 
    * /
        
   /*！\ファイル
    * \briefvpxイメージ記述子と関連するものについて説明します
    * オペレーション
    *
    * /
        
   #ifdef __cplusplus
   extern "C" {
   #endif
        
#ifndef VPX_IMAGE_H #define VPX_IMAGE_H

       / *！\brief現在のABIバージョン番号
        *
        * \内部
        *このファイルがABIを変更するような方法で変更された場合、これは
        *値を上げる必要があります. 例には以下が含まれますが、これに限定されません
        * to、タイプの変更、列挙の削除または再割り当て、
        *構造体へのフィールドの追加/削除/再配置
        * /
   #define VPX_IMAGE_ABI_VERSION（1）/ ** <\ hiddeninitializer * /
        
   #define VPX_IMG_FMT_PLANAR 0x100 /**<画像は平面です
                                              フォーマット */
   #define VPX_IMG_FMT_UV_FLIP 0x200 /**<V平面がU平面に先行
                                              メモリ内*/
   #define VPX_IMG_FMT_HAS_ALPHA 0x400 /**<画像にアルファチャネルがあります
                                              成分 */
        
       / *！\briefサポートされている画像形式のリスト*/
       typedef enum vpx_img_fmt {
           VPX_IMG_FMT_NONE、
           VPX_IMG_FMT_RGB24、/**<24ビット/ピクセルパックRGB*/
           VPX_IMG_FMT_RGB32、/**<32ビット/ピクセルパック0RGB*/
           VPX_IMG_FMT_RGB565、/ ** <16ビット/ピクセル、565 * /
           VPX_IMGFMT_RGB555、/ ** <16ビット/ピクセル、555 * /
           VPX_IMG_FMT_UYVY、/**<UYVYパックYUV*/
           VPX_IMG_FMT_YUY2、/**<YUYVパックYUV*/
           VPX_IMG_FMT_YVYU、/**<YVYUパックYUV*/
           VPX_IMG_FMT_BGR24、/**<24ビット/ピクセルパックBGR*/
           VPX_IMG_FMT_RGB32_LE、/**<32ビットパックBGR0*/
           VPX_IMG_FMT_ARGB、/ ** <32ビットパックARGB、alpha = 255 * /
           VPX_IMG_FMT_ARGB_LE、/ ** <32ビットパックBGRA、alpha = 255 * /
           VPX_IMG_FMT_RGB565_LE、/ ** <16ビット/ピクセル、
                                        gggbbbbb rrrrrggg * /
           VPX_IMG_FMT_RGB555_LE、/ ** <16ビット/ピクセル、
                                        gggbbbbb 0rrrrrgg * /
           VPX_IMG_FMT_YV12 = VPX_IMG_FMT_PLANAR |
             VPX_IMG_FMT_UV_FLIP | 1、/**<平面YVU*/
           VPX_IMG_FMT_I420 = VPX_IMG_FMT_PLANAR | 2、
        
           VPX_IMG_FMT_VPXYV12 = VPX_IMG_FMT_PLANAR |
             VPX_IMG_FMT_UV_FLIP | 3、/ ** <平面4：2：0形式
                                            vpx色空間*/
           VPX_IMG_FMT_VPXI420 = VPX_IMG_FMT_PLANAR | 4 /**<平面
             vpx色空間を使用した4：2：0形式* /
       }
       vpx_img_fmt_t; /**<列挙型vpx_img_fmtのエイリアス*/
        
   #if！defined（VPX_CODEC_DISABLE_COMPAT）|| ！VPX_CODEC_DISABLE_COMPAT
   / ** \ deprecated#VPX_IMG_FMT_PLANARを使用*/
   #define IMG_FMT_PLANAR VPX_IMG_FMT_PLANAR
   / ** \ deprecated#VPX_IMG_FMT_UV_FLIPを使用*/
   #define IMG_FMT_UV_FLIP VPX_IMG_FMT_UV_FLIP
   / ** \ deprecated#VPX_IMG_FMT_HAS_ALPHAを使用*/
   #define IMG_FMT_HAS_ALPHA VPX_IMG_FMT_HAS_ALPHA
        
       / *！\briefサポートされている画像形式の非推奨リスト
        *\deprecated新しいコードは#vpx_img_fmtを使用する必要があります
        * /
   #define img_fmt vpx_img_fmt
       / *！\enumimg_fmtの簡単なエイリアス. 
        *\deprecated新しいコードは#vpx_img_fmt_tを使用する必要があります
        * /
   #define img_fmt_t vpx_img_fmt_t
        
   / ** \ deprecated#VPX_IMG_FMT_NONEを使用*/
   #define IMG_FMT_NONE VPX_IMG_FMT_NONE
   / ** \ deprecated＃VPX_IMG_FMT_RGB24を使用* /
   #define IMG_FMT_RGB24 VPX_IMG_FMT_RGB24
   / ** \ deprecated＃VPX_IMG_FMT_RGB32を使用* /
   #define IMG_FMT_RGB32 VPX_IMG_FMT_RGB32
   / ** \ deprecated＃VPX_IMG_FMT_RGB565を使用* /
   #define IMG_FMT_RGB565 VPX_IMG_FMT_RGB565
   / ** \ deprecated＃VPX_IMG_FMT_RGB555を使用* /
   #define IMG_FMT_RGB555 VPX_IMG_FMT_RGB555
   / ** \ deprecated#VPX_IMG_FMT_UYVYを使用*/
   #define IMG_FMT_UYVY VPX_IMG_FMT_UYVY
   / ** \ deprecated＃VPX_IMG_FMT_YUY2を使用* /
   #define IMG_FMT_YUY2 VPX_IMG_FMT_YUY2
   / ** \ deprecated#VPX_IMG_FMT_YVYUを使用*/
   #define IMG_FMT_YVYU VPX_IMG_FMT_YVYU
   / ** \ deprecated＃VPX_IMG_FMT_BGR24を使用* /
   #define IMG_FMT_BGR24 VPX_IMG_FMT_BGR24
   / ** <\ deprecated#VPX_IMG_FMT_RGB32_LEを使用*/
   #define IMG_FMT_RGB32_LE VPX_IMG_FMT_RGB32_LE
   / ** \ deprecated#VPX_IMG_FMT_ARGBを使用*/
   #define IMG_FMT_ARGB VPX_IMG_FMT_ARGB
        
   / ** \ deprecated#VPX_IMG_FMT_ARGB_LEを使用*/
   #define IMG_FMT_ARGB_LE VPX_IMG_FMT_ARGB_LE
   / ** \ deprecated#VPX_IMG_FMT_RGB565_LEを使用*/
   #define IMG_FMT_RGB565_LE VPX_IMG_FMT_RGB565_LE
   / ** \ deprecated#VPX_IMG_FMT_RGB555_LEを使用*/
   #define IMG_FMT_RGB555_LE VPX_IMG_FMT_RGB555_LE
   / ** \ deprecated＃VPX_IMG_FMT_YV12を使用* /
   #define IMG_FMT_YV12 VPX_IMG_FMT_YV12
   / ** \ deprecated＃VPX_IMG_FMT_I420を使用* /
   #define IMG_FMT_I420 VPX_IMG_FMT_I420
   / ** \ deprecated＃VPX_IMG_FMT_VPXYV12を使用* /
   #define IMG_FMT_VPXYV12 VPX_IMG_FMT_VPXYV12
   / ** \ deprecated#VPX_IMG_FMT_VPXI420を使用*/
   #define IMG_FMT_VPXI420 VPX_IMG_FMT_VPXI420
   #endif / * VPX_CODEC_DISABLE_COMPAT * /
        
       / **\brief画像記述子*/
       typedef struct vpx_image
       {{
           vpx_img_fmt_t fmt; /**<画像形式*/
        
           /*画像ストレージの寸法*/
           unsigned int w; /**<保存された画像の幅*/
           unsigned int h; /**<保存された画像の高さ*/
        
           /*画像表示サイズ*/
           unsigned int d_w; /**<表示される画像の幅*/
           unsigned int d_h; /**<表示される画像の高さ*/
        
           /*クロマサブサンプリング情報*/
           unsigned int x_chroma_shift; / ** <サブサンプリング順序、X * /
           unsigned int y_chroma_shift; / ** <サブサンプリング順序、Y * /
        
           /*画像データポインタ. * /
   #define VPX_PLANE_PACKED 0 /**<すべてのパック形式に使用*/
   #define VPX_PLANE_Y 0 / ** <Y（輝度）平面* /
   #define VPX_PLANE_U 1 / ** <U（クロマ）平面* /
   #define VPX_PLANE_V 2 / ** <V（クロマ）平面* /
   #define VPX_PLANE_ALPHA 3 / ** <A（透明）平面* /
   #if！defined（VPX_CODEC_DISABLE_COMPAT）|| ！VPX_CODEC_DISABLE_COMPAT
   #define PLANE_PACKED VPX_PLANE_PACKED
   #define PLANE_Y VPX_PLANE_Y
   #define PLANE_U VPX_PLANE_U
   #define PLANE_V VPX_PLANE_V
   #define PLANE_ALPHA VPX_PLANE_ALPHA
   #endif
        
           unsigned char * planets [4]; /**<左上のピクセルへのポインタ
           各平面のq*/
           int stride [4]; /**<各平面の行間のストライド*/
        
           int bps; / ** <サンプルあたりのビット数（パック形式の場合）* /
        
           / *次のメンバーは、アプリケーションによって次のように設定できます. 
            *データをこの画像に関連付けます. 
            * /
           void * user_priv; / ** <は、アプリケーションによって次のように設定できます. 
                                    データをこの画像に関連付けます. * /
        
           /*以下のメンバーはプライベートとして扱われる必要があります. * /
           unsigned char * img_data; /**<プライベート*/
           int img_data_owner; /**<プライベート*/
           int self_allocd; /**<プライベート*/
       } vpx_image_t; / **<structvpx_imageのエイリアス*/
        
       / **\briefサーフェス上の長方形の表現*/
       typedef struct vpx_image_rect
       {{
           unsigned int x; /**<左端の列*/
           unsigned int y; /**<最上行*/
           unsigned int w; /**<幅*/
           unsigned int h; /**<高さ*/
       } vpx_image_rect_t; / **<structvpx_image_rectのエイリアス*/
        
       / *！\ brief記述子を開き、ストレージを割り当てます
        *下にある画像
        *
        *指定された形式の画像を保存するための記述子を返します. 
        *記述子のストレージはヒープに割り当てられます. 
        *
        * \ param[in]img記述子のストレージへのポインター. 
        *このパラメータがNULLの場合、ストレージ
        *記述子に割り当てられます
        *ヒープ上. 
        * \ param[in]fmt画像の形式
        * \ param[in]d_w画像の幅
        * \ param[in]d_h画像の高さ
        * \ param [in] align各行の配置（バイト単位）
        * 画像. 
        *
        *\return初期化された画像記述子へのポインタを返します. 
        * imgパラメータがnull以外の場合、imgの値
        *パラメータが返されます. 
        * /
        
vpx_image_t * vpx_img_alloc（vpx_image_t * img、vpx_img_fmt_t fmt、unsigned int d_w、unsigned int d_h、unsigned int align）;

       / *！\ brief既存のストレージを使用して、記述子を開きます
        *下にある画像
        *
        *指定された形式の画像を保存するための記述子を返します. 
        *記述子のストレージは他の場所に割り当てられており、
        *記述子はそのストレージを「ラップ」することが望まれます. 
        *
        * \ param[in]img記述子のストレージへのポインター. 
        *このパラメータがNULLの場合、ストレージ
        *記述子は
        *ヒープに割り当てられます. 
        * \ param[in]fmt画像の形式
        * \ param[in]d_w画像の幅
        * \ param[in]d_h画像の高さ
        * \ param [in] align各行の配置（バイト単位）
        * 画像. 
        * \ param[in]img_data画像に使用するストレージ
        *
        *\return初期化された画像記述子へのポインタを返します. 
        * imgパラメータがnull以外の場合、imgの値
        *パラメータが返されます. 
        * /
       vpx_image_t * vpx_img_wrap（vpx_image_t * img、
                                 vpx_img_fmt_t fmt、
                                 unsigned int d_w、
                                 unsigned int d_h、
                                 unsigned int align、
                                 unsigned char * img_data）;
        
       / *！\briefの表示部分を識別する長方形を設定します
        * 画像
        *
        *画像に表示されている長方形（ビューポート）を更新します
        *指定された座標とサイズに一致するサーフェス. 
        *
        * \ param[in]img画像記述子
        * \ param[in]x左端の列
        * \ param[in]y最上行
        * \ param [in] w width
        * \ param[in]h高さ
        *
        
*要求された長方形が有効な場合は\return0、それ以外の場合は*ゼロ以外. * / int vpx_img_set_rect（vpx_image_t * img、unsigned int x、unsigned int y、unsigned int w、unsigned int h）;

       / *！\ brief画像を垂直方向に反転します（上から下）
        *
        *画像記述子のポインタとストライドを調整して作成します
        *画像は逆さまに参照されます. 
        *
        * \ param[in]img画像記述子
        * /
       void vpx_img_flip（vpx_image_t * img）;
        
       / *！\brief画像記述子を閉じます
        *
        *イメージに関連付けられている割り当てられたすべてのストレージを解放します
        *記述子. 
        *
        * \ param[in]img画像記述子
        * /
       void vpx_img_free（vpx_image_t * img）;
        
   #endif
   #ifdef __cplusplus
   }
   #endif
        
   ----終了コードブロック----------------------------------------
        
20.24. vpx_integer.h
   ----コードブロックを開始--------------------------------------
        
   / *
    * Copyright（c）2010、2011、Google Inc.無断複写・転載を禁じます. 
    *
    *このソースコードの使用はBSDスタイルのライセンスによって管理されています
    *ソースのルートにあるLICENSEファイルにあります
    * 木. 追加の知的財産権の付与は
    *ファイルPATENTSにあります. 貢献しているすべてのプロジェクト作成者は
    *ソースツリーのルートにあるAUTHORSファイルにあります. 
    * /
        
#ifndef VPX_INTEGER_H #define VPX_INTEGER_H

   / * ptrdiff_t、size_t、wchar_t、NULLを取得します* /
   #include <stddef.h>
        
   #if defined（_MSC_VER）|| 定義済み（VPX_EMULATE_INTTYPES）
   typedef signed char int8_t;
   typedef署名された短いint16_t;
   typedef signed int int32_t;
   typedef unsigned char uint8_t;
   typedef unsigned short uint16_t;
   typedef unsigned int uint32_t;
        
   #if defined（_MSC_VER）
   typedef署名済み__int64int64_t;
   typedef unsigned __int64 uint64_t;
   #define PRId64 "I64d"
   #endif
        
   #ifdef HAVE_ARMV6
   typedef unsigned int int_fast16_t;
   ＃そうしないと
   typedef署名されたshortint_fast16_t;
   #endif
   typedef signed char int_fast8_t;
   typedef unsigned char uint_fast8_t;
        
#ifndef _UINTPTR_T_DEFINED typedef unsigned int uintptr_t; #endif

＃そうしないと

   /*ほとんどのプラットフォームにはC99標準整数型があります. * /
        
   #if defined（__ cplusplus）&&！defined（__ STDC_FORMAT_MACROS）
   #define __STDC_FORMAT_MACROS
   #endif
   #include <stdint.h>
   #include <inttypes.h>
        
#endif

#endif

   ----終了コードブロック----------------------------------------
        
20.25. 著者ファイル
   アーロン・ワトリー<awatry@gmail.com>
        
   エイドリアングランジ<agrange@google.com>
        
   アレックスコンバース<alex.converse@gmail.com>
        
   Andoni Morales Alastruey <ylatuya@gmail.com>
        
   Andres Mejia <mcitadel@gmail.com>
        
   Attila Nagy <attilanagy@google.com>
        
   ファビオペドレッティ<fabio.ped@libero.it>
        
   フランクガリガン<fgalligan@google.com>
        
   Fredrik Soederquist <fs@opera.com>
        
   フリッツ・ケーニッヒ<frkoenig@google.com>
        
   Gaute Strokkenes <gaute.strokkenes@broadcom.com>
        
   Giuseppe Scrivano <gscrivano@gnu.org>
        
   Guillermo Ballester Valor <gbvalor@gmail.com>
        
   Henrik Lundin <hlundin@google.com>
        
   ジェームズベリー<jamesberry@google.com>
        
   James Zern <jzern@google.com>
        
   Jan Kratochvil <jan.kratochvil@redhat.com>
        
   Jeff Muizelaar <jmuizelaar@mozilla.com>
        
   ジム・バンコスキー<jimbankoski@google.com>
        
   Johann Koenig <johannkoenig@google.com>
        
   John Koleszar <jkoleszar@google.com>
        
   ジャスティン・クリフト<justin@salasaga.org>
        
   Justin Lebar <justin.lebar@gmail.com>
        
   ルカ・バルバート<lu_zero@gentoo.org>
        
   加藤誠<makoto.kt@gmail.com>
        
   Martin Ettl <ettl.martin78@googlemail.com>
        
   Michael Kohler <michaelkohler@live.com>
        
   Mikhal Shemer <mikhal@google.com>
        
   パスカルマッシミーノ<pascal.massimino@gmail.com>
        
   パトリックウェスティン<patrik.westin@gmail.com>
        
   ポールウィルキンス<paulwilkins@google.com>
        
   Pavol Rusnak <stick@gk2.sk>
        
   Philip Jaegenstedt <philipj@opera.com>
        
   スコット・ラバーンウェイ<slavarnway@google.com>
        
   Tero Rintaluoma <teror@google.com>
        
   ティモシーB.テリベリー<tterribe@xiph.org>
        
   トム・フィネガン<tomfinegan@google.com>
        
   Yaowu Xu <yaowu@google.com>
        
   Yunqing Wang <yunqingwang@google.com>
        
Google Inc.

Mozilla Foundation

Xiph.Org Foundation

20.26. ライセンス
Copyright（c）2010、2011、Google Inc.無断複写・転載を禁じます. 

次の条件が満たされている場合、変更の有無にかかわらず、ソース形式およびバイナリ形式での再配布および使用が許可されます. 

oソースコードの再配布では、上記の著作権表示、この条件のリスト、および次の免責事項を保持する必要があります. 

oバイナリ形式での再配布では、上記の著作権表示、この条件のリスト、および以下の免責事項を、配布に付属するドキュメントやその他の資料に複製する必要があります. 

o事前の書面による特別な許可なしに、Googleの名前またはその貢献者の名前を、このソフトウェアから派生した製品を推奨または宣伝するために使用することはできません. 

このソフトウェアは、著作権所有者および寄稿者によって「現状有姿」で提供され、商品性および特定目的への適合性の黙示の保証を含むがこれに限定されない、明示または黙示の保証は否認されます. いかなる場合も、著作権所有者または寄稿者は、直接的、間接的、偶発的、特別、例示的、または結果的な損害（代替の商品またはサービスの調達、使用、データ、または利益の損失を含むがこれらに限定されない）に対して責任を負わないものとします. またはビジネスの中断）ただし、契約、無過失責任、または不法行為（過失またはその他を含む）にかかわらず、このソフトウェアの使用から何らかの形で生じた責任の理論に基づいて、このソフトウェアの使用から生じたもの. 

20.27. 特許
追加の知的財産権付与（特許）

「この実装」とは、WebMプロジェクトの一部としてGoogleが配布する著作権で保護された作品を意味します. 

Googleは、これにより、永続的、世界的、非独占的、無料、ロイヤリティフリー、取消不能（このセクションに記載されている場合を除く）の特許ライセンスを付与します.  、およびその他の方法で、VP8のこの実装の内容を実行、変更、および伝播します. このようなライセンスは、現在Googleが所有し、将来取得する、Googleがライセンスを取得できる、このVP8の実装によって必然的に侵害される特許請求にのみ適用されます. この付与には、この実装のさらなる変更の結果としてのみ侵害されるクレームは含まれていません. 

21.セキュリティに関する考慮事項
[RFC4732]および[RFC3552]で概説されているように、VP8デコーダーは適切なセキュリティの考慮事項を考慮に入れる必要があります. デコーダーが悪意のあるペイロードに対して堅牢であることが非常に重要です. 悪意のあるペイロードによって、デコーダーが割り当てられたメモリをオーバーランしたり、過度のリソースを消費したりしてはなりません. エンコーダーの問題は通常まれですが、同じことがエンコーダーにも当てはまります. 悪意のあるストリームデータにより、エンコーダが誤動作してはなりません. これにより、攻撃者がトランスコーディングゲートウェイにアクセスできるようになる可能性があります. 

22.参考文献
22.1. 規範的参照
[RFC2119] Bradner、S.、「要件レベルを示すためにRFCで使用するキーワード」、BCP 14、RFC 2119、1997年3月. 

22.2. 有益な参考文献
[ベル]ベル、T. 、クリアリー、J. 、およびI.ウィッテン、「テキスト圧縮」、1990年. 

[ISO-C99]国際標準化機構、「情報技術-プログラミング言語-C」、ISO / IEC 9899：1999、1999. 

[ITU-R_BT.601] International Telecommunication Union、「ITU BT.601-7：標準4：3およびワイドスクリーン16：9アスペクト比のデジタルテレビのスタジオエンコーディングパラメータ」、2011年3月. 

[Kernighan] Kernighan、B. and D. Ritchie、 "The C Programming Language（2nd edition）"、April1988. 

[Loeffler] Loeffler、C.、Ligtenberg、A.、and G. Moschytz、 "Practical Fast 1-D DCT Algorithms with 11 Multiplications"、1989年5月. 

[RFC3552] Rescorla、E.およびB. Korver、「セキュリティの考慮事項に関するRFCテキストを作成するためのガイドライン」、BCP 72、RFC 3552、2003年7月. 

[RFC4732] Handley、M.、Ed. 、Rescorla、E.、Ed. 、およびIAB、「Internet Denial-of-ServiceConsiderations」、RFC 4732、2006年12月. 

[シャノン]シャノン、C. 、「通信の数学的理論」、ベルシステムテクニカルジャーナルVol. 27、pp.379-423および623-656、1948年7月および10月. 

著者の住所

James Bankoski Google Inc.

Eメール：jimbankoski@google.com

JohnKoleszarGoogleInc. 

Eメール：jkoleszar@google.com

Lou Quillio Google Inc.

メール：louquillio@google.com

Janne Salonen Google Inc.

Eメール：jsalonen@google.com

PaulWilkinsGoogleInc. 

Eメール：paulwilkins@google.com

Yaowu Xu Google Inc.

メール：yaowu@google.com