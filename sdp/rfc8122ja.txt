RFCトランス
プライバシーポリシー
コンタクト
イチジク
@ tex2e
8122
RFC 8122-セッション記述プロトコル（SDP）日本語訳のトランスポート層セキュリティ（TLS）プロトコルを介したコネクション型メディアトランスポート
URL：https：//tools.ietf.org/html/rfc8122
パッケージ：RFC 8122-セッション記述プロトコル（SDP）のトランスポート層セキュリティ（TLS）プロトコルを介したコネクション型メディアトランスポート
編集編集：自動生成
[検索] [txt | html | pdf | with errata | bibtex] [Tracker] [WG] [Email] [Diff1] [Diff2] [Nits]
        
差出人：draft-ietf-mmusic-4572-update-13提案された標準更新者：8844正誤表存在インターネット技術特別調査委員会（IETF）J. Lennoxコメントの要求：8122 Vidyo廃止：4572 C. Holmbergカテゴリ：標準トラックEricsson ISSN：2070 -1721 2017年3月

セッション記述プロトコル（SDP）のトランスポート層セキュリティ（TLS）プロトコルを介したコネクション型メディアトランスポート

概要

このドキュメントでは、Session Description Protocol（SDP）を使用して、トランスポート層セキュリティ（TLS）プロトコルを介してセキュアなコネクション型メディアトランスポートセッションを確立する方法を指定します. これは、SDPプロトコル識別子「TCP / TLS」を定義します. また、TLSセッションに提示される証明書を識別するSDPの「フィンガープリント」属性の構文とセマンティクスも定義します. このメカニズムにより、セッション記述の整合性が保証されている限り、TLS接続を介したメディア転送を安全に確立できます. 

このドキュメントは、複数のフィンガープリントの使用法を明確にすることにより、RFC4572を廃止します. 

このメモのステータス

これはインターネット標準化過程の文書です. 

このドキュメントは、インターネット技術特別調査委員会（IETF）の製品です. これは、IETFコミュニティのコンセンサスを表しています. パブリックレビューを受け、Internet Engineering Steering Group（IESG）による公開が承認されました. インターネット標準の詳細については、RFC7841のセクション2を参照してください. 

このドキュメントの現在のステータス、正誤表、およびフィードバックの提供方法に関する情報は、http：//www.rfc-editor.org/info/rfc8122で入手できます. 

著作権表示

Copyright（c）2017 IETFTrustおよびドキュメントの作成者として特定された人物. 全著作権所有. 

このドキュメントは、このドキュメントの発行日に有効なBCP 78およびIETFドキュメントに関連するIETFトラストの法的規定（http://trustee.ietf.org/license-info）の対象となります. これらのドキュメントは、このドキュメントに関するあなたの権利と制限を説明しているため、注意深く確認してください. このドキュメントから抽出されたコードコンポーネントには、Trust LegalProvisionsのセクション4.eで説明されているSimplifiedBSD Licenseテキストが含まれている必要があり、Simplified BSDLicenseで説明されているように保証なしで提供されます. 

目次

   1.はじめに. . . . . . . . . . . . . . . . . . . . . . . . 3
     1.1. RFC4572からの変更. . . . . . . . . . . . . . . . . . 4
   2.用語. . . . . . . . . . . . . . . . . . . . . . . . . 4
   3.概要. . . . . . . . . . . . . . . . . . . . . . . . . . 4
     3.1. SDP動作モード. . . . . . . . . . . . . . . . . . 4
     3.2. 脅威モデル. . . . . . . . . . . . . . . . . . . . . . 5
     3.3. 自己署名証明書の必要性. . . . . . . . . . 6
     3.4. TLS接続のSDP記述の例. . . . . . . 6
   4.プロトコル識別子. . . . . . . . . . . . . . . . . . . . 7
   5.指紋属性. . . . . . . . . . . . . . . . . . . . 7
     5.1. 複数の指紋. . . . . . . . . . . . . . . . . . 9
   6.エンドポイントの識別. . . . . . . . . . . . . . . . . . . 10
     6.1. 証明書の選択. . . . . . . . . . . . . . . . . . . 10
     6.2. 証明書の提示. . . . . . . . . . . . . . . . 11
   7.セキュリティに関する考慮事項. . . . . . . . . . . . . . . . . . . 12
   8.IANAの考慮事項. . . . . . . . . . . . . . . . . . . . . 14
   9.参照. . . . . . . . . . . . . . . . . . . . . . . . . 15
     9.1. 規範的参照. . . . . . . . . . . . . . . . . . 15
     9.2. 有益な参考資料. . . . . . . . . . . . . . . . . 16
   謝辞. . . . . . . . . . . . . . . . . . . . . . . . . 18
   著者のアドレス. . . . . . . . . . . . . . . . . . . . . . . 18
        
1.はじめに
セッション記述プロトコル（SDP）[8]は、アナウンスまたは招待状でマルチメディアセッションを記述するための汎用フォーマットを提供します. 多くのアプリケーションでは、マルチメディアセッションの一部として、コネクション型トランスポートを使用するメディアストリームを確立することが望ましいです. RFC 4145「セッション記述プロトコル（SDP）でのTCPベースのメディアトランスポート」[7]は、このようなコネクション型ストリームを記述および確立するための一般的なメカニズムを指定しています. ただし、直接サポートするトランスポートプロトコルはTCPのみです. 多くの場合、セッション参加者は、メディアセッションの機密性、データの整合性、および認証を提供したいと考えています. したがって、このドキュメントはTCPベースのメディア仕様を拡張して、セッションの説明でトランスポート層セキュリティ（TLS）プロトコルを使用するメディアセッションを記述できるようにします[10]. 

TLSプロトコルにより、アプリケーションは、機密性とデータの整合性を提供するチャネルを介して通信できます. ただし、TLS仕様では、特定のプロトコルがこのセキュリティで保護されたチャネルを確立して使用する方法は指定されていません. 特に、TLSは、認証証明書をTLS上で実行されるプロトコルの問題として、どのように解釈および検証するかという問題を残しています. このドキュメントでは、コネクション型メディアトランスポートの場合のそのような使用法を指定します. 

この問題を複雑にしているのは、メディアを交換するエンドポイントが、有名なルート証明機関（CA）によって署名された認証証明書を取得できないことがよくあることです. ほとんどの認証局は、署名された証明書、特にホストベースの証明書に対して課金します. さらに、認証局は署名された証明書を正しい当事者に発行していることを確認できなければならないため、署名された証明書を取得するにはかなりの管理オーバーヘッドがあります. さらに、多くの場合、エンドポイントのIPアドレスとホスト名は動的です. たとえば、DHCPから取得できます. DHCPリース期間中有効なCA署名付き証明書を取得することは実用的ではありません. このようなホストの場合、通常、自己署名証明書が唯一のオプションです. この仕様は、SDP記述の整合性が保証されている場合に、自己署名証明書を安全に使用できるようにするメカニズムを定義します. これにより、エンドポイントは、セッションの説明内に「証明書フィンガープリント」と呼ばれる証明書の安全なハッシュを含めることができます. 提供された証明書のフィンガープリントがセッションの説明にあるものと一致する場合、エンドホストは自己署名証明書も信頼できます. 

このドキュメントの残りの部分は、次のようにレイアウトされています. 問題と脅威のモデルの概要はセクション3に記載されています. セクション4は、SDPでTLSベースのコネクション型メディアを確立するための基本的なメカニズムを示しています. セクション5では、SDPフィンガープリント属性について説明します. これは、SDPコンテンツの整合性が保証されていることを前提として、自己署名証明書の安全な使用を可能にします. セクション6では、提示されるX.509証明書と、それらがTLSでどのように使用されるかについて説明します. セクション7では、追加のセキュリティに関する考慮事項について説明します. 

1.1. RFC4572からの変更
このドキュメントはRFC4572 [20]を廃止しますが、古い実装との下位互換性を維持しています. RFC 4572 [20]からの変更点は次のとおりです. 

o複数の「fingerprint」属性を使用して、特定の証明書に関連付けられたフィンガープリント（さまざまなハッシュ関数を使用して計算）を伝送したり、複数の証明書に関連付けられたフィンガープリントを伝送したりできることを明確にします. 

o複数の指紋が提供されている場合の指紋照合手順を明確にします. 

oより強力な暗号スイートで優先ハッシュ関数を更新し、証明書のフィンガープリントと証明書の署名を計算するために同じハッシュ関数を使用する必要をなくします. 

2.用語
このドキュメントのキーワード「MUST」、「MUST NOT」、「REQUIRED」、「SHALL」、「SHALL NOT」、「SHOULD」、「SHOULD NOT」、「RECOMMENDED」、「MAY」、「OPTIONAL」は次のとおりです.  RFC 2119 [3]で説明されているように解釈されます. 

3.概要
このセクションでは、コネクション型メディアストリームのTLSトランスポートを促進する脅威モデルについて説明します. また、エンドシステムが自己署名証明書を使用する必要性についても詳しく説明します. 

3.1. SDP動作モード
マルチメディアセッションには、アドバタイズとオファーアンサーの2つの主要な操作モードがあります. アドバタイズされたセッションは、より単純なモードです. このモードでは、サーバーは、何らかの方法で、サーバーが利用可能にしているマルチメディアセッションのSDPセッション記述を公開します. この動作モードの典型的な例は、Session Announcement Protocol（SAP）[15]であり、SDPセッションの説明が定期的に既知のマルチキャストグループに送信されます. 

従来、これらの説明にはマルチキャスト会議が含まれますが、ユニキャストセッションも可能です. （明らかに、コネクション型メディアはマルチキャストを使用できません. ）セッション記述の受信者は、セッション記述で公開されているアドレスに接続します. これらの受信者は、セッションの説明の広告主に以前は知られていない可能性があります. 

あるいは、SDP会議はオファー-アンサーモードで動作することができます[4]. このモードでは、マルチメディアセッションの2人の参加者が、それらの間でマルチメディアセッションをネゴシエートできます. このモデルでは、一方の参加者がもう一方の参加者にその観点から目的のセッションの説明を提供し、もう一方の参加者が独自の観点から目的のセッションで応答します. このモードでは、セッションの各参加者は他の参加者の知識を持っています. これは、Session Initiation Protocol（SIP）[17]で使用される動作モードです. 

3.2. 脅威モデル
マルチメディア会議の参加者は、メディアセッションの機密性、データの整合性、および認証を保証したいと考えることがよくあります. このセクションでは、さまざまなタイプの攻撃者と、これらの保証に違反しようとする方法について説明します. 次に、TLSプロトコルを使用して攻撃者を阻止する方法について説明します. 

最も単純なタイプの攻撃者は、マルチメディアセッションに関連するトラフィックを受動的にリッスンする攻撃者です. この攻撃者は、たとえば、会議の参加者の1人と同じローカルエリアまたはワイヤレスネットワーク上にいる可能性があります. この種の攻撃者は、接続のデータの整合性や認証を脅かすことはなく、TLSのほとんどすべての操作モードでメディアストリームの機密性を提供できます. 

より高度なのは、ネットワークを介して自分のデータトラフィックを送信できるが、有効なトラフィックを変更またはリダイレクトできない攻撃者です. SDPの「アドバタイズされた」操作モードでは、これはほとんど攻撃とは見なされません. メディアセッションは、ネットワーク上のどこからでも開始されることが期待されています. ただし、SDPのオファー/アンサーモードでは、このタイプの攻撃はより深刻です. 攻撃者は、セッションの一方または両方のエンドポイントへの接続を開始して、エンドポイントになりすましたり、中間者として通信を傍受したりする可能性があります. これらの攻撃を阻止するために、TLSはエンドポイント証明書を使用します. 証明書の秘密鍵が危険にさらされていない限り、エンドポイントには、証明書を検証するための外部的に信頼されたメカニズム（最も一般的には相互に信頼された証明機関）があります. 

最後に、最も深刻なタイプの攻撃者は、セッションの説明を変更またはリダイレクトできる攻撃者です. たとえば、侵害された、または悪意のあるSIPプロキシサーバーです. TLS自体も、TLSを使用するメカニズムも、そのような攻撃者からSDPセッションを保護することはできません. 代わりに、SDP記述自体を何らかのメカニズムで保護する必要があります. たとえば、SIPは、S / MIME [22]を使用してセッション記述を保護する方法を定義します. 

3.3. 自己署名証明書の必要性
SDPセッションの説明は、マルチメディアセッションに参加する必要のあるエンドポイントによって作成されます. SIP電話などの多くの場合、このようなエンドポイントには動的に構成されたIPアドレスとホスト名があり、ほぼゼロの構成で展開する必要があります. このようなエンドポイントの場合、実際の目的では、有名な認証局によって署名された証明書を取得することは不可能です. 

2つのエンドポイントに事前の関係がない場合、攻撃者が中間者攻撃を開始しないという保証がないため、通常、自己署名証明書は信頼できません. ただし、幸いなことに、SDPセッション記述の整合性が保証されれば、それらのSDP記述自体を事前の関係と見なすことができます. 証明書はセッション記述自体に安全に記述できます. これは、SDP属性として証明書の安全なハッシュまたは「証明書フィンガープリント」を提供することによって行われます. このメカニズムについては、セクション5で説明します. 

3.4. TLS接続のSDP記述の例
図1は、TLSを介したT.38ファックスセッションの可用性を通知するSDPオファーを示しています. 簡潔にするために、この例ではセッションの説明の主要部分を省略し、「m」行とその属性のみを示しています. （この例は、protoパラメータと指紋属性を除​​いてRFC 4145 [7]の最初の例と同じです. ）例のTLS固有の属性の説明については、後続のセクションを参照してください. 

注：RFCのフォーマット規則により、このドキュメントでは、内容が72文字を超える行にSDPを分割します. バックスラッシュ文字は、この線の折り畳みが行われた場所を示します. このバックスラッシュとそれに続くCRLFおよび空白は、実際のSDPコンテンツには表示されません. 

m=image 54111 TCP/TLS t38
c=IN IP4 192.0.2.2
a=setup:passive
a=connection:new
a=fingerprint:SHA-256 \
   12:DF:3E:5D:49:6B:19:E5:7C:AB:4A:AD:B9:B1:3F:82:18:3B:54:02:12:DF: \
   3E:5D:49:6B:19:E5:7C:AB:4A:AD
a=fingerprint:SHA-1 \
   4A:AD:B9:B1:3F:82:18:3B:54:02:12:DF:3E:5D:49:6B:19:E5:7C:AB
        
図1：TLSメディアストリームを提供するSDPの説明の例

4.プロトコル識別子
SDPの「m」行は、特に、セッションのメディアに使用されるトランスポートプロトコルを指定します. トランスポートプロトコル識別子の説明については、SDP [8]の「メディアの説明」セクションを参照してください. 

この仕様は、プロトコル識別子「TCP / TLS」を定義します. これは、説明されているメディアがTCPを介したトランスポート層セキュリティプロトコル[10]を使用することを示します. （他のトランスポートプロトコルでのTLSの使用については、このドキュメントでは説明していません. ）「TCP / TLS」プロトコル識別子は、上位層プロトコルではなく、トランスポートプロトコルのみを記述します. 「TCP / TLS」を指定する「m」行は、アプリケーションがTLSで実行されていることを示すために、fmt識別子を使用してプロトコルをさらに修飾する必要があります. 

この識別子で記述されたメディアセッションは、RFC 4145 [7]で定義された手順に従います. また、その仕様で定義されているSDP属性、「setup」および「connection」も使用します. 

5.指紋属性
TLSセッションの当事者は、TLSハンドシェイク手順の一部として認証証明書を提示することにより、IDを示します. 認証証明書は、RFC 3279 [5]、5280 [11]、および4055 [6]でプロファイルされているように、X.509 [2]証明書です. 

メディアストリームを接続に関連付け、メディアストリームへの不正なバージイン攻撃を防ぐために、エンドポイントは証明書のフィンガープリントを提供する必要があります. TLS接続用に提示されたX.509証明書がSDPで提示されたフィンガープリントと一致する場合、エンドポイントは、SDPの作成者が実際に接続のイニシエーターであると確信できます. 

証明書のフィンガープリントは、証明書の識別符号化規則（DER）形式の安全な一方向ハッシュです. （証明書のフィンガープリントは、X.509証明書を操作するツールによって広くサポートされています. たとえば、コマンド「openssl x509 -fingerprint」を使用すると、opensslパッケージのコマンドラインツールで証明書のフィンガープリントが印刷され、Mozillaおよびインターネットの証明書マネージャーが印刷されます. エクスプローラーは、証明書の詳細を表示するときにそれらを表示します. ）

フィンガープリントは、SDPでは属性（「a」行）として表されます. これは、使用されるハッシュ関数の名前と、それに続くハッシュ値自体で構成されます. ハッシュ値は、コロンで区切られた大文字の16進バイトのシーケンスとして表されます. バイト数はハッシュ関数で定義されます. （これは、opensslおよびブラウザーの証明書マネージャーで使用される構文です. たとえば、分離されていない小文字の16進バイトを使用するHTTPダイジェスト認証[24]でハッシュ値を表すために使用される構文とは異なります. 他のアプリケーションとの整合性指紋の数がより重要であると考えられました. ）

フィンガープリント属性の正式な構文は、図2の拡張バッカスナウア記法[9]に示されています. この構文は、SDP [8]のBNF構文を拡張したものです. 

属性= /指紋属性

finger-attribute = "fingerprint" "：" hash-funcSPフィンガープリント

   hash-func = "sha-1" / "sha-224" / "sha-256" /
                             「sha-384」/「sha-512」/
                             "md5" / "md2" /トークン
                             ; 追加のハッシュ関数は来ることができるだけです
                             ; RFC3279の更新から
        
指紋= 2UHEX *（ "：" 2UHEX）; 大文字の16進数の各バイト、区切り; コロンで. 

   UHEX = DIGIT /％x41-46; AF大文字
        
図2：指紋属性の拡張バッカスナウア構文

RFC 4055 [6]によって更新されたRFC3279 [5]に従って、定義されたハッシュ関数は「SHA-1」[1] [16]、「SHA-224」[1]、「SHA-256」[1]、 「SHA-384」[1]、「SHA-512」[1]、「MD5」[13]、および「MD2」[23]、「SHA-256」が推奨されます. 「ハッシュ関数テキスト名」という名前の新しいIANAレジストリ、

セクション8で指定されているように、将来のトークンを追加できますが、RFC 3279 [5]を更新または廃止するRFCに含まれている場合にのみ追加できます. 

この仕様に準拠する実装では、MD2およびMD5ハッシュ関数を使用して指紋を計算したり、それらを使用して計算された受信指紋を検証したりしてはなりません. 

注：MD2およびMD5ハッシュ関数は、実装がそれらを認識できるように、この仕様にリストされています. 未使用のハッシュ関数をログに記録する実装では、これらのアルゴリズムの発生を未知のハッシュアルゴリズムとは異なる方法でログに記録する場合があります. 

フィンガープリント属性は、セッションレベルまたはメディアレベルのSDP属性のいずれかです. これがセッションレベルの属性である場合、メディアレベルのフィンガープリント属性が定義されていないすべてのTLSセッションに適用されます. 

5.1. 複数の指紋
複数のSDPフィンガープリント属性を「m」行に関連付けることができます. これは、異なるハッシュ関数を使用して証明書に対して複数のフィンガープリントが計算された場合に発生する可能性があります. 複数の証明書に関連付けられた1つ以上のフィンガープリントが計算された場合にも発生する可能性があります. これは、「m」行に関連付けられたメディアに複数の証明書が使用される場合（たとえば、RTPとRTP制御プロトコル（RTCP）に別々の証明書が使用される場合）、またはどの証明書がいつ使用されるかがわからない場合に必要になることがあります. 指紋が交換されます. このような場合、可能な証明書ごとに1つ以上のフィンガープリントを計算する必要があります. 

エンドポイントは、少なくとも、「SHA-256」ハッシュ関数アルゴリズムと、可能な各証明書の証明書に署名を生成するために使用されるハッシュ関数の両方を使用してフィンガープリントを計算する必要があります. 署名アルゴリズムからのハッシュを含めることで、RFC 4572 [20]の厳密な実装との相互運用性が保証されます. エンドポイントに、ピアがサポートしていることがわかっているより強力なハッシュアルゴリズムを備えたハッシュが含まれている場合、ピアがハッシュアルゴリズムをサポートしていないことがわかっている場合、またはローカルポリシーでより強力なアルゴリズムの使用が義務付けられている場合は、これらのフィンガープリントのいずれかを省略できます. 

複数の証明書に関連付けられたフィンガープリントを計算する場合は、同じハッシュ関数のセットを使用して、「m」行に関連付けられた各証明書のフィンガープリントを計算する必要があります. 

エンドポイントは、（ピアによって提供されるものから）最も優先されるハッシュ関数を使用するフィンガープリントのセットを選択し、使用される各証明書がそのセットから1つのフィンガープリントと一致することを確認する必要があります. 

証明書がそのようなフィンガープリントと一致しない場合、エンドポイントはTLS接続を確立してはなりません（MUSTNOT）. 

注：SDPフィンガープリント属性には、特定の証明書への参照は含まれていません. エンドポイントは、一致するものを探すために、フィンガープリントを証明書ハッシュと比較する必要があります. 

6.エンドポイントの識別
6.1. 証明書の選択
X.509証明書は、IDと公開鍵をバインドします. TLSセッションを記述するSDPが整合性保護を提供するメカニズムを介して送信される場合、構文的に有効なIDをアサートする証明書を使用できます（MAY）. たとえば、HTTP / TLS [14]を介して送信されたSDP記述、またはS / MIME [22]によって保護されたSDP記述は、メディア接続を保護する証明書で任意のIDをアサートできます（MAY）. 

ホップバイホップの整合性保護のみを提供するセキュリティプロトコル（たとえば、SIPSスキーム[17]、SIP over TLS）は、有効なIDが受け入れられるモードを許可するのに十分に安全であると見なされます. ただし、この事実のセキュリティへの影響については、セクション7を参照してください. 

SDPが整合性保護されていない状況では、TLS接続に提供される証明書は、接続の適切なIDを証明する必要があります. これらのシナリオでは、エンドポイントによって提示される証明書は、次のように、SDP接続アドレスまたはSDPメッセージの作成者のIDのいずれかを証明する必要があります. 

oメディア記述の接続アドレスがIPアドレスとして指定されている場合、エンドポイントは、セッション記述の「c」行の接続アドレスのIPと完全に一致するiPAddresssubjectAltNameを持つ証明書を使用できます（MAY）. 同様に、メディア記述の接続アドレスが完全修飾ドメイン名として指定されている場合、エンドポイントは、指定された「c」回線接続アドレスと正確に一致するdNSNamesubjectAltNameを持つ証明書を使用できます（MAY）. （ワイルドカードパターンは使用しないでください. ）

oあるいは、セッションのSDPセッション記述が、セッション参加者のIDがURI（Uniform Resource Identifiers）によって定義されているプロトコル（SIP [17]など）を介して送信された場合、エンドポイントは、UniformResourceIdentifierを持つ証明書を使用できます（MAY）.  SDPを生成したエンドポイントのIDに対応するsubjectAltName. の詳細

有効なURIは、送信プロトコルによって異なります. （URIの有効性の詳細については、セクション7を参照してください. 

IDマッチングは、RFC 5280 [11]で指定されているマッチングルールを使用して実行されます. 特定のタイプの複数のIDが証明書に存在する場合（たとえば、複数のdNSName名）、セットのいずれか1つでの一致は許容可能と見なされます. セクション7で説明されているように、証明書キャッシュの使用をサポートするには、エンドポイントは、サポートするIDごとに同じ証明書を一貫して提供する必要があります. 

6.2. 証明書の提示
すべての場合において、TLSサーバーとして機能するエンドポイント（つまり、コネクション型メディアの用語では「setup：passive」の役割を担うエンドポイント）は、セクション6.1に示されているルールに従って、TLSの開始時に証明書を提示する必要があります. 証明書が元のフィンガープリントと一致しない場合、クライアントエンドポイントはbad_certificateエラーでメディア接続を終了する必要があります. 

SDPオファー/アンサーモデル[4]が使用されている場合、クライアント（「setup：active」ロールを持つエンドポイント）もセクション6.1のルールに従って証明書を提示する必要があります. サーバーは証明書を要求する必要があります. クライアントが提供しない場合、または証明書が提供されたフィンガープリントと一致しない場合、サーバーエンドポイントはbad_certificateエラーでメディア接続を終了する必要があります. 

オファー/アンサーモデルが使用されている場合、メディア接続がアンサーをアウトパスしてオファー側に戻す可能性があることに注意してください. したがって、提供者が「setup：passive」または「setup：actpass」の役割を提供した場合、（RFC 4145 [7]で指定されているように）提供者が提供を送信するとすぐに着信接続のリッスンを開始する必要があります. ただし、TLS接続を介して送信されたデータは、SDP回答で一致するフィンガープリントを受信するまで有効であると想定してはなりません（MUSTNOT）. フィンガープリントが到着すると、クライアントの証明書と一致しない場合、前の段落で述べたように、サーバーエンドポイントはbad_certificateエラーでメディア接続を終了する必要があります. 

オファー/アンサーが使用されていない場合（たとえば、SDPがSession Announcement Protocol [15]を介して送信された場合）、クライアントが証明書フィンガープリントをサーバーに通信するために使用できる安全なチャネルはありません. この場合、サーバーはクライアント証明書を要求する場合があります. これは、有名な認証局によって署名されている必要があります. または、クライアントが証明書なしで接続できるようにする場合があります. 

7.セキュリティに関する考慮事項
このドキュメント全体は、セキュリティに関係しています. 解決すべき問題はセクション1で扱われ、概要はセクション3で示されます. SDP一般に適用されるセキュリティの考慮事項については、SDP仕様[8]を参照してください. 

SDPでTCP / TLS接続を提供する（またはSDPオファー/アンサーモードでTCP / TLS接続に同意する）ことは、エンドポイントが指定されたフィンガープリントでTLS接続を受け入れる義務を作成しません. 代わりに、エンドポイントは、選択されたTLSストリーム暗号とMACアルゴリズムが上位レベルのアプリケーションのセキュリティニーズを確実に満たすように、標準のTLSネゴシエーション手順を実行する必要があります. （たとえば、TLS_NULL_WITH_NULL_NULLの提供されたストリーム暗号は、ほとんどすべてのアプリケーションシナリオで拒否される必要があります. ）

すべてのSDPメッセージと同様に、TLSストリームを説明するSDPメッセージは、カプセル化アプリケーションプロトコル（SIP、メディアゲートウェイコントロールプロトコル（MGCP）など）で伝達されます. SDPセキュリティ記述の整合性を確保するのは、カプセル化プロトコルの責任です. したがって、アプリケーションプロトコルは、独自のセキュリティメカニズム（たとえば、セキュアマルチパート）を呼び出すか、あるいは、下位層のセキュリティサービス（たとえば、TLSまたはIPsec）を利用する必要があります. このセキュリティサービスは、強力なメッセージ認証と効果的なリプレイ保護を提供する必要があります. 

ただし、このような整合性保護が常に可能であるとは限りません. このような場合、エンドシステムは、他の関係者がこのメカニズムを使用して以前に提示した証明書のキャッシュを維持する必要があります. 可能であれば、これまで未知のエンドシステムに関連付けられたセキュリティで保護されていない証明書が提示されたときにユーザーに通知する必要があります. また、過去に通信した相手から別のセキュリティで保護されていない証明書が提示された場合は、強く警告する必要があります. このように、SDPの整合性保護がない場合でも、このドキュメントのメカニズムのセキュリティは、2つの場合に中間者攻撃に対して脆弱なSecure Shell（SSH）プロトコル[18]のセキュリティと同等です. パーティは最初に通信しますが、その後に発生するものを検出できます. （「相手方」の正確な定義に注意してください

相互運用性と展開を支援するために、ホップバイホップの整合性保護のみを提供するセキュリティプロトコル（SIPSスキーム[17]、SIP over TLSなど）は、構文的に有効なIDが受け入れられるモードを許可するのに十分に安全であると見なされます. 証明書. SIPSは現在、

短中期的に展開されたネットワークで使用される可能性が最も高い整合性メカニズム. ただし、このモードでは、SDPの整合性は、SIPプロキシサーバーなどの侵害されたミドルボックスまたは悪意のあるミドルボックスによる攻撃に対して脆弱です. エンドシステムは、ホップバイホップ方式でのみ保護されるSDPセッションについてユーザーに警告する場合があり、TCP / TLSを介して実行されるメディア形式の定義では、エンドツーエンドの整合性メカニズムのみを使用するように指定する場合があります. 

SDPメッセージの送信方法によっては、リモート証明書で提示されたsubjectAltNameがリモートパーティに期待されるかどうかを常に判断できるとは限りません. 特に、ゲートウェイ制御プロトコル[21]によって制御されるエンドポイントによって生成されるコール転送、サードパーティのコール制御、またはセッションの説明を考えると、SIPでは、どのエンティティがリモートSDP応答を生成する必要があるかを常に判断できるとは限りません. 一般に、SDP記述の信頼性と整合性保護を使用しない場合、SIPを介して送信される証明書は、エンドポイントのレコードのSIPアドレスをuniformResourceIndicatorsubjectAltNameとしてアサートする必要があります. エンドポイントが、コールを発信または受信したID以外のID（iPAddressまたはdNSName IDを含む）をアサートする証明書をSIP経由で受信すると、ユーザーに警告し、確認を求める必要があります. これは、証明書が自己署名されているか、認証局によって署名されているかに関係なく適用されます. 「sip：bob@example.com」の証明書は、認証局によって合法的に署名されている場合がありますが、「sip：alice@example.com」への呼び出しには受け入れられない場合があります. （この問題は、この仕様に固有の問題ではありません. 同じ考慮事項が、SIPを介して伝送されるS / MIME署名付きSDPにも当てはまります. ）

このドキュメントでは、コネクション型チャネルを介してRTPおよびRTCPパケットを安全に転送するためのメカニズムは定義されていません. 詳細については、RFC 7850 [19]を参照してください. 

TLSは、安全なコネクション型メディアにとって常に最適な選択であるとは限りません. 場合によっては、高レベルまたは低レベルのセキュリティプロトコルが適切な場合があります. 

このドキュメントはRFC4572 [20]からのセキュリティを改善します. 優先ハッシュ関数をSHA-1からSHA-256に更新し、MD2およびMD5ハッシュ関数の使用を廃止します. 

複数のフィンガープリントの使用法と処理を明確にすることで、このドキュメントはハッシュの俊敏性と、より新しくより安全なハッシュ関数の段階的な展開も可能にします. 

8.IANAの考慮事項
IANAは、RFC 4572 [20]で定義されている登録を更新して、この仕様を参照しています. 

このドキュメントでは、SDPプロト値「TCP / TLS」を定義しています. その形式はセクション4で定義されています. このproto値は、「Session Description Protocol（SDP）Parameters」レジストリ内の「proto」レジストリの下でIANAによって登録されています. 

このドキュメントでは、SDPセッションとメディアレベルの属性「fingerprint」を定義しています. その形式はセクション5で定義されています. この属性は、「Session Description Protocol（SDP）Parameters」レジストリ内の「att-field（セッションレベルとメディアレベルの両方）」レジストリの下でIANAによって登録されています. 

SDP仕様[8]は、この仕様で定義されている「TCP / TLS」プロト値のような新しいプロト値を定義する仕様は、メディア形式（fmt）名前空間を管理するためのルールを定義する必要があると述べています. TCP / TLSプロトコルの場合、新しいフォーマットにはMIME登録が関連付けられている必要があります. フォーマットに既存のMIMEサブタイプを使用することをお勧めします. MIMEサブタイプが存在しない場合は、フォーマットのトランスポートプロトコルを定義する標準化過程RFCを作成または参照することにより、IETFプロセス[12]を通じて適切なサブタイプを登録することをお勧めします. 

IANAは、このドキュメントを参照するために、「ハッシュ関数テキスト名」レジストリ（[20]で最初に作成された）を更新しました. 

証明書のフィンガープリントに使用されるハッシュ関数の名前は、IANAによって登録されます. ハッシュ関数は、RFC3279を更新または廃止する標準化過程RFCによって定義されなければなりません[5]. 

新しいハッシュ関数のテキスト名を登録するときは、次の情報を提供する必要があります. 

oハッシュ関数のテキスト名. 

o X.509証明書で使用されるハッシュ関数のオブジェクト識別子（OID）. 

o RFC 3279 [5]を更新または廃止し、X.509証明書でのハッシュ関数の使用を定義するStandards TrackRFCへの参照. 

表1に、このレジストリーの初期値を示します. 

        + -------------------- + ------------------------ + --- -------- +
        | ハッシュ関数名| OID | リファレンス|
        + -------------------- + ------------------------ + --- -------- +
        | "md2" | 1.2.840.113549.2.2 | RFC 3279 |
        | "md5" | 1.2.840.113549.2.5 | RFC 3279 |
        | 「sha-1」| 1.3.14.3.2.26 | RFC 3279 |
        | 「sha-224」| 2.16.840.1.101.3.4.2.4 | RFC 4055 |
        | 「sha-256」| 2.16.840.1.101.3.4.2.1 | RFC 4055 |
        | 「sha-384」| 2.16.840.1.101.3.4.2.2 | RFC 4055 |
        | 「sha-512」| 2.16.840.1.101.3.4.2.3 | RFC 4055 |
        + -------------------- + ------------------------ + --- -------- +
        
表1：IANAハッシュ関数のテキスト名レジストリ

9.参考文献
9.1. 規範的参照
[1]米国国立標準技術研究所、「Secure Hash Standard（SHS）」、FIPS PUB 180-4、DOI 10.6028 / NIST.FIPS.180-4、2015年8月、<http://nvlpubs.nist.gov/ nistpubs / FIPS /NIST.FIPS.180-4.pdf>. 

[2]国際標準化機構、「情報技術-オープンシステム相互接続-ディレクトリ-パート8：公開鍵および属性証明書フレームワーク」、ISO / IEC 9594-8：2014、2014年3月、<https：/ /www.iso.org/standard/64854.html>. 

[3] Bradner、S. 、「要件レベルを示すためにRFCで使用するキーワード」、BCP 14、RFC 2119、DOI 10.17487 / RFC2119、1997年3月、<http://www.rfc-editor.org/info/ rfc2119>. 

[4] Rosenberg、J. およびH. Schulzrinne、「Session Description Protocol（SDP）を使用したオファー/アンサーモデル」、RFC 3264、DOI 10.17487 / RFC3264、2002年6月、<http://www.rfc-editor.org / info / rfc3264>. 

[5] Bassham、L.、Polk、W. 、およびR. Housley、「インターネットX.509公開鍵インフラストラクチャ証明書および証明書失効リスト（CRL）プロファイルのアルゴリズムと識別子」、RFC 3279、DOI 10.17487 / RFC3279、 2002年4月、<http://www.rfc-editor.org/info/rfc3279>. 

[6] Schaad、J.、Kaliski、B. 、およびR. Housley、「インターネットX.509公開鍵インフラストラクチャ証明書および証明書失効リスト（CRL）プロファイルで使用するRSA暗号化の追加のアルゴリズムと識別子」、RFC 4055 、DOI 10.17487 / RFC4055、2005年6月、<http://www.rfc-editor.org/info/rfc4055>. 

[7] Yon、D. およびG. Camarillo、「Session Description Protocol（SDP）におけるTCPベースのメディアトランスポート」、RFC 4145、DOI 10.17487 / RFC4145、2005年9月、<http：//www.rfc-editor.  org / info / rfc4145>. 

[8] Handley、M.、Jacobson、V. 、およびC. Perkins、「SDP：Session Description Protocol」、RFC 4566、DOI 10.17487 / RFC4566、2006年7月、<http://www.rfc-editor.org/ info / rfc4566>. 

[9] Crocker、D.、Ed. およびP.Overell、「構文仕様の拡張BNF：ABNF」、STD 68、RFC 5234、DOI 10.17487 / RFC5234、2008年1月、<http://www.rfc-editor.org/info/rfc5234>. 

[10] Dierks、T. およびE. Rescorla、「トランスポート層セキュリティ（TLS）プロトコルバージョン1.2」、RFC 5246、DOI 10.17487 / RFC5246、2008年8月、<http://www.rfc-editor.org/info / rfc5246>. 

[11] Cooper、D.、Santesson、S.、Farrell、S.、Boeyen、S.、Housley、R. 、およびW. Polk、「インターネットX.509公開鍵インフラストラクチャ証明書および証明書失効リスト（CRL）プロファイル"、RFC 5280、DOI 10.17487 / RFC5280、2008年5月、<http://www.rfc-editor.org/info/rfc5280>. 

[12] Freed、N.、Klensin、J. 、およびT. Hansen、「メディアタイプの仕様と登録手順」、BCP 13、RFC 6838、DOI 10.17487 / RFC6838、2013年1月、<http：//www.rfc- editor.org/info/rfc6838>. 

9.2. 有益な参考資料
[13] Rivest、R. 、「MD5メッセージダイジェストアルゴリズム」、RFC 1321、DOI 10.17487 / RFC1321、1992年4月、<http://www.rfc-editor.org/info/rfc1321>. 

[14] Rescorla、E. 、「HTTP Over TLS」、RFC 2818、DOI 10.17487 / RFC2818、2000年5月、<http://www.rfc-editor.org/info/rfc2818>. 

[15] Handley、M.、Perkins、C. 、およびE. Whelan、「Session Announcement Protocol」、RFC 2974、DOI 10.17487 / RFC2974、2000年10月、<http://www.rfc-editor.org/info/ rfc2974>. 

[16] Eastlake 3rd、D. and P. Jones、 "US Secure Hash Algorithm 1（SHA1）"、RFC 3174、DOI 10.17487 / RFC3174、September 2001、<http://www.rfc-editor.org/info/ rfc3174>. 

[17] Rosenberg、J.、Schulzrinne、H.、Camarillo、G.、Johnston、A.、Peterson、J.、Sparks、R.、Handley、M. 、およびE. Schooler、「SIP：SessionInitiationProtocol」 、RFC 3261、DOI 10.17487 / RFC3261、2002年6月、<http://www.rfc-editor.org/info/rfc3261>. 

[18] Ylonen、T. and C. Lonvick、Ed. 、 "The Secure Shell（SSH）Protocol Architecture"、RFC 4251、DOI 10.17487 / RFC4251、2006年1月、<http://www.rfc-editor.org/ info / rfc4251>. 

[19] Lazzaro、J. 、「コネクション型トランスポートを介したフレーミングリアルタイムトランスポートプロトコル（RTP）およびRTP制御プロトコル（RTCP）パケット」、RFC 4571、DOI 10.17487 / RFC4571、2006年7月、<http：// www .rfc-editor.org / info / rfc4571>. 

[20] Lennox、J. 、「セッション記述プロトコル（SDP）のトランスポート層セキュリティ（TLS）プロトコルを介したコネクション型メディアトランスポート」、RFC 4572、DOI 10.17487 / RFC4572、2006年7月、<http：// www .rfc-editor.org / info / rfc4572>. 

[21] Taylor、T. 、「RFC 3525のHistoricへの再分類」、RFC 5125、DOI 10.17487 / RFC5125、2008年2月、<http://www.rfc-editor.org/info/rfc5125>. 

[22] Ramsdell、B. およびS. Turner、「Secure / Multipurpose Internet Mail Extensions（S / MIME）Version 3.2 Message Specification」、RFC 5751、DOI 10.17487 / RFC5751、2010年1月、<http：//www.rfc- editor.org/info/rfc5751>. 

[23] Turner、S. and L. Chen、 "MD2 to Historic Status"、RFC 6149、DOI 10.17487 / RFC6149、2011年3月、<http://www.rfc-editor.org/info/rfc6149>. 

[24] Shekh-Yusef、R.、Ed. 、Ahrens、D.、and S. Bremer、 "HTTP Digest Access Authentication"、RFC 7616、DOI 10.17487 / RFC7616、September 2015、<http：//www.rfc- editor.org/info/rfc7616>. 

謝辞

このドキュメントには、Cullen Jennings、Paul Kyzivat、Roman Shpount、およびMartinThomsonによる重要な貢献が含まれていました. Elwyn Daviesは、ドキュメントのGen-ARTレビューを実行しました. 

著者の住所

Jonathan Lennox Vidyo

   メール：jonathan@vidyo.com
        
クリステルホルムバーグエリクソン

   Eメール：christer.holmberg@ericsson.com
        