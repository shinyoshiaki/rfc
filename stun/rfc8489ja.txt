RFC Trans
プライバシーポリシー
連絡先
フィグス
テックスツーイー
8489
RFC 8489。NAT用セッショントラバーサルユーティリティ（STUN）日本語訳
URL ：https://tools.ietf.org/html/rfc8489
タイトル :rfc 8489:NAT用セッショントラバーサルユーティリティ(STUN)
翻訳編集 : 自動生成
インターネット技術タスクフォース（IETF） M. Petit-Huguenin コメントのリクエストです。8489 Impedance Mismatch Obsoletes: 5389 G. Salgueiro Category:Standards Track Cisco ISSN: 2070-1721 J. Rosenberg Five9 D. Wing Citrix R. Mahy Unaffiliated P. Matthews Nokia February 2020    
NAT用セッショントラバーサルユーティリティ（STUN)

アブストラクト

Session Traversal Utilities for NAT (STUN)は、NATトラバーサルを扱う上で、他のプロトコルのツールとして機能するプロトコルである。エンドポイントが、NATによって割り当てられたIPアドレスとポートを決定するために使用することができます。また、2つのエンドポイント間の接続性を確認したり、NAT bindingを維持するためのキープアライブプロトコルとして使用することも可能です。STUNは既存の多くのNATで動作し、NATから特別な動作を要求されることはありません。

STUNはそれ自体でNATトラバーサルソリューションではありません。むしろ、NATトラバーサルソリューションの文脈で使用されるツールです。

この文書は、RFC5389を廃止するものである。

本メモの位置づけ

これは、Internet Standards Trackの文書です。

この文書は、インターネット技術タスクフォース（IETF）の成果物である。IETFコミュニティのコンセンサスを表すものである。パブリックレビューを受け、インターネットエンジニアリングステアリンググループ（IESG）により発行が承認されている。インターネット標準に関する詳しい情報は、RFC7841の第2章に記載されています。

この文書の現在の状況、正誤表、およびこの文書に対するフィードバックの提供方法に関する情報は、https://www.rfc-editor.org/info/rfc8489 で入手できます。

著作権について

Copyright (c) 2020 IETF Trust and the persons identified as the document authors.すべての権利を保有する。

この文書は、この文書の発行日に有効なBCP 78およびIETFトラストのIETF文書に関する法的規定(https://trustee.ietf.org/license-info)に従うものとします。これらの文書は、この文書に関するあなたの権利と制限を記述していますので、注意深く確認してください。この文書から抽出されたコードコンポーネントは、トラスト法的規定のセクション4.eに記載されているように、簡易BSDライセンステキストを含まなければならず、簡易BSDライセンスに記載されているように、保証なしで提供されます。

目次

1.はじめに............................................... ..... 4
2.運用の概要........................................... 5
3.用語..................................................... ......7
4.定義......................................................... ......7
5. STUNメッセージ構造.......................................... 9
6.基本プロトコル手順................................................. 11
   6.1. リクエストまたはインジケーションの作成........................ 11
   6.2. リクエストまたはインジケーションの送信......................... 12
        6.2.1. UDPまたはDTLS-over-UDPを介した送信.................. 13
        6.2.2. TCPまたはTLS-over-TCP経由での送信................... 14
        6.2.3. TLS-over-TCPまたはDTLS-over-UDPを介した送信......... 15
   6.3. STUNメッセージの受信.................................. 16
        6.3.1. リクエストの処理............................... 17
               6.3.1.1. 成功またはエラー応答の形成....... 17
               6.3.1.2. 成功またはエラー応答の送信..... 18
        6.3.2. 表示の処理........................... 18
        6.3.3. 成功応答の処理...................... 19
        6.3.4. エラー応答の処理................................. 19
7. FINGERPRINTメカニズム.......................................................... 20
8.サーバーのDNS検出................................................ 20
   8.1. STUN URIスキームセマンティクス................................. 21
9.認証およびメッセージ整合性メカニズム................ 22
   9.1. 短期資格メカニズム........................... 23
        9.1.1. HMACキー........................................... 23
        9.1.2. リクエストまたはインジケーションの形成..................... 23
        9.1.3. リクエストまたはインジケーションを受け取る.................................. 23
        9.1.4. 返答を受け取る............................... 25
        9.1.5. 後続のリクエストの送信........................ 25
   9.2. Long-Term Credentialメカニズム............................ 26
        9.2.1. ビッドダウン攻撃防止......................... 27
        9.2.2. HMACキー........................................... 27
     
        9.2.3. リクエストの作成.................................. 28
               9.2.3.1. 最初のリクエスト............................. 28
               9.2.3.2. 後続のリクエスト................................. 29
        9.2.4. リクエストの受け取り................................ 29
        9.2.5. 応答の受け取り............................... 31
10.代替サーバーメカニズム................................................. 33
11. RFC 3489との下位互換性......................... 34
12.サーバーの基本的な動作......................................... 34
13. STUNの使用法........................................................ ..... 35
14. STUN属性........................................................ .36
   14.1. マップされたアドレス........................................... 37
   14.2. XOR-MAPPED-ADDRESS ....................................... 38
   14.3. ユーザー名................................................................. 39
   14.4. USERHASH ................................................................. 40
   14.5 メッセージの整合性........................................ 40
   14.6 MESSAGE-INTEGRITY-SHA256 ................................. 41
   14.7. フィンガープリント........................................................ 41
   14.8. エラーコード ............................................... 42
   14.9. REALM ................................................................. ... 44
   14.10. NONCE ................................................................. ..44
   14.11. パスワードアルゴリズム..................................... 44
   14.12. パスワードアルゴリズム................................................ 45
   14.13. 不明な属性................................................ 45
   14.14. ソフトウェア................................................................ 46
   14.15. 代替サーバー.................................................. 46
   14.16. 代替ドメイン........................................ 46
15.運用上の考慮事項................................................. 47
16.セキュリティに関する考慮事項................................................. 47
   16.1. プロトコルに対する攻撃............................. 47
        16.1.1. 外部からの攻撃................................... 47
        16.1.2. 内部攻撃................................................. 48
        16.1.3. ビッドダウン攻撃.................................. 48
   16.2. 使用に影響を与える攻撃.............................. 50
        16.2.1. 攻撃I：に対する分散型DoS（DDoS）
                ターゲット............................................ 51
        16.2.2. 攻撃II：クライアントのサイレンシング..................... 51
        16.2.3. 攻撃III：クライアントのIDを想定する..... 52
        16.2.4. 攻撃IV：盗聴.......................... 52
   16.3. ハッシュアジリティ計画.................................................. 52
17. IABの考慮事項............................................ 53
18. IANAの考慮事項........................................... 53
   18.1. STUN Security Features Registry .......................... 53
   18.2. STUNメソッドレジストリ.................................... 54
   18.3. STUN属性レジストリ................................. 54
        18.3.1. 更新された属性................................ 55
        18.3.2. 新しい属性................................................. 55
   18.4. STUNエラーコードレジストリ................................ 56
   18.5. STUNパスワードアルゴリズムレジストリ........................ 56
     
        18.5.1. パスワードアルゴリズム............................... 57
               18.5.1.1. MD5 ................................................ 57
               18.5.1.2. SHA-256 .................................. 57
   18.6. STUN UDPおよびTCPポート番号............................ 57
19. RFC 5389以降の変更点........................................ 57
20.参考資料......................................................... ..... 58
   20.1. 規範的な参照..................................... 58
   20.2. 有益な参照................................... 61
付録A. STUNメッセージタイプを決定するCスニペット............ 64
付録B.テストベクトル......................................... 64
  B.1. を使用した長期認証を使用したサンプルリクエスト
        MESSAGE-INTEGRITY-SHA256およびUSERHASH ..................... 65
謝辞................................................................ .66
貢献者................................................. ..... 66
著者のアドレス............................................... 0.67

1.はじめに
本仕様で定義されるプロトコル、Session Traversal Utilities for NAT（STUN）は、ネットワークアドレス変換器（NAT）に対処するためのツールを提供する。これは、エンドポイントが、自分のプライベートIPアドレスとポートに対応する、NATによって割り当てられたIPアドレスとポートを決定するための手段を提供するものである。また、エンドポイントがNATのbindingを維持するための方法も提供する。いくつかの拡張により、このプロトコルは2つのエンドポイント間の接続性チェック[RFC8445]や2つのエンドポイント間のパケットリレー[RFC5766]に使用することができます。

この仕様は、そのツールとしての性質に則り、拡張可能なパケットフォーマットを定義し、いくつかのトランスポートプロトコル上での動作を定義し、2種類の認証形式を提供するものである。

STUNは、1つまたは複数のNATトラバーサルソリューションのコンテキストで使用されることを意図しています。これらの解決策は「STUNの使用法」として知られている。各用途は、NATトラバーサルソリューションを実現するためにSTUNがどのように利用されるかを記述する。通常、使用法は、STUNメッセージがいつ送信されるか、どのオプション属性を含めるか、どのサーバーが使われるか、どの認証機構が使われるかを示す。対話型接続確立(ICE)[RFC8445]は、STUNの1つの使用法である。SIP Outbound [RFC5626]は、STUNのもう一つの使用法である。場合によっては、STUNの拡張を必要とする使用法もある。STUNの拡張は、新しいメソッド、属性、またはエラー応答コードの形であり得る。STUNの使用法に関するより詳細な情報は、セクション13に記載されている。

2.操作の概要
このセクションは説明的なものです。

                           /-----\
                         // STUN  \\
                        |   Server  |
                         \\       //
                           \-----/




                      +--------------+             Public Internet
      ................|     NAT 2    |.......................
                      +--------------+



                      +--------------+             Private Network 2
      ................|     NAT 1    |.......................
                      +--------------+




                           /-----\
                         // STUN  \\
                        |   Client  |
                         \\       //               Private Network 1
                           \-----/

図1：STUNの構成の一例

考えられるSTUN構成の1つを図1に示す。この構成では、STUNプロトコルを実装する2つのエンティティ（STUNエージェントと呼ぶ）が存在する。図中の下側のエージェントはクライアントであり、プライベートネットワーク1に接続されている。このネットワークは、NAT 1を介してプライベートネットワーク2に接続されています。プライベートネットワーク2は、NAT2を通じてパブリックインターネットに接続されています。図の上側のエージェントは、パブリックインターネットに存在するサーバーです。

STUNはクライアント・サーバー・プロトコルである。これは2種類のトランザクションをサポートする。一つは、クライアントがサーバーにリクエストを送り、サーバーがレスポンスを返すリクエスト/レスポンス・トランザクションである。もう1つは、クライアントまたはサーバーのいずれかのエージェントが、応答を生成しない指示を送信する指示トランザクションである。どちらのタイプのトランザクションも、トランザクションIDを含み、これはランダムに選択された96ビットの数字である。リクエスト/レスポンストランザクションでは、このトランザクションIDによって、クライアントはレスポンスを生成したリクエストと関連付けることができ、インジケーションでは、トランザクションIDはデバッグの補助として機能する。

すべてのSTUNメッセージは、メソッド、クラス、トランザクションIDを含む固定ヘッダーで始まる。この仕様では、Bindingという1つのメソッドだけを定義しているが、他のメソッドは他の文書で定義されることが期待される。クラスは、これがリクエスト、成功応答、エラー応答、または指示のいずれであるかを示す。固定ヘッダーに続いて、0個以上の属性が来る。これは、特定のメッセージのための追加情報を伝えるType-Length-Valueの拡張である。

本書は、"Binding "と呼ばれる単一のメソッドを定義する。Bindingメソッドは、リクエスト/レスポンストランザクションまたはインジケーショントランザクションのいずれかで使用することができる。リクエスト/レスポンストランザクションで使用する場合、Bindingメソッドは、NATがSTUNクライアントに割り当てた特定のbindingを決定するために使用することができる。リクエスト/レスポンスまたはインジケーショントランザクションで使用される場合、Bindingメソッドは、これらのbindingを維持するために使用することも可能です。

Bindingリクエスト/レスポンストランザクションでは、BindingリクエストはSTUNクライアントからSTUNサーバーに送信されます。BindingリクエストがSTUNサーバーに到着したとき、STUNクライアントとSTUNサーバーの間で1つ以上のNATを通過している場合がある（図1では、そのようなNATが2つある）。バインド要求メッセージがNATを通過すると、NATはパケットのソース・トランスポート・アドレス（つまり、ソースIPアドレスとソースポート）を変更します。
その結果、サーバーが受信したリクエストのソース・トランスポート・アドレスは、サーバーに最も近いNATが作成したパブリックIPアドレスとポートになります。これを「反射型トランスポートアドレス」と呼びます。
STUNサーバーは、そのソーストランスポートアドレスをSTUN BindingレスポンスのXOR-MAPPED-ADDRESS属性にコピーし、BindingレスポンスをSTUNクライアントに送り返す。このパケットがNATを通過して戻ってくると、NATはIPヘッダーの宛先トランスポートアドレスを変更するが、STUNレスポンスのボディ内のXOR-MAPPED-ADDRESS属性のトランスポートアドレスは変更されないままである。このようにして、クライアントは、STUNサーバーに対して最も外側のNATによって割り当てられた反射的なトランスポートアドレスを知ることができる。

いくつかの用途では、STUNは他のプロトコルと多重化されなければならない（例えば、[RFC8445]と[RFC5626]）。これらの用途では、パケットを検査し、それがSTUNパケットであるかどうかを判断する方法が必要である。STUNは、STUNヘッダにおいて、以下のような固定値を持つ3つのフィールドを提供する。

この目的のために使用される。これが十分でない場合、STUNパケットにはFINGERPRINT値も含まれ、パケットを区別するためにさらに使用することができます。

STUNは、"メカニズム "と呼ばれる、利用者が使用を決定できる一連のオプション手続きを定義する。これらのメカニズムは、DNS発見、代替サーバーへのリダイレクト技術、デマルチプレクシングのためのフィンガープリント属性、および2つの認証とメッセージインテグリティの交換を含む。認証メカニズムは、ユーザー名、パスワード、およびメッセージ整合性値の使用を中心に展開される。本仕様では、2つの認証メカニズム、長期的なクレデンシャルメカニズムと短期的なクレデンシャルメカニズムが定義されている。各用法は、その用法で許可される機構を指定する。

長期的なクレデンシャル機構では、クライアントとサーバーは事前に用意されたユーザー名とパスワードを共有し、HTTP[RFC7616]で定義されたものに影響を受けたダイジェストチャレンジ/レスポンス交換を実行するが、詳細については異なる。短期クレデンシャル機構では、クライアントとサーバーは、STUN交換の前に、何らかの帯域外の方法を通じてユーザー名とパスワードを交換する。たとえば、ICEの使用法[RFC8445]では、2つのエンドポイントは帯域外のシグナリングを使用してユーザー名とパスワードを交換する。これらはリクエストとレスポンスの整合性保護と認証のために使用される。チャレンジやノンスは使用されない。

3.用語解説
本文書のキーワード「MUST」「MUST NOT」「REQUIRED」「SHALL」「SHALL NOT」「SHOULD」「SHOULD NOT」「RECOMMENDED」「NOT RECOMMENDED」「MAY」「OPTIONAL」は、ここに示すようにすべて大文字で現れる場合に限り、BCP14 [RFC2119] [RFC8174] で説明されているように解釈することになっています。

4.定義
STUNエージェント。STUNエージェントは、STUNプロトコルを実装するエンティティである。このエンティティは、STUNクライアントまたはSTUNサーバーのいずれにもなり得る。

STUNクライアント。STUNクライアントは、STUNリクエストを送信し、STUNレスポンスとSTUNインディケーションを受信するエンティティである。STUN クライアントは、インジケーションを送信することもできる。本明細書では、「STUNクライアント」と「クライアント」という用語は同義である。

STUNサーバー。STUNサーバーは、STUN要求とSTUN指示を受信し、STUN応答を送信するエンティティである。STUNサーバーはまた、表示を送信することもできる。本明細書では、「STUNサーバー」と「サーバー」という用語は同義である。

トランスポートアドレス。IPアドレスとポート番号（UDPやTCPのポート番号など）を組み合わせたものです。

Reflexive Transport Address（反射型トランスポートアドレス）。クライアントが学習するトランスポートアドレスで、IPネットワーク上の他のホスト（通常はSTUNサーバー）から見たそのクライアントを識別するもの。クライアントと他のホストとの間にNATが介在している場合、反射型トランスポートアドレスは、NATのパブリック側でクライアントに割り当てられたマッピングアドレスを表す。反射型トランスポートアドレスは、STUNレスポンスのマップドアドレス属性（MAPPED-ADDRESSまたはXOR-MAPPED-ADDRESS）から学習される。

マップド・アドレス。反射的アドレスと同じ意味。この用語は、歴史的な理由とMAPPED-ADDRESSおよびXOR-MAPPED-ADDRESS属性の命名に起因してのみ保持されている。

Long-Term Credential（長期クレデンシャル）。クライアントとサーバ間で共有される秘密を表すユーザ名と関連するパスワード。長期クレデンシャルは通常、サブスクライバがサービスに登録するときにクライアントに付与され、サブスクライバがサービスを離れるか明示的にクレデンシャルを変更するまで存続する。

長期パスワード：長期クレデンシャルのパスワードです。

Short-Term Credential (短期クレデンシャル)。クライアントとサーバ間で共有される秘密を表す、一時的なユーザ名と関連するパスワード。短期クレデンシャルは、STUN 交換に先立つ、クライアントとサーバ間の何らかのプロトコル機構を通じて取得される。短期クレデンシャルには明示的な時間的範囲があり、これは特定の時間（5 分など）またはイベント（セッション開始プロトコル（SIP） [RFC3261] のダイアログの終了など）に基づくことができる。短期クレデンシャルの特定のスコープは、アプリケーションの使用方法によって定義される。

短期パスワード：短期クレデンシャルのパスワード・コンポーネント。

STUN インジケーション。STUNメッセージのうち、応答を受け取らないもの。

属性（Attribute）。STUNメッセージに追加できるTLV（Type-Length-Value）オブジェクトを表すSTUN用語である。属性は、理解必須属性と理解任意属性の2種類に分けられる。STUNエージェントは、理解できない理解オプション属性を安全に無視することができるが、理解できない理解必須属性を含むメッセージは正常に処理することができない。

RTO。Retransmission TimeOutの略で、リクエストの送信からそのリクエストの最初の再送信までの初期期間を定義する。

5.STUNメッセージの構造
STUNメッセージは、ネットワーク指向フォーマット（最上位バイトまたはオクテットを最初に、一般にビッグエンディアンとも呼ばれる）を使用してバイナリで符号化される。送信順序は、[RFC0791]の付録Bで詳しく説明されている。特に断りのない限り、数値定数は10進数（ベース10）である。

すべてのSTUNメッセージは、20バイトのヘッダと、それに続く0個以上の属性からなる。STUNヘッダは、STUNメッセージタイプ、メッセージ長、マジッククッキー、およびトランザクションIDを含む。

      0                   1                   2                   3
      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     |0 0|     STUN Message Type     |         Message Length        |
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     |                         Magic Cookie                          |
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     |                                                               |
     |                     Transaction ID (96 bits)                  |
     |                                                               |
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

図2：STUNメッセージヘッダーのフォーマット

すべての STUN メッセージの最上位 2 ビットはゼロでなければならない（MUST）。これは、STUNが同じポートで他のプロトコルと多重化されているときに、STUNパケットを他のプロトコルと区別するために使用することができる。

メッセージタイプは、STUNメッセージのメッセージクラス（要求、成功応答、エラー応答、指示）とメッセージメソッド（主要機能）を定義する。メッセージクラスは4つあるが、STUNのトランザクションはリクエスト／レスポンス・トランザクション（リクエストメッセージとレスポンスメッセージからなる）とインディケーション・トランザクション（単一のインディケーションメッセージからなる）の2種類だけである。応答クラスは、STUNメッセージの迅速な処理を助けるために、エラー応答と成功応答に分割されている。

STUN Message Type フィールドは、さらに以下の構造に分解される。

                       0                 1
                       2  3  4 5 6 7 8 9 0 1 2 3 4 5
                      +--+--+-+-+-+-+-+-+-+-+-+-+-+-+
                      |M |M |M|M|M|C|M|M|M|C|M|M|M|M|
                      |11|10|9|8|7|1|6|5|4|0|3|2|1|0|
                      +--+--+-+-+-+-+-+-+-+-+-+-+-+-+
                      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+

図 3：STUN メッセージタイプフィールドのフォーマット

ここでは、STUN Message Typeフィールドのビットを最上位（M11）～最下位（M0）で示す。
M11からM0は、メソッドの12ビットエンコーディングを表す。
C1 と C0 は、クラスを表す 2 ビットの符号化です。
0b00 のクラスはrequest、
0b01 のクラスはindication、
0b10 のクラスはsuccess response、
0b11 のクラスはerror responseである。
本仕様では、Binding という単一のメソッドを定義する。メソッドとクラスは直交しており，各メソッドに対して，リクエスト，成功レスポンス，エラーレスポンス，インジケーションが可能である。新しいメソッドを定義する拡張は、そのメソッドに対してどのクラスが許可されるかを示さなければならない（MUST）。

例えば、
bindingリクエストは、class=0b00（リクエスト）、method=0b0000000001（binding）で、最初の16ビットは0x0001として符号化されます。
bindingレスポンスは、class=0b10（成功レスポンス）とmethod=0b0000000001を持ち、0x0101として最初の16ビットに符号化される。

注：この不幸な符号化は、[RFC3489]における値の割り当てが、ビットフィールドを用いた指示メッセージ、成功応答、エラー応答の符号化を考慮していなかったことによる。

マジッククッキーフィールドは、ネットワークバイトオーダーで固定値0x2112A442を含まなければならない(MUST)。RFC3489]では、マジッククッキーフィールドを構成する32ビットはトランザクションIDの一部であった。この場所にマジッククッキーを置くことで、サーバーは[RFC5389]によってSTUNに追加された特定の属性をクライアントが理解するかどうかを検知することができる。さらに、STUNが同じポートで他のプロトコルと多重化されているときに、STUNパケットを他のプロトコルのパケットと区別するのに役立つ。

トランザクションIDは96ビットの識別子であり、STUNトランザクションを一意に識別するために使用される。リクエスト／レスポンス・トランザクションの場合、トランザクションIDはSTUNクライアントがリクエストのために選択し、サーバーがレスポンスでエコーするものである。指示の場合、それは指示を送信するエージェントによって選択される。トランザクションIDは、主にリクエストとレスポンスの関連付けのために使用されるが、ある種の攻撃の防止に役立つという小さな役割も果たす。サーバーはまた、トランザクションIDを、すべてのクライアント間で各トランザクショ ンを一意に識別するためのキーとして使用する。そのため、トランザクションIDは0 ... 2**96-1の区間から一様にランダムに選ばれなければならず(MUST)、暗号的に ランダムでなければならない(MUST)。同じリクエストの再送は同じトランザクションIDを再利用するが、新しいリク エストが前のリクエストとビット単位で同一であり、同じトランスポートアドレスから 同じIPアドレスに送られない限り、クライアントは新しいトランザクションのために 新しいトランザクションIDを選択しなければならない[MUST]。成功応答とエラー応答は、対応するリクエストと同じトランザクションIDを伝えなければ ならない[MUST]。エージェントが同じポートでSTUNサーバーとSTUNクライアントとして動作している場合、エージェントが送信したリクエストのトランザクションIDは、エージェントが受信したリクエストのトランザクションIDとは何の関係もない。

メッセージ長は、20バイトのSTUNヘッダーを含まない、メッセージのサイズをバイト数で含まなければならない（MUST）。全てのSTUN属性は4バイトの倍数にパディングされるので、このフィールドの最後の2ビットは常にゼロである。これは、STUNパケットを他のプロトコルのパケットと区別する別の方法を提供する。

ヘッダのSTUN固定部分に続いて、0個以上の属性がある。各属性はTLV（Type-Length-Value）符号化されている。エンコードと属性自体の詳細は、セクション14で与えられる。

6.ベースプロトコルの手順
このセクションでは、STUNプロトコルの基本手順を定義する。メッセージがどのように形成され、どのように送信され、どのように受信時に処理されるかを記述している。また、Bindingメソッドの詳細な処理も定義している。この文書の他のセクションは、特定の状況下で使用法が選択できるオプションの手順を記述している。他の文書では、新しいメソッド、新しい属性、新しいエラー応答コードを追加することによって、STUNの他の拡張を定義することができる。

6.1.リクエストまたはインディケーションを形成する
リクエストまたはインジケーションメッセージを策定するとき、エージェントはヘッダーを作成するときにセクション5の規則に従わなければならない[MUST]。加えて、メッセージクラスは "Request "または "Indication "のいずれか(適切な場合)でなければならず (MUST)、メソッドはBindingまたは他のドキュメントで定義された何らかのメソッドのいずれか でなければならない。

次にエージェントは、メソッドや用法によって指定された属性を追加する。例えば、いくつかの用法は、エージェントが認証方法（セクション9）またはFINGERPRINT属性（セクション7）を使用することを指定するかもしれません。

エージェントがリクエストを送信する場合、リクエストにSOFTWARE属性を追加するべきである(SHOULD)。エージェントは、方法に応じて、表示にSOFTWARE属性を含めてもよい（MAY）。STUNの拡張は、新しい表示においてSOFTWAREが有用であるかどうかを議論すべきである。SOFTWARE属性の組み込みはセキュリティに影響するかもしれないことに注 意すること。詳細についてはセクション16.1.2を参照。

認証のないBindingメソッドでは、使用方法が指定されていない限り、属性は必要ない。

UDPまたはDTLS-over-UDP[RFC6347]で送信されるすべてのSTUNメッセージは、既知の場合、パスMTU未満であるべきです（SHOULD）。

UDPのパスMTUが不明な場合、メッセージは576バイトとIPv4のファーストホップMTU[RFC1122]、IPv6[RFC8200]の1280バイトのうち小さい方とすべきです（SHOULD）。この値は、IPパケットの全体サイズに相当する。したがって、IPv4の場合、実際のSTUNメッセージは548バイト（576から20バイトのIPヘッダー、8バイトのUDPヘッダーを差し引いたもの、IPオプションは使用しないと仮定）以下である必要があります。

DTLS-over-UDP においてパスの MTU が不明な場合は、（13 バイトの）DTLS Record ヘッダーのサイズ、メッセージ認証コード（MAC）サイズ、パディングサイズを考慮し、前項のルールを調整する必要がある。

STUNは、リクエストがMTUより小さく、レスポンスがMTUより大きいケースを処理する機能を提供しない。この制限がSTUNの問題になることは想定されていない。MTU制限は、STUN自体がMTU特性を調べるために使用されるケースを考慮し、MUSTではなくSHOULDである[RFC5780]。また、そのようなメカニズムがないプロトコルにPath MTU Discoveryを追加するためにSTUNを使用するフレームワークについては、[STUN-PMTUD]を参照してください。このアプリケーションまたは同様のアプリケーション以外では、MTU制約に従わなければならない（MUST）。

6.2. リクエストまたはインディケーションの送信
その後、エージェントはリクエストまたはインジケーションを送信する。本書は、UDP、TCP、TLS-over-TCP、またはDTLS-over-UDP上でSTUNメッセージを送信する方法を規定するもので、将来的に他のトランスポートプロトコルが追加されるかもしれない。STUN Usageは、どのトランスポートプロトコルを使用し、エージェントがどのように受信者のIPアドレスとポートを決定するのかを指定しなければならない。セクション8では、Usageが使用を選択できるサーバーのIPアドレスとポートを決定するDNSベースの方法について説明する。

いつでも、クライアントは、同じSTUNサーバーに対して複数の未処理のSTUN要求（つまり、異なるトランザクションIDで進行中の複数のトランザクション）を持ってもよい（MAY）。新しいトランザクションの速度に対する他の制限（接続性チェックのためにICEが指定するもの、STUNがTCP上で実行される場合など）がない限り、クライアントは同じサーバーに対する未処理のトランザクションを10個に制限するべきである（SHOULD）。

6.2.1.UDPでの送信またはDTLS-over-UDPでの送信
STUN over UDPまたはSTUN over DTLS-over-UDP [RFC7350]を実行するとき、STUNメッセージがネットワークによってドロップされる可能性がある。STUNリクエスト/レスポンストランザクションの信頼性は、クライアントアプリケーション自身によるリクエストメッセージの再送信によって達成される。STUN指示は再送されない。したがって、UDPまたはDTLS-over-UDP上での指示トランザクションは信頼性がない。

クライアントは、RTO（"Retransmission TimeOut"）の間隔で開始し、再送のたびに倍増するSTUNリクエストメッセージを再送するべきである（SHOULD）。RTOはラウンドトリップタイム(RTT)の推定値であり、[RFC6298]で説明されているように計算されるが、2つの例外がある。まず、RTOの初期値は500ms以上であることが望ましい（SHOULD）。この「SHOULD」の例外ケースは、輻輳閾値を導出するために他のメカニズムが使用される場合（固定レートストリーム用にICEで定義されているものなど）、またはネットワーク容量が既知の非インターネット環境でSTUNが使用される場合です。固定回線アクセスリンクでは、500msの値が推奨される（RECOMMENDED）。第2に、RTOの値は、1秒単位で切り上げるべきではありません（SHOULD NOT）。むしろ、1msの精度を維持すべきである。TCPと同様に、Karnのアルゴリズムの使用は推奨される（RECOMMENDED）［KARN87］。STUNに適用される場合、それは、リクエストの再送をもたらすSTUNトランザク ションからRTT推定値を計算すべきではない[SHOULD NOT]ということを意味する。

RTOの値は、トランザクション終了後にクライアントによってキャッシュされ、同じ サーバーへの次のトランザクションのRTOの開始値として使用されるべきである (IPアドレスの等しさに基づく)。過去10分間に同じサーバーにトランザクションが発生しなかった場合、値は古いとみなされ、破棄されるべきである(SHOULD)。

再送は、応答を受け取るまで、あるいは合計Rc個のリクエストが送られ るまで続く。Rcは設定可能であるべきであり、デフォルトは7であるべきである。 最後のリクエストの後、RTOのRm倍に相当する時間が応答なしで経過した場合 (この最後のリクエストだけが実際に成功した場合に応答を得るための十分な時間を 提供する)、クライアントはトランザクションが失敗したとみなすべきである[SHOULD]。Rmは設定可能であるべきであり[SHOULD]、デフォルトは16であるべきである。UDPまたはDTLS-over-UDP上のSTUNトランザクションは、ハードICMPエラー [RFC1122]があった場合にも失敗したとみなされる。例えば、RTOが500msであると仮定すると、リクエストは0ms、500ms、1500ms、 3500ms、7500ms、15500ms、31500msの時間に送信されるであろう。39500ミリ秒後にクライアントが応答を受け取らなかった場合、クライアントはトランザクションがタイムアウトしたものとみなす。

6.2.2.TCPまたはTLS-over-TCPで送信する。
TCPおよびTLS-over-TCP [RFC8446]の場合、クライアントはサーバへのTCP接続を開く。

STUNのいくつかの使用法では、STUNはTCP接続上の唯一のプロトコルである。この場合、追加のフレーミングやデマルチプレックスの助けを借りることなく送信することができます。他の使用法、または他の拡張では、STUNはTCP接続上で他のデータと多重化されるかもしれない。その場合、STUNは、エージェントが完全なSTUNメッセージと完全なアプリケーションレイヤーメッセージを抽出することを可能にする、用途や拡張によって指定されたある種のフレーミングプロトコルの上で実行されなければならない（MUST）。セクション8のDNS手順によって発見されたウェルノウンポートまたはポート上で実行されるSTUNサービスは、STUN単独のためであり、他のデータと多重化されたSTUNのためではない。したがって、これらのサーバーへの接続では、フレーミングプロトコルは使用されない。追加のフレーミングが利用される場合、その使用法は、クライアントがどのようにそれを適用することを知り、どのポートに接続するのかを指定することになる。例えば、ICEの接続チェックの場合、この情報はクライアントとサーバー間の帯域外ネゴシエーションによって知ることができます。

STUN over TCPおよびTLS-over-TCPの信頼性はTCP自体によって処理され、STUNプロトコルレベルでは再送信はない。しかし、リクエスト/レスポンストランザクションでは、クライアントがリクエス トメッセージを送信してからTi秒後までに応答を受け取らなかった場合、そのトランザク ションはタイムアウトしたとみなされる。Tiは設定可能であるべきであり、デフォルトで39.5秒を持つべきである。この値は、 デフォルトの初期RTOでTCPとUDPのタイムアウトを等しくするために選択されたものである。

また、クライアントがTCPコネクションを確立できなかったり、レスポンスを受信する前にTCPコネクションがリセットされたり失敗した場合、進行中のリクエスト/レスポンストランザクションは失敗したものとみなされます。

クライアントは一つのTCP(またはTLS-over-TCP)コネクション上で複数のトランザク ションを送信してもよく(MAY)、前のリクエストに対する応答を受け取る前に別のリク エストを送信してもよい(MAY)。クライアントは、それが完了するまでコネクションを開いたままにしておく べきである(SHOULD)。

oは、そのコネクション上で送信するSTUNリクエストまたはインジケーションをそれ以上持っていない。

oは、その接続で送信されたSTUNリクエストで学習されたリソース（マッピングされたアドレス（MAPPED-ADDRESSまたはXOR-MAPPED-ADDRESS）または中継アドレス［RFC5766］など）を使用する予定がないこと。

o そのポートで他のアプリケーションプロトコルを多重化している場合、その他のプロトコルの使用を終了している。

o その学習したポートをリモートピアで使用する場合、いくつかのTCP NATトラバーサル技術（例えば、[RFC6544]）で必要とされるように、そのリモートピアとの通信を確立している。

最終的なキープアライブメカニズムの詳細は、各STUN Usageに任されている。いずれにせよ、アイドル状態のTCP接続が機能しなくなったためにトランザクションが失敗した場合、クライアントはRSTを送信して新しいTCP接続を開こうとするべきである(SHOULD)。

サーバー側では、サーバーが接続がタイムアウトしたと判断した場合(例えば、クライアントがネットワークから切断した場合など)を除き、サーバーは接続を開いたままにし、クライアントに閉じさせるべきである(SHOULD)。クライアントが学習したbindingは、接続が開いている間だけ、間にあるNATで有効であり続ける。bindingをいつまで必要とするかは、クライアントだけが知っている。サーバーは、応答が送信されなかったリクエストをそのコネクション上で受信した 場合、そのコネクションを閉じるべきではありません(SHOULD NOT)。サーバーは、応答を送るためにクライアントに向けてコネクションを開くことは決して あってはならない(MUST NOT)。サーバーは、過負荷の場合のコネクション管理に関するベストプラクティスに従うべきである(SHOULD)。

6.2.3.TLS-over-TCPまたはDTLS-over-UDPで送信する。
STUNがTLS-over-TCPまたはDTLS-over-UDP上で単独で実行される場合、TLS_DHE_RSA_WITH_AES_128_GCM_SHA256およびTLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256暗号スイートは（古いバージョンのプロトコルとの互換性のために）実装しなければならないが、特定のSTUN使用の規則によって非推奨であればこの限りではない。その他の暗号スイートは実装してもよい（MAY）。TLSバージョン1.3 [RFC8446]以降を実装するSTUNクライアントとサーバーは、これらの仕様の必須暗号スイートも実装する必要があり、これらの仕様のサポートを検出すると非推奨暗号スイートの使用を無効化すべきである(SHOULD)ことに注意。Perfect Forward Secrecy (PFS) 暗号スイートは、PFS でない暗号スイートよりも優先されなければならない (MUST)。(単一)DESやRC4に基づくものなど、既知の弱点を持つ暗号スイートは使用してはならない(MUST NOT)。実装はTLSレベルの圧縮を無効にしなければならない(MUST)。

これらの推奨事項は、TLSまたはDTLSを使用するSTUN Usageの実装と配備が従わなければならない[BCP195]の推奨事項の一部に過ぎない。

TLS Certificateメッセージを受信した場合、クライアントは証明書を検証し、証明書によって特定されるサイトを検査しなければならない(MUST)。証明書が無効または失効している場合、または証明書によって特定されない場合、クライアントは証明書を検証し、証明書によって特定されるサイトを検査しなければならない。

適切な相手であれば、クライアントはSTUNメッセージを送信したり、STUNトランザクションを続行したりしてはならない(MUST NOT)。クライアントはサーバーの身元を確認しなければならない(MUST)。そのためには、[RFC6125]で定義されている識別手順に従い、DNS-IDまたはCN-IDタイプ、オプションとしてワイルドカード文字を左端のラベルとして持つ識別子を含むが、SRV-IDまたはURI-IDタイプではない証明書を使用することである。

STUNがTLS-over-TCP接続またはDTLS-over-UDP関連で他のプロトコルと多重化されて実行される場合、必須暗号スイートおよびTLS処理手順は、これらのプロトコルで定義されたとおりに動作します。

6.3. STUNメッセージの受信
本節では、STUN メッセージの処理について規定する。ここで規定される処理は、本仕様で定義されるSTUNメッセージに対するものであり、後方互換性のための追加規則はセクション11で定義される。これらの追加手続きはオプションであり、使用者はそれらを利用することを選択できる。最初に、クラスに依存しない処理操作のセットが適用される。続いて、クラス固有の処理が行われます（以下のサブセクションで説明します）。

STUNエージェントがSTUNメッセージを受信すると、まずそのメッセージがセクション5の規則に従うかどうかをチェックする。最初の2ビットが0であること、マジッククッキーフィールドが正しい値であること、メッセージ長が適切であること、メソッド値がサポートされているメソッドであることをチェックする。メッセージクラスが特定のメソッドに対して許可されているかどうかをチェックする。メッセージクラスが "Success Response "または "Error Response "の場合、エージェントはトランザクションIDがまだ進行中のトランザクションと一致するかどうかチェックする。FINGERPRINT拡張が使用されている場合、エージェントはFINGERPRINT属性が存在し、正しい値を含んでいることを確認する。何らかのエラーが検出された場合，メッセージは静かに破棄される。STUNが他のプロトコルと多重化されている場合、エラーはこれが本当のSTUNメッセージでないことを示すかもしれない；この場合、エージェントはメッセージを別のプロトコルとして解析することを試みるべきである。

その後、STUNエージェントは、利用者が指定した認証メカニズムで必要とされるチェックを行う（セクション9参照）。

認証チェックが終わると、STUNエージェントはメッセージに未知の属性と既知の、しかし予期せぬ属性があるかどうかをチェックする。未知の理解-任意属性は、エージェントによって無視されなければならない(MUST)。既知の、しかし予期せぬ属性は、エージェントによって無視されるべきである（SHOULD）。未知の理解必須属性は、メッセージクラスに依存する処理を引き起こし、以下に説明される。

この時点で、さらなる処理はリクエストのメッセージクラスに依存する。

6.3.1. リクエストの処理
リクエストに1つ以上の未知の理解度要求属性が含まれている場合、サーバーはエラーコード420（Unknown Attribute）のエラーレスポンスを返信し、未知の理解度要求属性をリストアップするUNKNOWN-ATTRIBUTES属性をレスポンスに含める。

そうでない場合、サーバーはそのメソッドや特定の使用法が必要とする追加チェックを行う。すべてのチェックが成功した場合、サーバーは以下に説明するように成功応答を作成する。

UDPまたはDTLS-over-UDP上で実行されるとき、サーバーが受け取るリクエストはトランザクションの最初のリクエストである可能性もあるし、再送である 可能性もある。クライアントが、元のリクエストに送られた応答ではなく、再送に対する 応答を受け取る場合、クライアントとサーバーの全体のステートは、元の再送 に対する応答だけを受け取る場合、または両方の応答を受け取る場合(この場合、 クライアントは最初の応答を使う)と同じでなければならない[MUST]。この要件を満たす最も簡単な方法は、サーバーが過去40秒間にUDPまたはDTLS-over-UDPで受信したすべてのトランザクションIDと、それに対応する応答を記憶することである。しかし、これはサーバーが状態を保持することを必要とし、認証されていないリクエストには不適切である。別の方法は、リクエストを再処理して応答を再計算することである。後者のテクニックは、冪等性(idempotent)のあるリクエストにのみ適用され なければならず(リクエストは、同じリクエストがシステム全体のステートに影響 を与えることなく安全に繰り返せるときに冪等性とみなされる)、同じリクエストに対して 同じ成功応答をもたらすものである。Bindingメソッドはidempotentとみなされる。反射的なトランスポートアドレス値を変更させ、異なる成功応答において異なる マップドアドレスをもたらす可能性がある、ある稀なネットワークイベントが あることに注意すること。STUNの拡張は、トランザクションステートを保存しないサーバーにおけるリク エストの再送の意味を議論しなければならない[MUST]。

6.3.1.1. 成功またはエラー応答の形成
応答（成功またはエラー）を形成するとき、サーバは第6節の規則に従う。レスポンスのメソッドはリクエストと同じであり、メッセージクラスは "Success Response "または "Error Response "のいずれかである。

エラー応答には、上記の処理で指定されたエラーコードを含む ERROR-CODE 属性を付加しなければなりません。理由のフレーズは固定されていないが、エラーコードに適したものであるべきである（SHOULD）。特定のエラーに対しては、メッセージに追加の属性が追加される。これらの属性は、エラーコードが指定された記述の中で綴られる。例えば、エラーコードが420(Unknown Attribute)の場合、サーバーはUNKNOWN-ATTRIBUTES属性を含めなければならない(MUST)。ある種の認証エラーは、属性を追加する原因にもなる(セクション9参照)。拡張は、他のエラーおよび/またはエラーケースで追加される追加属性を定義することができる。

サーバーが認証機構を使用してリクエストを認証した場合、サーバーは適切な認証属性を 応答に追加するべきである(セクション9参照)。

また、サーバーは、特定の方法または使用方法によって必要とされる属性を追加する。さらに、サーバーはメッセージにSOFTWARE属性を追加するべきである（SHOULD）。

Bindingメソッドでは、使用法で指定されていない限り、追加のチェックは必要ない。成功応答を形成するとき、サーバーは応答にXOR-MAPPED-ADDRESS属性を追加する。この属性は、リクエストメッセージのソーストランスポートアドレスを含む。UDPまたはDTLS-over-UDPの場合、これはリクエストメッセージのソースIPアドレスとソースUDPポートである。TCPおよびTLS-over-TCPの場合、これはサーバーから見たTCP接続のソースIPアドレスとソースTCPポートである。

6.3.1.2.成功・エラーレスポンスの送信
応答（成功またはエラー）は、リクエストが受信されたのと同じトランスポートで送信される。リクエストがUDPまたはDTLS-over-UDPで受信された場合、レスポンスの宛先IPアドレスとポートは、受信したリクエストメッセージのソースIPアドレスとポートに等しくなります。リクエストがTCPまたはTLS-over-TCPで受信された場合、レスポンスはリクエストが受信されたのと同じTCPコネクションで送り返されます。

サーバーは、リクエストを受信した順番とは異なる順番でレスポンスを送信することが許可されています。

6.3.2.インジケーションの処理
もし、その指示に未知の理解必要属性が含まれている場合は、その指示は破棄され、処理は停止される。

そうでない場合、エージェントは、その方法又は特定の使用法が要求する追加のチェックを行う。すべてのチェックが成功した場合，エージェントは，次に指示を処理する。指示に対する応答は生成されない。

Bindingメソッドの場合、使用法で指定されていない限り、追加のチェックや処理は必要ない。エージェントがメッセージを受信しただけで、間にあるNATのbindingがリフレッシュされた。

インジケーションはUDPやDTLS-over-UDPで再送されないので（リクエストとは異なる）、送信エージェントでインジケーションの再送を処理する必要はない。

6.3.3.サクセスレスポンスの処理
成功レスポンスに不明な理解必須属性が含まれている場合、レスポンスは破棄され、トランザクションは失敗したものとみなされる。

そうでない場合、クライアントは、そのメソッドまたは特定の使用法が必要とする追加のチェックを行います。すべてのチェックが成功した場合、クライアントは成功応答を処理する。

Bindingメソッドでは、クライアントはレスポンスにXOR-MAPPED-ADDRESS属性が存在することを確認する。クライアントは、指定されたアドレスファミリーをチェックする。もしそれがサポートされていないアドレスファミリであれば、その属性は無視されるべきである（SHOULD）。それが予期しないがサポートされているアドレスファミリである場合(例えば、 BindingトランザクションはIPv4で送られたが、指定されたアドレスファミリは IPv6である)、クライアントはその値を受け入れて使ってもよい(MAY)。

6.3.4.エラーレスポンスの処理
エラー応答に理解度不要の属性が含まれている場合、またはエラー応答にERROR-CODE属性が含まれていない場合、トランザクションは単に失敗したとみなされる。

そうでない場合、クライアントは次に、認証メカニズム(セクション9参照)によって指定された処理を行う。その結果、新しいトランザクションが試行されるかもしれない。

この時点での処理は、エラーコード、メソッド、使用方法によって異なりますが、以下はデフォルトのルールです。

o エラーコードが300から399の場合、ALTERNATE-SERVER拡張(セクション10)が使用されていない限り、クライアントはトランザクションを失敗したとみなすべきである。

o エラーコードが400から499の場合、クライアントはトランザクションの失敗を宣言する。420（Unknown Attribute）の場合、レスポンスは追加情報を与えるUNKNOWN-ATTRIBUTES属性を含むべきである。

o エラーコードが500から599の場合、クライアントはリクエストを再送してもよい[MAY](そうするクライアントは、これを行う回数を制限しなければならない) 。特定のエラーコードが異なる値を指定しない限り、再送の回数は4回に制限される べきである[SHOULD]。

それ以外のエラーコードは、クライアントがトランザクションを失敗したと判断することになる。

7. FINGERPRINTメカニズム 
このセクションでは、STUNメッセージが同じトランスポートアドレスで多重化されたときに、他のプロトコルのパケットと区別するのを助けるSTUNのオプションメカニズムについて説明する。このメカニズムはオプションであり、STUNの使用法は、それが使用されるかどうか、いつ使用されるかを記述しなければならない。FINGERPRINTメカニズムはRFC3489との後方互換性がなく、互換性が要求される環境では使用することができない。

一部の用途では、STUNメッセージは、RTP（Real-Time Transport Protocol）などの他のプロトコルと同じトランスポートアドレスに多重化される。セクション6で説明する処理を適用するためには、まずSTUNメッセージをアプリケーションパケットから分離する必要がある。

セクション5では、この目的のために使用できるSTUNヘッダーの3つの固定フィールドを説明する。しかし、場合によっては、これら3つの固定フィールドでは十分でないことがある。

FINGERPRINT拡張が使用されるとき，エージェントは，他のエージェントに送るメッセージにFINGERPRINT属性を含める。14.7節では，この属性の配置と値について説明する。

エージェントがSTUNメッセージと思われるものを受信すると、他の基本的なチェックに加えて、エージェントはメッセージがFINGERPRINT属性を含み、その属性が正しい値を含むかどうかもチェックする。セクション6.3では、STUNメッセージの全体的な処理の中で、いつFINGERPRINTチェックが実行されるかを説明しています。この追加チェックは、エージェントがSTUNメッセージに見えるかもしれない他のプロトコルのメッセージを検出するのに役立つ。

8.サーバーのDNSディスカバリー
このセクションでは、クライアントがDNSを使用してサーバーのIPアドレスとポートを決定することを可能にするSTUNのオプション手順について説明する。STUN Usageは、この拡張が使用される場合とそのタイミングを記述しなければならない。への

この手順を使用する場合、クライアントはSTUN URI [RFC7064]を知っている必要がある。また、使用法はクライアントがこのURIを取得する方法を記述しなければならない。STUN URIをソフトウェアにハードコードすることは、ドメイン名が失われたり、法的またはその他の理由で変更する必要がある場合に備えて、推奨されない（NOT RECOMMENDED）。

クライアントがパブリックインターネット上でBindingリクエスト/レスポンストランザクションを受け入れるSTUNサーバーを見つけたい場合、STUN URIスキームは「stun」です。TLSまたはDTLSセッション上でBindingリクエスト/レスポンストランザクションを受け入れるSTUNサーバーを見つけたい場合、URIスキームは「stuns」である。

stun」および「stuns」URIの構文は、[RFC7064]のセクション3.1に定義されている。STUN用法は、追加のURIスキームを定義してもよい（MAY）。

8.1.STUN URIスキームのセマンティクス
stun」URIの<host>部分がIPアドレスを含む場合、このIPアドレスはサーバーにコンタクトするために直接使用される。IPアドレスを含む「stuns」URIは拒否されなければならない(MUST)。将来のSTUN拡張または使用法は、STUNサーバーを認証し、中間者攻撃を防ぐ方法を実証する場合に、この要件を緩和することができる。

URIにIPアドレスが含まれていない場合、[RFC2782]で規定されたSRV手続きを用いて、<host>部に含まれるドメイン名をトランスポートアドレスに解決する。DNS SRVサービス名は、<scheme>部分の内容である。SRVルックアップのプロトコルは、クライアントがSTUNを実行するトランスポートプロトコルである。UDPの場合は "udp"、TCPの場合は "tcp "です。

RFC 2782の手順に従って、コンタクトするサーバーを決定します。RFC 2782は、SRVレコードのセットがどのようにソートされ、そして試行されるかの詳細を綴っている。しかし、RFC2782は、クライアントが「（プロトコル、アドレス、サービス）への接続を試みる」べきであると述べているだけで、失敗した場合に何が起こるかについての詳細は一切述べていない。これらの手順に従うとき、STUNトランザクションが応答を受け取らずにタイムアウトした場合、クライアントはRFC2782で定義された順序で次のサーバーにリクエストを再試行するべきである(SHOULD)。指示トランザクションは応答やタイムアウトを生成しないので、そのような再試行は、リクエスト/レスポンス送信の場合にのみ可能である。

さらに、ドメイン名のAまたはAAAAリソースレコードのいずれかを問い合わせる代わりに、デュアルスタックIPv4/IPv6クライアントは、[RFC8305]で指定されているように、両方を問い合わせ、受け取ったすべてのIPアドレスでリクエストを試さなければならない(MUST)。

STUNリクエストのデフォルトポートは、TCPとUDPの両方で、3478です。STUN over TLSおよびSTUN over DTLSリクエストのデフォルトポートは、5349です。サーバーは、STUN over DTLSをSTUN over TLSと同じポートで実行することができます。

サーバーソフトウェアが初期メッセージがDTLSまたはSTUNメッセージであるかどうかの判定をサポートしている場合、UDP。サーバーソフトウェアが初期メッセージがTLSまたはSTUNメッセージであるかどうかの判定をサポートしている場合、サーバーはTCP上のSTUNと同じポートでSTUN over TLSを実行することができます。

STUNサーバーの管理者は、UDPとTCPのSRVレコードにこれらのポートを使用すべきです（SHOULD）。すべての場合において、DNSのポートは、サーバーがリッスンしているものを反映しなければならない（MUST）。

SRVレコードが見つからない場合、クライアントは[RFC8305]で説明されているように、ドメイン名のAレコードとAAAAレコードの両方のルックアップを実行する。その結果、IPアドレスのリストが生成され、それぞれのIPアドレスは、STUNの使用法とは無関係に、UDPまたはTCPを使用してデフォルトのポートで同時にコンタクトすることができます。TLSを必要とする用途の場合、クライアントはデフォルトのSTUN over TLSポートを使用してIPアドレスに接続します。DTLSを必要とする用途では、クライアントはデフォルトのSTUN over DTLSポートを使用してIPアドレスに接続します。

9.認証とメッセージの完全性メカニズム
このセクションでは、クライアントとサーバーが認証とメッセージの完全性を提供するために使用できるSTUNの2つのメカニズムを定義する。この2つのメカニズムは、短期クレデンシャルメカニズムと長期クレデンシャルメカニズムとして知られている。これらの2つのメカニズムはオプションであり、各使用法はこれらのメカニズムを使用するかどうか、いつ使用するかを指定しなければならない。その結果、クライアントとサーバーの両方は、どの用法が適用されるかを知ることで、（もしあれば）どのメカニズムに従うべきかを知ることができる。例えば、ICEをサポートするパブリックインターネット上のSTUNサーバーは、認証を持たないが、接続性チェックをサポートするエージェント内のSTUNサーバー機能は、短期の資格情報を利用するだろう。これら2つのメカニズムの概要については、セクション2に記載されている。

各機構では、6章で規定した処理を拡張し、その機構を利用するために必要な追加処理を規定している。追加処理は、メッセージの形成時、基本チェックが行われた直後のメッセージ受信時、エラー応答の詳細処理の3箇所で行われる。

エージェントは、MESSAGE-INTEGRITY-SHA256とFINGERPRINT属性を除いて、MESSAGE-INTEGRITYに続くすべての属性を無視しなければならない(MUST)ことに注意すること。同様に、エージェントはMESSAGE-INTEGRITY属性が存在しない場合、FINGERPRINT属性を除いて、MESSAGE-INTEGRITY-SHA256属性に続くすべての属性を無視しなければならない（MUST）。

9.1.短期間のクレデンシャルメカニズム
短期クレデンシャル機構は、STUNトランザクションの前に、クライアントとサーバーがユーザー名とパスワードの形のクレデンシャルを交換するために他のプロトコルを使用したことを想定している。このクレデンシャルは時間制限付きである。制限時間は用途によって定義される。例として、ICEの用法[RFC8445]では、2つのエンドポイントは帯域外シグナリングを使用してユーザー名とパスワードに合意し、このユーザー名とパスワードはメディアセッションの期間中適用可能である。

この信用証明書は、各リクエストと多くの応答で、メッセージの完全性チェックを形成 するために使用される。長期的なメカニズムのようなチャレンジとレスポンスはない。その結果、クレデンシャルの時間制限のある性質により、再生は制限される。

9.1.1.HMACキー
短期間の認証情報については、HMAC（Hash-Based Message Authentication Code）鍵が次のように定義されています。

                       key = OpaqueString(パスワード)        
ここで、OpaqueStringプロファイルは[RFC8265]で定義されています。エンコーディングはUTF-8 [RFC3629]を使用します。

9.1.2.リクエストまたはインディケーションを形成する
リクエストまたはインジケーションメッセージの場合、エージェントは、両エージェ ントがサポートするメッセージ完全性アルゴリズムを外部の仕組みから知ってい ない限り、メッセージにUSERNAME、MESSAGE-INTEGRITY-SHA256、およびMESSAGE-INTEGRITY属性を含めなければならない[MUST]。この場合、USERNAMEに加えてMESSAGE-INTEGRITYまたはMESSAGE-INTEGRITY-SHA256のいずれかが含まれなければならない(MUST)。MESSAGE-INTEGRITY属性のHMACはセクション14.5で述べられているように計算され、MESSAGE-INTEGRITY-SHA256属性のHMACはセクション14.6で述べられているように計算される。パスワードがリクエストや表示に含まれることはないことに注意すること。

9.1.3.リクエストまたはインジケーションを受信する
エージェントは、メッセージの基本的な処理を行った後、指定された順序で以下に列挙するチェックを実行する。

o メッセージに 1) MESSAGE-INTEGRITY または MESSAGE-INTEGRITY-SHA256 属性と 2) USERNAME 属性がない場合。

* メッセージがリクエストである場合、サーバーはエラー応答でリクエストを拒否しなければならない(MUST)。この応答にはエラーコード400(Bad Request)を使用しなければならない(MUST)。

* メッセージが表示である場合、エージェントはその表示を黙って破棄しなければならない(MUST)。

o USERNAMEに現在サーバー内で有効なユーザー名が含まれていない場合。

* メッセージがリクエストである場合、サーバーはエラー応答でリクエストを拒否しなけれ ばならない(MUST)。この応答には、エラーコード401(Unauthenticated)を使用しなければならない(MUST)。

* メッセージが表示である場合、エージェントはその表示を黙って破棄しなければならない(MUST)。

o MESSAGE-INTEGRITY-SHA256 属性が存在する場合、ユーザー名に関連付けられたパスワードを使用して、セクション 14.6 で説明されているようにメッセージの完全性の値を計算する。MESSAGE-INTEGRITY-SHA256属性が存在しない場合、同じパスワードを使用して、セクション14.5で説明されているように、メッセージの整合性の値を計算する。結果の値が対応する属性（MESSAGE-INTEGRITY-SHA256またはMESSAGE-INTEGRITY）のコンテンツと一致しない場合。

* メッセージがリクエストである場合、サーバーはエラー応答でリクエストを拒否しなけれ ばならない(MUST)。この応答には、エラーコード401(Unauthenticated)を使用しなければならない(MUST)。

* メッセージが表示である場合、エージェントはその表示を黙って破棄しなければならない(MUST)。

これらのチェックに合格した場合、エージェントはリクエストまたは指示の処理を続行する。MESSAGE-INTEGRITY-SHA256属性を含むリクエストに対してサーバーが生成した 応答は、リクエストを認証するために利用したパスワードを使用して計算された MESSAGE-INTEGRITY-SHA256属性を含まなければならない[MUST]。MESSAGE-INTEGRITY属性だけを含むリクエストに対してサーバーが生成した 応答は、リクエストを認証するために利用したパスワードを使って計算された MESSAGE-INTEGRITY属性を含まなければならない。これは、これらの属性のうち1つだけが応答中に現れることができることを意味する。応答はUSERNAME属性を含んではならない(MUST NOT)。

いずれかのチェックが失敗した場合、サーバーはエラー応答にMESSAGE-INTEGRITY-SHA256、 MESSAGE-INTEGRITY、またはUSERNAME属性を含めてはならない [MUST NOT]。これは、これらの失敗例では、サーバーがMESSAGE-INTEGRITY-SHA256または MESSAGE-INTEGRITY属性を計算するのに必要な共有秘密を決定できないためである。

9.1.4.レスポンスの受信
クライアントは応答中にMESSAGE-INTEGRITYまたはMESSAGE-INTEGRITY-SHA256属性を探す。もし存在し、クライアントがリクエストでMESSAGE-INTEGRITYまたは MESSAGE-INTEGRITY-SHA256属性の一つだけを送った場合(セクション9.1.2 の外部指示のため、またはセクション9.1.5で定義するようにこれは後続リクエストであるため）、応答 のアルゴリズムはマッチしなければならない。

次にクライアントは、リクエストに使用したのと同じパスワードを使用して、 MESSAGE-INTEGRITY属性についてはセクション14.5、MESSAGE-INTEGRITY-SHA256属性についてはセクション14.6で定義されているように、 応答のメッセージ整合性を算出する。結果として得られる値が、それぞれMESSAGE-INTEGRITYまたはMESSAGE-INTEGRITY-SHA256属性の内容と一致する場合、その応答は認証されたとみなされる。値が一致しない場合、あるいはMESSAGE-INTEGRITYとMESSAGE-INTEGRITY-SHA256の両方がない場合、処理はリクエストが信頼できるトランスポートと信頼できないトランスポートのどちらで送られたかによる。

リクエストが信頼性の低いトランスポート上で送られた場合、その応答は受 信されなかったものとして破棄されなければならない[MUST]。これは、再送(該当する場合)が継続されることを意味する。受け取ったすべての応答が破棄された場合、トランザクションを終了した後にタイムアウ トをシグナリングする代わりに、レイヤーは完全性保護が破られたことをシグナリング しなければならない[MUST]。

リクエストが信頼できるトランスポート上で送られた場合、応答は破棄されなけれ ばならず[MUST]、レイヤーは直ちにトランザクションを終了し、完全性保護が破 壊されたことをシグナリングしなければならない[MUST]。

9.1.5.後続のリクエストの送信
同じサーバーに後続のリクエストを送るクライアントは、最初のリクエストに対する応答で受け取った属性と一致するMESSAGE-INTEGRITY-SHA256またはMESSAGE-INTEGRITY属性のみを送らなければならない(MUST)。ここで、「同じサーバー」とは、同じIPアドレスとポート番号を意味し、単に同じURIやSRVルックアップ結果という意味ではない。

9.2.長期的なクレデンシャルメカニズム
長期クレデンシャル機構は、クライアントとサーバ間で共有されるユーザ名とパスワードの形 で、長期クレデンシャルに依存する。クレデンシャルは、ユーザーに対してプロビジョニングされ、ユーザーがシステムのサブスクライバーでなくなるか、変更されるまで有効であると仮定されるため、長期的と見なされる。これは基本的に、ユーザーに与えられる従来の「ログイン」ユーザー名とパスワードである。

これらのユーザー名とパスワードは長期間有効であることが予想されるため、ダイジェストチャレンジという形で再生防止が提供される。このメカニズムでは、クライアントは最初に、認証情報や完全性チェックを提供することなく、リクエストを送信します。サーバーはこのリクエストを拒否し、ユーザーにレルム(ユーザー名とパスワードの選択においてユーザーまたはエージェントを導くために使用される)とnonceを提供する。nonceは、限定的なリプレイ保護を提供する。これは、サーバーによって選択され、有効期間または有効なクライアントIDを示すような方法で符号化されたクッキーである。サーバーだけが、クッキーの内部構造を知る必要があります。クライアントはリクエストを再試行し、今度はユーザ名とレルムを含み、サーバから提供されたnonceをエコーする。クライアントはまた、この文書で定義されている message-integrity 属性の一つを含み、nonce を含むリクエスト全体に対する HMAC を提供する。サーバーはnonceを検証し、メッセージの完全性をチェックする。それらが一致する場合、リクエストは認証される。nonceがもはや有効でない場合、それは「stale」とみなされ、サーバーは リクエストを拒否して新しいnonceを提供する。

同じサーバへのその後のリクエストでは、クライアントは以前に使用した nonce、ユーザ名、realm、およびパスワードを再利用する。このように、サーバによってnonceが無効になるまで、後続のリクエストは拒否されないが、その場合、拒否はクライアントに新しいnonceを提供する。

指示はチャレンジできないので、長期クレデンシャル機構は指示を保護するために使用でき ないことに注意する。表示を利用する用途は、短期クレデンシャルを使用するか、そのための認証とメッセージの完全性を省略する必要がある。

この仕様をサポートすることを示すために、サーバーはNONCE属性値の前に、「obMatJos2」とセクション18.1で定義されている24ビットSTUN Security Featuresの（4文字）base64 [RFC4648]エンコーディングを連結した文字列を付けなければならない（MUST）。24ビットのセキュリティ機能セットは3バイトとしてエンコードされ、ビット0は1バイト目の最上位ビット、ビット23は3バイト目の最下位ビットとする。セキュリティ機能を使用しない場合は、24ビット全てを0に設定したバイト配列とする。

代わりにエンコードされなければならない（MUST）。この文書の残りの部分では、"nonce cookie "という用語は、NONCE属性値の前に付けられた完全な13文字の文字列を指すことになる。

長期クレデンシャル機構はオフライン辞書攻撃の影響を受けやすいため、デプロイメントでは推測が困難なパスワ ードを利用すべきである（SHOULD）。クレデンシャルがユーザーによって入力されるのではなく、デバイスのプロビジョニング中にクライアントデバイスに配置される場合、パスワードは少なくとも 128 ビットのランダム性を持つべきである（SHOULD）。クレデンシャルがユーザーによって入力される場合、パスワード構造に関する現在のベストプラクティスに従 うべきである。

9.2.1.ビッドダウン攻撃防止
本書では、パスワード保護に使用するアルゴリズムを選択する機能と、匿名ユーザー名を使用する機能を提供する、2つの新しいセキュリティ機能を紹介します。これらの機能は、STUNプロトコルの旧バージョンとの後方互換性を保つために、両方ともオプションである。

このような新機能は、メッセージ経路上の攻撃者がこれらの機能を削除し、より弱いセキュリティ特性を強制することができるビッドダウン攻撃の対象となります。このような攻撃が発見されないようにするため、ノンスは追加情報で強化されています。

nonceクッキー」の値は、選択された特定のSTUNセキュリティ機能ビットに基づき変化する。本書が特定のSTUNセキュリティ機能を説明するセクションで「nonce cookie」に言及する場合、「nonce cookie」の対応するSTUNセキュリティ機能ビットが1に設定されることを理解する。

例えば、PASSWORD-ALGORITHMSセキュリティ機能（セクション9.2.4で定義）が使用される場合、対応する「パスワードアルゴリズム」ビット（セクション18.1で定義）は「nonce cookie」において1に設定されます。

9.2.2. HMACキー
PASSWORD-ALGORITHM属性で指定された、異なるアルゴリズムを使用しない長期クレデンシャルの場合、キーは16バイトである。

                key = MD5(username ":" OpaqueString(realm) ":" OpaqueString(password))        
ここで、MD5 は [RFC1321] と [RFC6151] で定義されており、OpaqueString プロファイルは [RFC8265] で定義されています。エンコーディングは UTF-8 [RFC3629] を使用する。

16バイトの鍵は、以下の5つのフィールドを連結した結果のMD5ハッシュを取ることで形成されます。(1) USERNAME属性から引用符と末尾のヌルを取り除いたユーザー名（この場合、OpaqueStringはすでに適用されている）、 (2) シングルコロン、 (3) OpaqueString処理後の引用符と末尾のヌルを取り除いた領域、 (4) シングルコロン、 (5) OpaqueString処理後の末尾ヌルを除いたパスワード、。例えば、ユーザー名が「user」、レルムが「realm」、パスワードが「pass」の場合、16バイトのHMACキーは、文字列「user:realm:pass」に対してMD5ハッシュを実行した結果、ハッシュ値は0x8493fbc53ba582fb4c044c456bdc40ebになります。

長期的な信用証明書とともに使用される場合のキーの構造は、SIP [RFC3261]も利用するシステムでの展開を容易にする。一般的に、SIPのダイジェスト認証メカニズムを利用するSIPシステムは、実際にパ スワードをデータベースに保存しない。むしろ、彼らは「H(A1)」と呼ばれる値を格納する。これは、上で定義したキーと等しい。たとえば、このメカニズムは、[RFC5090]で定義されている認証拡張と 共に使用することができる。

PASSWORD-ALGORITHMを使用する場合、使用する鍵長およびアルゴリズムは18.5.1節で説明する。

9.2.3.リクエストの形成
クライアントからサーバへの最初のリクエスト(セクション8のDNS手続きが使用され ている場合はホスト名で、そうでない場合はIPアドレスで識別)は、セクション9.2.3.1の規則 に従って処理される。前のリクエスト/レスポンストランザクションが正常に完了した後、クライアント が次のリクエストを開始する場合は、9.2.3.2節の規則に従って行われる。401(Unauthenticated)または438(Stale Nonce)エラー応答の結果としてリクエストを形成することは、セクション9.2.5でカバーされ、「後続リクエスト」とはみなされず、したがってセクション9.2.3.2で記述される規則を利用しない。これらのタイプのリクエストは、それぞれ異なる必須属性を持つ。

9.2.3.1.最初のリクエスト
クライアントがサーバーとのリクエスト/レスポンストランザクションを成功させていない場合、USERNAME、USERHASH、MESSAGE-INTEGRITY、MESSAGE-INTEGRITY-SHA256、REALM、NONCE、PASSWORD-ALGORITHMS、およびPASSWORD-ALGORITHM属性を省略しなければならない[MUST]。言い換えると、最初のリクエストは、認証やメッセージの完全性が適用されていないかのように送信される。

9.2.3.2.後続の要求
リクエスト/レスポンストランザクションが完了すると、クライアントはサーバーから realmとnonceを提示され、認証に使用するユーザー名とパスワードを選択したことになる。クライアントは、その後のサーバーとの通信のために、ユーザー名、パス ワード、realm、nonceをキャッシュするべきである(SHOULD)。クライアントが後続のリクエストを送るとき、USERNAMEまたはUSERHASH、REALM、NONCE、PASSWORD-ALGORITHM属性のいずれかに、これらのキャッシュされた値を含めなければならない(MUST)。MESSAGE-INTEGRITY属性またはMESSAGE-INTEGRITY-SHA256属性を含めなければならない (キャッシュされたパスワードを使用してセクション14.5と14.6の説明に従って計算され る)。2つの属性の選択は、最初のリクエストに対する応答で受け取った属性 に依存する。

9.2.4.リクエストの受信
サーバーはリクエストの基本的な処理を行った後、指定された順序で以下に示すチェックを行う。REALMの値は、STUNサーバーのプロバイダーのドメイン名であることが推奨される（RECOMMENDED）ことに注意してください。

o メッセージがMESSAGE-INTEGRITYまたはMESSAGE-INTEGRITY-SHA256属性を含まない場合、サーバーはエラーコード401 (Unauthenticated) を持つエラー応答を生成しなければならない(MUST)。この応答はREALM値を含まなければならない(MUST)。この応答は、サーバーが選択したNONCEを含まなければならない(MUST)。サーバーは、ソースIPアドレスとポートが同じでない限り、2つのリクエストに 同じNONCEを選んではならない[MUST NOT]。その場合、サーバーはPASSWORD-ALGORITHMS属性に優先順位をつけてそれらを列挙することができる。サーバーがPASSWORD-ALGORITHMS属性を追加する場合、STUN Security Featureの「Password algorithms」ビットを1に設定しなければならない。 サーバーは匿名ユーザー名をサポートしてもよく、その場合STUN Security Featureの「Username anonymity」ビットを1に設定しなければならない。 応答はUSERNAME、USERHASH、MESSAGE-INTEGRITY、MESSAGE-INTEGRITY-SHA256属性を持ってはならない(SHOULD NOT).

注：異なる送信元IPアドレスやポートに対してNONCEを再利用することは、[RFC5389]では明示的に禁止されていない。

o メッセージがMESSAGE-INTEGRITYまたはMESSAGE-INTEGRITY-SHA256属性を含み、USERNAMEまたはUSERHASH、 REALM、NONCE属性のいずれかが欠けている場合、サーバーはエラーコード400 (Bad Request)を持つエラー応答を生成しなければならない。この応答には、USERNAME、USERHASH、NONCE、またはREALMを含めるべきではありません。

属性がない。レスポンスには、MESSAGE-INTEGRITY または MESSAGE-INTEGRITY-SHA256 属性を生成するために必要な属性がないため、含めることはできません。

o NONCE属性がSTUN Security Feature "Password algorithms "ビットを1に設定した "nonce cookie "で始まる場合、サーバーは指定された順序でこれらのチェックを実行する。

* リクエストがPASSWORD-ALGORITHMSもPASSWORD-ALGORITHMアルゴリズムも含まない場合、リクエストはPASSWORD-ALGORITHMがMD5であるかのように処理される。

* そうでなければ、(1)PASSWORD-ALGORITHMとPASSWORD-ALGORITHMSがともに存在し、(2)PASSWORD-ALGORITHMSがこのNONCEを送った応答で送られた値に一致し、(3)PASSWORD-ALGORITHMとPASSWORD-ALGORITHMS中のエントリーのいずれかにマッチしないかぎり、サーバーはエラーコード400 (Bad Request) でエラー応答を生成しなければならない[MUST]。

o USERNAMEまたはUSERHASH属性の値が有効でない場合、サーバーはエラーコード401(Unauthenticated)のエラーレスポンスを生成しなければならない(MUST)。この応答はREALM値を含まなければならない(MUST)。このレスポンスには、サーバーが選択したNONCEを含まなければならない(MUST)。応答はPASSWORD-ALGORITHMS属性を含まなければならない(MUST)。レスポンスはUSERNAMEまたはUSERHASH属性を含むべきではない(SHOULD NOT)。応答は、MESSAGE-INTEGRITYまたはMESSAGE-INTEGRITY-SHA256属性を含んでもよい (前の鍵を使用して計算する)。

o MESSAGE-INTEGRITY-SHA256属性が存在する場合、ユーザー名に関連付けられたパスワードを使用して、セクション14.6で説明されているようにメッセージの完全性の値を計算する。そうでない場合は、同じパスワードを使用して、セクション14.5で説明されているようにMESSAGE-INTEGRITY属性の値を計算する。結果の値がMESSAGE-INTEGRITY属性またはMESSAGE-INTEGRITY-SHA256属性のコンテンツと 一致しない場合、サーバーはエラー応答でそのリクエストを拒否しなければ ならない[MUST]。この応答は、エラーコード401(Unauthenticated)を使用しなければならない (MUST)。REALMとNONCE属性を含まなければならず、USERNAME、USERHASH、MESSAGE-INTEGRITY、またはMESSAGE-INTEGRITY-SHA256属性を含むべきではない（SHOULD NOT）。

o NONCEがもはや有効でない場合、サーバーはエラーコード438(Stale Nonce)を持つエラー応答を生成しなければならない(MUST)。この応答は、NONCE、REALM、PASSWORD-ALGORITHMS属性を含まなければならず、USERNAMEとUSERHASH属性を含むべきではありません(SHOULD NOT)。NONCE属性の値は有効でなければならない(MUST)。応答は、MESSAGE-INTEGRITYまたはMESSAGE-INTEGRITY-SHA256属性を含んでもよい。

を計算するために、以前のNONCEを使用します。サーバは、さらなるセキュリティを提供するために、NONCEを取り消すことができる。ガイドラインは[RFC7616]の5.4節を参照。

これらのチェックに合格した場合、サーバーはリクエストの処理を続行する。サーバーが生成するすべての応答は、PASSWORD-ALGORITHMがMD5であるかのように(リクエストがPASSWORD-ALGORITHMSもPASSWORD-ALGORITHMも含まないので)リクエストが処理されない限り、リクエストを認証するために利用されたユーザー名とパスワードを使って計算されるMESSAGE-INTEGRITY-SHA256属性を含めなければならない。その場合、MESSAGE-INTEGRITY-SHA256属性の代わりにMESSAGE-INTEGRITY属性を使用しなければならず(MUST)、REALM、NONCE、USERNAME、USERHASH属性は含まれるべきではない(SHOULD NOT)。

9.2.5.レスポンスの受信
応答がエラーコード401(Unauthenticated)または438(Stale Nonce)のエラー応答の場合、クライアントはNONCE属性値が「nonce cookie」で始まっているかどうかをテストしなければならない(MUST)。もしそうなら、そして「nonce cookie」がSTUN Security Featureの「Password algorithms」ビットを1に設定しているが、PASSWORD-ALGORITHMS属性が存在しない場合、クライアントは新規トランザクションでリクエストを再試行してはならない(MUST NOT)。

応答がエラーコード401(Unauthenticated)のエラー応答である場合、クライアントは新しいトランザクションでリクエストを再試行するべきである(SHOULD)。このリクエストには、クライアントがエラー応答からREALMの適切なユーザー名として決定したUSERNAMEまたはUSERHASHを含めなければならない(MUST)。nonce cookie」が存在し、STUN Security Featureの「Username anonymity」ビットが1に設定されている場合は、USERHASH属性を使用しなければならない(MUST)が、そうでない場合はUSERNAME属性を使用しなければならない（MUST）。リクエストは、エラー応答からコピーされたREALMを含まなければならない(MUST)。リクエストは、エラー応答からコピーされたNONCEを含まなければならない(MUST)。応答がPASSWORD-ALGORITHMS属性を含む場合、リクエストは同じ内容のPASSWORD-ALGORITHMS 属性を含まなければならない(MUST)。応答がPASSWORD-ALGORITHMS属性を含み、この属性がクライアントがサポートするアルゴリズムを少なくとも一つ含む場合、リクエストはリスト上で最初にサポートされるアルゴリズムを持つPASSWORD-ALGORITHM属性を含まなければならない(MUST)。応答がPASSWORD-ALGORITHMS属性を含み、この属性がクライアントがサポートしているアルゴリズムを含まない場合、クライアントは新しいトランザクションでリクエストを再試行してはならない(MUST NOT)。クライアントは、USERNAME、USERHASH、REALM、またはそれに関連するパスワードを前回の試行から変更していない場合、この再試行を実行してはならない(MUST NOT)。

応答がエラーコード438(Stale Nonce)のエラー応答の場合、クライアントは438 (Stale Nonce)応答で提供された新しいNONCE属性を使用して、リクエストを再試行しなけれ ばならない[MUST]。この再試行は、USERNAMEまたはUSERHASH、REALM、およびMESSAGE-INTEGRITYまたはMESSAGE-INTEGRITY-SHA256属性も含まなければならない[MUST]。

他のすべての応答について、NONCE属性がSTUNセキュリティ機能「パスワードアルゴリズム」ビットを1に設定した「nonce cookie」で始まり、PASSWORD-ALGORITHMSが存在しない場合、その応答は無視されなければならない（MUST）。

応答がエラーコード400(Bad Request)のエラー応答で、MESSAGE-INTEGRITYまたはMESSAGE-INTEGRITY-SHA256属性のいずれかを含まない場合、応答は受信しなかったかのように破棄されなければならない[MUST]。これは、再送(該当する場合)が継続されることを意味する。

注意：この場合、400レスポンスはアプリケーションに到達せず、タイムアウトとなります。

クライアントは応答中にMESSAGE-INTEGRITYまたはMESSAGE-INTEGRITY-SHA256属性を探す(成功または失敗のいずれか)。存在する場合、クライアントはリクエストに使用したのと同じパスワードを使用して、セクション14.5または14.6で定義されているように、応答上のメッセージの完全性を計算する。結果の値がMESSAGE-INTEGRITYまたはMESSAGE-INTEGRITY-SHA256属性のコンテンツと一致する場合、応答は認証されたとみなされる。値が一致しない場合、またはMESSAGE-INTEGRITYとMESSAGE-INTEGRITY-SHA256の両方がない場合、処理はリクエストが信頼できるトランスポートまたは信頼できないトランスポート上で送信されることに依存する。

リクエストが信頼性の低いトランスポート上で送られた場合、その応答は受 信されなかったものとして破棄されなければならない[MUST]。これは、再送(該当する場合)が継続されることを意味する。受け取ったすべての応答が破棄された場合、トランザクションを終了した後にタイムアウ トをシグナリングする代わりに、レイヤーは完全性保護が破られたことをシグナリング しなければならない[MUST]。

リクエストが信頼できるトランスポート上で送られた場合、応答は破棄されなけれ ばならず[MUST]、レイヤーは直ちにトランザクションを終了し、完全性保護が破 壊されたことをシグナリングしなければならない[MUST]。

レスポンスにPASSWORD-ALGORITHMS属性が含まれる場合、それ以降のリクエストはすべてMESSAGE-INTEGRITY-SHA256のみを使用して認証されなければならない（MUST）。

10. ALTERNATE-SERVERメカニズム 
このセクションでは、サーバーがクライアントを別のサーバーにリダイレクトすることを可能にするSTUNのメカニズムについて説明する。この拡張はオプションであり、使用法はこの拡張を使うかどうか、いつ使うかを定義しなければならない。ALTERNATE-SERVER属性は、IPアドレスを運ぶ。

この拡張を使用するサーバーは、リクエストメッセージにエラーコード300(Try Alternate)のエラー応答メッセージを返信することによって、クライアントを別のサーバーにリダイレクトする。サーバーはエラー応答に少なくとも一つのALTERNATE-SERVER属性を含めなければならない(MUST)。この属性には、リクエストメッセージのソースIPアドレスと同じアドレスファミリーのIPアドレスが含まれなければならない(MUST)。サーバーは必須の属性の後に、リクエストメッセージのソースIPアドレス以外のアドレスファミリーのIPアドレスを含む追加のALTERNATE-SERVER属性を含むべきである(SHOULD)。エラー応答メッセージは認証されてもよい[MAY]が、応答の認証が不可能または実用的でないALTERNATE-SERVERの使用例もある。トランザクションがTLSまたはDTLSを使用する場合、トランザクションがMESSAGE-INTEGRITY-SHA256属性で認証される場合、そしてサーバーが異なる証明書を使用するサーバーにリダイレクトしたい場合、その証明書のsubjectAltName内の名前を含むALTERNATE-DOMAIN属性を含めなければならない(MUST)。MESSAGE-INTEGRITY-SHA256属性に対するこの一連の条件は、トランザクションが認証されていること、クライアントがこの仕様を実装していること、したがってALTERNATE-DOMAIN属性を処理できることを示す。

この拡張機能を使用するクライアントは、300（Try Alternate）エラーコードを次のように処理する。クライアントは、エラー応答にALTERNATE-SERVER属性を探す。見つかった場合、クライアントは現在のトランザクションを失敗したとみなし、前のリクエストに使用されたのと同じトランスポートプロトコルを使用して、属性で指定されたサーバーにリクエストを再試行する。そのリクエストは、認証される場合、クライアントがリダイレクトを実行したサーバーへのリクエストで使用したであろう同じクレデンシャルを利用しなければならない(MUST)。トランスポートプロトコルがTLSまたはDTLSを使用する場合、クライアントはALTERNATE-DOMAIN 属性を探す。この属性が見つかった場合、[RFC6125]の推奨事項を使用して証明書を 検証するために、そのドメインを使用しなければならない[MUST]。証明書は、DNS-IDまたはCN-ID(最終的にはワイルドカードを使用)タイプの識別子を 含まなければならない(MUST)が、SRV-IDまたはURI-IDタイプの識別子は含まれない。属性が見つからない場合、オリジナルのリクエストに使用されたのと同じドメ インが、証明書を検証するために使用されなければならない[MUST]。クライアントが過去5分以内にこのリクエストをすでに送ったサーバーにリダイレ クトされた場合、クライアントはリダイレクトを無視し、トランザクションが失敗し たとみなさなければならない[MUST]。これは、リダイレクトがループした場合に、サーバー間で無限にピンポンするこ とを防ぐためである。

11.RFC 3489との後方互換性
RFC5389]のセクション12ですでに述べられている下位互換性に加えて、 DTLSは[RFC3489](「クラシックSTUN」と呼ばれる)とともに使用してはならない [MUST NOT]。DTLS上でマジッククッキー(参考文献[1]のセクション6参照)を使用しない STUNリクエストや指示はすべて無効とみなされなければならない[MUST]。すべてのリクエストは500 (Server Error) エラー応答を生成しなければならず、指示は無視されなければならない [MUST]。

12.サーバーの基本動作
このセクションでは、基本的なスタンドアロンSTUNサーバーの動作を定義する。

歴史的に、「クラシックSTUN」[RFC3489]は、STUNbinding要求を受信して返信することで、クライアントにサーバー反射型トランスポートアドレスを提供していたサーバーの動作のみを定義していた。[RFC5389]はプロトコルを拡張可能なフレームワークとして再定義し、サーバー機能はその文書で定義される唯一のSTUN Usageとなった。このSTUN Usageは、「Basic STUN Server」とも呼ばれる。

STUNサーバーは、Bindingメソッドをサポートしなければならない（MUST）。それは、短期または長期の信用証明書メカニズムを利用すべきではない(SHOULD NOT)。これは、リクエストの認証に関わる作業が、単にそれを処理する作業よりも多いからである。同じ理由で、ALTERNATE-SERVERの仕組みも利用すべきではない[SHOULD NOT]。それはUDPとTCPをサポートしなければならない(MUST)。STUN over TCP/TLSまたはSTUN over UDP/DTLSをサポートしてもよい[MAY]が、DTLSとTLSはこの基本的な動作モードでは最小限のセ キュリティ効果をもたらす。TCPまたはTLS-over-TCP接続はBindingトランザクションの終了後に閉じられるので、キープアライブメカニズムを必要としない。それはFINGERPRINTメカニズムを利用してもよいが、それを要求してはならない(MUST NOT)。スタンドアロンサーバーはSTUNを実行するだけなので、FINGERPRINTは何の利益も与えない。それを要求することは、RFC3489との互換性を壊すことになり、そのような互換性はスタンドアロンサーバーでは望ましいことである。スタンドアロンSTUNサーバーは、セクション11で説明されているように、 [RFC3489]を使用するクライアントとの後方互換性をサポートするべきである(SHOULD)。

STUNサーバーの管理者は、セクション8で説明されているように、それらの サーバーのDNSエントリーを提供することが推奨される(RECOMMENDED)。AリソースレコードとAAAAリソースレコードの両方が返される場合、Bindingリクエストは冪等であるため、クライアントはIPv4とIPv6アドレスにSTUN Bindingリクエストを同時に送ることができる(［RFC8305］で規定されているように)。返されるMAPPED-ADDRESSまたはXOR-MAPPED-ADDRESS属性は、使用されるサーバーアドレスのアドレスファミリーと必ずしも一致しないことに注意すること。

基本的なSTUNサーバーは、それだけでNATトラバーサルの解決策にはなりません。しかし、STUN Usagesを通じて、ソリューションの一部として活用することができる。これについては、セクション13でさらに説明する。

13.STUNの使用法
STUNはそれ自体、NATトラバーサルの問題に対する解決策ではありません。むしろ、STUNはより大きなソリューションの中で使用できるツールを定義している。STUNの使用」という用語は、STUNをコンポーネントとして使用するすべてのソリューションに対して使用されます。

STUN Usageは、いつリクエストを送るか、レスポンスをどうするか、ここで定義された（あるいはSTUNの拡張機能で定義された）どのオプション手続きを使うかなど、STUNが実際にどのように利用されるかを定義します。また、使用法は次のようなことも定義している。

o どのSTUNメソッドが使用されているか。

o どのようなトランスポートが使用されているか。DTLS-over-UDP が使用される場合、[RFC6347]のセクション 4.2.1 に記載されているサービス拒否対策の実装が必須となる。

o どのような認証やメッセージの整合性のメカニズムが使用されているか。

o [RFC4107]で議論されているように、完全性メカニズムのための手動鍵導出と自動鍵導出に関する考慮事項。

o STUN メッセージを他のメッセージと区別するために、どのようなメカニズムが使用されるか。STUN が TCP または TLS-over-TCP 上で実行される場合、フレーミングメカニズムが必要とされることがある。

o STUNクライアントがSTUNサーバーのIPアドレスとポートを決定する方法。

o STUNサーバーに対して両方のアドレスファミリーが見つかった場合、IPv4とIPv6アドレスの同時使用（Happy Eyeballs [RFC8305]）が非代替トランザクションでどのように機能するか。

o RFC3489への後方互換性が必要かどうか。

o ここで定義された（FINGERPRINTやALTERNATE-SERVERのような）、あるいは他の拡張機能で定義されたオプション属性が必要とされるものである。

o MESSAGE-INTEGRITY-SHA256 の切り捨てが許可される場合、切り捨てのために許可される限界値。

o STUN が TCP または TLS-over-TCP で実行される場合のキープアライブメカニズム。

o 1）TCPまたはTLS-over-TCP、2）認証が使用される場合に、サーバーにエニーキャストアドレスが使用できるかどうか。

さらに、STUNの使用法は、その使用法においてSTUNを使用することのセキュリティ上の意味を考慮しなければならない。STUNに対する多くの攻撃が知られており（本書の「セキュリティの考慮点」セクションを参照）、どのような使用方法でも、これらの攻撃を阻止または軽減する方法を考慮しなければならない。

最後に、使用法は、STUNの使用法がNATトラバーサルに対するUnilateral Self-Address Fixingアプローチの例であるかどうかを検討し、そうであればRFC3424 [RFC3424]で提起された質問に対処しなければならない。

14.STUN 属性
STUNヘッダーの後には、0個以上の属性がある。各属性は、16ビットのタイプ、16ビットの長さ、および値でTLV符号化されなければならない(MUST)。各STUN属性は32ビットの境界で終わらなければならない（MUST）。上記のように、属性内のすべてのフィールドは最上位ビットから送信されます。

      0                   1                   2                   3
      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     |         Type                  |            Length             |
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     |                         Value (variable)                ....
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
図4：STUN属性のフォーマット

Lengthフィールドの値は、パディング前の属性のValue部分の長さを、バイト単位で含まなければならない（MUST）。STUNは属性を32ビット境界に揃えるので、内容が4バイトの倍数でない属性は、その値が4バイトの倍数を含むように、1、2、または3バイトのパディングでパディングされる。パディングビットは送信時にゼロに設定されなければならず（MUST）、受信側では無視されなければならない（MUST）。

どの属性タイプもSTUNメッセージに複数回出現してもよい（MAY）。特に指定がない限り、出現の順序は重要である：最初の出現のみが受信者によって処理される必要があり、重複は受信者によって無視されてもよい（MAY）。

将来の本仕様の改訂時に、必要に応じて新しい属性を追加できるように、属性空間は2つの範囲に分けられています。0x0000 から 0x7FFF の間の型値を持つ属性は、以下の通りです。

これは、STUNエージェントがその属性を理解しない限り、メッセージを正常に処理できないことを意味するもので、理解必須属性である。0x8000から0xFFFFの間のタイプ値を持つ属性は、理解度オプション属性であり、これは、STUNエージェントがこれらの属性を理解しない場合、無視できることを意味する。

STUN属性タイプのセットは、IANAによって維持される。本仕様で定義される初期セットは、セクション18.3にある。

本節の残りの部分では、本仕様で定義される各種属性のフォーマットについて説明する。

14.1. MAPPED-ADDRESS
MAPPED-ADDRESS属性は、クライアントの反射的トランスポートアドレスを示す。8ビットのアドレスファミリーと16ビットのポートからなり，その後にIPアドレスを表す固定長の値が続く。アドレスファミリーがIPv4の場合、アドレスは32ビットでなければならない（MUST）。アドレスファミリーがIPv6の場合、アドレスは128ビットでなければなりません（MUST）。すべてのフィールドは、ネットワークバイトオーダーでなければならない。

MAPPED-ADDRESS属性のフォーマットは以下の通りです。

      0                   1                   2                   3
      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     |0 0 0 0 0 0 0 0|    Family     |           Port                |
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     |                                                               |
     |                 Address (32 bits or 128 bits)                 |
     |                                                               |
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

図5：MAPPED-ADDRESS属性のフォーマット

アドレスファミリーは、以下の値を取ることができます。

0x01：IPv4 0x02：IPv6

MAPPED-ADDRESSの最初の8ビットは0に設定されなければならず、受信機からは無視されなければならない(MUST)。これらのビットは、自然な32ビット境界でパラメータを整列させるために存在する。

この属性は、[RFC3489]クライアントとの後方互換性を実現するために、サーバのみが使用します。

14.2.xor-mapped-address
XOR-MAPPED-ADDRESS属性はMAPPED-ADDRESS属性と同じだが、反射的なトランスポートアドレスがXOR関数によって難読化される点が異なる。

XOR-MAPPED-ADDRESSのフォーマットは以下の通りです。

      0                   1                   2                   3
      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     |0 0 0 0 0 0 0 0|    Family     |         X-Port                |
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     |                X-Address (Variable)
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

図6 XOR-MAPPED-ADDRESS 属性のフォーマット

Family フィールドは、IP アドレスファミリーを表し、MAPPED-ADDRESS の Family フィールドと同じように符号化される。

X-Portは、マップされたポートとマジック・クッキーの最上位16ビットをXORすることで計算されます。
IPアドレスファミリーがIPv4の場合、X-AddressはマップされたIPアドレスとマジッククッキーのXORによって計算されます。
IPアドレスファミリーがIPv6の場合、X-Addressは、マップされたIPアドレスとマジッククッキーと96ビットトランザクションIDの連結をXORすることによって計算される。すべての場合において、XOR演算はネットワークバイトオーダー（つまり、メッセージにエンコードされる順番）の入力に対して動作する。

属性の値の最初の8ビットを符号化して処理する規則、属性の複数出現を処理する規則、アドレスファミリーを処理する規則は、MAPPED-ADDRESSの場合と同じである。

注：XOR-MAPPED-ADDRESSとMAPPED-ADDRESSは、トランスポートアドレスの符号化においてのみ異なる。前者は、トランスポートアドレスをマジッククッキーとXORすることでエンコードする。後者は、それを直接バイナリでエンコードする。RFC 3489は当初、MAPPED-ADDRESSだけを指定していた。しかし、展開の経験から、STUNのMAPPED-ADDRESS属性のようなNATのパブリックIPアドレスを含む32ビットバイナリペイロードを、一般的なアプリケーションレイヤーゲートウェイ（ALG）機能を提供しようとする善意だが間違った試みで書き換えるNATがあることがわかった。このような動作はSTUNの動作を妨害し、またSTUNのメッセージ整合性チェックの失敗の原因となる。

14.3.USERNAME
USERNAME属性は、メッセージの完全性のために使われる。メッセージの完全性チェックに使われるユーザ名とパスワードの組合せを識別するものである。

USERNAMEの値は、認証ユーザー名を含む可変長の値である。これは、509バイト以下のUTF-8エンコード[RFC3629]シーケンスを含まなければならず、OpaqueStringプロファイル[RFC8265]を使用して処理されていなければならない(MUST)。準拠する実装は、[RFC5389]と互換性があるように、763オクテット以下のUTF-8エンコードされたシーケンスをパースできるようにしなければならない(MUST)。

注：[RFC5389]は、[RFC2279]のUTF-8の定義を誤って参照しています。[RFC2279]では、エンコードされた文字あたり最大6オクテットを想定していました。[RFC2279]は[RFC3629]に置き換えられ、Unicode 2.0とISO/IEC 10646で行われた変更と一致し、エンコードされた文字あたり4オクテットのみを許可しています。

注：この仕様では、配置されたパスワードストアとの互換性を向上させるために、ユーザー名文字列処理にUsernameCasePreservedプロファイルではなく、OpaqueStringプロファイルを使用しています。HTTPおよびSIPダイジェスト認証に使用される多くのパスワードデータベースは、プレーンテキストのパスワードを保存する代わりに、username:realm:passwordのMD5ハッシュを保存する。RFC3489]では、STUN認証は、SIPやHTTPのように、スペース以外のASCII制御文字を禁止する以外に、ユーザー名とパスワードの前処理を行わない、これらの既存のデータベースと可能な限り互換性を持つように設計された。STUN仕様の次の改訂版[RFC5389]では、ユーザー名とパスワードの前処理にSASLprep [RFC4013] stringprep [RFC3454] プロファイルを使用しました。SASLprepは、Unicode Normalization Form KC (Compatibility Decomposition, followed by Canonical Composition) [UAX15] を使用し、様々な制御、スペース、非テキスト、非推奨、または不適切なコードポイントを禁止しています。PRECISフレームワーク[RFC8264]はstringprepを廃止している。PRECISのユーザー名とパスワードの扱い [RFC8265]は、Unicode Normalization Form C (Canonical Decomposition, followed by Canonical Composition)を使用しています。HTTP Digestの下で異なるユーザー名文字列が、OpaqueStringで処理される単一のSTUNユーザー名にマッピングされる特定のケースがありますが、これらのケースは非常にまれで、検出および修正が容易です。UsernameCasePreserved プロファイルでは、HTTP Digest で有効なユーザー名と処理された形式（特に双方向テキストと互換形式を含むユーザー名）が一致しないことがより多くなります。オペレータは、問題のある文字を避けるために、ユーザー名で許可されるコードポイントをさらに自由に制限することができます。

14.4.USERHASH
USERHASH属性は、ユーザー名の匿名性をサポートする場合に、USERNAME属性の代わりとして使用されます。

USERHASHの値は、32バイトの固定長である。ユーザー名は OpaqueString プロファイル [RFC8265] で処理されていなければならず (MUST)、realm は OpaqueString プロファイル [RFC8265] で処理されてからハッシュされなければなりません (MUST)。

以下は、クライアントがユーザー名をハッシュ化するために実行する操作です。

   userhash = SHA-256(OpaqueString(username) ":" OpaqueString(realm))        

14.5.メッセージインテグリティ
MESSAGE-INTEGRITY属性は、STUNメッセージのHMAC-SHA1［RFC2104］を含む。MESSAGE-INTEGRITY属性は、どのSTUNメッセージタイプにも存在することができる。SHA-1ハッシュを使用するので、HMACは20バイトになる。

HMACのキーは、どのクレデンシャル・メカニズムが使用されているかによって異なる。セクション9.1.1では短期クレデンシャル・メカニズムのキーを定義し、セクション9.2.2では長期クレデンシャル・メカニズムのキーを定義する。他のクレデンシャル・メカニズムは、HMACに使用されるキーを定義しなければならない（MUST）。

HMACの入力として使用されるテキストは、MESSAGE-INTEGRITY属性の前の属性を含むまでのSTUNメッセージである。STUNメッセージヘッダのLengthフィールドは、MESSAGE-INTEGRITY属性の終わりを指すように調整される。MESSAGE-INTEGRITY属性の値は、ダミー値に設定される。

計算が実行されると、MESSAGE-INTEGRITY属性の値は埋められ、STUNヘッダーのLengthの値は正しい値(メッセージ全体の長さ)に設定される。同様に、MESSAGE-INTEGRITYを検証するとき、STUNヘッダーのLengthフィールドは、STUNメッセージ上でHMACを計算する前に、MESSAGE-INTEGRITY属性の終わりを指すように、MESSAGE-INTEGRITY属性の前の属性まで含めて調整しなければならない。このような調整は、FINGERPRINTやMESSAGE-INTEGRITY-SHA256などの属性がMESSAGE-INTEGRITYの後に現れるときに必要である。このような計算の例については、[RFC5769]も参照されたい。

14.6.メッセージインテグリティシャ256
MESSAGE-INTEGRITY-SHA256属性は、STUNメッセージのHMAC-SHA256 [RFC2104]を含む。MESSAGE-INTEGRITY-SHA256属性は、どのSTUNメッセージタイプにも存在することができる。MESSAGE-INTEGRITY-SHA256属性は、STUNメッセージのHMAC-SHA-256 [RFC2104] の初期部分を含む。値は最大で32バイトになるが、少なくとも16バイトでなければならず、4バイトの倍数でなければならない（MUST）。STUN Usageが切り捨てを許可することを明示的に指定しない限り、値は完全な32バイトでなければならない。STUN Usageは、16バイトより長い最小長を指定することができる。

HMACのキーは、どのクレデンシャル・メカニズムが使用されているかによって異なる。セクション9.1.1では短期クレデンシャル機構のキーを定義し、セクション9.2.2では長期クレデンシャル機構 のキーを定義する。他のクレデンシャル機構は、HMACに使用されるキーを定義しなければならない（MUST）。

HMACの入力として使用されるテキストは、MESSAGE-INTEGRITY-SHA256属性の前の属性を含むまでのSTUNメッセージである。STUNメッセージヘッダのLengthフィールドは、MESSAGE-INTEGRITY-SHA256属性の終わりを指すように調整される。MESSAGE-INTEGRITY-SHA256属性の値は、ダミー値に設定される。

計算が実行されると、MESSAGE-INTEGRITY-SHA256属性の値が埋められ、STUNヘッダーのLengthの値が正しい値（メッセージ全体の長さ）に設定される。同様に、MESSAGE-INTEGRITY-SHA256を検証する場合、STUNヘッダーのLengthフィールドは、STUNメッセージ上でHMACを計算する前に、MESSAGE-INTEGRITY-SHA256属性の終わりを指すように調整されなければならず、MESSAGE-INTEGRITY-SHA256属性より前の属性を含むまでである。このような調整は、FINGERPRINTなどの属性がMESSAGE-INTEGRITY-SHA256の後に現れるときに必要である。このような計算の例については、付録B.1も参照されたい。

14.7.フィンガープリント
FINGERPRINT属性は、すべてのSTUNメッセージに存在してもよい（MAY）。

属性の値は、STUNメッセージのCRC-32からFINGERPRINT属性自身を除いたもので、32ビット値0x5354554eとXORされたものとして計算される。(XOR操作は、アプリケーションプロトコルによって生成されたCRC-32を含むパケットで、FINGERPRINTテストが誤検出を報告しないことを保証する)。32ビットCRCは、ITU V.42 [ITU.V42.2002]で定義されているものであり、以下の通りです。

の生成多項式は x^32 + x^26 + x^23 + x^22 + x^16 + x^12 + x^11 + x^10 + x^8 + x^7 + x^5 + x^4 + x^2 + x + 1 となります。RFC1952]のセクション8にあるCRC-32のサンプルコードを参照してください。

存在する場合、FINGERPRINT属性はメッセージの最後の属性でなければならず、したがって、MESSAGE-INTEGRITYとMESSAGE-INTEGRITY-SHA256の後に現れることになる。

FINGERPRINT属性は、STUNパケットを他のプロトコルのパケットと区別するのに役立つ。セクション7を参照してください。

MESSAGE-INTEGRITYやMESSAGE-INTEGRITY-SHA256と同様に、FINGERPRINT属性で使用するCRCはSTUNメッセージヘッダのLengthフィールドを対象とする。したがって、CRCを計算する前に、この値が正しく、メッセージ長の一部としてCRC属性を含む必要があります。メッセージでFINGERPRINT属性を使用する場合、属性はまずダミー値でメッセージに配置され、次にCRCが計算され、属性の値が更新される。MESSAGE-INTEGRITYまたはMESSAGE-INTEGRITY-SHA256属性も存在する場合、CRCはMESSAGE-INTEGRITYとMESSAGE-INTEGRITY-SHA256属性の値に対しても行われるため、CRCが計算される前に正しいメッセージ完全性の値で存在しなければならない。

14.8.ERROR-CODE（エラーコード
ERROR-CODE属性は、エラー応答メッセージで使われます。それは、300から699の範囲の数値エラーコード値とUTF-8 [RFC3629]で符号化されたテキストの理由フレーズを含んでいます; それはまた、SIP [RFC3261] とHTTP [RFC7231] とのコードの割り当てと意味論において一貫しています。理由フレーズは診断のために意図されており、エラーコードに適したものであれば何でもよい。定義されたエラーコードのための推奨される理由フレーズは、エラーコードのためのIANAレジストリに含まれています。理由フレーズは，128文字未満のUTF-8エンコード[RFC3629]シーケンスでなければならない(エンコードする場合は509バイト，デコードする場合は763バイトの長さになることもある)。

      0                   1                   2                   3
      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     |           Reserved, should be 0         |Class|     Number    |
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     |      Reason Phrase (variable)                                ..
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

図7 ERROR-CODE 属性のフォーマット

処理を容易にするため、図7に示すように、エラーコードのクラス（百の位）を他のコードとは別に符号化する。

Reserved ビットは 0 であるべきであり、32 ビット境界でのアライメントのためのものである。受信機はこれらのビットを無視しなければならない（MUST）。Classは、エラーコードの百の位を表します。値は3から6の間でなければならない（MUST）。Numberは，エラーコードを100倍したバイナリ符号化を表し，その値は0から99の間でなければならない（MUST）。

以下のエラーコードと、その推奨理由フレーズが定義されています。

300 代替を試す。クライアントはこのリクエストに対して代替のサーバーに連絡する必要がある。このエラー応答は、リクエストがUSERNAMEまたはUSERHASH属性と有効なMESSAGE-INTEGRITYまたはMESSAGE-INTEGRITY-SHA256属性を含む場合にのみ送られなければならない(MUST)。それ以外は送ってはならず、エラーコード400 (Bad Request) が示唆される。このエラー応答はMESSAGE-INTEGRITYまたはMESSAGE-INTEGRITY-SHA256属性で保護されなければならず、受信者は代替サーバーにリダイレクトする前にこの応答のMESSAGE-INTEGRITYまたはMESSAGE-INTEGRITY-SHA256を検証しなければならない。

注：300応答のメッセージ整合性を生成し検証しない場合、オンパスの攻撃者が300応答を改ざんし、後続のSTUNメッセージを被害者に送信させることができます。

400 Bad Request:リクエストは不正な形式でした。クライアントは、前回の試行から変更せずにリクエストを再試行すべきではない(SHOULD NOT)。サーバーはこのエラーに対して有効なMESSAGE-INTEGRITYまたはMESSAGE-INTEGRITY-SHA256を生成できないかもしれないので、クライアントはこの応答で有効なMESSAGE-INTEGRITYまたはMESSAGE-INTEGRITY-SHA256属性を期待してはならない(MUST NOT)。

401 Unauthenticated（認証されていない）。リクエストには、処理を進めるための正しい認証情報が含まれていません。クライアントは、適切な認証情報を使ってリクエストを再試行する必要があります。

420 Unknown Attribute:サーバーは、理解できない理解必須の属性を含むSTUNパケットを受信した。サーバーは、この不明な属性をエラー応答のUNKNOWN-ATTRIBUTE属性に入れなければならない(MUST)。

438 Stale Nonce: クライアントが使用した NONCE は、もはや有効ではありません。クライアントは、レスポンスで提供された NONCE を使用して再試行する必要があります。

500 サーバーエラーです。サーバーに一時的なエラーが発生しました。クライアントが再試行する必要があります。

14.9. レルム
REALM属性はリクエストとレスポンスに存在する可能性がある。これは[RFC3261]に記述されているrealm-valueの文法を満たすが、二重引用符とその周囲の空白を除いたテキストを含む。つまり、それは引用符で囲まれていないrealm-valueである(したがって、qdtext またはquoted-pairのシーケンスである)。それは、128文字未満のUTF-8エンコード[RFC3629]シーケンス(エンコード時は509バイト、デコード時は763バイトまで可能)で、OpaqueStringプロファイル[RFC8265]を使用して処理されていなければならない[MUST]。

リクエストにREALM属性が存在する場合、認証に長期的なクレデンシャルが使用されていることを示す。ある種のエラー応答に存在することは、サーバーがクライアントにそのレルムの長期的なクレデンシャルを認証に使用することを望むことを示す。

14.10. ノンス
NONCE属性は、リクエストとレスポンスに存在する可能性がある。これは[RFC3261]で定義されているqdtextまたはquoted-pairのシーケンスを含んでいます。これは、NONCE属性が実際の周囲の引用文字を含まないことを意味することに注意してください。NONCE属性は128文字以下でなければなりません（エンコード時には509バイト、デコード時には763バイトになる可能性があります）。サーバーにおけるnonce値の選択に関するガイダンスについては、[RFC7616]のセクション5.4を参照してください。

14.11.パスワード・アルゴリズム
PASSWORD-ALGORITHMS属性は、リクエストとレスポンスに存在する可能性がある。これは、サーバーが長期パスワードを導き出すために使用できるアルゴリズムのリストを含んでいます。

既知のアルゴリズムの集合は、IANAによって維持される。本仕様で定義される初期セットは、18.5項にある。

この属性には、アルゴリズム番号と可変長パラメータのリストが含まれる。アルゴリズム番号は，18.5節に定義されるように，16ビット値である。パラメータは，16ビット値としてのパラメータの長さ（パディング前）で始まり，各アルゴリズムに固有のパラメータがそれに続く。パラメータは，属性と同じように，32ビット境界にパディングされる。

      0                   1                   2                   3
      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     |         Algorithm 1           | Algorithm 1 Parameters Length |
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     |                    Algorithm 1 Parameters (variable)
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     |         Algorithm 2           | Algorithm 2 Parameters Length |
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     |                    Algorithm 2 Parameters (variable)
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     |                                                             ...  
図8：PASSWORD-ALGORITHMS属性のフォーマット

14.12.パスワードアルゴリズム
PASSWORD-ALGORITHM属性は、リクエストにのみ存在する。これは、サーバーが長期パスワードから鍵を導出するために使用しなければならないアルゴリズムを含んでいます。

既知のアルゴリズムのセットは、IANAによって維持される。本仕様で定義される初期セットは、18.5項にある。

この属性は、アルゴリズム番号と可変長パラメータを含む。アルゴリズム番号は，18.5節で定義される16ビットの値である。パラメータは，パラメータの長さ（パディング前）を16ビット値として開始し，アルゴリズムに固有のパラメータが続く。パラメータは，属性と同じように，32ビット境界にパディングされる。同様に，パディングビットは送信時にゼロに設定されなければならず，受信側では無視されなければならない（MUST）。

      0                   1                   2                   3
      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     |          Algorithm           |  Algorithm Parameters Length   |
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     |                    Algorithm Parameters (variable)
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

図9：PASSWORD-ALGORITHM属性のフォーマット

14.13.アンノウンアトリビュート
UNKNOWN-ATTRIBUTES属性は、ERROR-CODE属性の応答コードが420（Unknown Attribute）の時のみ、エラー応答中に存在する。

この属性には16ビットの値のリストが含まれ、各値はサーバーが理解できなかった属性タイプを表しています。

      0                   1                   2                   3
      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     |      Attribute 1 Type         |       Attribute 2 Type        |
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     |      Attribute 3 Type         |       Attribute 4 Type    ...
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

図10：UNKNOWN-ATTRIBUTES属性のフォーマット

注：[RFC3489]では，このフィールドは，最後の属性を複製することによって32にパディングされていた。このバージョンの仕様では，属性のための通常のパディング規則が代わりに使用される。

14.14. ソフトウェア
SOFTWARE属性は、メッセージを送信するエージェントが使用しているソフトウェアのテキスト記述を含んでいます。これは，クライアントとサーバで使用される。その値には製造元とバージョン番号を含むべきである（SHOULD）。この属性はプロトコルの動作に影響を与えず、診断とデバッグのためのツールとしてのみ機能する。SOFTWAREの値は可変長である。128文字以下のUTF-8エンコード[RFC3629]シーケンスでなければならない(エンコード時は509バイト、デコード時は763バイトになることもある)。

14.15.オルタネートサーバー
代替サーバーは、STUNクライアントが試みるべき別のSTUNサーバーを特定する代替トランスポートアドレスを表す。

MAPPED-ADDRESSと同じようにエンコードされているため、IPアドレスで1台のサーバーを参照することになる。

14.16.オルタネートドメイン
代替ドメインは、トランスポートプロトコルがTLSまたはDTLSを使用する場合に、ALTERNATE-SERVER属性のIPアドレスを検証するために使用されるドメイン名を表すものである。

ALTERNATE-DOMAINの値は可変長である。255文字以下の有効なDNS名[RFC1123]（A-labels[RFC5890]を含む）でなければならない[MUST]。

15.運用上の留意点
STUNはエニーキャストアドレスで使用してもよいが、UDPで、かつ認証が使用されないSTUN使用法でのみ使用する。

16.セキュリティに関する考慮事項
TLSまたはDTLSを使用するSTUN Usageの実装と展開は、[BCP195]の推奨に従わなければならない（MUST）。

長期クレデンシャル機構(セクション9.2)を使用するSTUN Usageの実装およびデプロイは、[RFC7616]のセクション5の推奨に従わなければならない[MUST]。

16.1. プロトコルに対する攻撃
16.1.1.外部からの攻撃
攻撃者は、STUN操作の失敗を引き起こすために、転送中のSTUNメッセージを変更しようとすることができる。これらの攻撃は、短期または長期のクレデンシャルを使用するメッセージ整合性メカニズムを通じて、リクエストとレスポンスの両方で検出される。もちろん、検出されれば、操作されたパケットはドロップされ、STUNトランザクションが事実上失敗する原因となる。この攻撃はオンパスの攻撃者によってのみ可能である。

転送中のSTUNメッセージを変更せずに観察できる攻撃者（例えば、Wi-Fiなどの共有アクセス媒体上に存在する攻撃者）は、STUN処理を中断させるために、STUN要求を見て、すぐにSTUN応答（通常はエラー応答）を送信できる。この攻撃は、MESSAGE-INTEGRITYを利用するメッセージでも防止される。しかし、いくつかのエラー応答、特に認証に関連するものは、MESSAGE-INTEGRITYで保護することができない。STUN自体が安全なトランスポートプロトコル（例えば、TLS）上で実行される場合、これらの攻撃は完全に緩和される。

STUNの使用方法によっては、これらの攻撃は最小限の影響であるため、軽減するためにメッセージインテグリティを必要としない場合がある。例えば、STUNを基本STUNサーバーに使用し、ICEで使用するためのサーバー反射候補を発見する場合、これらの攻撃は接続性チェック段階で検出されるため、認証とメッセージ整合性は必要ない。しかし、接続性チェック自体は、ICE全体の適切な運用のために保護が必要である。セクション13で説明するように、STUNの用途は、認証とメッセージの完全性が必要な場合を記述する。

STUNは、認証と完全性保護のために共有秘密のHMACを使用するため、オフライン辞書攻撃の対象となる。認証が利用される場合、それはオフライン辞書攻撃を容易に受けない強力なパスワードであるべきである（SHOULD）。TLSまたはDTLSを使用したチャネル自体の保護は、これらの攻撃を軽減する。

STUNはMESSAGE-INTEGRITYとMESSAGE-INTEGRITY-SHA256の両方をサポートしているため、オンパスの攻撃者によるビッドダウン攻撃の対象となることがあります。攻撃者はMESSAGE-INTEGRITY-SHA256属性を削除し、MESSAGE-INTEGRITY属性だけを残し、潜在的な脆弱性を悪用することができます。TLSまたはDTLSを使用したチャネル自体の保護により、これらの攻撃は軽減されます。STUNの将来のバージョンで、MESSAGE-INTEGRITYのサポートを適時に削除することが必要である。

注：パスワードのハッシュにSHA-256を使用することは、ハッシュを計算するための比較的遅い最小時間を提供することによって、網羅的なパスワード検索を遅くすることを目的とした現代の標準を満たしていません。Argon2 [Argon2]のようなより良いアルゴリズムが利用可能ですが、SHA-256は[RFC7616]との整合性のために選ばれました。

16.1.2. 内部攻撃
不正なクライアントは、サーバーに対して大量のSTUNリクエストを送信することで、DoS攻撃を仕掛けようとすることがあります。幸い、STUNリクエストはサーバーがステートレスで処理できるため、そのような攻撃を効果的に仕掛けることは困難である。

不正なクライアントは、STUNサーバーをリフレクターとして使用し、偽のソースIPアドレスとポートでリクエストを送信する可能性があります。このような場合、応答はそのソースIPとポートに配信されることになる。この攻撃では、パケット数の増加はありませんが（STUNサーバーは、クライアントが送信する各パケットに対して1パケットを送信します）、STUNレスポンスは通常リクエストよりも大きいため、データ量は若干増加します。この攻撃は、イングレスソースアドレスフィルタリングによって軽減されます。

SOFTWARE属性によってエージェントの特定のソフトウェアバージョンを明らかにすることは、セキュリティホールを含むことが知られているソフトウェアに対する攻撃に対して、エージェントをより脆弱にすることを可能にするかもしれません。実装者は、SOFTWARE属性の使用を設定可能なオプションにすることが望ましい（SHOULD）。

16.1.3.ビッドダウン攻撃
本書では、長期クレデンシャル機構を使用する際に、サーバー側に保存されるパスワードの機密性を保護するために、異なるアルゴリズムを選択する可能性を追加しながらも

RFC5389]で使用されたアルゴリズムであるMD5との互換性を確保する。この選択は、サーバーがPASSWORD-ALGORITHMS属性でサポートされるアルゴリズムのリストをクライアントに送り、クライアントが選択したアルゴリズムを含むPASSWORD-ALGORITHM属性を送り返すことで機能します。

PASSWORD-ALGORITHMS属性は認証されていない応答で送られなければならないので、MD5の最終的な脆弱性を利用したいオンパスの攻撃者は、保護されていない応答からPASSWORD-ALGORITHMS属性を取り除くだけで、サーバーはその後、クライアントが[RFC5389]で定義されているこのプロトコルのバージョンを実行しているかのように振る舞うようにする。

この攻撃や他の類似のビッドダウン攻撃から保護するために、nonceは、どのセキュリティ機能が使用されているかを示すセキュリティビットのセットで強化されている。パスワードアルゴリズムの選択の場合、PASSWORD-ALGORITHMS属性を含む同じ応答でサーバーから返されるnonceに、マッチングビットが設定される。その後の認証トランザクションで使用されるnonceは、最初に送信されたものと同一であることがサーバーによって検証されるため、オンパスの攻撃者によって変更されることはない。さらに、クライアントは、そのサーバへの次の認証トランザクションで、受信したPASSWORD-ALGORITHMS属性をコピーすることが義務付けられている。

PASSWORD-ALGORITHMSを取り除くオンパス攻撃は、クライアントが次の認証されたトランザクションでサーバにそれを送り返すことができないので、検出されるであろう。クライアントは、セキュリティビットは設定されているが、マッチする属性がないため、その攻撃を検出することになり、これはセッションを終了させる。このプロトコルの古いバージョンを使用しているクライアントは、PASSWORD-ALGORITHMSを送り返さないが、いずれにしてもMD5しか使用できないので、攻撃は取るに足らないものである。

オンパス攻撃は、PASSWORD-ALGORITHMS属性とともにセキュリティビットを削除しようとするかもしれないが、サーバーは、次の認証されたトランザクションが無効なnonceを含むときにそれを発見するだろう。

PASSWORD-ALGORITHMS属性からいくつかのアルゴリズムを削除するオンパス攻撃も、その後の認証トランザクションでサーバーが検証するときにその属性が元のものと異なるので、同様に敗北する。

なお、本書で紹介するビッドダウン保護機構は、401（Unauthenticated）レスポンスの後、サーバーが2回目のリクエストを受信するまで攻撃を検知できないため、本質的に制限があります。

SHA-256は、[RFC7616]との互換性のためにパスワードハッシュの新しいデフォルトとして選ばれましたが、SHA-256は（MD5のように）比較的速いアルゴリズムであるため、ブルートフォース攻撃を抑止することはほとんどできません。具体的には、ユーザーが弱いパスワードを持っている場合、単一の交換をキャプチャする攻撃者は、ブルートフォース攻撃を使用してユーザーのパスワードを学習し、潜在的に同じパスワードが使用されたサーバーや他のサーバーにユーザーになりすますことができることを意味します。なお、このような攻撃者は、ブルートフォース攻撃なしで、サーバー自体にユーザーをなりすますことができます。

Argon2[アルゴン2]のような強力な（つまり遅い）アルゴリズムがあれば、この2つのケースを解決できます。しかし、最初のケースでは、このユーザーのデータベースエントリーが、その強力なメカニズムだけを使うように更新されて初めて解決できるのです。

このプロトコルのbid-down防御は、攻撃者がクライアントとサーバーが共同でサポートするよりも弱いアルゴリズムを使用してハンドシェイクを完了させることを防ぎますが、最も弱い共同アルゴリズムがブルートフォース攻撃で侵害できないほど強力である場合に限られます。具体的には、オンパスの攻撃者は、パスワードハッシュにArgon2 [Argon2]とSHA-256の両方をサポートするクライアントに対してビッドダウン攻撃を行い、それを使ってMESSAGE-INTEGRITY-SHA256値を収集し、オフラインブルートフォース攻撃に使用できるかもしれません。これは、サーバーが2番目のリクエストを受信したときに検出されるが、攻撃者がMESSAGE-INTEGRITY-SHA256値を取得することを防ぐことはできない。

同様に、USERHASHメカニズムに対する攻撃は、サーバーがパス上でその機能が破棄されたことを検出するため、セッションを確立することに成功しませんが、それでもクライアントはUSERNAME属性でユーザ名をクリアで送信するように説得され、攻撃者に公開されたでしょう。

最後に、メッセージの保護に使用されるHMACアルゴリズムの将来のアップグレードのためにビッドダウン保護メカニズムを採用する場合、現在のHMACアルゴリズムがすでに侵害されている場合は、限られた保護しか提供できません。

16.2. 使用に影響を与える攻撃
このセクションでは、STUN の使用法に対して仕掛けられる可能性のある攻撃を列挙する。各STUN利用者は、これらの攻撃が自らに当てはまるかどうかを検討し、当てはまる場合はその対策を検討する必要がある。

このセクションの攻撃のほとんどは、攻撃者がSTUNクライアントがBinding request/responseトランザクションを通じて学習したreflexiveアドレスを変更することを中心に展開されます。を使用するため

リフレクティブアドレスは用途に応じた機能であるため、これらの攻撃の適用や改善方法は用途に応じたものとなります。一般的な状況では、オンパスの攻撃者によるリフレクティブアドレスの変更は容易である。例えば、STUNがUDP上で直接実行される一般的な状況を考えてみましょう。この場合、オンパスの攻撃者は、STUNサーバーに到着する前に、BindingリクエストのソースIPアドレスを変更することができる。STUNサーバーはその後、XOR-MAPPED-ADDRESS属性でこのIPアドレスをクライアントに返し、その（改ざんされた）IPアドレスとポートに応答を送り返す。攻撃者もこのレスポンスを傍受できれば、クライアントに向け返送することができる。メッセージの完全性チェックによってこの攻撃から保護することは不可能です。メッセージの完全性の値はソースIPアドレスをカバーできず、介在するNATはこの値を変更できなければならないからです。代わりに、以下に挙げる攻撃を防ぐための1つの解決策は、ICE [RFC8445]で行われているように、クライアントが学習した反射的なアドレスを検証することである。

他の用途では、これらの攻撃を防ぐために他の手段を用いることがあります。

16.2.1. 攻撃I：ターゲットに対する分散DoS（DDoS）
この攻撃では、攻撃者は1つまたは複数のクライアントに、意図したターゲットを指す同じ偽の反射アドレス を提供します。これにより、STUNクライアントは自分のreflexiveアドレスがターゲットのそれと等しいと思い込むように騙されます。もしクライアントが、その反射アドレスでトラフィックを受信するために（例えば、SIPメッセージで）その反射アドレスを渡すと、トラフィックは代わりにターゲットに送信されます。この攻撃は、特にマルチメディアアプリケーションを有効にするためにSTUNを使用しているクライアントで使用される場合、かなりの増幅をもたらすことができます。ただし、STUNサーバーからターゲットへのパケットが攻撃者を通過するターゲットに対してのみ実行可能であり、可能なケースが限定される。

16.2.2.攻撃Ⅱ：クライアントを黙らせる
この攻撃では、攻撃者はSTUNクライアントに偽のリフレクティブアドレスを提供します。攻撃者が提供するリフレクティブアドレスは、どこにもルーティングしないトランスポートアドレスです。その結果、クライアントは、reflexiveアドレスを渡したときに期待したパケットを一切受け取れなくなります。この悪用は、攻撃者にとってはあまり面白いものではありません。単一のクライアントに影響を与えるため、望ましいターゲットでないことが多いのです。さらに、この攻撃を実行できる攻撃者は、STUNサーバーやDHCPサーバーからクライアントが応答を受け取らないようにするなど、他の手段でクライアントへのサービスを拒否することもできます。セクション16.2.1で説明した攻撃と同様に、この攻撃は、攻撃者がSTUNサーバーからこの未使用IPアドレスに向けて送信されるパケットに対してパス上にある場合にのみ可能である。

16.2.3.攻撃Ⅲ：クライアントのアイデンティティを仮定する
この攻撃は、攻撃Ⅱと似ています。ただし、偽造された反射アドレスは攻撃者自身を指しています。これにより、攻撃者はクライアント宛のトラフィックを受信することができます。

16.2.4.攻撃Ⅳ：盗聴
この攻撃では、攻撃者はクライアントに、自分自身へのルーティングを行うリフレクティブアドレスを使用するように強制します。そして、受信したパケットをすべてクライアントに転送します。この攻撃では、攻撃者はクライアントに送信されるすべてのパケットを観察することができます。ただし、この攻撃を行うには、攻撃者がクライアントからSTUNサーバーへのパケットをすでに観察できている必要があります。ほとんどの場合（アクセスネットワークから攻撃を仕掛ける場合など）、攻撃者はクライアントに送信されるパケットをすでに観測できることを意味します。この攻撃は、結果として、クライアントからSTUNサーバーまでの経路上の攻撃者によるトラフィックを観測するのにのみ有効であり、クライアントに向けてルーティングされるパケットの経路上では一般に有効ではない。

この攻撃はSTUNサーバー自身によって些細なことで仕掛けられるので、STUNサーバーのユーザーは、通信フローに自身を挿入できる他のノードと同じレベルの信頼性を持つべきであることに注意してください。

16.3.ハッシュアジリティプラン
本仕様では、メッセージの完全性を計算するために HMAC-SHA256 を使用し、場合によっては HMAC-SHA1 と組み合わせて使用する。後日、HMAC-SHA256が危険にさらされていることが判明した場合、以下の救済措置を適用する必要があります。

o 新しいmessage-integrity属性と新しいSTUN Security Featureビットの両方が、標準化過程の文書で割り当てられる予定です。新しいmessage-integrity属性は、新しいハッシュを使用してその値を計算することになる。STUN Security Featureビットは、1）サーバーがこの新しいハッシュアルゴリズムに対応していることを、長期的な信用メカニズムを使ってSTUNクライアントに知らせる、2）新しいmessage-integrity属性に対するビッドダウン攻撃を防ぐ、ということを同時に行うために使用されるであろう。

o 短期クレデンシャル機構を使用するSTUNクライアントとサーバーは、どのようなメッセージ完全性属性が使用されているかを知らせるために使用する外部機構を更新する必要があります。

本書で説明するビッドダウン保護機構は新しいものであるため、ハッシュアルゴリズムの強度をHMAC-SHA1に下げるビッドダウン攻撃に対しては、現時点では保護することができない。というのがその理由である。

移行期間終了後、この文書を更新する新しい文書では、HMAC-SHA1を非推奨とする新しいSTUN Security Featureビットが割り当てられます。このビットが使用されると、HMAC-SHA1が非推奨であり、もはや使用されるべきではないことを通知する。

同様に、HMAC-SHA256が危険であることが判明した場合、新しいuserhash属性と新しいSTUNセキュリティ機能ビットが標準追跡文書で割り当てられる。新しいuserhash属性は、新しいハッシュを使用してその値が計算されます。STUN Security Featureビットは、1）長期クレデンシャル機構を使用するSTUNクライアントに、このサーバーがuserhash属性の新しいハッシュアルゴリズムをサポートしていることを知らせる、2）新しいuserhash属性のビッドダウン攻撃を防止する、を同時に行うために使用されます。

17.IABの検討事項
IABはUnilateral Self-Address Fixing (UNSAF)の問題を研究した。UNSAFとは、クライアントが協調的なプロトコル反映メカニズム [RFC3424]を介して、NATの反対側の別の領域でそのアドレスを決定しようとする一般的なプロセスで ある。STUNは、一方のエージェントがNATの背後にあり、他方がNATのパブリック側にある場合、バインド要求/応答トランザクションを使用してこの機能を実行するために使用することができます。

IABは、この目的のために開発されたプロトコルが、特定の考慮事項のセットを文書化することを提案している。いくつかのSTUN UsageはUNSAF機能を提供し（ICE [RFC8445]など）、他のものは提供しないので（SIP Outbound [RFC5626]など）、これらの検討事項に対する答えは、usage自体によって対処される必要があります。

18. IANAに関する考慮事項
18.1.STUNセキュリティ機能レジストリ
STUN Security Featureセットは、24ビットをフラグとして定義する。

IANAは、9.2.1項に記載されたビッドダウン攻撃防止メカニズムによって保護されるSTUN Security Featuresを含む新しいレジストリを作成した。

STUN Security Featuresの初期値は、以下の通りです。

Bit 0: パスワードアルゴリズム Bit 1: ユーザー名の匿名化 Bit 2-23:未設定

ビットはビットセットの最上位側から割り当てられるので、ビット0は左端のビット、ビット23は右端のビットになります。

新しいセキュリティ機能は、Standards Action [RFC8126]によって割り当てられます。

18.2.STUNメソッドレジストリ
STUNメソッドは、0x000-0x0FFの範囲の16進数である。STUNメッセージへのSTUNメソッドのエンコーディングは、セクション5で説明される。

0x000-0x07Fの範囲のSTUNメソッドは、IETF Review [RFC8126]によって割り当てられます。0x080-0x0FFの範囲のSTUNメソッドは、エキスパートレビュー[RFC8126]によって割り当てられる。エキスパートの責任は、選択されたコードポイントが使用中でないこと、および要求が異常に多くのコードポイントに対するものでないことを確認することである。拡張自体の技術的なレビューは、指定されたエキスパートの責任範囲外である。

IANAは、以下のようにメソッド0x002の名前を更新し、また、以下のSTUNメソッドの参照をRFC 5389からRFC 8489に更新しました。

0x000:予約 0x001: binding 0x002:Reserved; [RFC5389]以前はSharedSecretだった。

18.3.STUN 属性レジストリ
STUN属性タイプは、0x0000-0xFFFFの範囲にある16進数です。0x0000-0x7FFFの範囲のSTUN属性タイプは理解必須とみなされ、0x8000-0xFFFFの範囲のSTUN属性タイプは理解任意とみなされます。STUNエージェントは、未知の理解度要求属性と理解度任意属性を異なる方法で処理する。

理解度要求範囲の前半（0x0000-0x3FFF）および理解度任意範囲の前半（0x8000-0xBFFF）のSTUN属性タイプは、IETFレビュー［RFC8126］によって割り当てられます。理解度要求範囲の後半（0x4000-0x7FFF）および理解度任意範囲の後半（0xC000-0xFFFF）のSTUN属性タイプは、エキスパートレビュー［RFC8126］によって割り当てられます。専門家の責任は、選択されたコードポイントが使用されていないこと、および要求が異常に多くのコードポイントに対するものでないことを確認することである。拡張自体の技術的なレビューは、指定されたエキスパートの責任範囲外である。

18.3.1.属性の更新
IANAは、属性0x0002、0x0004、0x0005、0x0007、0x000Bの名前を更新し、以下の各STUNメソッドの参照をRFC5389からRFC8489に更新しました。

さらに、[RFC5389]では、属性0x0003の名前に誤りがありました。[RFC5389]ではCHANGE-ADDRESSと呼ばれていましたが、実際にはCHANGE-REQUESTと呼ばれていました。したがって、IANAは0x0003の説明を「Reserved; was CHANGE-REQUEST prior to [RFC5389]」と更新しています。

   Comprehension-required range (0x0000-0x7FFF):
   0x0000: Reserved
   0x0001: MAPPED-ADDRESS
   0x0002: Reserved; was RESPONSE-ADDRESS prior to [RFC5389]
   0x0003: Reserved; was CHANGE-REQUEST prior to [RFC5389]
   0x0004: Reserved; was SOURCE-ADDRESS prior to [RFC5389]
   0x0005: Reserved; was CHANGED-ADDRESS prior to [RFC5389]
   0x0006: USERNAME
   0x0007: Reserved; was PASSWORD prior to [RFC5389]
   0x0008: MESSAGE-INTEGRITY
   0x0009: ERROR-CODE
   0x000A: UNKNOWN-ATTRIBUTES
   0x000B: Reserved; was REFLECTED-FROM prior to [RFC5389]
   0x0014: REALM
   0x0015: NONCE
   0x0020: XOR-MAPPED-ADDRESS

   Comprehension-optional range (0x8000-0xFFFF)
   0x8022: SOFTWARE
   0x8023: ALTERNATE-SERVER
   0x8028: FINGERPRINT


18.3.2.新しい属性
IANAは、"STUN Attributes "レジストリに以下の属性を追加しました。

理解が必要な範囲（0x0000-0x7FFF）：0x001C：MESSAGE-INTEGRITY-SHA256 0x001D：PASSWORD-ALGORITHM 0x001E：USERHASH

理解度-オプションの範囲（0x8000-0xFFFF）0x8002：PASSWORD-ALGORITHMS 0x8003：ALTERNATE-DOMAIN

18.4.STUNエラーコードレジストリ
STUNエラーコードは、0～699の範囲内の数値である。STUNエラーコードは、UTF-8 [RFC3629]のテキストによる理由フレーズを伴っており、これは人間が消費することだけを目的としており、適切なものであれば何でもよい。

STUNエラーコードは、SIP［RFC3261］およびHTTP［RFC7231］とコードポイントの割り当ておよびセマンティクスが一致している。

新しいSTUNエラーコードは、IETF Review [RFC8126]に基づいて割り当てられる。仕様は、リクエストを許可する前に、このエラーコードを理解しないクライアントがどのように処理するかを慎重に検討しなければならない。セクション6.3.4のルールを参照してください。

IANAは、14.8節で定義されたエラーコードの参照をRFC 5389からRFC 8489に更新しました。

IANAは、401エラーコードの名称を「Unauthorized」から「Unauthenticated」に変更しました。

18.5.STUNパスワードアルゴリズムレジストリ
IANAは「STUN Password Algorithms」と題する新しいレジストリを作成しました。

パスワードのアルゴリズムは、0x0000～0xFFFFの範囲内の16進数です。

パスワードアルゴリズム」レジストリの初期内容は以下の通りです。

0x0000: 予約 0x0001: MD5 0x0002:SHA-256 0x0003-0xFFFF: 未設定

前半の範囲（0x0000-0x7FFF）のパスワードアルゴリズムは、IETF Review [RFC8126]によって割り当てられます。後半の範囲（0x8000-0xFFFF）のパスワードアルゴリズムは、Expert Review [RFC8126]によって割り当てられます。

18.5.1.パスワードのアルゴリズム
18.5.1.1.MD5
このパスワードアルゴリズムは、[RFC1321]から引用しています。

鍵長は16バイトで、パラメータ値は空である。

注：このアルゴリズムは、レガシーシステムとの互換性のためにのみ使用されなければならない（MUST）。

                key = MD5(username ":" OpaqueString(realm) ":" OpaqueString(password))        
18.5.1.2.SHA-256
このパスワードアルゴリズムは、[RFC7616]から引用しています。

鍵長は32バイトで、パラメータ値は空です。

              key = SHA-256(username ":" OpaqueString(realm) ":" OpaqueString(password))        
18.6.STUN UDPおよびTCPのポート番号
IANAは、「サービス名とトランスポートプロトコルのポート番号レジストリ」において、以下のポートの参照をRFC 5389からRFC 8489に更新しました。

   stun 3478/tcp Session Traversal Utilities for NAT (STUN) port stun 3478/udp Session Traversal Utilities for NAT (STUN) port stuns 5349/tcp Session Traversal Utilities for NAT (STUN) port    
19.RFC 5389以降の変更点
本仕様は、[RFC5389]を廃止するものである。本仕様は，RFC5389と以下の点で異なる。

o DTLS-over-UDP [RFC6347]のサポートを追加しました。

o サーバーとのトランザクションがない場合、RTOはstaleとみなされることを明確にした。

o RTO の計算を [RFC6298] と整合させました。

o TLSのciphersuiteを更新しました。

o STUN URI [RFC7064]のサポートを追加しました。

o SHA256 メッセージインテグリティのサポートを追加しました。

o PRECIS（Preparation, Enforcement, and Comparison of Internationalized Strings）のサポートを[RFC8265]に更新しました。

o パスワードの暗号化アルゴリズムを選択するためのプロトコルとレジストリを追加しました。

o 匿名のユーザー名に対応しました。

o ビッドダウン攻撃を防止するためのプロトコルおよびレジストリを追加しました。

o NONCEを共有することができなくなったことを明記した。

o 代替サーバーの仕組みにドメイン名を使用できるようにしました。

o Cスニペットを追加しました。

o テストベクターを追加しました。

20.参考資料
20.1.規範となる参考文献
[ITU.V42.2002] 国際電気通信連合、「非同期-同期変換を用いたDCEの誤り訂正手順」、ITU-T勧告V.42、2002年3月。

[KARN87] Karn, P. and C. Partridge, "Improving Round-Trip Time Estimates in Reliable Transport Protocol", SIGCOMM '87, Proceedings of ACM workshop on Frontiers in computer communications technology, Pages 2-7, DOI 10.1145/55483.55484, August 1987.

[RFC0791] Postel, J., "Internet Protocol", STD 5, RFC 791, DOI 10.17487/RFC0791, September 1981, <https://www.rfc-editor.org/info/rfc791>.

[RFC1122] Braden, R., Ed., "Requirements for Internet Hosts - Communication Layers", STD 3, RFC 1122, DOI 10.17487/RFC1122, October 1989, <https://www.rfc-editor.org/info/rfc1122>.

[RFC1123] Braden, R., Ed., "Requirements for Internet Hosts - Application and Support", STD 3, RFC 1123, DOI 10.17487/RFC1123, October 1989, <https://www.rfc-editor.org/info/rfc1123>.

[RFC1321] Rivest, R., "The MD5 Message-Digest Algorithm", RFC 1321, DOI 10.17487/RFC1321, April 1992, <https://www.rfc-editor.org/info/rfc1321>.

[RFC2104] Krawczyk, H., Bellare, M., and R. Canetti, "HMAC:Keyed-Hashing for Message Authentication", RFC 2104, DOI 10.17487/RFC2104, February 1997, <https://www.rfc-editor.org/info/rfc2104>.

[RFC2119] Bradner, S., "Key words for use in RFC to Indicate Requirement Levels", BCP 14, RFC 2119, DOI 10.17487/RFC2119, March 1997, <https://www.rfc-editor.org/info/rfc2119>.

[RFC2782] Gulbrandsen, A., Vixie, P., and L. Esibov, "A DNS RR for Specifying location of services (DNS SRV)", RFC 2782, DOI 10.17487/RFC2782, February 2000, <https://www.rfc-editor.org/info/rfc2782>.

[RFC3629] Yergeau, F., "UTF-8, a transformation format of ISO 10646", STD 63, RFC 3629, DOI 10.17487/RFC3629, November 2003, <https://www.rfc-editor.org/info/rfc3629>.

[RFC4648] Josefsson, S., "The Base16, Base32, and Base64 Data Encodings", RFC 4648, DOI 10.17487/RFC4648, October 2006, <https://www.rfc-editor.org/info/rfc4648>.

[RFC5890] Klensin, J., "Internationalized Domain Names for Applications (IDNA):Definitions and Document Framework", RFC 5890, DOI 10.17487/RFC5890, August 2010, <https://www.rfc-editor.org/info/rfc5890>.

[RFC6125] Saint-Andre, P. and J. Hodges, "Representation and Verification of Domain-Based Application Service Identity within Internet Public Key Infrastructure Using X.509 (PKIX) Certificates in Context of Transport Layer Security (TLS)", RFC 6125, DOI 10.17487/RFC6125, March 2011, <https://www.rfc-editor.org/info/rfc6125>.

[RFC6151] Turner, S. and L. Chen, "Updated Security Considerations for the MD5 Message-Digest and the HMAC-MD5 Algorithms", RFC 6151, DOI 10.17487/RFC6151, March 2011, <https://www.rfc-editor.org/info/rfc6151>.

[RFC6298] Paxson, V., Allman, M., Chu, J., and M. Sargent, "Computing TCP's Retransmission Timer", RFC 6298, DOI 10.17487/RFC6298, June 2011, <https://www.rfc-editor.org/info/rfc6298>.

[RFC6347] Rescorla, E. and N. Modadugu, "Datagram Transport Layer Security Version 1.2", RFC 6347, DOI 10.17487/RFC6347, January 2012, <https://www.rfc-editor.org/info/rfc6347>.

[RFC7064] Nandakumar, S., Salgueiro, G., Jones, P., and M. Petit-Huguenin, "URI Scheme for the Session Traversal Utilities for NAT (STUN) Protocol", RFC 7064, DOI 10.17487/RFC7064, November 2013, <https://www.rfc-editor.org/info/rfc7064>.

[RFC7350] Petit-Huguenin, M. and G. Salgueiro, "Datagram Transport Layer Security (DTLS) as Transport for Session Traversal Utilities for NAT (STUN)", RFC 7350, DOI 10.17487/RFC7350, August 2014, <https://www.rfc-editor.org/info/rfc7350>.

[RFC7616] Shekh-Yusef, R., Ed., Ahrens, D., and S. Bremer, "HTTP Digest Access Authentication", RFC 7616, DOI 10.17487/RFC7616, September 2015, <https://www.rfc-editor.org/info/rfc7616>.

[RFC8174] Leiba, B., "Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words", BCP 14, RFC 8174, DOI 10.17487/RFC8174, May 2017, <https://www.rfc-editor.org/info/rfc8174>.

[RFC8200] Deering, S. and R. Hinden, "Internet Protocol, Version 6 (IPv6) Specification", STD 86, RFC 8200, DOI 10.17487/RFC8200, July 2017, <https://www.rfc-editor.org/info/rfc8200>.

[RFC8265] Saint-Andre, P. and A. Melnikov, "Preparation, Enforcement, and Comparison of Internationalized Strings Representing Usernames and Passwords", RFC 8265, DOI 10.17487/RFC8265, October 2017, <https://www.rfc-editor.org/info/rfc8265>.

[RFC8305] Schinazi, D. and T. Pauly, "Happy Eyeballs Version 2: Better Connectivity Using Concurrency", RFC 8305, DOI 10.17487/RFC8305, December 2017, <https://www.rfc-editor.org/info/rfc8305>.

20.2. Informative References
[Argon2] Biryukov, A., Dinu, D., Khovratovich, D., and S. Josefsson, "The memory-hard Argon2 password hash and proof-of-work function", Work in Progress, draft-irtf-cfrg-argon2-09, November 2019.

[BCP195] Sheffer, Y., Holz, R., and P. Saint-Andre, "Recommendations for Secure Use of Transport Layer Security (TLS) and Datagram Transport Layer Security (DTLS)", BCP 195, RFC 7525, May 2015, <https://www.rfc-editor.org/info/bcp195>.

[RFC1952] Deutsch, P., "GZIP file format specification version 4.3", RFC 1952, DOI 10.17487/RFC1952, May 1996, <https://www.rfc-editor.org/info/rfc1952>.

[RFC2279] Yergeau, F., "UTF-8, a transformation format of ISO 10646", RFC 2279, DOI 10.17487/RFC2279, January 1998, <https://www.rfc-editor.org/info/rfc2279>.

[RFC3261] Rosenberg, J., Schulzrinne, H., Camarillo, G., Johnston, A., Peterson, J., Sparks, R., Handley, M., and E. Schooler, "SIP: Session Initiation Protocol", RFC 3261, DOI 10.17487/RFC3261, June 2002, <https://www.rfc-editor.org/info/rfc3261>.

[RFC3424] Daigle, L., Ed. and IAB, "IAB Considerations for UNilateral Self-Address Fixing (UNSAF) Across Network Address Translation", RFC 3424, DOI 10.17487/RFC3424, November 2002, <https://www.rfc-editor.org/info/rfc3424>.

[RFC3454] Hoffman, P. and M. Blanchet, "Preparation of Internationalized Strings ("stringprep")", RFC 3454, DOI 10.17487/RFC3454, December 2002, <https://www.rfc-editor.org/info/rfc3454>.

[RFC3489] Rosenberg, J., Weinberger, J., Huitema, C., and R. Mahy, "STUN - Simple Traversal of User Datagram Protocol (UDP) Through Network Address Translators (NATs)", RFC 3489, DOI 10.17487/RFC3489, March 2003, <https://www.rfc-editor.org/info/rfc3489>.

[RFC4013] Zeilenga, K., "SASLprep: Stringprep Profile for User Names and Passwords", RFC 4013, DOI 10.17487/RFC4013, February 2005, <https://www.rfc-editor.org/info/rfc4013>.

[RFC4107] Bellovin, S. and R. Housley, "Guidelines for Cryptographic Key Management", BCP 107, RFC 4107, DOI 10.17487/RFC4107, June 2005, <https://www.rfc-editor.org/info/rfc4107>.

[RFC5090] Sterman, B., Sadolevsky, D., Schwartz, D., Williams, D., and W. Beck, "RADIUS Extension for Digest Authentication", RFC 5090, DOI 10.17487/RFC5090, February 2008, <https://www.rfc-editor.org/info/rfc5090>.

[RFC5389] Rosenberg, J., Mahy, R., Matthews, P., and D. Wing, "Session Traversal Utilities for NAT (STUN)", RFC 5389, DOI 10.17487/RFC5389, October 2008, <https://www.rfc-editor.org/info/rfc5389>.

[RFC5626] Jennings, C., Ed., Mahy, R., Ed., and F. Audet, Ed., "Managing Client-Initiated Connections in Session Initiation Protocol (SIP)", RFC 5626, DOI 10.17487/RFC5626, October 2009, <https://www.rfc-editor.org/info/rfc5626>.

[RFC5766] Mahy, R., Matthews, P., and J. Rosenberg, "Traversal Using Relays around NAT (TURN):Session Traversal Utilities for NAT (STUN) へのリレー拡張", RFC 5766, DOI 10.17487/RFC5766, April 2010, <https://www.rfc-editor.org/info/rfc5766>.

[RFC5769] Denis-Courmont, R., "Test Vectors for Session Traversal Utilities for NAT (STUN)", RFC 5769, DOI 10.17487/RFC5769, April 2010, <https://www.rfc-editor.org/info/rfc5769>.

[RFC5780] MacDonald, D. and B. Lowekamp, "NAT Behavior Discovery Using Session Traversal Utilities for NAT (STUN)", RFC 5780, DOI 10.17487/RFC5780, May 2010, <https://www.rfc-editor.org/info/rfc5780>.

[RFC6544] Rosenberg, J., Keranen, A., Lowekamp, B., and A. Roach, "TCP Candidates with Interactive Connectivity Establishment (ICE)", RFC 6544, DOI 10.17487/RFC6544, March 2012, <https://www.rfc-editor.org/info/rfc6544>.

[RFC7231] Fielding, R., Ed. and J. Reschke, Ed., "Hypertext Transfer Protocol (HTTP/1.1):Semantics and Content", RFC 7231, DOI 10.17487/RFC7231, June 2014, <https://www.rfc-editor.org/info/rfc7231>.

[RFC8126] Cotton, M., Leiba, B., and T. Narten, "Guidelines for Writing an IANA Considerations Section in RFC", BCP 26, RFC 8126, DOI 10.17487/RFC8126, June 2017, <https://www.rfc-editor.org/info/rfc8126>.

[RFC8264] Saint-Andre, P. and M. Blanchet, "PRECIS Framework:Preparation, Enforcement, and Comparison of Internationalized Strings in Application Protocols", RFC 8264, DOI 10.17487/RFC8264, October 2017, <https://www.rfc-editor.org/info/rfc8264>.

[RFC8445] Keranen, A., Holmberg, C., and J. Rosenberg, "Interactive Connectivity Establishment (ICE):A Protocol for Network Address Translator (NAT) Traversal", RFC 8445, DOI 10.17487/RFC8445, July 2018, <https://www.rfc-editor.org/info/rfc8445>.

[RFC8446] Rescorla, E., "The Transport Layer Security (TLS) Protocol Version 1.3", RFC 8446, DOI 10.17487/RFC8446, August 2018, <https://www.rfc-editor.org/info/rfc8446>.

[STUN-PMTUD] Petit-Huguenin, M., Salgueiro, G., and F. Garrido, "Packetization Layer Path MTU Discovery (PLMTUD) For UDP Transports Using Session Traversal Utilities for NAT (STUN)", Work in Progress, draft-ietf-tram-stun-pmtud-15, December 2019.

[UAX15] Unicode Standard Annex #15, "Unicode Normalization Forms", Mark Davis and Ken Whistler 編.The Unicode Standardの不可欠な部分、<http://unicode.org/reports/tr15/>。

付録A．STUNメッセージタイプを決定するCスニペット
msg_type パラメータにホスト・バイト順の 16 ビット STUN メッセージ・タイプ値が与えられた場合、STUN メッセージ・タイプを決定する C マクロを以下に示します。

   <CODE BEGINS>
   #define IS_REQUEST(msg_type)       (((msg_type) & 0x0110) == 0x0000)
   #define IS_INDICATION(msg_type)    (((msg_type) & 0x0110) == 0x0010)
   #define IS_SUCCESS_RESP(msg_type)  (((msg_type) & 0x0110) == 0x0100)
   #define IS_ERR_RESP(msg_type)      (((msg_type) & 0x0110) == 0x0110)
   <CODE ENDS>
   
メソッドやクラスをメッセージタイプに変換する関数です。

   <CODE BEGINS> int type(int method, int cls) { return (method & 0x1F80) << 2 | (method & 0x0070) << 1 | (method & 0x000F) | (cls & 0x0002) << 7 | (cls & 0x0001) << 4; } <CODE ENDS>        
メッセージタイプからメソッドを抽出するための関数です。

   <CODE BEGINS> int method(int type) { return (type & 0x3E00) >> 2 | (type & 0x00E0) >> 1 | (type & 0x000F); } <CODE ENDS>        
メッセージタイプからクラスを抽出する関数です。

   <CODE BEGINS> int cls(int type) { return (type & 0x0100) >> 7 | (type & 0x0010) >> 4; } <CODE ENDS>        
付録B．テストベクター
このセクションでは、[RFC5769]で定義されたテストベクタのリストをMESSAGE-INTEGRITY-SHA256で補強します。RFC5769]のセクション2に記載されているすべてのフォーマットと定義がここに適用される。

B.1.MESSAGE-INTEGRITY-SHA256とUSERHASHによる長期認証のリクエスト例

このリクエストでは、以下のパラメータを使用します。

   ユーザー名："<U+30DE><U+30C8><U+30EA><U+30C3><U+30AF><U+30B9>"（引用符なし） OpaqueString [RFC8265] 処理に影響されません。        
   パスワード：OpaqueString [RFC8265]処理の前後にそれぞれ「The<U+00AD>M<U+00AA>tr<U+2168>」と「TheMatrIX」（引用符なし）。        
   Nonce: "obMatJos2AAACf//499k954d6OL34oL9FSTvy64sA" (クォートなし)        
レルムです。"example.org" (引用符なし)

        00 01 00 9c リクエストタイプとメッセージ長 21 12 a4 42 Magic Cookie 78 ad 34 33 } c6 ad 72 c0 } トランザクションID 29 da 41 2e } 00 1e 00 20 USERHASH属性ヘッダー 4a 3c f3 8f } ef 69 92 bd } a9 52 c6 78 } 04 17 da 0f } ユーザーハッシュ値（32バイト） 24 81 94 15 } 56 9e 60 b2 } ユーザーハッシュヘッダー
        05 c4 6e 41 } 40 7f 17 04 } 00 15 00 29 NONCE属性ヘッダ 6f 62 4d 61 } 74 4a 6f 73 } 32 41 41 } 43 66 2f 2f } 34 39 39 6b } Nonce値及びパディング（3バイト） 39 35 34 64 } 36 4f 4c 33 } 34 6f 4c 39 } 46 53 54 76 } 79 36 34 73 } 41 00 00 } 41 36 34 73 } 41 00 00 0 
        00 14 00 0b REALM属性ヘッダ 65 78 61 6d } 70 6c 65 2e } （注）1．  レルム値（11 バイト）とパディング（1 バイト） 6f 72 67 00 } 00 1c 00 20 MESSAGE-INTEGRITY-SHA256 属性ヘッダ e4 68 6c 8f } 0e de b5 90 } 13 e0 70 90 } 01 0a 93 ef }.  HMAC-SHA256 値 cc bc cc 54 } 4c 0a 45 d9 } f8 30 aa 6d } 6f 73 5a 01 } 。   
謝辞

Michael Tuexen, Tirumaleswar Reddy, Oleg Moskalenko, Simon Perreault, Benjamin Schwartz, Rifaat Shekh-Yusef, Alan Johnston, Jonathan Lennox, Brandon Williams, Olle Johansson, Martin Thomson, Mihaly Meszaros, Tolga Asveren, Noriyuki Toriiに感謝します。Spencer Dawkins, Dale Worley, Matthew Miller, Peter Saint-Andre, Julien Elie, Mirja Kuehlewind, Eric Rescorla, Ben Campbell, Adam Roach, Alexey Melnikov, and Benjamin Kadukには本書の改善に役立つコメント、提案、質問などをいただきました。

RFC 5389のAcknowledgementsセクションは、次のように表示されました。

Cedric Aoun、Pete Cordell、Cullen Jennings、Bob Penfield、Xavier Marjou、Magnus Westerlund、Miguel Garcia、Bruce Lowekamp、および Chris Sullivan のコメントと、Baruch Sterman と Alan Hawrylyshen の初期実装に感謝の意を表し ます。Leslie Daigle、Allison Mankin、Eric Rescorla、Henning Schulzrinneには、この作業に関するIESGとIABのインプットに感謝します。

投稿者

Christian HuitemaとJoel WeinbergerはRFC 3489のオリジナル共著者です。

著者の住所

Marc Petit-Huguenin インピーダンスミスマッチ

   メール： marc@petit-huguenin.org        
Gonzalo Salgueiro Cisco 7200-12 Kit Creek Road Research Triangle Park, NC 27709 United States of America.

   メール： gsalguei@cisco.com        
Jonathan Rosenberg Five9 Edison, NJ United States of America.

   メール：jdrosen@jdrosen.net URI：http://www.jdrosen.net        
Dan Wing シトリックス・システムズ株式会社アメリカ

   メール： dwing-ietf@fuggles.com        
ロハン・マヒー 無所属

   メール： rohan.ietf@gmail.com        
Philip Matthews Nokia 600 March Road Ottawa, Ontario K2K 2T6 カナダ

電話番号613-784-3139 Email: philip_matthews@magma.ca