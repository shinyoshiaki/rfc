RFCトランス
プライバシーポリシー
お問い合わせ先
イチジク
テックスツーイー
5746
RFC 5746 - Transport Layer Security (TLS) Renegotiation Indication Extension 日本語訳
URL :https://tools.ietf.org/html/rfc5746
タイトル :RFC 5746 - Transport Layer Security (TLS) Renegotiation Indication Extension (トランスポート レイヤー セキュリティー再交渉表示拡張)
翻訳編集 : 自動生成
インターネット技術タスクフォース（IETF） E. Rescorla Request for Comments:5746 RTFM, Inc. アップデート5246, 4366, 4347, 4346, 2246 M. Ray Category:Standards Track S. Dispensa ISSN: 2070-1721 PhoneFactor N. Oskov Microsoft February 2010    
トランスポートレイヤーセキュリティ（TLS）再ネゴシエーション表示拡張

概要

Secure Socket Layer (SSL) および Transport Layer Security (TLS) の再ネゴシエーションは、攻撃者がターゲットサーバーと TLS 接続を形成し、任意のコンテンツを注入し、クライアントからの新しい TLS 接続に接続する攻撃に対して脆弱である。サーバはクライアントの最初のTLSハンドシェイクを再交渉として扱うため、攻撃者が送信した最初のデータは、その後のクライアントデータと同じエンティティからのものであると考える。本仕様では、再交渉を実行中のTLS接続に暗号的に関連付けるTLS拡張を定義し、この攻撃を防止する。

本メモの位置づけ

これはInternet Standards Trackの文書である。

この文書は、インターネット技術タスクフォース（IETF）の成果物である。この文書は、IETFコミュニティのコンセンサスを代表するものである。この文書は公開レビューを受けており、インターネット技術運営グループ （IESG）により発行が承認されている。インターネット標準に関する詳しい情報は、RFC 5741のセクション2に記載されています。

この文書の現在の状態、正誤表、それに対するフィードバックの方法に関する情報は、http://www.rfc-editor.org/info/rfc5746 で入手できます。

著作権について

Copyright (c) 2010 IETF Trust and the persons identified as the document authors.すべての著作権を保有します。

この文書は、この文書の発行日に有効なBCP 78およびIETFトラストのIETF文書に関す る法的規定(http://trustee.ietf.org/license-info)に従うものである。これらの文書は、この文書に関するあなたの権利と制限を記述しているので、 注意深く確認してください。この文書から抽出されたコードコンポーネントには、信託の法的規定のセクション4.eに記載されているように、簡易BSDライセンステキストを含める必要があり、簡易BSDライセンスに記載されているように、保証なしで提供されます。

目次

   1.はじめに...............................................  ..... 3
   2.このドキュメントで使用されている規則............................... 4
   3.安全な再ネゴシエーションの定義................................. 4
      3.1. 追加の接続状態................................ 4
      3.2. 拡張機能の定義....................................... 5
      3.3. 再ネゴシエーション保護要求シグナリング暗号
           スイートの価値................................................ 6
      3.4. クライアントの動作：初期ハンドシェイク......................... 6
      3.5. クライアントの動作：安全な再ネゴシエーション...................... 7
      3.6. サーバーの動作：初期ハンドシェイク......................... 7
      3.7. サーバーの動作：安全な再ネゴシエーション...................... 8
   4.下位互換性.......................................... 9
      4.1. クライアントの考慮事項...................................... 9
      4.2. クライアントの動作：レガシー（安全でない）再ネゴシエーション.......... 10
      4.3. サーバーに関する考慮事項..................................... 10
      4.4. サーバーの動作：レガシー（安全でない）再ネゴシエーション.......... 11
      4.5. SSLv3.................................................  .... 11
   5.セキュリティに関する考慮事項........................................ 12
   6.IANAの考慮事項............................................ 13
   7.謝辞...............................................  13
   8.参考文献...............................................  ...... 13
      8.1. 規範的参考文献...................................... 13
      8.2. 有益な参考資料.................................... 13

1.はじめに
TLS [RFC5246]では、クライアントまたはサーバーのいずれかが再ネゴシエーション (新しい暗号パラメータを確立する新しいハンドシェイク)を開始することができる。残念ながら、新しいハンドシェイクは元のハンドシェイクで確立された暗号パラメータを使用して実行されるが、2つの間に暗号的なバインディングは存在しない。これは、クライアントのトランスポート層接続を傍受できる攻撃者が、 クライアントとサーバーのやりとりの接頭辞として自身のトラフィックを 注入できる攻撃の機会を作り出す。この攻撃の1つの形態[Ray09]は、以下のように進行する。

   Client                        Attacker                        Server
   ------                        -------                         ------
                                     <----------- Handshake ---------->
                                     <======= Initial Traffic ========>
   <--------------------------  Handshake ============================>
   <======================== Client Traffic ==========================>

攻撃を開始するために、攻撃者はサーバへのTLS接続を形成する（おそらくクライアントからの最初の傍受接続に応答して）。その後、彼はサーバに好きなトラフィックを送信します。これはアプリケーション層での複数のリクエストとレスポンスを含むかもしれませんし、単にクライアントのデータをプリフィックスするための部分的なアプリケーション層のリクエストかもしれません。このトラフィックは、暗号化されていることを示すために==で示される。それから彼は、クライアントのTLSハンドシェイクをサーバーと続行することを許可する。このハンドシェイクは、攻撃者にとっては平文であるが、攻撃者のサーバへのTLS接続上で暗号化される。ハンドシェイクが完了すると、クライアントはサーバーとの間で新たに確立されたセキュリティパラメータを使用してサーバーと通信する。攻撃者はこのトラフィックを読むことはできませんが、サーバーは攻撃者との間の最初のトラフィックがクライアントとの間のトラフィックと同じであると考えます。

証明書ベースのクライアント認証が使用される場合、サーバーは、最初のバイトがTLSによって保護されているが未認証であり、その後のバイトがTLSに よって認証されクライアントの証明書にバインドされているバイトストリームを見るこ とになる。一部のプロトコル(特にHTTPS)では、認証前と認証後の段階の区別がなく、バイトは一様に処理されるため、サーバーは最初のトラフィックが認証されたクライアントIDに対応すると考えることになる。証明書ベースの認証がない場合でも、攻撃者がサーバからのデータをクライアントからのデータとして受け入れるように説得する、さまざまな攻撃が可能な場合があります。たとえば、HTTPS [RFC2818]がHTTPクッキー[RFC2965]とともに使用されている場合、攻撃者はクライアントのクッキーによって検証された任意のリクエストを生成できるかもし れない。

IMAPやSMTPのようないくつかのプロトコルは、認証フェーズと非認証フェーズの間の遷移をより明確にし、そのような遷移でプロトコルのステートマシンを部分的または完全にリセットすることを要求しています。厳密に従えば、これらのルールは攻撃の効果を制限することができます。例えば、攻撃者が見える領域に書き込むコマンドの前に、クライアントのパスワードを含むコマンドを置くことで、クライアントのパスワードが攻撃者に見えるようになります(この正確な攻撃はチャレンジレスポンス認証方式では機能しませんが、他の攻撃が可能であることに注意してください)。同様の攻撃はSMTPでも可能であり、実際、攻撃者がターゲットサーバーにアカウントを持っている必要は必ずしもない。

どちらの場合も、クライアントがTLS接続上でサーバーから特定のデータを要求することなく、未承諾の認証情報を送信するため、これらの攻撃が可能であることに注意することが重要である。クライアントが機密情報を送信する前に、TLS上でサーバとのラウンドトリップを必要とするプロトコルは、脆弱性が低いと思われます。

このような攻撃は、再ネゴシエーションのハンドシェイクとそれを包む TLS 暗号パラメータを暗号的に結びつけることで防ぐことができる。 したがって、サーバーは再ネゴシエーションと最初のネゴシエーションを区別することができ、 また再ネゴシエーションが接続間で継ぎ足されることを防ぐことができる。攻撃者が上記のように自分自身を注入しようとすると、暗号バインディングの不一致が発生するため、検出することができる。この拡張で使用されるデータは、[TLS-CHANNEL-BINDINGS]に記載されている tls-uniqueおよび/またはtls-unique-for-telnetチャネルバインディングで使用される データと似ているが、同じではない。ただし、この拡張は汎用RFC5056 [RFC5056] チャネルバインディングファシリティではない。

2.この文書で使用されている規約
本文書におけるキーワード「MUST」「MUST NOT」「REQUIRED」「SHALL」「SHALL NOT」「SHOULD」「SHOULD NOT」「RECOMMENDED」「MAY」「OPTIONAL」は [RFC2119]に記述されている通りに解釈されるものとします。

3.セキュア再ネゴシエーションの定義
3.1.追加接続状態
クライアントとサーバーの両方が、各TLS接続ステートについて3つの追加値を保存する必要がある(RFC 5246のセクション6.1参照)。これらの値は、(TLSセッションキャッシュエントリではなく)接続に固有である ことに注意。

o "secure_renegotiation" フラグ。この接続で安全な再ネゴシエーションが使用されているかどうかを示す。

o "client_verify_data": 直前のハンドシェイクでクライアントから送られた Finishedメッセージのverify_data。現在定義されている TLS のバージョンと暗号スイートでは、これは 12 バイトの値で、SSLv3 では 36 バイトの値になります。

o "server_verify_data": 直前のハンドシェイクでサーバーが送信したFinishedメッセージのverify_data。

3.2.拡張機能の定義
この拡張は、再ネゴシエーションが実行されるTLSコネクション(存在する場合)への 暗号バインディングを含む。この拡張の「extension data」フィールドは、「RenegotiationInfo」構造体を 含む。

      struct { opaque renegotiated_connection<0..255>; }.RenegotiationInfo;        
この拡張子の内容は、以下のように規定される。

o これがコネクションの最初のハンドシェイクである場合、「renegotiated_connection」 フィールドは、ClientHelloとServerHelloの両方で長さが0である。したがって、拡張の全エンコーディングは、ff 01 00 01 00となる。最初の2つのオクテットは拡張のタイプを表し、3番目と4番目のオクテットは拡張自体の長さを表し、最後のオクテットは「renegotiated_connection」フィールドのための長さ0のバイトである。

o 再交渉中のClientHellosの場合、このフィールドは3.1節に規定されたclient_verify_dataを含む。

o 再ネゴシエーションを行うServerHellosの場合、このフィールドはclient_verify_dataと server_verify_dataの連結を含む。現在のバージョンのTLSでは、これは24バイトの値である(SSLv3では72バイトの値である)。

この拡張は、データグラムTLS(DTLS)[RFC4347]とともに使用することも可能である。編集上の簡略化のため、本文書はTLSに言及しているが、本文書のすべての要件は DTLSにも等しく適用される。

3.3.再交渉保護要求シグナリング 暗号スイート値
SSLv3 と TLS 1.0/TLS 1.1 の両仕様は、実装が ClientHello に続くデータ (つまり拡張) を理解できない場合は無視するように要求しています。しかし、いくつかの SSLv3 と TLS 1.0 の実装はこのような場合、誤ってハンドシェイクを失敗させます。つまり、"renegotiation_info" 拡張を提供するクライアントは、ハンドシェイクに失敗する可能性がある。このようなサーバーとの互換性を高めるために、本文書は特別なSignaling Cipher Suite Value (SCSV) "TLS_EMPTY_RENEGOTIATION_INFO_SCSV" (コードポイント {0x00, 0xFF}) を通じて第二のシグナリング機構を定義している。この SCSV は真の暗号スイートではなく(有効なアルゴリズム群に対応しない)、ネゴシエートすることはできない。その代わり、以下の節で説明するように、空の "renegotiation_info" 拡張と同じセマンティクスを持っています。SSLv3 と TLS の実装は未知の暗号スイートを確実に無視するので、 SCSV はどのサーバにも安全に送ることができる。SCSV は SSLv2 の下位互換である CLIENT-HELLO にも含めることができます ([RFC5246] の付録 E.2 参照)。

注意: 再ネゴシエーションを全くサポートしない最小限のクライアントは、すべての最初のハンドシェイクで単にSCSVを使用することができます。以下のセクションの規則は、そのようなクライアントによる明白な再ネゴシエーションの試みを見たときに、準拠したサーバにハンドシェイクを中断させることになる。

3.4.クライアントの動作最初のハンドシェイク
このセクションとセクション3.5は、フルハンドシェイクとセッション再開ハンドシェイクの両方に適用されることに注意すること。

o クライアントは、空の「renegotiation_info」拡張、またはTLS_EMPTY_RENEGOTIATION_INFO_SCSV シグナリング暗号スイート値のいずれかをClientHelloに含めなければならない[MUST]。両方を含めることは推奨されない[NOT RECOMMENDED]。

o ServerHelloを受信したとき、クライアントはそれがrenegotiation_info 拡張を含んでいるかどうかを確認しなければならない[MUST]。

* この拡張がない場合、サーバは安全な再ネゴシエーションに対応していない。この場合、クライアントによっては、ハンドシェイクを継続せずに終了させたいと思うかもしれない。

* 拡張が存在する場合、secure_renegotiationフラグをTRUEに設定する。それからクライアントは、「renegotiated_connection」フィールドの長さがゼロであることを検証しなければならず[MUST]、そうでない場合は(fatal handshake_failure alertを送信して)ハンドシェイクを中断しなければならない[MUST]。

注：セクション3の後半で、「ハンドシェイクを中止する」は「致命的なhandshake_failureアラートを送信して接続を終了する」の略語として使用されています。

o ハンドシェイクが完了したら、クライアントは今後の使用のためにclient_verify_dataとserver_verify_dataの値を保存する必要があります。

3.5.クライアントの動作安全な再ネゴシエーション
このテキストは、接続の "secure_renegotiation" フラグが TRUE に設定されている場合に適用される (FALSE に設定されている場合は、セクション 4.2 を参照すること)。

o クライアントは、保存されたclient_verify_dataを含む「renegotiation_info」 拡張をClientHelloに含めなければならない[MUST]。SCSVは含めてはならない[MUST NOT]。

o ServerHelloを受信したとき、クライアントは「renegotiation_info」拡張が 存在することを検証しなければならない[MUST]。

o それからクライアントは、「renegotiated_connection」フィールドの前半 が保存されているclient_verify_data値と等しいこと、および後半が保存さ れているserver_verify_data値と等しいことを検証しなければならな い[MUST]。そうでない場合、クライアントはハンドシェイクを中断しなければならない[MUST]。

o ハンドシェイクが完了したら、クライアントは新しいclient_verify_dataとserver_verify_dataの値を保存する必要があります。

3.6.サーバーの動作最初のハンドシェイク
このセクションとセクション3.7は、フルハンドシェイクとセッション再開ハンドシェイクの両方に適用されることに注意すること。

o ClientHelloを受信したとき、サーバーはそれがTLS_EMPTY_RENEGOTIATION_INFO_SCSV SCSVを含むかどうかを確認しなければならない[MUST]。含まれている場合、secure_renegotiationフラグをTRUEに設定する。

o サーバーは、「renegotiation_info」拡張がClientHelloに含まれているかど うかを確認しなければならない[MUST]。この拡張が存在する場合、secure_renegotiationフラグをTRUEに設定する。次にサーバーは、「renegotiated_connection」フィールドの長さがゼロである ことを検証しなければならず[MUST]、ゼロでない場合はハンドシェイクを中断しなけれ ばならない[MUST]。

o TLS_EMPTY_RENEGOTIATION_INFO_SCSV SCSVと「renegotiation_info」拡張のどちらも含まれていない場合、 secure_renegotiationフラグをFALSEにセットする。この場合、一部のサーバはハンドシェイクを継続せずに終了させることを望むかもしれない; 議論についてはセクション 4.3 を参照のこと。

o secure_renegotiationフラグがTRUEに設定されている場合、サーバーはServerHello メッセージに空の「renegotiation_info」拡張を含まなければならない[MUST]。

o ハンドシェイクが完了すると、サーバーは将来の使用のためにclient_verify_dataとserver_verify_dataの値を保存する必要があります。

この仕様を実装するTLSサーバーは、クライアントから提供された未知の 拡張を無視しなければならず[MUST]、また、そのサーバーの最高バージョン番 号よりも高いバージョン番号を受け入れ、最高共通バージョンをネゴシエートしなけ ればならない[MUST]。これら2つの要件は、RFC5246に存在する既存の要件を繰り返すものであり、 単に前方互換性のためにここで述べているに過ぎない。

SCSVのみを含むClientHelloに対する応答として「renegotiation_info」拡張を 送ることは、RFC 5246のセクション7.4.1.4の、サーバーが未承諾拡張を送ること についての禁止事項の明確な例外であり、クライアントがTLS_EMPTY_RENEGOTIATION_ INFO_SCSV SCSVを介して拡張を受け取る意志を示しているのでのみ許可されていることに 注意してもらいたい。TLSの実装は、他のすべての拡張についてセクション7.4.1.4に準拠し続けなければならない[MUST]。

3.7.サーバーの動作セキュアな再ネゴシエーション
このテキストは、接続の "secure_renegotiation" フラグが TRUE に設定されている場合に適用される (FALSE に設定されている場合は、セクション 4.4 を参照)。

o ClientHelloを受信したとき、サーバーはそれがTLS_EMPTY_RENEGOTIATION_INFO_SCSV SCSVを含んでいないことを検証しなければならない[MUST]。このSCSVが存在する場合、サーバーはハンドシェイクを中断しなければならない[MUST]。

o サーバーは、「renegotiation_info」拡張が存在することを確認しなけれ ばならない[MUST](そうでない場合、サーバーはハンドシェイクを中止しな ければならない)。

o サーバーは、「renegotiated_connection」フィールドの値が保存されたclient_verify_data 値と等しいことを検証しなければならない[MUST]。

o サーバーは、保存されたclient_verify_dataとserver_verify_dataを含むrenegotiation_info 拡張を、ServerHelloに含めなければならない[MUST]。

o ハンドシェイクが完了したら、サーバーは新しいclient_verify_dataとserver_verify_dataの値を保存する必要があります。

4.後方互換性
この拡張をサポートしない既存の実装は広く展開されており、一般に、この拡張をサポートする新しい実装と相互運用する必要がある。このセクションでは、後方互換性のある相互運用のための考慮事項を説明する。

4.1.クライアントに関する考察
クライアントが「renegotiation_info」拡張または TLS_EMPTY_RENEGOTIATION_INFO_SCSV SCSV を提供し、サーバが ServerHello で「renegotiation_info」を返信しない場合、これはサーバが安全な再ネゴシエーションをサポートしていないことを 示唆する。いくつかの攻撃(セクション1参照)はクライアントには単一のハンドシェイクのように見えるので、クライアントは接続が攻撃を受けているかどうか判断できない。しかし、単にサーバーが拡張を認めないからと言って、脆弱であることを 意味するわけではないことに注意。サーバーはすべての再交渉を拒否し、単にそれを 通知しないことを選択するかもしれない。しかし、クライアントがTLSメカニズムによって純粋にそうであるかどうか を判断することは不可能である。

このような攻撃が不可能であることを保証したい場合、クライアントは、ハンドシェ イクを完了せずに拡張の受信に失敗すると、直ちに接続を終了させる必要がある。そのようなクライアントは、接続を終了する前に致命的な「handshake_failure」 警告を生成しなければならない[MUST]。しかし、再ネゴシエーションをサポートしない(したがって脆弱ではない)多くの TLSサーバーは、この拡張もサポートしないと予想されるので、一般的に、 この動作を実装するクライアントは相互運用性の問題に遭遇することになる。移行期間中にセキュリティを保証し、最大の相互運用性を実現するようなクライアント動作のセットは存在しない。クライアントは、アップグレードされていない可能性のあるサーバを扱う場合、どちらか一方を優先する必要があります。

4.2.クライアントの動作レガシー（安全でない）再ネゴシエーション
このテキストは、接続の「secure_renegotiation」フラグがFALSEに設定されている場合に適用されます。

アップグレードされていないサーバーは、クライアントに再ネゴシエーションを要求する可能性があります。クライアントはこの再ネゴシエーションの要求を拒否することが推奨される[RECOMMENDED]。そうするクライアントは、そのような要求に対して「no_renegotiation」アラートで応答しなければならない(MUST) (RFC 5246では、このアラートが「warning」レベルであることが要求されている)。一見アップグレードされていないように見えるサーバーが実は攻撃者 で、クライアントが別の正当なアップグレードされたサーバーと再ネゴシエート することを許可している可能性がある。それでもなお、クライアントが再ネゴシエーションを行う場合は、以下に述べるように行動しなければならない（MUST）。

renegotiate を選択したクライアントは、ClientHello において TLS_EMPTY_RENEGOTIATION_INFO_SCSV SCSV または "renegotiation_info" のいずれかを提供しなければならない(MUST)。アップグレードされていないサーバーとの正当な renegotiation では、そのサーバーはこれらのシグナルの両方を無視するはずである。しかし、サーバーが(不正確にも)拡張を無視できない場合、 「renegotiation_info」拡張を送信すると、ハンドシェイクの失敗を引き起こすかもしれない。したがって、クライアントが単にSCSVを送信することは許されるが、推奨されない(NOT RECOMMENDED)。これは、再ネゴシエーションに使用される ClientHello において、クライアントが "renegotiation_info" 拡張を送信しないことが許可されている唯一の状況である。

ダウングレード攻撃の場合、サーバーから見て最初のハンドシェイクであれば、 クライアントがSCSVを使用することでサーバーはこの攻撃を検知できなくなる (サーバーから見て再ネゴシエーションであれば、攻撃を検知できる)ことに注意。しかし、サーバーが空の「renegotiation_info」拡張子を送信し、クライアントが以前のverify_dataを含むものを期待している場合、この攻撃はクライアントによって検出されることになる。対照的に、クライアントが「renegotiation_info」拡張子を送信した場合、サーバーは直ちに攻撃を検出する。

ServerHelloを受信したとき、クライアントはそれが「renegotiation_info」 拡張を含んでいないことを検証しなければならない[MUST]。もし含まれていれば、クライアントはハンドシェイクを中断しなけれ ばならない[MUST]。(サーバーはすでに安全な再ネゴシエーションをサポートしないことを示 しているので、これが起こる唯一の方法は、サーバーが壊れているか攻撃され ている場合である)。

4.3.サーバーに関する考察
クライアントが「renegotiation_info」拡張または TLS_EMPTY_RENEGOTIATION_INFO_SCSV SCSV を提供しない場合、これはクライアントが安全な再ネゴシエーションを サポートしないことを意味する。セクション 1 で説明した攻撃は、2 つのハンドシェイクのように見えるが、これは

サーバは、再ネゴシエーションがクライアントにしか見えないような他の攻撃も可能かもしれません。もしサーバがそのような攻撃が不可能であることを保証したいのであれば、安全な再ネゴシエーションの使用をネゴシエートできなかった時点で、接続を直ちに終了させる必要がある。パッチが適用されていないクライアントからの接続を許可することを選択したサーバは、それらの接続上での再ネゴシエーションを拒否することによって、セクション1で説明した攻撃を防ぐことができる。

クライアントがプローブすることを可能にするために、再ネゴシエーションに 対応していないサーバーであっても、最初のハンドシェイクでこのドキュメントで 説明されている拡張の最小バージョンを実装しなければならず、それによって、 アップグレードされたことをシグナリングすることができる。

4.4.サーバーの動作レガシーな(安全でない)再交渉
このテキストは、接続の「secure_renegotiation」フラグがFALSEに設定されている場合に適用されます。

サーバーはレガシー再ネゴシエーションを許可しないことが推奨される[RECOMMENDED]。それにもかかわらず、サーバーがそれを許可する場合、このセクションの要件に従わなければならない(MUST)。

o ClientHelloを受信したとき、サーバーはそれがTLS_EMPTY_RENEGOTIATION_INFO_SCSV SCSVを含んでいないことを検証しなければならない[MUST]。このSCSVが存在する場合、サーバーはハンドシェイクを中断しなければならない[MUST]。

o サーバーは、「renegotiation_info」拡張が存在しないことを検証しなければ ならない[MUST]。存在する場合、サーバーはハンドシェイクを中止しなければ ならない[MUST]。

4.5.SSLv3
SSLv3 は IETF の変更管理下にあるプロトコルではありませんが ([SSLv3] を参照)、TLS の元々の基盤であり、ほとんどの TLS 実装も SSLv3 をサポートしています。IETF は SSLv3 の実装がこのドキュメントで定義されている "renegotiation_info" 拡張と SCSV を採用することを推奨しています。SCSV と拡張のセマンティクスは、 verify_data 値のサイズがそれぞれ 36 バイトであることを除けば、 TLS スタックと同じである。このようなスタックには、少なくとも最小限の拡張処理を追加する必要があることに注意してください。SSLv3 をサポートし、(SCSV または "renegotiation_info" によって) secure renegotiation を提供するクライアントは、サーバーのバージョンが {0x03, 0x00} であっても、サーバーから "renegotiation_info" 拡張を受け入れ、この仕様で述べられているように動作しなければならない(MUST)。secure renegotiation をサポートし、SSLv3 をサポートする TLS サーバーは、SCSV または "renegotiation_info" 拡張を受け入れ、提供されたクライアントバージョンが {0x03, 0x00} であってもこの仕様に記載されているように応答しなければならない(MUST)。SSLv3 は "no_renegotiation" 警告を定義しない(そして "warning" レベルで renegotiation を拒否することを示す方法も提供しない)。再ネゴシエーションを拒否する SSLv3 クライアントは fatal handshake_failure 警告を使うべきです(SHOULD)。

5.セキュリティに関する考察
このドキュメントで説明されている拡張は、TLSに対する攻撃を防ぐものである。この拡張が使用されない場合、TLS再ネゴシエーションは、攻撃者がクライアントの 会話のプレフィックスとして、TLSサーバーとの独自の会話を注入できる攻撃の対 象となる。この攻撃はクライアントからは見えず、サーバーからは通常の再ネゴシエーションのように見える。このドキュメントで定義されている拡張は、再ネゴシエーションを安全に実行することを可能にする。サーバーは、この拡張を使用せずにクライアントが再ネゴシエーションを 行うことを許可してはならない(SHOULD NOT)。多くのサーバは、再ネゴシエーションを全く行わないようにすることで、 この攻撃を軽減することができる。

この拡張により、概要で説明した中間者攻撃は緩和されるが、アプリケーションが再交渉に気づかない場合に直面する可能性のある問題をすべて解決できるわけではない。例えば、再ネゴシエーションの間、クライアントまたはサーバのどちらかが、以前に使用した証明書とは異なる証明書を提示することができる。これはアプリケーション開発者にとっては驚きであり (たとえば "getPeerCertificates()" APIコールが二度呼ばれても同じ値を返すと予想していたかもしれない)、 安全でない方法で処理されるかもしれない。

TLSの実装は、再ネゴシエーションを無効化および有効化するメカニズムを提供す るべきである[SHOULD]。

TLS実装者は、再ネゴシエーションがアプリケーションに提供されるAPIと どのように相互作用するかを明確に文書化することが推奨される(例えば、どの APIコールが異なる呼び出しで異なる値を返すか、どのコールバックが複数回呼ばれるか、 など)。

再ネゴシエーションを使用するが、一度認証された証明書を変更することを期待しない アプリケーションの生活をより簡単にするために、TLSの実装は、相手が先に使用したのとは異なる証明書および/または異なるサーバ名(server_name拡張)で認証しようとする場合、再ネゴシエーションを中断するオプションをアプリケーションに提供したいかもしれない。TLSの実装は、クライアント証明書が認証された後に再ネゴシエーションを無効にする オプションを提供することもできる。しかし、すべてのアプリケーションでこれらのオプションをデフォルトで有効にすると、ある証明書から別の証明書に変更するために再ネゴシエーションを使用することに依存している既存のアプリケーションを壊す可能性があります。(たとえば、長寿命のTLS接続は、更新された証明書に変更することができます。または、再ネゴシエーションは、別の証明書を使用することを必要とする別の暗号スイートを選択することができます)。最後に、再ネゴシエーションに依存するアプリケーションの設計者は、多くの TLS API がアプリケーションデータを単純なオクテットストリームとして表現していることに注意されたい。特に、再ネゴシエーションの間に相手が異なる証明書を提示した場合、アプリケーションがデータをどのように処理すべきかを指定する際に注意が必要である。

6.IANA の考慮事項
IANAは、プロトタイプの実装で使用されていた拡張コードポイント65281（0xff01）を、TLS ExtensionType値のレジストリに「renegotiation_info」拡張として追加しました。

IANA は TLS 暗号スイート番号 0x00,0xFF と名前 TLS_EMPTY_RENEGOTIATION_INFO_SCSV を TLS 暗号スイートレジストリに追加しました。

7.謝辞
この脆弱性は、Marsh Ray 氏によって発見され、Martin Rex 氏によって独自に再発見されました。ここで説明されている拡張の背後にある一般的な概念は、Steve Dispensa, Nasko Oskov, Eric Rescorlaによって独自に考案され、Nelson Bolyard, Pasi Eronen, Michael D'Errico, Stephen Farrell, Michael Gray, David-Sarah Hopwood, Ben Laurie, David Makepeace, Bodo Moeller, Martin Rex, Peter Robinson, Jesse Walker, Nico Williams, その他プロジェクトモーグルチームとTLSWGのメンバーが改良を加えました。

8.参考文献
8.1.標準的な参考文献
[RFC2119] Bradner, S., "Key words for use in RFCs to Indicate Requirement Levels", BCP 14, RFC 2119, March 1997.

[RFC5246] Dierks, T. and E. Rescorla, "The Transport Layer Security (TLS) Protocol Version 1.2", RFC 5246, August 2008.

8.2.参考文献
[RFC4347] Rescorla, E. and N. Modadugu, "Datagram Transport Layer Security", RFC 4347, April 2006.

[RFC5056] Williams, N., "On Use of Channel Bindings to Secure Channels", RFC 5056, November 2007.

[TLS-CHANNEL-BINDINGS] Altman, J., Williams, N., and L. Zhu, "Channel Bindings for TLS", Work in Progress, October 2009.

[RFC2818] Rescorla, E., "HTTP Over TLS", RFC 2818, May 2000.

[RFC2965] Kristol, D. and L. Montulli, "HTTP State Management Mechanism", RFC 2965, October 2000.

[Ray09] Ray, M., "Authentication Gap in TLS Renegotiation", November 2009, <http://extendedsubset.com/?p=8>.

[SSLv3] Freier, A., Karlton, P., and P. Kocher, "The SSL Protocol Version 3.0", Work in Progress, November 1996.

著者住所

Eric Rescorla RTFM, Inc. 2064 Edgewood Drive Palo Alto, CA 94303 USA

電子メール：ekr@rtfm.com

Marsh Ray PhoneFactor 7301 W 129th Street Overland Park, KS 66213 USA

電子メール：marsh@extendedsubset.com

Steve Dispensa PhoneFactor 7301 W 129th Street Overland Park, KS 66213 USA

EMail: dispensa@phonefactor.com

Nasko Oskov Microsoft One Microsoft Way Redmond, WA 98052 USA

EMail: nasko.oskov@microsoft.com