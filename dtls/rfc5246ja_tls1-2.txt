RFCトランス
プライバシーポリシー
お問い合わせ先
イチジク
テックスツーイー
5246
RFC 5246 - トランスポートレイヤーセキュリティ(TLS)プロトコル バージョン 1.2 日本語訳
URL : https://tools.ietf.org/html/rfc5246
タイトル : RFC 5246 - トランスポートレイヤーセキュリティ(TLS)プロトコル バージョン1.2
翻訳編集 : 自動生成
ネットワークワーキンググループ T. Dierks
意見募集：5246 無所属
Obsoletes: 3268, 4346, 4366 E. Rescorla
更新情報：4492 RTFM, Inc.
カテゴリー: Standards Track 2008年8月号
        
TLS（Transport Layer Security）プロトコル バージョン1.2

本メモの位置づけ

この文書は、インターネットコミュニティのためのインターネット標準トラックプロトコルを規定し、改善のための議論と提案を要請する。 このプロトコルの標準化状況およびステータスについては、最新版の「インターネット公式プロトコル標準」（STD 1）を参照してください。 このメモの配布は無制限である。

概要

本書は、TLS（Transport Layer Security）プロトコルのバージョン 1.2 を規定する。 TLS プロトコルは、インターネット上の通信セキュリティを提供する。このプロトコルにより、クライアント/サーバーアプリケーションは、盗聴、改ざん、メッセージの偽造を防ぐように設計された方法で通信することができます。

目次

   1 はじめに .......................................................................................................
      1.1 要件用語 ................................................................................................
      TLS 1.1 との主な相違点 ..............................................................................
   2 目標 ...................................................................................................................
   3.この文書の目的............................................7
   4.表示言語 ........................................................................................................
      基本ブロックサイズ ...............................................................................................
      その他 ........................................................................................................
      ベクター .............................................................................................................
      
      4.5. 列挙体 .........................................................................................................
      構築された型 ...........................................................................................
           4.6.1 バリアント ...........................................................................................
      暗号属性 ................................................................................................
      定数 .......................................................................................................
   HMACと疑似ランダム関数 .............................................................................
   TLSレコードプロトコル .........................................................................................
      接続状態 ........................................................................................................
      6.2 レコードレイヤ ................................................................................................
           フラグメンテーション .........................................................................................
        
           6.2.2 レコード圧縮・伸長 ..................................................................
           記録ペイロードの保護 .......................................................................
                  6.2.3.1 Null または標準ストリーム暗号 ....................................................
                  6.2.3.2. CBCブロック暗号 ...............................................................................
                  AEAD暗号...........................
      キー算出 ..................................................................................................
   TLSハンドシェーキングプロトコル ..................................................................................
      7.1. 暗号仕様変更プロトコル ...........................................................................
      アラートプロトコル ...............................................................................................
           クロージャーアラート
           エラーアラート ..............................................................................................
      ハンドシェイクプロトコルの概要 ............................................................................
      ハンドシェイクプロトコル ..........................................................................................
           Helloメッセージ ..........................................................................................
                  Hello Request .....................................................................................
                  Client Hello ・・・・・・・・・ 39
                  Server Hello ........................................................................................
                  7.4.1.4. Hello 拡張 .................................................................................
                           7.4.1.4.1 署名アルゴリズム ......45
           サーバー証明書 ...................................................................................
           サーバー鍵交換メッセージ ......................................................................
           証明書発行依頼 ................................................................................
           Server Hello Done ・・・・・・・・・・・・・・・・・ 55
           クライアント証明書 ...................................................................................
           クライアント鍵交換メッセージ ......................................................................
                  7.4.7.1. RSA暗号化されたプレマスター秘密メッセージ ......58
                  7.4.7.2. クライアントDiffie-Hellman公開値...........................61
           証明書ベリファイ ..................................................................................
           
   8 暗号計算 .............................................................................................
      マスターシークレットの計算 ..............................................................................
           8.1.1. RSA ...................................................................................................
           ディフィー・ヘルマン ...........................................................................................
   必須暗号スイート ..........................................................................................................
   10.アプリケーションデータプロトコル ..............................................................................
   セキュリティに関する留意点 .............................................................................................
   IANA の考慮事項 ............................................................................................
   付録A プロトコルのデータ構造と定数値 ............................................................
      A.1 レコードレイヤ ................................................................................................
      A.2 暗号仕様メッセージの変更 ............................................................................
      アラートメッセージ .................................................................................................
      ハンドシェイクプロトコル ..........................................................................................
           A.4.1. こんにちはメッセージ ....................................................................................
           A.4.2. サーバー認証と鍵交換メッセージ ......72
           クライアント認証と鍵交換メッセージ...74
           ハンドシェーク最終化メッセージ ..................................................................
      暗号スイート ................................................................................................
      セキュリティパラメータ .....................................................................................
        
      RFC 4492 の変更点 .........................................................................................
   付録B 用語集 .................................................................................................
   付録C 暗号スイート定義 ............................................................................
   付録D 実施上の留意点 .......................................................................................
      D.1. 乱数生成とシード .................................................................................
      D.2. 証明書と認証 ................................................................................
      D.3. 暗号スイート ................................................................................................
      D.4. インプリメンテーションの落とし穴 ..............................................................................
   付録E 後方互換性 ........................................................................................
      E.1. TLS 1.0/1.1 および SSL 3.0 との互換性.......................................
      図 2 SSL 2.0 との互換性 ................................................................................
      中間者バージョンアップの回避 ..............................................................
   付録F セキュリティ分析 ............................................................................................
      ハンドシェイクプロトコル ..........................................................................................
           F.1.1. 認証と鍵交換 ..............................................................................
                  匿名鍵交換 ..................................................................................
                  RSA 鍵交換と認証 ......92
                  とのディフィー・ヘルマン鍵交換
                           認証方法 ........................................................................................
           バージョンロールバック攻撃 ............................................................................
           F.1.3. ハンドシェイクプロトコルに対する攻撃の検出 ......94
           セッションの再開 .......................................................................................
      F.2. アプリケーションデータの保護 ...............................................................................
      F.3. 明示的IV ...............................................................................................
      F.4. 複合暗号モードの安全性 ..............................................................................
      F.5. サービス妨害（Denial of Service） ..........................................................................................
      Final Notes ....................................................................................................
   参考文献 ...................................................................................................................
   参考文献 .............................................................................................................
   ワーキンググループ情報
   貢献者 .......................................................................................................
        
1.はじめに
TLSプロトコルの主な目的は、通信する2つのアプリケーション間でプライバシーとデータの完全性を提供することです。 プロトコルは、TLS Record ProtocolとTLS Handshake Protocolという2つの層で構成されています。 最も低いレベルでは、何らかの信頼できるトランスポートプロトコル（たとえば、TCP [TCP] ）の上に、TLS Record Protocolが重なります。 TLS Record Protocolは2つの基本特性を持った接続セキュリティを提供します。

- 接続はプライベートです。データの暗号化には対称暗号が使われます（AES [AES]、RC4 [SCH]など）。 この対称暗号の鍵は接続ごとに一意に生成され、他のプロトコル（TLS ハンドシェイクプロトコルなど）で交渉した秘密に基づいています。 レコードプロトコルも暗号化せずに使うことが可能です。

- メッセージ転送には、鍵付きMACを使用したメッセージの完全性チェックが含まれるため、接続の信頼性は高い。MACの計算には安全なハッシュ関数（SHA-1など）が使用される。 レコードプロトコルはMACなしで動作させることができるが、一般にこのモードでは、他のプロトコルがセキュリティパラメータの交渉のためにレコードプロトコルをトランスポートとして使用している間のみ使用される。

TLSレコードプロトコルは、様々な上位プロトコルのカプセル化に使用されます。そのようなカプセル化されたプロトコルの一つであるTLSハンドシェイクプロトコルでは、アプリケーションプロトコルが最初の1バイトのデータを送受信する前に、サーバーとクライアントがお互いを認証し、暗号化アルゴリズムと暗号鍵をネゴシエートすることができます。TLSハンドシェイクプロトコルは、3つの基本的な特性を持つ接続セキュリティを提供する。

- ピアの身元は、非対称暗号または公開鍵暗号（RSA [RSA]、DSA [DSS]など）を使用して認証することができる。 この認証はオプションにすることができるが、一般に、少なくとも一方のピアに要求される。

- 共有秘密の交渉は安全です。交渉された秘密は盗聴されることがなく、認証された接続では、接続の途中に身を置くことができる攻撃者であっても秘密を取得することはできません。

- ネゴシエーションは信頼できる：攻撃者は、通信の当事者に検出されることなく、ネゴシエーションの通信を変更することはできません。

TLSの利点の1つは、アプリケーション・プロトコルに依存しないことです。TLSハンドシェイクをどのように開始するか、交換された認証証明書をどのように解釈するかは、TLS上で実行されるプロトコルの設計者と実装者の判断に任されています。

1.1.要求事項の用語
本文書におけるキーワード「MUST」「MUST NOT」「REQUIRED」「SHALL」「SHALL NOT」「SHOULD」「SHOULD NOT」「RECOMMENDED」「MAY」「OPTIONAL」はRFC 2119 [REQ] に記述されている通りに解釈されるものとします。

1.2 TLS 1.1との主な相違点
この文書は、TLS 1.1 [TLS1.1] プロトコルの改訂版であり、特に暗号アルゴリズムのネゴシエーションのための柔軟性が 改善されている。主な変更点は以下の通りです。

- 疑似乱数関数（PRF）のMD5/SHA-1の組み合わせが、暗号スイート指定のPRFに変更されました。本書で扱うすべての暗号スイートは P_SHA256 を使用する。

- デジタル署名された要素におけるMD5/SHA-1の組み合わせは、単一のハッシュに置き換えられました。署名付き要素に、使用したハッシュアルゴリズムを明示的に指定するフィールドが追加されました。

- クライアントとサーバーが、どのハッシュと署名のアルゴリズムを受け入れるかを指定できるようにするための大幅なクリーンアップ。これは、以前のバージョンのTLSから署名とハッシュアルゴリズムに関する制約をいくつか緩和していることに注意すること。

- データモードの追加による認証付き暗号化対応の追加。

- TLS 拡張の定義と AES 暗号スイートは、外部の [TLSEXT] と [TLSAES] からマージされた。

- EncryptedPreMasterSecretのバージョン番号のチェックを厳しくしました。

- 様々な要件を厳格化した。

- Verify_data の長さが暗号スイートに依存するようになりました（デフォルトは 12 のままです）。

- Bleichenbacher/Klima攻撃防御の記述をクリーンアップしました。

- 多くの場合、アラートを送信しなければならなくなりました。

- certificate_requestの後、利用可能な証明書がない場合、クライアントは空の証明書リストを送信しなければならなくなった。

- TLS_RSA_WITH_AES_128_CBC_SHAが実装必須の暗号スイートになりました。

- HMAC-SHA256暗号スイートを追加しました。

- IDEAとDESの暗号スイートを削除しました。 これらは現在非推奨であり、別のドキュメントで説明する予定です。

- SSLv2 後方互換性のある Hello のサポートは現在 SHOULD ではなく MAY であり、送信は SHOULD NOT です。 サポートはおそらく将来 SHOULD NOT になる予定です。

- 複数のケースアームが同じエンコーディングを持つことができるように、プレゼンテーション言語に限定的な「フォールスルー」を追加しました。

- 実装の落とし穴のセクションを追加

- 通常の説明と編集作業。

2.目標
TLSプロトコルの目標は、優先順位の高い順に以下の通りである。

1.暗号セキュリティ：2者間で安全な接続を確立するためにTLSを使用する必要があります。

2.相互運用性：独立したプログラマが、互いのコードを知らなくても暗号パラメータを正常に交換できるTLSを利用したアプリケーションを開発できること。

拡張性: TLSは、新しい公開鍵や一括暗号化方式を必要に応じて組み込むことができるフレームワークを提供することを目指しています。 これは、新しいプロトコルを作成する必要性を防ぐ（そして新しい弱点をもたらすリスクを冒す）ことと、全く新しいセキュリティライブラリを実装する必要性を避けるという2つのサブゴールを達成することにもつながります。

4.相対的な効率性：暗号操作、特に公開鍵操作は非常にCPUを消費する傾向がある。 このため、TLSプロトコルでは、オプションでセッションキャッシングスキームを組み込み、ゼロから確立する必要がある接続の数を減らしている。さらに、ネットワークアクティビティを減らすための配慮もなされています。

3.このドキュメントの目標
この文書とTLSプロトコル自体は、Netscape社が発行したSSL 3.0 Protocol Specificationをベースにしています。このプロトコルと SSL 3.0 の違いは劇的なものではありませんが、 TLS と SSL 3.0 の様々なバージョンが相互運用できないほど大きなものです (それぞれのプロトコルには、実装が以前のバージョンに戻ることができる仕組みが組み込まれていますが)。 この文書は主に、プロトコルを実装する読者とその暗号解析を行う読者を対象としています。そのため、アルゴリズムに依存するデータ構造やルールの多くを（付録ではなく）本文に記載し、より簡単にアクセスできるようにした。

この文書は、サービス定義やインタフェース定義の詳細を提供することを意図していないが、強固なセキュリティを維持するために必要なポリシーの領域を選択してカバーしている。

4.プレゼンテーション言語
この文書では，外部表現におけるデータのフォーマットを扱う。 以下の非常に基本的で，やや無造作に定義された表現構文を用いる。 この構文は，その構造においていくつかの情報源から引用されたものである。プログラミング言語「C」とXDR[エックスディーアール]に構文も意図も似ているが、あまり類似性を持たせるのは危険だろう。このプレゼンテーション言語の目的は、TLSを文書化することのみであり、その特定の目的を超えた一般的なアプリケーションはない。

4.1. 基本ブロックサイズ
データブロックのサイズは1バイト（8ビット）が基本であり、すべてのデータ項目は明示的に表現される。複数バイトのデータ項目は、左から右へ、上から下へ、バイトを連結したものである。バイトストリームから、マルチバイトアイテム（例では数値）を（C記法を用いて）形成する。

      値 = (byte[0] << 8*(n-1)) | (byte[1] << 8*(n-2))|。
              ... | byte[n-1]です。
        
マルチバイトの値に対するこのバイトオーダーは、一般的なネットワークバイトオーダーまたはビッグエンディアンフォーマットです。

4.2. その他
コメントは"/*"で始まり、"*/"で終わります。

オプションの構成要素は「[[ ]]」という二重括弧で囲んで表現する。

解釈されないデータを含む 1 バイトの実体は opaque 型である。

4.3 ベクトル
ベクター（一次元配列）は、均質なデータ要素のストリームである。 ベクターのサイズは、ドキュメント作成時に指定することも、実行時まで指定しないこともできる。 いずれの場合も、長さは、ベクターの要素数ではなく、バイト数を宣言するものである。T型の固定長ベクトルである新しい型，T'を指定するための構文は以下の通りである．

T T'[n]です。

ここで，T'はデータストリーム中でnバイトを占め，nはTの大きさの倍数である．

以下の例では、Datumはプロトコルが解釈しない連続した3バイト、DataはDatumの連続した3バイトで、合計9バイトを消費すると定義している。

      opaque Datum[3]; /* 3バイトの未解釈バイト */。
      Datum Data[9]; /* 3 バイトの連続したベクトル */。
        
可変長ベクターは、<floor..ceiling>という表記で、有効な長さの範囲を含めて指定する。 これを符号化すると、バイトストリームでは実際の長さがベクターの内容に優先する。長さは、ベクターの最大（上限）長を保持するために必要なバイト数だけ消費される数値の形式となる。可変長ベクトルで、実長フィールドが 0 のものを空ベクトルと呼ぶ。

      T T'＜床...天井＞。
        
以下の例では、mandatory は 300 バイトから 400 バイトの opaque 型のベクトルであり、決して空であってはならない。実際の長さフィールドは2バイトのuint16を消費し、これは値400を表すのに十分である（セクション4.4参照）。一方，longは最大800バイトのデータ，または400個のuint16要素を表すことができ，空である場合もある。そのエンコーディングには、ベクターの前に2バイトの実長フィールドが付加される。エンコードされたベクトルの長さは、単一要素の長さの偶数倍でなければならない（例えば、uint16の17バイトベクトルは不正である）。

      opaque 必須<300..400>。
            /* 長さフィールドは2バイトで、空白は不可 */。
      uint16 longer<0..800>;
            /* 0～400 16ビット符号なし整数 */
        
4.4. 数値
基本的な数値データ型は符号なしバイト（uint8）であり、それ以上の数値データ型は4.1節に示すように固定長のバイト列を連結したものであり、符号なしである。 以下の数値データ型があらかじめ定義されている。

      uint8 uint16[2]です。
      uint8 uint24[3]です。
      uint8 uint32[4]です。
      uint8 uint64[8]です。
        
本仕様書では，すべての値はネットワークバイト（ビッグエンディアン）順で格納されており，16進数のバイト01 02 03 04で表されるuint32は，10進数の値16909060と等価である。

なお，DH パラメータなど，整数を不透明なベクトルとして表現する必要がある場合は，符号なし整数として表現する（最上位ビットが設定されていても先頭のゼロオクテットは不要）．

4.5. 列挙体
さらにenumという疎なデータ型が用意されています。enum型のフィールドは、定義で宣言された値のみを仮定することができます。 各定義は異なる型です。同じ型の列挙体のみが割り当てられ、比較されることがある。次の例に示すように、列挙の各要素には値を割り当てる必要があります。列挙された要素には順序がないため、どのような順序でも一意な値を割り当てることができる。

      enum { e1(v1), e2(v2), ..., en(vn) [[, (n)]] } ここで。
        
列挙型は、その最大定義序数と同じだけのバイトストリームを占有する。 次の定義は、Color型のフィールドを運ぶために1バイトを使用することを意味する。

      enum { red(3), blue(5), white(7) } Color;
        
オプションとして、関連するタグを付けずに値を指定することで、余分な要素を定義することなく幅の定義を強制することができる。

次の例では、Tasteはデータストリームで2バイトを消費しますが、1、2、4のいずれかの値しか仮定できません。

      enum { sweet(1), sour(2), bitter(4), (32000) } Taste;
        
列挙の要素名は、定義された型内にスコープされる。最初の例では、列挙の2番目の要素への完全修飾された参照は、Color.blueとなる。このような資格は、課題のターゲットがしっかり特定されていれば必要ありません。

      Color color = Color.blue; /* オーバースペック、リーガル */。
      色 color = blue; /* 正しい、暗黙の型 */。
        
外部表現に変換されることのない列挙型は、数値情報を省略することができる。

      enum { low, medium, high } Amount;
        
4.6. 構築された型
構造体型は、便宜上、プリミティブ型から構成することができる。 各仕様は、新しい一意の型を宣言する。定義の構文は、C言語とよく似ています。

      構造体{
          T1 f1;
          T2 f2;
          ...
          Tn fn;
      } [[T]];
        
構造体内のフィールドは，列挙型と同様の構文で型名を修飾することができます． たとえば，T.f2は前の宣言の2番目のフィールドを指します． 構造体の定義は，埋め込むことができます．

4.6.1.
定義された構造体は、環境内で利用可能な何らかの知識に基づくバリアントを持つことができます。 セレクタは、構造体が定義する可能なバリアントを定義する列挙型でなければなりません。selectで宣言された列挙型の各要素には、ケースアームが必要です。 ケースアームにはフォールスルーが制限されており、2つのケースアームが間にフィールドを挟むことなく連続している場合、どちらも同じフィールドを含んでいることになります。したがって、以下の例では、"orange "と "banana "の両方にV2が含まれる。 これは、TLS 1.2の新しい構文の一部であることに注意してほしい。

バリアント構造の本体には、参照用のラベルを付与することができる。実行時にバリアントが選択される仕組みは、プレゼンテーション言語では規定されていない。

      構造体{
          T1 f1;
          T2 f2;
          ....
          Tn fn;
           セレクト（E）{
               case e1: Te1;
               case e2: Te2;
               case e3: case e4: Te3;
               ....
               case en: テン。
           } [[fv]]である。
      } [[テレビ]]です。
        
例えば、こんな感じです。

      enum { apple, orange, banana } VariantTag;
        
      構造体{
          uint16番号。
          不透明な文字列<0..10>; /* 可変長 */。
      } V1;
        
      構造体{
          uint32の数値。
          不透明文字列[10]; /* 固定長*/
      } V2;
        
      構造体{
          select (VariantTag) { /* セレクタの値は暗黙の了解です */。
              ケースアップル
                V1; /* VariantBody、タグ = apple */。
              ケースオレンジ
              ケースバナナ
                V2; /* VariantBody, tag = orange or banana */。
          } variant_body; /* variant のオプションのラベル */.
      } VariantRecord;
        
4.7 暗号属性
デジタル署名、ストリーム暗号、ブロック暗号、AEAD暗号、公開鍵暗号の5つの暗号操作について、それぞれデジタル署名、ストリーム暗号、ブロック暗号、AAD暗号、公開鍵暗号と呼称している。フィールドの暗号処理は、フィールドの型指定の前に適切なキーワードを付加することで指定する。 暗号鍵は現在のセッション状態によって暗示される(セクション 6.1 参照)。

デジタル署名された要素は、構造体DigitallySignedとして符号化される。

      構造体{
         SignatureAndHashAlgorithmのアルゴリズムです。
         opaque signature<0..2^16-1>;
      } DigitallySigned;
        
algorithm フィールドは、使用されるアルゴリズムを指定する（このフィールドの定義については 7.4.1.4.1 節を参照のこと）。algorithmフィールドの導入は従来からの変更点である。 署名は、要素の内容に対してそれらのアルゴリズムを用いた電子署名である。 内容自体は電線上に現れず、単に計算される。 署名の長さは、署名アルゴリズムと鍵で指定される。

RSA署名では、[PKCS1]で定義されているRSASSA-PKCS1-v1_5署名スキームを使用して生成された署名を不透明ベクトルに含めます。 PKCS1]で議論したように、DigestInfoはDERエンコードされなければなりません [X680] [X690] 。 パラメータなしのハッシュアルゴリズムでは(SHA-1を含みます) DigestInfo.AlgorithmIdentifier.parameters フィールドはNULLでなければなりませんが、実装はパラメータなしとNULLパラメータ付きの双方に対応しなければなりません (MUST)。TLSの以前のバージョンでは、DigestInfoエンコーディングを含まない別のRSA署名スキームを使用していたことに注意してください。

DSAでは、SHA-1ハッシュの20バイトをそのままデジタル署名アルゴリズムに通し、追加のハッシュは行いません。DSA署名は，上記のように不透明なベクトルであり，その中身はDERエンコーディングである．

      Dss-Sig-Value ::= SEQUENCE{。
          r INTEGER。
          s INTEGER
      }
        
注）現在の用語では、DSAはDigital Signature Algorithm、DSSはNISTの規格を指します。当初のSSLとTLSの仕様では、"DSS "が普遍的に使われていました。本書では、アルゴリズムを指す場合は「DSA」、規格を指す場合は「DSS」とし、歴史的な連続性を持たせるためにコードポイント定義に「DSS」を用いている。

ストリーム暗号では、平文と、暗号的に安全な鍵付き擬似乱数生成器から生成される同一量の出力との排他的論理和がとられる。

ブロック暗号では、平文の各ブロックが暗号文のブロックに暗号化される。 すべてのブロック暗号はCBC（Cipher Block Chaining）モードで行われ、ブロック暗号化されるすべての項目は、暗号ブロック長の正確な倍数となる。

AEAD暗号では、平文を暗号化すると同時に完全性を保護する。 入力は任意の長さでよく、Aead暗号の出力は、完全性チェック値を収容するため、一般に入力より大きくなる。

公開鍵暗号化では、公開鍵アルゴリズムを使ってデータを暗号化し、一致する秘密鍵によってのみ復号化できるようにする。公開鍵暗号化された要素は、不透明なベクトル<0..2^16-1>として符号化され、その長さは暗号化アルゴリズムと鍵によって指定される。

RSA暗号は[PKCS1]で定義されたRSAES-PKCS1-v1_5暗号方式で行われる。

次の例では

      ストリーム暗号化構造体 {
          uint8 field1;
          uint8 field2;
          デジタル署名入りの不透明な{
            uint8 field3<0...255>です。
            uint8 field4;
          };
      } UserType;
        
内部構造体の内容（field3、field4）を署名/ハッシュアルゴリズムの入力として使用し、構造体全体をストリーム暗号で暗号化する。この構造体の長さは、field1とfield2の2バイトに、署名とハッシュアルゴリズムの2バイトを加え、署名の長さを2バイト、署名アルゴリズムの出力の長さを加えたバイト数となる。この構造を符号化または復号化する前に、署名に使用するアルゴリズムと鍵が分かっているため、署名の長さは既知である。

4.8. 定数
型付き定数は、目的の型のシンボルを宣言し、それに値を割り当てることで、仕様のために定義することができる。

指定外の型（不透明型、可変長ベクター、不透明型を含む構造体）には値を割り当てることができません。複数要素の構造またはベクトルのフィールドをエリッドしてはならない。

例えば、こんな感じです。

      構造体{
          uint8 f1;
          uint8 f2;
      } 例1．
        
      例1 ex1 = {1, 4}; /* f1 = 1, f2 = 4 を代入 */。
        
5.HMACと疑似乱数関数
TLSレコードレイヤーは、メッセージの完全性を保護するために鍵付きのMessage Authentication Code (MAC)を使用する。 このドキュメントで定義されている暗号スイートは、 [HMAC]で述べられている、ハッシュ関数に基づいたHMACという構造を使用する。 必要に応じて他の暗号スイートはそれ自身のMAC構造を定義してもよい[MAY]。

この疑似ランダム関数（PRF）は、秘密、種、識別ラベルを入力とし、任意の長さの出力を生成するもので、暗号化されたデータブロックに秘密を展開し、鍵の生成や検証を行う。

ここでは、HMACをベースとしたPRFを一つ定義する。このPRFとSHA-256ハッシュ関数は、本文書で定義されているすべての暗号スイー ト、および本文書より前に発行されたTLS文書で、TLS 1.2がネゴシエートされたときに使用される。 新しい暗号スイートはPRFを明示的に指定しなければならず[MUST]、一般的には SHA-256またはより強力な標準ハッシュ関数付きのTLS PRFを使用するべきで ある[SHOULD]。

まず、1つのハッシュ関数を用いて、秘密と種を任意の量の出力に展開するデータ展開関数P_hash(secret, data)を定義する。

P_hash(secret, seed) = HMAC_hash(secret, A(1) + seed) + HMAC_hash(secret, A(2) + seed) + HMAC_hash(secret, A(3) + seed) + ...です。

ここで、＋は連結を表す。

A()は次のように定義されます。

      A(0) = シード
      A(i) = HMAC_hash(secret, A(i-1))
        
例えば、P_SHA256を使用して80バイトのデータを作成する場合、3回反復して(A(3))96バイトの出力データを作成する必要があります。

TLSのPRFは、P_hashをシークレットに適用することで作成されます。

      PRF(secret, label, seed) = P_<ハッシュ>(secret,label+seed)とする。
        
ラベルはASCII文字列である。長さバイトや末尾のヌル文字は含まず、指定されたとおりの形式で含める必要があります。例えば、"slithy toves "というラベルは、以下のバイトをハッシュ化することで処理される。

73 6c 69 74 68 79 20 74 6f 76 65 73

6.TLSレコードプロトコル
TLSレコードプロトコルはレイヤーを重ねたプロトコルであり、各レイヤーにおいて、メッセージは長さ、説明、およびコンテンツのフィールドを含むことができます。Record Protocolは、送信するメッセージを受け取り、データを管理可能なブロックに分割し、オプションで圧縮し、MACを適用し、暗号化して送信する。 受信したデータは復号、検証、解凍、再構成され、上位のクライアントに配信される。

このドキュメントでは、レコードプロトコルを使用する4つのプロトコル(ハンドシェイクプロトコル、アラートプロトコル、変更暗号仕様プロトコル、アプリケーションデータプロトコル)を説明する。 TLSプロトコルの拡張を可能にするために、レコードプロトコルでは追加のレコードコンテンツタイプをサポートできる。 新しいレコードコンテンツタイプの値は、セクション12で説明するようにTLS Content Type RegistryでIANAにより割り当てられる。

実装は、何らかの拡張でネゴシエートされない限り、このドキュメントで定 義されていないレコードタイプを送信してはならない[MUST NOT]。 TLS実装が予期しないレコードタイプを受け取った場合、それは unexpected_message警告を送信しなければならない[MUST]。

TLS上で使用するために設計されたプロトコルは、それに対するすべての可能な攻撃に対処するために慎重に設計されなければならない。 現実問題として、これはプロトコルの設計者がTLSが提供するセキュリティ特性としないものを認識しなければならず、後者に安全に頼ることができないことを意味する。

特に、レコードの型と長さは暗号化では保護されないことに注意。 この情報自体が機密である場合、アプリケーション設計者は情報漏洩を最小限に抑えるための措置（パディング、カバートラフィック）を取ることが望ましい。

6.1. 接続状態
TLS 接続状態とは、TLS Record Protocol の動作環境であり、圧縮アルゴリズム、暗号化アルゴリズム、MAC アルゴリズムが規定されている。また、これらのアルゴリズムのパラメータは、リードとライトの両方向の接続のためのMACキーとバルク暗号化キーが知られています。 論理的には、現在のリードとライトの状態、保留中のリードとライトの状態の4つの接続状態が常に存在します。 すべてのレコードは、現在のリードとライト状態の下で処理されています。保留状態のセキュリティパラメータはTLSハンドシェイクプロトコルによって設定することができ、ChangeCipherSpecは保留状態のいずれかを選択的に現在の状態にすることができる。この場合、該当する現在の状態は破棄され保留状態に置き換えられ、その後保留状態は空の状態に再初期化される。セキュリティパラメータで初期化されていない状態を現在の状態とすることは違法である。初期の現在の状態は、常に暗号化、圧縮、MACを使用しないことが指定されています。

TLS 接続の読み取り状態および書き込み状態のセキュリティパラメータは、以下の値を指定して設定する。

connection end このエンティティが、この接続において「クライアント」または「サーバ」のどちらと見なされるかを指定する。

PRFアルゴリズム マスターシークレットから鍵を生成するために使用されるアルゴリズム（セクション5および6.3参照）。

一括暗号化アルゴリズム 一括暗号化に使用するアルゴリズム。 この仕様には、このアルゴリズムの鍵サイズ、ブロック暗号、ストリーム暗号、AEAD 暗号の別、暗号のブロックサイズ（適切な場合）、明示および暗黙の初期化ベクター（またはノンス）の長さなどが含まれる。

MAC algorithm メッセージ認証に使用するアルゴリズム。 この仕様には、MAC アルゴリズムが返す値のサイズも含まれる。

圧縮アルゴリズム データ圧縮に使用するアルゴリズム。 この仕様には、圧縮を行うために必要なすべての情報を含める必要がある。

マスターシークレット 接続中の2つのピア間で共有される48バイトのシークレットです。

client random クライアントが提供する 32 バイトの値。

server random サーバーから提供される 32 バイトの値。

これらのパラメータはプレゼンテーション言語では次のように定義されています。

      enum { server, client } ConnectionEnd;
        
      enum { tls_prf_sha256 } PRFAlgorithm;
        
      enum { null, rc4, 3des, aes }.
        BulkCipherAlgorithm。
        
      enum { stream, block, aead } CipherType;
        
      enum { null, hmac_md5, hmac_sha1, hmac_sha256,
           HMAC_SHA384, HMAC_SHA512} MACAlgorithm;
        
      enum { null(0), (255) } CompressionMethod;
        
      /* PRFAlgorithm の CompressionMethod で指定されたアルゴリズム。
         BulkCipherAlgorithm、および MACAlgorithm が追加される場合があります。*/
        
      構造体{
          ConnectionEndの実体。
          PRFAlgorithm prf_algorithmです。
          BulkCipherAlgorithm bulk_cipher_algorithm;
          CipherType cipher_type;
          uint8 enc_key_length。
          uint8 block_length。
          uint8 fixed_iv_length。
          uint8 record_iv_length。
          MACAlgorithm mac_algorithm;
          uint8 mac_length。
          uint8 mac_key_length。
          CompressionMethod compression_algorithm;
          opaque master_secret[48]。
          opaque client_random[32]。
          opaque server_random[32]。
      } SecurityParameters;
        
レコード層は、セキュリティパラメータを用いて、以下の6項目を生成する（このうちいくつかは、すべての暗号で必要とされないため、空欄となる）。

クライアント書き込み MACキー サーバ書き込みMACキー クライアント書き込み暗号化キー サーバ書き込み暗号化キー クライアント書き込みIV サーバ書き込みIV

クライアントの書き込みパラメータは、サーバーがレコードを受信して処理するときに使用され、その逆も同様である。これらの項目をセキュリティパラメータから生成するためのアルゴリズムについては、6.3節で説明する。

セキュリティパラメータを設定し、鍵を生成したら、接続状態を現在の状態にしてインスタンス化することができる。 これらの現在の状態は、レコードを処理するたびに更新されなければならない(MUST)。 各接続状態には以下の要素が含まれる。

compression state 圧縮アルゴリズムの現在の状態。

cipher state 暗号化アルゴリズムの現在の状態。ストリーム暗号の場合、データの暗号化・復号化を継続するために必要な状態情報も含まれる。

MACキー 上記で生成された、この接続のMACキー。

シーケンス番号 各接続状態はシーケンス番号を含み、これは読み込み状態と書き込み状態で別々に保持される。 シーケンス番号は、接続状態がアクティブ状態になるたびにゼロに設定されなければならない(MUST)。シーケンス番号は uint64 型であり、2^64-1 を超えてはならない。連番は折り返さない。TLSの実装がシーケンス番号をラップする必要がある場合、その代わりにrenegotiateを行わなければならない(MUST)。シーケンス番号は各レコードの後にインクリメントされる。具体的には、特定の接続状態の下で送信される最初のレコードは、シーケンス番号0を使用しなければならない(MUST)。

6.2. レコードレイヤ
TLSレコード層は、上位層から解釈されないデータを任意のサイズの空でないブロックとして受け取る。

6.2.1. フラグメンテーション
レコードレイヤーは情報ブロックを2^14バイト以下のチャンクのデータを運ぶTLSPlaintextレコードに断片化する。 クライアントメッセージの境界はレコードレイヤーで保存されない(すなわち、同じContentTypeの複数のクライアントメッセージは単一のTLSPlaintextレコードに合体してもよいし、単一のメッセージは複数のレコードにわたって断片化してもよい(MAY)。

      構造体{
          uint8 メジャー。
          uint8 マイナー
      } ProtocolVersion;
        
      enum {
          change_cipher_spec(20)、alert(21)、handshake(22) です。
          application_data(23), (255)
      } ContentType;
        
      構造体{
          ContentTypeの種類。
          ProtocolVersion バージョン。
          uint16の長さです。
          opaque fragment[TLSPlaintext.length]。
      } TLSPlaintext;
        
type 閉じられたフラグメントを処理するために使用される上位プロトコル。

version 採用しているプロトコルのバージョン。このドキュメントでは、バージョン{ 3, 3 }を使用するTLSバージョン1.2について述べる。 バージョン値3.3は、TLS 1.0に対して{3, 1}を使用したことに由来する歴史的なものである。 (付録A.1参照) 複数のTLSバージョンをサポートするクライアントは、ServerHelloを受け取る前に どのバージョンが採用されるか分からないかもしれないことに注意すること。ClientHelloに採用すべきレコードレイヤのバージョン番号については、付録Eを参照のこと。

length 以下のTLSPlaintext.fragmentの長さ（バイト単位）。 長さは2^14を超えてはならない（MUST NOT）。

fragment アプリケーションデータ。このデータは透過的であり、独立したブロックとして扱われ、type フィールドで指定された上位プロトコルで処理される。

実装は、Handshake、Alert、またはChangeCipherSpecコンテンツタイプの長さ0のフラグメントを送信してはならない[MUST NOT]。アプリケーションデータのゼロ長フラグメントは、トラフィック解析対策として有用である可能性があるため、送信してもよい（MAY）。

注：異なるTLSレコードレイヤーコンテンツタイプのデータは、インターリーブしてもよい（MAY）。アプリケーションデータは、一般的に他のコンテンツタイプよりも送信の優先順位が低い。しかし、レコードはレコードレイヤーで保護されているのと同じ順序でネットワークに配信されなければならない(MUST)。受信者は、コネクション上の最初のハンドシェイクに続くハンドシェイク中に、インターリーブされたアプリケーション層トラフィックを受信し処理しなければならない(MUST)。

6.2.2. レコードの圧縮と伸張
すべてのレコードは、現在のセッションの状態で定義された圧縮アルゴリズムを用いて圧縮される。常にアクティブな圧縮アルゴリズムが存在しますが、初期状態ではCompressionMethod.nullとして定義されています。圧縮アルゴリズムはTLSPlaintext構造をTLSCompressed構造に変換する。 圧縮関数は、接続状態がアクティブになるたびにデフォルトの状態情報で初期化される。 [RFC3749]では、TLS用の圧縮アルゴリズムについて説明している。

圧縮は可逆圧縮でなければならず、コンテンツの長さを1024バイト以上増加させてはならない。 伸長機能が2^14バイトを超える長さに伸長するTLSCompressed.fragmentに遭遇した場合、致命的な伸長失敗エラーを報告しなければならない(MUST)。

      構造体{
          ContentType type; /* TLSPlaintext.typeと同じ */。
          ProtocolVersion version;/* TLSPlaintext.versionと同じ */。
          uint16の長さです。
          opaque fragment[TLSCompressed.length]。
      } TLSCompressed;
        
length 以下のTLSCompressed.fragmentの長さ（バイト）。 長さは2^14 + 1024を超えてはならない（MUST NOT）。

fragment TLSPlaintext.fragmentの圧縮形式。

注: CompressionMethod.null 操作は ID 操作であり、フィールドは変更されません。

実装上の注意：解凍関数は、メッセージが内部バッファオーバーフローを引き起こさないようにする責任があります。

6.2.3. レコードペイロードの保護
暗号化関数とMAC関数は、TLSCompressed構造をTLSCiphertextに変換し、復号化関数はその逆の処理を行う。 レコードのMACにはシーケンス番号も含まれるため、メッセージの欠落、余分、繰り返しを検出することが可能である。

      構造体{
          ContentTypeの種類。
          ProtocolVersion バージョン。
          uint16の長さです。
          select (SecurityParameters.cipher_type) {.
              case stream: GenericStreamCipher;
              case block: GenericBlockCipher;
              case aead: GenericAEADCipher;
          } フラグメント
      } TLSCiphertext;
        
type typeフィールドはTLSCompressed.typeと同一である。

version バージョンフィールドはTLSCompressed.versionと同一である。

length 以下の TLSCiphertext.fragment の長さ(バイト)。 長さは 2^14 + 2048 を超えてはならない(MUST NOT)。

fragment TLSCompressed.fragmentの暗号化された形式で、MACを含む。

6.2.3.1. Null または標準ストリーム暗号
ストリーム暗号（BulkCipherAlgorithm.null を含む、付録 A.6 参照）は TLSCompressed.fragment 構造をストリーム TLSCiphertext.fragment 構造に変換し、またそこから変換します。

      ストリーム圧縮構造 {
          opaque content[TLSCompressed.length]。
          opaque MAC[SecurityParameters.mac_length]。
      } GenericStreamCipher;
        
として、MACを生成する。

      MAC(MAC_write_key, seq_num +)
                            TLSCompressed.type +.
                            TLSCompressed.version +.
                            TLSCompressed.lengthの+。
                            TLSCompressed.fragment）です。
        
ここで、"+"は連結を表す。

seq_num このレコードのシーケンス番号。

MAC SecurityParameters.mac_algorithm で指定された MAC アルゴリズム。

MACは暗号化の前に計算されることに注意． ストリーム暗号はMACを含むブロック全体を暗号化する． 同期ベクトルを使用しないストリーム暗号（RC4など）の場合，あるレコードの終了時点のストリーム暗号の状態が，その後のパケットで単に使用されることになる．暗号スイートが TLS_NULL_WITH_NULL_NULL の場合、暗号化は ID 操作で構成される (つまり、データは暗号化されず、MAC サイズは 0 であり、MAC が使用されていないことを意味する)。 NULL およびストリーム暗号の両方について、 TLSCiphertext.length は TLSCompressed.length と SecurityParameters.mac_length を加えたものである。

6.2.3.2. CBCブロック暗号
ブロック暗号（3DESやAESなど）の場合、暗号化関数とMAC関数がTLSCompressed.fragment構造をブロックTLSCiphertext.fragment構造に変換したり、ブロックTLSCiphertext.fragmentから変換したりします。

      struct {
          opaque IV[SecurityParameters.record_iv_length];
          block-ciphered struct {
              opaque content[TLSCompressed.length];
              opaque MAC[SecurityParameters.mac_length];
              uint8 padding[GenericBlockCipher.padding_length];
              uint8 padding_length;
          };
      } GenericBlockCipher;
        
MACは、6.2.3.1節で説明したように生成される。

IV 初期化ベクトル(IV)はランダムに選ばれるべきであり、予測不可能でなければならない(SHOULD)。1.1より前のバージョンのTLSでは、IVフィールドがなく、前のレコードの最後の 暗号文ブロック(「CBC残余」)がIVとして使用されていたことに注意。ブロック暗号の場合、IV の長さは SecurityParameters.record_iv_length であり、これは SecurityParameters.block_size と同じである。

padding 平文の長さがブロック暗号のブロック長の整数倍になるように強制的に追加されるパディングのこと。パディングは、TLSCiphertext.lengthがブロック長の整数倍となる限り、255バイトまでの任意の長さにしてもよい[MAY]。パディングデータベクターの各UINT8には、パディング長の値を埋めなければならない (MUST)。 受信者はこのパディングをチェックし、パディングエラーを示すために bad_record_mac 警告を使用しなければならない(MUST)。

padding_length パディングの長さは、GenericBlockCipher 構造体の合計サイズが暗号のブロック長の倍数になるようにしなければならない (MUST)。有効な値は、0 から 255 までの範囲とする。この長さは、padding_length フィールド自身を除いたパディングフィールドの長さを指定する。

暗号化されたデータの長さ (TLSCiphertext.length) は SecurityParameters.block_length, TLSCompressed.length, SecurityParameters.mac_length, padding_length の合計より 1 つ多い値である。

例：ブロック長が8バイト、コンテンツ長（TLSCompressed.length）が61バイト、MAC長が20バイトの場合、パディング前の長さは82バイト（この中にはIVは含まれない。パディング長は、6、14、22と254バイトまで設定することができる。パディングの長さが必要最小限の6であれば、パディングは6バイトとなり、それぞれに値6が含まれる。したがって、ブロック暗号化前のGenericBlockCipherの最後の8オクテットは、xx 06 06 06 06 06（xxはMACの最後のオクテット）である。

注：CBCモード（Cipher Block Chaining）のブロック暗号では、暗号文が送信される前にレコードの平文全体を知っておくことが重要です。 そうしないと、攻撃者は[CBCATT]で説明した攻撃を行うことが可能になります。

実装上の注意：Canvelら[CBCTIME]は、MACを計算するのに必要な時間に基づいてCBCパディングに対するタイミング攻撃を実証した。この攻撃を防御するために、実装は、パディングが正しくても正しくなくてもレコー ド処理時間が本質的に同じになるようにしなければならない[MUST]。 一般的に、これを行う最善の方法は、パディングが正しくなくてもMACを計算し、 その後にパケットを拒否することだけである。例えば、パッドが正しくないと思われる場合、実装では長さゼロのパッドを想定し、その後MACを計算するかもしれません。MACの性能はデータ断片のサイズにある程度依存するため、これによって小さなタイミングチャネルが残されますが、既存のMACの大きなブロックサイズとタイミング信号の小さなサイズのために、悪用できるほど大きくはないと考えられています。

6.2.3.3. AEAD 暗号
AEAD [AEAD] 暗号（[CCM]や[GCM]など）の場合、AEAD 機能は TLSCompressed.fragment 構造と AEAD TLSCiphertext.fragment 構造との変換を行う。

      struct {
         opaque nonce_explicit[SecurityParameters.record_iv_length];
         aead-ciphered struct {
             opaque content[TLSCompressed.length];
         };
      } GenericAEADCipher;
        
AEAD暗号は、[AEAD]のセクション2.1に記載されているように、1つの鍵、nonce、平文、および認証チェックに含まれる「追加データ」を入力として受け取る。 鍵は、client_write_key または server_write_key のどちらかである。MACキーは使用しない。

各 AEAD 暗号スイートは，AEAD 操作に供給される nonce の構築方法と，GenericAEADCipher.nonce_explicit部の長さを指定しなければならない（MUST）． 多くの場合，セクション 3.2 で述べた部分暗黙 nonce テクニックを使用することが適切と考えられる．この場合、暗黙的な部分はclient_write_ivおよびserver_write_ivとして key_blockから導出されるべきである(SHOULD) (セクション6.3で説明)が、明示的な部分は GenericAEAEDCipher.nonce_explicit に含まれる。

平文はTLSCompressed.fragmentである。

追加認証データは、additional_dataとし、以下のように定義する。

      additional_data = seq_num + TLSCompressed.type +.
                        TLSCompressed.version + TLSCompressed.length。
        
ここで、"+"は連結を表す。

aead_output は、AEAD 暗号化処理により出力された暗号文である。 一般に TLSCompressed.length よりも長いが、AEAD 暗号によって異なる。各 AEAD 暗号は 1024 バイトを超える拡張を生成してはならない(MUST NOT)．

AEADEncrypted = AEAD-Encrypt(write_key, nonce, plaintext, additional_data)

復号と検証のために、暗号は鍵、nonce、additional_data、AEADEncrypted 値を入力とする。 出力は平文か、復号に失敗したことを示すエラーである。別途、整合性チェックは行わない。ということです。

TLSCompressed.fragment = AEAD-Decrypt(write_key, nonce, AEADEncrypted, additional_data)

復号化に失敗した場合、致命的なbad_record_mac警告が生成されなければならない(MUST)。

6.3. キー算出
レコードプロトコルは、ハンドシェイクプロトコルが提供するセキュリティパラメータから、現在の接続状態（付録A.6参照）が必要とするキーを生成するアルゴリズムを必要とします。

マスターシークレットはセキュアバイト列に展開され、クライアント書き込みMACキー、サーバ書き込みMACキー、クライアント書き込み暗号キー、サーバ書き込み暗号キーに分割されます。それぞれバイト列からこの順番で生成される。未使用の値は空である。AEAD暗号の中には、さらにクライアントライトIVとサーバーライトIVを必要とするものがある（セク ション6.2.3.3参照）。

鍵やMAC鍵の生成時には、マスターシークレットをエントロピー源として使用する。

鍵素材を生成するには、以下の計算を行います。

key_block = PRF(SecurityParameters.master_secret, "key expansion", SecurityParameters.server_random + SecurityParameters.client_random)。

そして、key_blockを以下のように分割する。

client_write_MAC_key[SecurityParameters.mac_key_length] server_write_MAC_key[SecurityParameters.mac_key_length] client_write_key[SecurityParameters.enc_key_length] server_write_key[SecurityParameters.enc_key_length] server_write_IV[SecurityParameters.fixed_iv_length] server_write_IV[SecurityParameters.fixed_iv_length] server_writ_key_key_length]である。

現在、client_write_IV と server_write_IV は [AEAD] のセクション 3.2.1 で説明されている暗黙の nonce 技術に対してのみ生成される。

実装上の注意：現在定義されている暗号スイートで最も多くの資料を必要とするのは AES_256_CBC_SHA256 である。32バイトの鍵2個と32バイトのMAC鍵2個、合計128バイトの鍵素材が必要です。

7.TLSハンドシェイクプロトコル
TLSには3つのサブプロトコルがあり、ピアはレコードレイヤのセキュリティパラメータに合意し、自分自身を認証し、ネゴシエーションされたセキュリティパラメータをインスタンス化し、エラー状態を互いに報告できるようにするために使用されています。

ハンドシェイクプロトコルは、以下の項目からなるセッションのネゴシエーションを担当する。 セッション識別子 アクティブまたはリジューム可能なセッション状態を識別するためにサーバーが選択する任意のバイト列。

peer certificate X509v3 [PKIX]ピアの証明書。この状態の要素は、NULLでもよい。

圧縮方式 暗号化する前にデータを圧縮するために使用するアルゴリズム。

cipher spec 鍵生成に用いる PRF (pseudorandom function)、バルクデータ暗号化アルゴリズム (null, AES 等)、MAC アルゴリズム (HMAC-SHA1 等) を指定する。 また mac_length 等の暗号属性を定義する。 正式な定義は付録 A.6 を参照のこと)。

マスターシークレット クライアントとサーバー間で共有される48バイトのシークレット。

is resumable 新しい接続を開始するためにセッションを使用できるかどうかを示すフラグ。

これらの項目は、アプリケーションデータを保護する際にレコード層が使用するセキュリティパラメータを作成するために使用される。TLSハンドシェイクプロトコルの再開機能により、同じセッションを使用して多くの接続をインスタンス化することができます。

7.1 Change Cipher Spec プロトコル
change cipher spec プロトコルは、暗号化戦略の遷移を知らせるために存在します。 このプロトコルは単一のメッセージで構成され、現在の（保留中ではない）接続状態の下で暗号化および圧縮されます。メッセージは、値 1 の 1 バイトで構成される。

      構造体{
          enum { change_cipher_spec(1), (255) } タイプ。
      } changeCipherSpec;
        
ChangeCipherSpec メッセージは、クライアントとサーバの両方から送信され、後続のレコードが新たにネゴシエートされた CipherSpec と鍵で保護されることを受信側に通知する。このメッセージの受信により、受信者は記録層に読み出し保留状態を直ちに読み出し中状態にコピーするよう指示する。このメッセージを送信した直後に、送信者は記録層に書き込み保留状態を書き込み活性状態にするよう指示しなければならない(MUST)。

(セクション 6.1 参照) ChangeCipherSpec メッセージは、セキュリティパラメータが合意された後、検証用の Finished メッセージが送信される前に、ハンドシェイク中に送信される。

注：コネクション上でデータが流れている間に再ハンドシェイクが発生した場合、通信当事者は古いCipherSpecを使用してデータの送信を継続することができます。しかし、ChangeCipherSpecが送信されると、新しいCipherSpecを使用しなければならない(MUST)。 ChangeCipherSpecを最初に送信した側は、相手側が新しい鍵材料の計算を終了したことを知らない(たとえば、時間のかかる公開鍵操作を実行しなければならない場合)。 したがって、受信者がデータをバッファしなければならない小さな時間のウィンドウが存在してもよい[MAY]。実際には、最新の機械では、この間隔はかなり短くなる可能性が高い。

7.2. アラートプロトコル
TLSレコード層がサポートするコンテンツタイプの1つにアラートタイプがある。アラートメッセージは、メッセージの重要度（警告または致命的）とアラートの説明を伝えます。致命的なレベルの警告メッセージは、接続を直ちに終了させます。 この場合、セッションに対応する他の接続は継続できますが、セッション識別子は無効化されなければならず、失敗したセッションが新しい接続を確立するために使われるのを防ぎます。 他のメッセージと同様に、警告メッセージは現在の接続状態によって指定されるように暗号化と圧縮が行われます。

      enum { warning(1), fatal(2), (255) } AlertLevel;
        
      enum {
          close_notify(0),
          unexpected_message(10),
          bad_record_mac(20),
          decryption_failed_RESERVED(21),
          record_overflow(22),
          decompression_failure(30),
          handshake_failure(40),
          no_certificate_RESERVED(41),
          bad_certificate(42),
          unsupported_certificate(43),
          certificate_revoked(44),
          certificate_expired(45),
          certificate_unknown(46),
          illegal_parameter(47),
          unknown_ca(48),
          access_denied(49),
          decode_error(50),
          decrypt_error(51),
          export_restriction_RESERVED(60),
          protocol_version(70),
          insufficient_security(71),
          internal_error(80),
          user_canceled(90),
          no_renegotiation(100),
          unsupported_extension(110),
          (255)
      } AlertDescription;
        
      struct {
          AlertLevel level;
          AlertDescription description;
      } Alert;
        
7.2.1. クロージャーアラート
切断攻撃を避けるために、クライアントとサーバーは接続が終了するという知識を共有する必要があります。クロージングメッセージの交換は、当事者のいずれかが開始することができる。

close_notify このメッセージは、送信者がこの接続でこれ以上メッセージを送信しないことを受信者に 通知する。 TLS 1.1では、接続を適切に閉じることに失敗しても、もはやセッションを再開する必要はない ことに注意すること。これは、TLS 1.0からの変更で、広く普及している実装方法に適合させるためである。

いずれの当事者もclose_notifyアラートを送信することにより、クローズを開始することができる。クローズアラート後に受信したデータは、無視されます。

他の致命的な警告が送信されていない限り、各パーティは接続の書き込み側を閉じる前に close_notify警告を送信する必要がある。 相手パーティは自身のclose_notify警告で応答し、保留中の書き込みを破棄して直ちに接続を閉じなければならない (MUST)。 接続の読み取り側を閉じる前に、閉じる側の開始者が応答のclose_notify警告まで待つ必要はない。

TLSを使用するアプリケーションプロトコルが、TLS接続が閉じられた後に基礎 となるトランスポート上で何らかのデータを伝送することを提供する場合、 TLS実装は、TLS接続が終了したことをアプリケーション層に示す前に、応答 のclose_notifyアラートを受け取らなければならない。 アプリケーションプロトコルが追加のデータを転送しないが、基礎のトランスポート 接続だけを終了するなら、実装は応答のclose_notifyを待たずにトランスポートを 終了することを選んでもよい[MAY]。この規格のいかなる部分も、接続が開かれたり閉じられたりするときを含め、 TLSの使用プロファイルがそのデータ伝送を管理する方法を指示すると見なされるべきではない。

注：コネクションを閉じる際には、トランスポートを破壊する前に、保留されているデータを確実に配信することが前提となっています。

7.2.2.エラーアラート
TLSハンドシェイクプロトコルにおけるエラー処理は非常にシンプルである。 エラーが検出されると、検出側は相手側にメッセージを送信する。致命的な警告メッセージを送信または受信すると、両パーティーは直ちに接続を閉じます。 サーバーとクライアントは、失敗した接続に関連付けられたすべてのセッション識別子、鍵、秘密を忘れなければなりません。 したがって、致命的な警告で終了した接続は再開してはいけません(MUST NOT)。

実装が致命的な警告として定義されている状態に遭遇したときはいつでも、接続を閉じる前に適切な警告を送信しなければならない(MUST)。 警告レベルが明示的に指定されていないすべてのエラーに対して、送信側はこれを致命的なエラーとして扱うかどうかをその裁量で判断してもよい(MAY)。もし実装が警告を送ることを選択したが、その後すぐに接続を閉じるつもりであれば、その警告を致命的な警告レベルで送らなければならない[MUST]。

警告レベルのアラートを送受信した場合、一般的に接続を正常に継続することができます。受信側が接続を続行しないことを決定した場合（例．そのため、送信側は受信側がどのように振る舞うかを一般的に知ることができません。 したがって、送信側が接続を継続したい場合には警告アラートはあまり有用ではなく、省略されることもあります。 たとえば、相手が期限切れの証明書を受け入れることを決定し（おそらくユーザーに確認した後に）接続を継続したい場合、通常certificate_expired警告は送信されません。

以下のエラーアラートが定義されています。

unexpected_message 不適切なメッセージを受信した。この警告は常に致命的であり、適切な実装間の通信では決して観測されるべきではありません。

bad_record_mac この警告は、不正な MAC を持つレコードを受信した場合に返される。このアラートは、TLSCiphertext が無効な方法で復号されたためにアラートが送信された場合にも返されなければならない(MUST)。 このメッセージは常に致命的で、適切な実装間の通信では決して観測されるべきではありません (メッセージがネットワークで破損した場合は例外)。

decryption_failed_RESERVED この警告はTLSのいくつかの以前のバージョンで使用されており、CBCモード [CBCATT]に対する特定の攻撃を許可していたかもしれない。 準拠する実装によって送信されてはならない[MUST NOT]。

record_overflow 2^14+2048 バイトを超える長さの TLSCiphertext レコードを受信した、または 2^14+1024 バイトを超える TLSCompressed レコードに復号した。 このメッセージは常に致命的で、適切な実装間の通信では決して観測されてはならない( ネットワークでメッセージが破損した場合は除く )。

decompression_failure 伸長関数が不正な入力(例えば、過度に長く伸びるデータ)を受け取った。 このメッセージは常に致命的で、適切な実装間の通信では決して観察されるべきではありません。

handshake_failure 警告メッセージの受信は、送信者が利用可能なオプションから許容できるセキュリティパラメータのセットをネゴシエートできなかったことを示す。 これは致命的なエラーである。

no_certificate_RESERVED この警告はSSLv3で使われていたが、どのバージョンのTLSでも使われていない。 準拠する実装からは送られてはならない(MUST NOT)。

bad_certificate 証明書が破損していた、正しく検証できない署名が含まれていた、など。

unsupported_certificate 証明書がサポートされていないタイプであった。

certificate_revoked 証明書がその署名者によって取り消された。

certificate_expired 証明書の有効期限が切れている、または現在有効でない。

certificate_unknown 証明書の処理中に他の（特定されない）問題が発生し、受け入れ不能になりました。

illegal_parameter ハンドシェイクのフィールドが範囲外であった、または他のフィールドと矛盾していた。このメッセージは常に致命的です。

unknown_ca 有効な証明書チェーンまたは部分チェーンを受け取りましたが、CA 証明書が見つからないか、既知の信頼できる CA と照合できないため、証明書は受け入れられませんでした。このメッセージは常に致命的です。

access_denied 有効な証明書を受け取ったが、アクセス制御を適用したところ、送信者がネゴシエーションを続けないことにした。 このメッセージは常に致命的である。

decode_error フィールドが指定範囲外であるか，メッセージの長さが正しくないため，メッセージをデコードできなかった。 このメッセージは常に致命的であり，適切な実装間の通信では決して観測されるべきでない（ネットワークでメッセージが破壊された場合を除く）。

decrypt_error ハンドシェイクの暗号化処理に失敗した（署名を正しく検証できない、Finishedメッセージを検証できないなど）。 このメッセージは常に致命的である。

export_restriction_RESERVED この警告はTLSのいくつかの以前のバージョンで使用されていた。 準拠する実装によって送信されてはならない[MUST NOT]。

protocol_version クライアントがネゴシエーションを試みたプロトコルのバージョンは認識されているが、サポートされていない。 (例えば、セキュリティ上の理由から古いプロトコルのバージョンは避けられるかもしれない) このメッセージは常に致命的なものである。

insufficient_security サーバがクライアントのサポートする暗号よりも安全な暗号を要求したためにネゴシエーションが失敗した場合に handshake_failure の代わりに返される。このメッセージは常に致命的です。

internal_error 相手やプロトコルの正しさとは無関係な内部エラー（メモリ割り当ての失敗など）により、継続が不可能になった。 このメッセージは常に致命的である。

user_canceled このハンドシェイクは、プロトコル障害とは無関係の何らかの理由でキャンセルされている。ハンドシェイク完了後にユーザーが操作をキャンセルした場合、close_notify を送信して接続を閉じる方が適切です。 この警告の後に close_notify を送信する必要があります。このメッセージは一般的に警告です。

no_renegotiation クライアントがHelloリクエストに応答して、またはサーバが最初のハンドシェイクの後にクライアントHelloに応答して送信する。 これらのいずれかが通常再ネゴシエーションにつながる。それが適切でない場合、受信者はこの警告で応答すべきである。その時点で、元の要求者は接続を続行するかどうかを決定できる。 これが適切な場合の一つは、サーバーがリクエストを満たすためにプロセスを 生成した場合である。そのプロセスは起動時にセキュリティパラメータ (鍵長、認証など)を受け取るかもしれないし、その時点以降のパラメータへの 変更を伝えるのは難しいかもしれない。このメッセージは常に警告です。

対応するクライアントHelloに入れなかった拡張を含む拡張サーバーHelloを受信したクライアントが送信するunsupported_extension。このメッセージは常に致命的です。

新しいアラート値は、セクション12に記載されているように、IANAによって割り当てられる。

7.3 ハンドシェイクプロトコルの概要
セッション状態の暗号パラメータは、TLSレコードレイヤの上で動作するTLSハンドシェイクプロトコルによって生成されます。 TLSクライアントとサーバーが最初に通信を開始するとき、彼らはプロトコルバージョンに合意し、暗号アルゴリズムを選択し、オプションでお互いを認証し、公開鍵暗号化技術を使用して共有秘密を生成します。

TLSハンドシェイクプロトコルでは、以下の手順で行います。

- Helloメッセージの交換により、アルゴリズムの合意、ランダム値の交換、セッション再開の確認などを行う。

- クライアントとサーバーがプレマスターシークレットに合意するために必要な暗号化パラメータを交換する。

- 証明書と暗号情報を交換し、クライアントとサーバーの認証を可能にする。

- プリマスターシークレットと交換した乱数値からマスターシークレットを生成する。

- 記録層にセキュリティパラメータを提供する。

- クライアントとサーバーは、相手が同じセキュリティ・パラメータを計算し、攻撃者によって改ざんされることなくハンドシェイクが行われたことを確認できるようにします。

上位レイヤーは、TLSが常に2つのピア間で可能な限り強い接続をネゴシエートするかどうかに過度に依存すべきではないことに注意してください。中間者攻撃者が、2つのエンティティがサポートする最も安全性の低い方式に落とさせることを試みる方法はいくつかある。プロトコルはこのリスクを最小化するように設計されているが、それでも利用可能な攻撃はある。例えば、攻撃者は安全なサービスが実行されているポートへのアクセスをブロックしたり、ピアに認証されていない接続を交渉させようとしたりできる。 基本ルールは、上位レベルはセキュリティ要件が何かを認識し、彼らが必要とするより安全ではないチャネルで情報を送信してはならないということである。TLS プロトコルは、どの暗号スイートも約束されたレベルのセキュリティを提供するという点で安全です。もし、あなたが証明書を検証したホストと 1024 ビットの RSA 鍵交換で 3DES を交渉すれば、その安全性は期待できます。

クライアントが ClientHello メッセージを送ると、サーバーは ServerHello メッセージで応答しなければならず、さもなければ致命的なエラーが発生し、接続は失敗します。ClientHelloとServerHelloは、クライアントとサーバーの間でセキュリティ強化機能を確立するために使用されます。ClientHelloとServerHelloは、プロトコルバージョン、セッションID、暗号スイート、圧縮方式という属性を確立する。さらに、ClientHello.randomとServerHello.randomという2つのランダムな値を生成し、交換する。

実際の鍵交換では、サーバ証明書、ServerKeyExchange、クライアント証明書、ClientKeyExchangeの最大4つのメッセージが使用される。これらのメッセージのフォーマットを指定し、クライアントとサーバーが共有秘密に合意するためのメッセージの使用方法を定義することで、新しい鍵交換方式を作成することができます。この秘密はかなり長くなければならない(MUST)。現在定義されている鍵交換方式は、46バイトから上の範囲の秘密を交換する。

Helloメッセージに続いて、サーバは認証される場合はCertificateメッセージでその証明書を送る。 さらに、必要であればServerKeyExchangeメッセージを送ることもある(例えば、サーバが証明書を持たない場合や、証明書が署名のみの場合)。 サーバが認証された場合、選択した暗号スイートに適していれば、クライアントに証明書を要求できる。 次に、ハンドシェークのHelloメッセージ段階が完了したことを示すServerHelloDoneメッセージが送信される。その後、サーバはクライアントの応答を待つ。 サーバがCertificateRequestメッセージを送信した場合、クライアントはCertificateメッセージを送信しなければならない(MUST)。 ClientKeyExchangeメッセージが送信され、そのメッセージの内容は、ClientHelloとServerHelloで選択した公開鍵アルゴリズムに依存することになる。クライアントが署名機能を持つ証明書を送信した場合、証明書内の秘密鍵の所有を明示的に確認するため、電子署名付きのCertificateVerifyメッセージが送信される。

この時点で、ChangeCipherSpecメッセージがクライアントから送信され、クライアントは保留中のCipher Specを現在のCipher Specにコピーする。これに対して、サーバは自身のChangeCipherSpecメッセージを送信し、保留中のものを現在のCipher Specに転送し、新しいCipher SpecでFinishメッセージを送信します。この時点でハンドシェイクが完了し、クライアントとサーバーはアプリケーション層のデータ交換を開始することができる。 (以下のフローチャートを参照) アプリケーションデータは最初のハンドシェイクが完了する前(TLS_NULL_WITH_NULL_NULL以外の暗号スイートが確立する前)には送信してはならない(MUST NOT)。

クライアントサーバー

      ClientHello -------->
                                                      サーバーハロー
                                                     証明書※1
                                               ServerKeyExchange* （サーバーキーエクスチェンジ
                                              CertificateRequest*
                                   <-------- ServerHelloDone
      証明書※1
      ClientKeyExchange
      CertificateVerify*
      [ChangeCipherSpec】です。］
      終了しました -------->
                                               [ChangeCipherSpec】です。］
                                   <--------終了しました
      アプリケーションデータ <-------> アプリケーションデータ
        
図1.フルハンドシェイクのメッセージフロー

* 常に送信されるわけではないオプションや状況依存のメッセージを示す。

注：パイプラインの停止を回避するために、ChangeCipherSpecは独立したTLSプロトコルのコンテンツタイプであり、実際にはTLSハンドシェイクメッセージではありません。

クライアントとサーバが（新しいセキュリティパラメータを交渉するのではなく）以前のセッションを再開したり、既存のセッションを複製することを決定した場合、メッセージフローは次のようになります。

クライアントは、再開するセッションのセッションIDを使用してClientHelloを送信する。その後、サーバーはセッションキャッシュをチェックし、一致するものがあるかどうかを確認する。一致するものが見つかり、サーバーが指定されたセッション状態の下で接続を再確立する意思がある場合、同じSession ID値でServerHelloを送る。 この時点で、クライアントとサーバーは両方ともChangeCipherSpecメッセージを送り、直接Finishedメッセージに進まなければならない[MUST]。 再確立が完了すると、クライアントとサーバーはアプリケーションレイヤーのデータの交換を始めてもよい[MAY](下記のフロー図を参照)。 Session IDが一致しない場合、サーバーが新しいセッションIDを生成してTLSクライアントとサーバーがフルハンドシェイクを実施する。

クライアントサーバー

      ClientHello -------->
                                                       サーバーハロー
                                                [ChangeCipherSpec】です。］
                                    <--------終了しました
      [ChangeCipherSpec】です。］
      終了しました -------->
      アプリケーションデータ <-------> アプリケーションデータ
        
図2 省略型ハンドシェイクのメッセージフロー

各メッセージの内容や意義については、次項以降で詳しく紹介します。

7.4 ハンドシェイクプロトコル
TLS ハンドシェイクプロトコルは、TLS レコードプロトコルの上位クライアントとして定義されている。 このプロトコルは、セッションの安全属性をネゴシエートするために使用される。 ハンドシェイクメッセージは TLS レコードレイヤに供給され、そこで一つ以上の TLSPlaintext 構造内にカプセル化されて、現在のアクティブセッション状態によって 指定されるように処理・送信される。

      enum {
          hello_request(0), client_hello(1), server_hello(2),
          証明書(11)、server_key_exchange(12)。
          certificate_request(13), server_hello_done(14),
          certificate_verify(15)、client_key_exchange(16)。
          終了(20)、(255)
      } HandshakeType;
        
      構造体{
          HandshakeType msg_type; /* ハンドシェイクタイプ */。
          uint24 長さ; /* メッセージのバイト数 */。
          select (HandshakeType) {.
              case hello_request: HelloRequest;
              case client_hello: ClientHello;
              case server_hello: ServerHello;
              ケース証明書： 証明書。
              case server_key_exchange: ServerKeyExchange;
              case certificate_request: CertificateRequest;
              case server_hello_done: ServerHelloDone;
              case certificate_verify: CertificateVerify;
              case client_key_exchange: ClientKeyExchange;
              case finished: 終了しました。
          } body;
      } ハンドシェイク
        
ハンドシェイクプロトコルのメッセージは、以下に送信されなければならない順序で示されている。予期しない順序でハンドシェイクメッセージを送信すると、致命的なエラーとなる。ただし、不要なハンドシェイクメッセージは省略することができる。Certificateメッセージはハンドシェイクの中で2回使用されるが(サーバからクライアント、 クライアントからサーバ)、その最初の位置でのみ記述される。 これらの順序規則に縛られないメッセージはHelloRequestメッセージで、これは いつでも送信できるが、ハンドシェイクの途中で到着した場合はクライアントが無視 すべきである[SHOULD]。

新しいハンドシェイクメッセージタイプは、セクション12で説明されているように、IANAによって割り当てられる。

7.4.1. こんにちはメッセージ
Helloフェーズメッセージは、クライアントとサーバ間でセキュリティ強化機能を交換するために使用される。 新しいセッションが開始されると、レコード層の接続状態の暗号化、ハッシュ、圧縮アルゴリズムがNULLに初期化される。現在の接続状態が再交渉メッセージに使用される。

7.4.1.1. Hello リクエスト
このメッセージはいつ送信されますか？

HelloRequestメッセージは、いつでもサーバーから送信されてもよい[MAY]。

このメッセージの意味

HelloRequestは、クライアントがネゴシエーションプロセスを新たに開始すべきことを知らせるシンプルな通知である。これに対して、クライアントは都合の良いときに ClientHello メッセージを送信する。このメッセージは、どちらがクライアントかサーバかを確定するためではなく、 単に新しいネゴシエーションを開始するためのものである。 サーバは、クライアントの最初の接続時にHelloRequestをすぐに送るべきでは ありません。 その時点でClientHelloを送るのはクライアントの仕事です。

このメッセージは、クライアントが現在セッションのネゴシエーションを行っている場合、無視される。 このメッセージは、クライアントがセッションの再ネゴシエーションを望まない場合、無視してもよい（MAY）。また、クライアントが望む場合は、no_renegotiation警告で応答してもよい。ハンドシェイクメッセージはアプリケーションデータよりも送信を優先させることを意図しているので、クライアントから数レコードを受信しないうちにネゴシエーションを開始することが期待される。サーバーがHelloRequestを送信してもClientHelloの応答がない場合、fatalアラートを出して接続を閉じることがあります。

HelloRequestを送った後、サーバーはその後のハンドシェークネゴシエーション が完了するまでリクエストを繰り返すべきではない[SHOULD NOT]。

このメッセージの構成

      struct { } HelloRequest;
        
このメッセージは、ハンドシェイクを通して維持され、Finishedメッセージと証明書検証メッセージで使用されるメッセージハッシュに含まれてはならない(MUST NOT)。

7.4.1.2. クライアントハロー
このメッセージはいつ送信されますか？

クライアントがサーバに初めて接続するとき、最初のメッセージとして ClientHello を送信することが要求されます。 また、クライアントは HelloRequest に対する応答として、または既存の接続のセキュリティパラメータを再交渉するために、自発的に ClientHello を送信することができます。

このメッセージの構成

ClientHelloメッセージには、プロトコルの後半で使用されるランダム構造体が含まれる。

         構造体{
             uint32 gmt_unix_time です。
             opaque random_bytes[28]。
         } Random;
        
gmt_unix_time 送信者の内部時計による標準的なUNIX 32ビットフォーマットでの現在の時刻と日付（1970年1月1日午前0時からの秒数、UTC、うるう秒は無視）です。時計は、基本的なTLSプロトコルでは正しく設定される必要はない。 より上位のプロトコルやアプリケーションプロトコルでは、追加の要件を定義することができる。 歴史的な理由により、データ要素の名前は、現在の世界標準時 (UTC) の前身である GMT を使用していることに注意すること。

random_bytes 安全な乱数生成器により生成された 28 バイト。

ClientHelloメッセージは可変長のセッション識別子を含む。空でない場合、クライアントがセキュリティパラメータを再利用したい同一クライアント・サーバ間のセッションを識別する値。セッション識別子は、以前の接続、今回の接続、または現在アクティブな他の接続のものでもよい(MAY)。 2番目のオプションは、クライアントが接続のランダム構造と派生値を更新したい場合に有用であり、3番目のオプションは、完全なハンドシェイクプロトコルを繰り返すことなく複数の独立した安全な接続を確立することが可能である。これらの独立した接続は、順次または同時に発生する可能性があります。SessionIDは、Finishedメッセージの交換で交渉するハンドシェイクが完了したときに有効となり、老化またはセッションに関連する接続で致命的なエラーが発生したために削除されるまで持続します。 SessionIDの実際のコンテンツは、サーバーによって定義されます。

      opaque SessionID<0..32> です。
        
警告: SessionIDは暗号化や即時のMAC保護なしで転送されるので、サーバはセッション識別子に機密情報を置いたり、偽のセッション識別子のコンテンツにセキュリティ侵害を起こさせたりしてはいけません(SessionIDを含む全体としてのハンドシェークのコンテンツは、ハンドシェークの最後に交換される終了メッセージで保護されることに注意してください)。

ClientHelloメッセージでクライアントからサーバに渡される暗号スイートリストには、クライアントがサポートする暗号アルゴリズムの組み合わせが、クライアントの好みの順（好きなものを先に）で含まれています。 それぞれの暗号スイートは、鍵交換アルゴリズム、一括暗号化アルゴリズム（秘密鍵長を含む）、MACアルゴリズム、PRFを定義しています。サーバーは暗号スイートを選択するか、または受け入れ可能な選択肢が提示されない場合は、ハンドシェイク失敗の警告を返して接続を閉じる。 このリストにサーバーが認識しない、サポートしない、または使用したくない暗号スイートが含まれている場合、サーバーはそれらの暗号スイートを無視し、残りのものを通常通り処理しなければならない[MUST]。

      uint8 CipherSuite[2]; /* 暗号スイートセレクター */。
        
ClientHelloには、クライアントがサポートする圧縮アルゴリズムのリストが含まれており、クライアントの好みに応じて並べられます。

      enum { null(0), (255) } CompressionMethod;
        
      構造体{
          ProtocolVersion client_version;
          ランダム
          セッションID session_id;
          CipherSuite cipher_suites<2..2^16-2>;
          CompressionMethod compression_methods<1..2^8-1>;
          select (extensions_present) {。
              case false とする。
                  struct {}を使用します。
              の場合は真。
                  拡張子extension<0..2^16-1>。
          };
      } ClientHello;
        
TLSでは、extensionsブロックのcompression_methodsフィールドに続く拡張が可能である。拡張機能の有無は、ClientHello の末尾の compression_methods に続くバイトがあるかどうかで判断することができる。このオプションデータの検出方法は、可変長フィールドを持つ通常のTLSの方法とは異なるが、拡張機能が定義される以前のTLSとの互換性のために使用されていることに注意。

client_version このセッションでクライアントが通信を希望するTLSプロトコルのバージョン。 これは、クライアントがサポートする最新(最高値)バージョンであるべきである[SHOULD]。今回の仕様では、3.3とする（後方互換性の詳細は付録Eを参照）。

random クライアントが生成するランダム構造。

session_id この接続にクライアントが使用したいセッションのID。 session_idがない場合、またはクライアントが新しいセキュリティパラメータを生成したい場合、このフィールドは空です。

cipher_suites これはクライアントがサポートする暗号化オプションのリストで、クライアントの優先順位が最初になります。session_idフィールドが空でない場合(セッション再開要求を意味する)、この ベクターは少なくともそのセッションのcipher_suiteを含まなければならない [MUST]。 値は付録A.5で定義されている。

compression_methods これは、クライアントがサポートする圧縮方法のリストで、クライアントの優先順位でソートされています。session_idフィールドが空でない場合(セッション再開要求を意味する)、そのセッションの compression_methodを含めなければならない(MUST)。 このベクトルはCompressionMethod.nullを含まなければならず、すべての実装でサポートしなければ ならない(MUST)。したがって、クライアントとサーバーは常に圧縮方法について合意することができる。

extensions クライアントは、extensionsフィールドにデータを送ることで、サーバーに拡張機能を要求してもよい(MAY)。実際の "Extension "フォーマットは7.4.1.4節に定義されている。

クライアントが拡張機能を使用して追加機能を要求し、その機能がサーバーから提供されない場合、クライアントはハンドシェイクを中止してもよい[MAY]。サーバーは、extensionsフィールドがあってもなくてもClientHelloメッセージを 受け入れなければならず[MUST]、(他のすべてのメッセージと同様に)メッセージ のデータ量がこれらの形式のいずれかに正確に一致するかどうかをチェックしなけ ればならない[MUST]。

ClientHelloメッセージの送信後、クライアントはServerHelloメッセージを待つ。 サーバからHelloRequest以外のハンドシェイクメッセージが返ってきた場合は、致命的なエラーとして処理される。

7.4.1.3. Hello サーバー
このメッセージはいつ送信されますか？

サーバは、許容できるアルゴリズムのセットを見つけることができたとき、ClientHelloメッセージの応答としてこのメッセージを送信します。そのようなマッチングが見つからない場合、ハンドシェイク失敗の警告を応答する。

このメッセージの構成

      構造体{
          ProtocolVersion server_version。
          ランダムランダム
          セッションID session_id;
          CipherSuite cipher_suite;
          CompressionMethod compression_method;
          select (extensions_present) {。
              case false とする。
                  struct {}を使用します。
              の場合は真。
                  拡張子extension<0..2^16-1>。
          };
      } ServerHello;
        
拡張モジュールの存在は、ServerHelloの末尾のcompression_methodフィールドに続くバイトがあるかどうかで検出することができる。

server_version このフィールドには、クライアントがclient helloで提案したものと、サーバーがサポートする最も高いもののうち、低い方の値が格納されます。このバージョンの仕様では、バージョンは3.3である（後方互換性の詳細については付録Eを参照のこと）。

random この構造体はサーバによって生成され、ClientHello.random とは独立に生成されなければならない(MUST)。

session_id この接続に対応するセッションの ID です。 ClientHello.session_id が空でない場合、サーバーはセッションキャッシュを検索し、一致するものを探します。一致するものが見つかり、指定されたセッション状態を使用して新しい接続を確立する意思がある場合、サーバーはクライアントから供給されたものと同じ値で応答します。この場合、セッションは再開され、終了メッセージに直接進むことが指示される。 それ以外の場合、このフィールドには新しいセッションを示す別の値が入る。 サーバは空の session_id を返して、セッションがキャッシュされず、再開されないことを示すことができる。セッションを再開する場合、最初にネゴシエートされたのと同じ暗号スイートを使用して再開する必要があります。サーバが以前にsession_idを提供していたとしても、セッションを再開する必要はないことに注意してください。クライアントは、どのようなハンドシェイクの間でも、新しい暗号スイートのネゴシエーションを含む完全なネゴシエーションを行う準備をしなければならない(MUST)。

cipher_suite ClientHello.cipher_suitesのリストからサーバーが選択した1つの暗号化スイート。 再開セッションの場合、このフィールドは再開されるセッションの状態からの値です。

compression_method ClientHello.compression_methodsのリストから、サーバーが選択した単一の圧縮アルゴリズム。 再開セッションの場合、このフィールドは再開セッションの状態の値です。

extensions 拡張のリスト。 クライアントから提供された拡張のみが、サーバーのリストに表示され ることに注意すること。

7.4.1.4. Hello 拡張機能
拡張子の形式は

      構造体{
          ExtensionType extension_type;
          opaque extension_data<0..2^16-1>;
      } 拡張。
        
      enum {
          signature_algorithms(13), (65535)
      } ExtensionType;
        
これです。

- "extension_type" は、特定の拡張子の種類を識別する。

- "extension_data "には、特定の拡張タイプに固有の情報が含まれる。

拡張の初期セットは付属文書[TLSEXT]で定義される。 拡張タイプのリストは、セクション12で説明するように、IANAによって維持され る。

拡張タイプは、対応するClientHelloに同じ拡張タイプが出現しない限り、 ServerHelloに出現してはならない[MUST NOT]。クライアントが、関連するClientHelloでリクエストしていない拡張タイプを ServerHelloで受け取った場合、それはunsupported_extensionの致命的な警告でハンドシェイクを中断しなけれ ばならない[MUST]。

しかしながら、将来的には、このフレームワーク内で「サーバー指向」の拡張 が提供されるかもしれない。 そのような拡張(例えば、タイプx)は、クライアント が最初に、拡張タイプをサポートすることを示す空のextension_dataと共にClientHelloで タイプxの拡張を送信することが必要とされる。この場合、クライアントは拡張子の種類を理解する能力を提供し、サーバーはクライアントの申し出に応じることになります。

ClientHelloまたはServerHelloメッセージに異なるタイプの複数の拡張子が存在する場合、拡張子はどのような順番で現れてもよい(MAY)。同じタイプの拡張子が2つ以上あってはならない（MUST NOT）。

最後に、拡張は新規セッションを開始するときとセッション再開を要求するときの 両方に送ることができるということに注意すること。 実際、セッション再開を要求するクライアントは、サーバーがこの要求を 受け入れるかどうかを一般的に知らない。したがって、再開を試みない場合に送るのと同じ拡張 を送るべきである[SHOULD]。

一般に、各拡張タイプの仕様は、フルハンドシェイク時とセッション再開時の両方 に拡張の効果を記述する必要がある。 現在のほとんどのTLS拡張は、セッションが開始されたときにのみ関係する。 古いセッションが再開されたときに、サーバーはこれらの拡張をClient Helloで処理せず、 Server Helloに含めない。ただし、拡張によっては、セッション再開時に異なる動作を指定することもある。

このプロトコルでは、新機能と既存機能の間で微妙な（あるいはそうでない）相互作用が発生することがあり、その結果、全体のセキュリティが大幅に低下することがあります。 新しい拡張機能を設計する際には、以下の点を考慮する必要があります。

- 一般に、前者にはエラー警告を、後者にはサーバ拡張応答のフィールドを使用すべきです。

- 拡張機能は、ハンドシェークメッセージの操作によって特定の機能の使用(または不使用)を強制する攻撃を可能な限り防ぐように設計されるべきである。 この原則は、その機能がセキュリティ問題を引き起こすと考えられるかどうかに関係なく、従わなければならない。

多くの場合、拡張フィールドがFinishedメッセージハッシュの入力に含まれていることで十分であるが、拡張がハンドシェークフェーズで送信されるメッセージの意味を変更する場合は、細心の注意が必要である。設計者や実装者は、ハンドシェイクが認証されるまでは、能動的な攻撃者がメッセージを修正したり、拡張機能を挿入、削除、交換することができるという事実を認識しておく必要があります。

- TLSの設計の主要な側面、たとえば暗号スイートネゴシエーションの設計を 変更するために拡張を使用することは技術的に可能だろう。 これは推奨されない。TLSの新しいバージョンを定義する方がより適切だろう。 特にTLSハンドシェークアルゴリズムはバージョン番号に基づいて バージョンロールバック攻撃に対する特定の保護を持っており、大きな設計変更では バージョンロールバックの可能性を重要視すべきであるからである。

7.4.1.4.1 署名アルゴリズム
クライアントはsignature_algorithms拡張を使用して、電子署名に使用できる 署名/ハッシュアルゴリズムのペアをサーバに示す。 この拡張のextension_dataフィールドはsupported_signature_algorithmsの値を 含んでいる。

      enum {
          none(0), md5(1), sha1(2), sha224(3), sha256(4), sha384(5),
          sha512(6)、(255)
      } HashAlgorithm;
        
      enum { anonymous(0), rsa(1), dsa(2), ecdsa(3), (255) }.
        SignatureAlgorithm。
        
      構造体{
            HashAlgorithm ハッシュ。
            SignatureAlgorithm 署名。
      } SignatureAndHashAlgorithm;
        
      SignatureAndHashAlgorithm（シグネチャーアンドハッシュアルゴリズム
        supported_signature_algorithms<2..2^16-2>です。
        
SignatureAndHashAlgorithmの各値は、クライアントが検証を希望するハッシュとシグネチャのペアを1つずつ列挙しています。値は、優先順位の高い順に示されています。

注：署名アルゴリズムやハッシュアルゴリズムが実装によってすべて受け入れられるとは限らないため（例えば、SHA-1ではDSAだがSHA-256ではダメ）、ここではアルゴリズムを対で記載している。

ハッシュ このフィールドは、使用可能なハッシュアルゴリズムを示す。 値はそれぞれ、ハッシュなしデータ、MD5 [MD5]、SHA-1、SHA-224、SHA-256、SHA-384、 SHA-512 [SHS]のサポートを示す。 none」は将来の拡張性のために提供されており、署名前にハッシュを必要と しない署名アルゴリズムに対応するためのものである。

signature このフィールドは、使用されるかもしれない署名アルゴリズムを示す。 値はそれぞれ、匿名署名、RSASSA-PKCS1-v1_5 [PKCS1]とDSA [DSS]、ECDSA [ECDSA]を示す。 匿名」の値はこの文脈では意味がないがセクション 7.4.3 で使われている。 この拡張には現れてはならない(MUST NOT)。

暗号スイートは許容される署名アルゴリズムを示すが、ハッシュアルゴリズムは示さないので、この拡張のセマンティクスはやや複雑である。7.4.2項と7.4.3項で適切なルールを説明します。

もしクライアントが(このセクションでリストされた)デフォルトのハッ シュと署名のアルゴリズムだけをサポートしているなら、signature_algorithms 拡張を省略しなければならない。 もしクライアントがデフォルトのアルゴリズムをサポートしていな い、あるいは他のハッシュと署名のアルゴリズム(そしてサーバから送られたメッ セージの検証、すなわちサーバの証明書やサーバの鍵交換にそれらを使用 する意思がある)もサポートしているなら、受け付ける意思があるアルゴリズムをリ ストした signature_algorithms 拡張を送らなければならない(MUST)。

クライアントがsignature_algorithmsエクステンションを送信しない場合、サーバは以下を実行しなけれ ばならない。

- negotiated key exchange algorithm が (RSA, DHE_RSA, DH_RSA, RSA_PSK, ECDH_RSA, ECDHE_RSA) のいずれかである場合、クライアントが値 {sha1,rsa} を送ったかのように動作させます。

- ネゴシエーションされた鍵交換アルゴリズムが (DHE_DSS, DH_DSS) のいずれかである場合、クライアントが値 {sha1,dsa} を送ったかのように動作する。

- ネゴシエーションされた鍵交換アルゴリズムが (ECDH_ECDSA, ECDHE_ECDSA) のいずれかである場合、クライアントが値 {sha1,ecdsa} を送ったかのように動作する。

注: これは、明示的なルールがないTLS 1.1からの変更であるが、実際問題として、相手はMD5とSHA-1をサポートしていると仮定することが可能である。

注: この拡張は、1.2より前のバージョンのTLSでは意味がない。 クライアントは、それ以前のバージョンを提供している場合、これを提供して はならない[MUST NOT]。 しかし、クライアントがこれを提供したとしても、 [TLSEXT]で規定されているルールでは、サーバーは理解できない拡張を 無視することが要求されている。

サーバーはこの拡張を送信してはならない[MUST NOT]。 TLSサーバーはこの拡張の受信をサポートしなければならない[MUST]。

セッション再開を行う場合、この拡張はServer Helloには含まれず、Client Helloでは（存在すれば）無視される。

7.4.2. サーバー証明書
このメッセージはいつ送信されますか？

サーバーは、合意された鍵交換方式が認証に証明書を使用するときは常に Certificateメッセージを送信しなければならない[MUST](これにはDH_anon以外のこのド キュメントで定義されているすべての鍵交換方式が含まれる)。 このメッセージは常に ServerHelloメッセージの直後に送られることになる。

このメッセージの意味

このメッセージは、サーバーの証明書チェーンをクライアントに伝える。

証明書は、ネゴシエートされた暗号スイートの鍵交換アルゴリズムおよびネゴシエートされたエクステンションに適したものでなければならない（MUST）。

このメッセージの構成

      opaque ASN.1Cert<1..2^24-1>;
        
      構造体{
          ASN.1Cert certificate_list<0..2^24-1>;
      } 証明書
        
certificate_list これは、証明書のシーケンス（チェーン）である。 送信者の証明書は、リストの最初に来なければならない（MUST）。証明書の検証は、ルート鍵が独立して配布されることを必要とするので、ルート証明機関を指定する自己署名証明書は、いかなる場合でも検証するために、リモートエンドがすでに所有していなければならないという前提で、連鎖から省略してもよい[MAY]。

証明書要求メッセージに対するクライアントの応答には、同じメッセージタイプと構造が使用される。クライアントは、サーバーの認証リクエストに応答して送信する適切な証明書がない場合、 証明書を送信しなくてもよい[MAY]ということに注意すること。

注：PKCS#7 [PKCS7] は、PKCS#6 [PKCS6] 拡張証明書を使用しないため、証明書ベクトルのフォーマットとして使用されない。 また、PKCS#7はSEQUENCEではなくSETを定義しており、リストのパース作業が難しくなっている。

サーバから送信される証明書については、以下のルールが適用される。

- 証明書のタイプは、明示的にネゴシエートされない限り、X.509v3でなければならない(MUST)(例：[TLSPGP]) 。

- エンドエンティティ証明書の公開鍵（および関連する制限事項）は、選択された鍵交換アルゴリズムと互換性がなければならな い。

Key Exchange Alg.証明書の鍵の種類

RSA RSA公開鍵。証明書は、RSA_PSK鍵を暗号化に使用することを許可しなければならない(keyEnciphermentビットは、key usage拡張が存在する場合は設定しなければならない)。注：RSA_PSKは[TLSPSK]で定義されている。

DHE_RSA RSA公開鍵。証明書は、ECDHE_RSA鍵を、サーバー鍵交換メッセージで採用される署名方式とハッシュアルゴリズムで署名するために使用することを許可しなければならない(MUST)（鍵使用拡張がある場合はdigitalSignatureビットを設定しなければならない)。注：ECDHE_RSAは[TLSECC]で定義されています。

DHE_DSS DSA公開鍵。証明書は、サーバー鍵交換メッセージで採用されるハッシュアルゴリズムで署名するために、その鍵を使用することを許可しなければならない（MUST）。

DH_DSS Diffie-Hellman 公開鍵。keyAgreement ビットの DH_RSA は、key usage 拡張がある場合に設定されなければならない(MUST)。

ECDH_ECDSA ECDH対応の公開鍵。公開鍵は[TLSECC]に記述されているように、ECDH_RSAはクライアントがサポートするカーブとポイント形式を使わなければならない(MUST)。

ECDHE_ECDSA ECDSA対応の公開鍵。証明書は、サーバーの鍵交換メッセージで採用されるハッシュ アルゴリズムでの署名にその鍵を使用することを許可しなければならない[MUST]。 公開鍵は[TLSECC]で述べられているように、クライアントがサポートする曲線と点の形式を使用しなけれ ばならない[MUST]。

- server_name" と "trusted_ca_keys" の拡張子 [TLSEXT] は、証明書の選択の指針として使用される。

クライアントが「signature_algorithms」拡張を提供した場合、サーバーが 提供するすべての証明書は、その拡張に現れるハッシュ/署名アルゴリズムのペアで 署名されなければならない[MUST]。 これは、ある署名アルゴリズムの鍵を含む証明書は、別の署名アルゴリズムで 署名してもよい[MAY]ということを意味していることに注意。 これはTLS 1.1 が、同じアルゴリズムでなければならないとしていたのと異なる点であ る。これは、DH_DSS、DH_RSA、ECDH_ECDSA、およびECDH_RSA鍵交換アルゴリズムが、証明書の署名に使用するアルゴリズムを制限しないことも意味することに注意してください。固定DH証明書は、拡張機能に現れるいかなるハッシュ/署名アルゴリズムペアでも署名することができる(MAY)。 DH_DSS、DH_RSA、ECDH_ECDSA、およびECDH_RSAという名称は歴史的なものである。

サーバーが複数の証明書を持つ場合、上記の基準(トランスポート層のエンドポイント、ロー カルの設定や好みなど、他の基準も含む)に基づいて、そのうちの一つを選択する。 サーバーが単一の証明書を持つ場合、それがこれらの基準を満たしていることの検証を試みるべ きである[SHOULD]。

例えば、RSASSA-PSS 署名鍵 (SubjectPublicKeyInfo の id-RSASSA-PSS OID) を持つ証明書は、TLS で対応する署名アルゴリズムが定義されていないため、使用することができな い。

新しい鍵交換方法を指定する暗号スイートがTLSプロトコルに指定されると、証明書のフォーマットと必要な暗号化された鍵情報が暗示される。

7.4.3 サーバ鍵交換メッセージ
このメッセージはいつ送信されますか？

このメッセージは、サーバ証明書メッセージ (匿名ネゴシエーションであれば ServerHello メッセージ) の直後に送られる。

ServerKeyExchangeメッセージは、サーバ証明書メッセージ（送信された場合）に、クライアントがプレマスター秘密を交換するのに十分なデータが含まれていない場合にのみ、サーバから送信されます。これは、以下の鍵交換方式に当てはまります。

DHE_DSS DHE_RSA DH_anon

以下の鍵交換方式では，ServerKeyExchange メッセージを送信することは適法でない．

RSA DH_DSS DH_RSA

TLSECC]で定義されているような他の鍵交換アルゴリズムは、ServerKeyExchange メッセージを送信するかどうか、およびメッセージを送信する場合はその 内容を指定しなければならない[MUST]。

このメッセージの意味

このメッセージは、クライアントが鍵交換を完了するためのDiffie-Hellman公開鍵（結果は事前マスターの秘密）、または他のアルゴリズムの公開鍵など、事前マスターの秘密を通信するための暗号情報を伝えるものである。

このメッセージの構成

      enum { dhe_dss, dhe_rsa, dh_anon, rsa, dh_dss, dh_rsa
            /* ECDHなどの拡張が可能 -- [TLSECC]を参照 */
           } KeyExchangeAlgorithm;
        
      構造体{
          opaque dh_p<1..2^16-1>;
          opaque dh_g<1..2^16-1>;
          opaque dh_Ys<1..2^16-1>;
      } ServerDHParams; /* エフェメラルDHパラメータ */。
        
dh_p Diffie-Hellman 操作に使用される素因数分解。

dh_g Diffie-Hellman 操作に使用されるジェネレーター。

dh_Ys サーバーの Diffie-Hellman 公開値 (g^X mod p)です。

      構造体{
          select (KeyExchangeAlgorithm) {.
              case dh_anon:
                  ServerDHParamsのparamsです。
              case dhe_dss:
              ケース dhe_rsa:
                  ServerDHParamsのparamsです。
                  デジタル署名入り構造体 {
                      opaque client_random[32]。
                      opaque server_random[32]。
                      ServerDHParamsのparamsです。
                  } signed_params;
              ケースrsa。
              case dh_dss:
              ケース dh_rsa:
                  struct {} ;
                 /* rsa, dh_dss, dh_rsa ではメッセージは省略される */
              /* ECDHなどの拡張が可能 -- [TLSECC]を参照 */
          };
      } ServerKeyExchange;
        
params サーバーの鍵交換パラメータ。

signed_params 非匿名の鍵交換の場合、サーバーの鍵交換パラメータに対する署名。

クライアントが「signature_algorithms」拡張を提供している場合、 署名アルゴリズムとハッシュアルゴリズムはその拡張にリストされたペア でなければならない(MUST)。 ここで矛盾が生じる可能性があることに注意。 例えば、クライアントがDHE_DSS鍵交換を提供しても、 「signature_algorithms」拡張からDSAペアが省かれている場合がある。正しくネゴシエートするために、サーバーは暗号スイートの候補を選択する 前に、「signature_algorithms」拡張と照合しなければならない(MUST)。 これはやや非効率だが、元の暗号スイート設計への変更を最小限にするために 設計された妥協点である。

さらに、ハッシュと署名のアルゴリズムは、サーバーのエンドエンティティ証明書のキーと互換性がなければならない(MUST)。RSA鍵は、証明書に制約がある場合、許可されたあらゆるハッシュ・アルゴリズムとともに使用することができる（MAY）。

DSA署名は、ハッシュアルゴリズムの安全な表示を含まないため、複数のハッシュを任意の鍵で使用する場合、ハッシュの置換のリスクがある。現在、DSA[DSS]はSHA-1との組み合わせでのみ使用可能です。今後のDSSの改訂[DSS-3]では、DSAで他のダイジェストアルゴリズムを使用できるようにするとともに、各鍵サイズにどのダイジェストアルゴリズムを使用すべきかというガイダンスを示す予定である。さらに、[PKIX]の将来のリビジョンでは、どのダイジェストアルゴリズムがDSAとともに使用されるかを証明書が示すためのメカニズムが規定されるかもしれない。

新しい鍵交換アルゴリズムを含む追加の暗号スイートがTLS用に定義されると、鍵交換アルゴリズムに関連する証明書タイプが、クライアントがプレマスター秘密を交換するのに十分な情報を提供しない場合にのみ、サーバ鍵交換メッセージが送信されます。

7.4.4. 証明書要求
このメッセージはいつ送信されますか？

非匿名サーバーは、選択された暗号スイートに適切であれば、オプションとしてクライアントに証明書を要求することができる。このメッセージは、ServerKeyExchangeメッセージの直後に送信される(送信された場合。それ以外の場合は、このメッセージはサーバのCertificateメッセージの後に続く)。

このメッセージの構成

      enum {
          RSA_SIGN(1), DSS_SIGN(2), RSA_FIXED_DH(3), DSS_FIXED_DH(4),
          rsa_ephemeral_dh_RESERVED(5)、dss_ephemeral_dh_RESERVED(6)のようになります。
          fortezza_dms_RESERVED(20)、(255)
      } ClientCertificateType;
        
      opaque DistinguishedName<1..2^16-1>;
        
      構造体{
          ClientCertificateType certificate_types<1..2^8-1>;
          SignatureAndHashAlgorithm（シグネチャーアンドハッシュアルゴリズム
            supported_signature_algorithms<2^16-1>です。
          DistinguishedName certificate_authorities<0..2^16-1>;
      } CertificateRequest;
        
certificate_types クライアントが提供する可能性のある証明書タイプ のリスト。

rsa_sign RSA 鍵を含む証明書 dss_sign DSA 鍵を含む証明書 rsa_fixed_dh 静的な DH 鍵を含む証明書 dss_fixed_dh 静的な DH 鍵を含む証明書

supported_signature_algorithms サーバーが検証可能なハッシュ/署名アルゴリズムのペアを、優先順位の降順に並べたリストです。

certificate_authorities 受け入れ可能な certificate_authorities の識別名 [X501] のリストで、DER エンコー ド形式で表現される。これらの識別名は、ルート認証局またはサボーディネート認証局の希望する識別名を指定することができる。従って、このメッセージは、既知のルートおよび希望する認証空間を記述するために使用することができる。certificate_authoritiesのリストが空の場合、外部からの取り決めがない限り、クライアントは適切なClientCertificateTypeの任意の証明書を送信してもよい(MAY)。

certificate_types と supported_signature_algorithms フィールドの相互作用はやや複雑です。 certificate_types は SSLv3 から TLS に存在していましたが、やや仕様が不明でした。 その機能の多くは supported_signature_algorithms に取って代わられています。以下のルールが適用されます。

- クライアントから提供される証明書は、supported_signature_algorithmsにあるハッシュ/署名アルゴリズムのペアを使用して署名されなければならない（MUST）。

- クライアントが提供するエンドエンティティ証明書は、certificate_typesと互換性のある鍵を含まなければならない（MUST）。鍵が署名鍵の場合、supported_signature_algorithmsにある何らかのハッシュ/署名アルゴリズムのペアで使用可能でなければならない（MUST）。

- 歴史的な理由により、一部のクライアント証明書のタイプ名には、証明書に署名するために使用されるアルゴリズムが含まれています。たとえば、以前のバージョンのTLSでは、rsa_fixed_dhはRSAで署名され、静的なDHキーを含む証明書を意味した。TLS 1.2 では、この機能は supported_signature_algorithms によって廃止され、証明書の種類によって署名に使用するアルゴリズムを制限することはなくなりました。例えば、サーバーが dss_fixed_dh 証明書タイプと {{sha1, dsa}, {sha1, rsa}} 署名タイプを送った場合、クライアントは RSA-SHA1 で署名した静的 DH 鍵を含む証明書で返答してもかまいません(MAY)。

新しいClientCertificateTypeの値は、セクション12に記述されているように、IANAによって割り当てられる。

注：RESERVEDと記載されている値は、SSLv3で使用されていたため、使用できない場合があります。

注：匿名サーバーがクライアント認証を要求することは、致命的なhandshake_failureアラートである。

7.4.5. Hello Done サーバー
このメッセージはいつ送信されますか？

ServerHelloDone メッセージは、ServerHello および関連するメッセージの終了を示すためにサーバから送信される。 このメッセージの送信後、サーバはクライアントからの応答を待つ。

このメッセージの意味

このメッセージは、サーバが鍵交換をサポートするためのメッセージの送信を終了したことを意味し、クライアントは鍵交換のフェーズを進めることができる。

ServerHelloDoneメッセージを受信すると、クライアントは、必要であればサーバーが有効な証明書を提供したことを確認し、サーバーのHelloパラメータが受け入れられることをチェックするべきである[SHOULD]。

このメッセージの構成

      struct { } ServerHelloDone;
        
7.4.6. クライアント証明書
このメッセージはいつ送信されますか？

ServerHelloDoneメッセージの受信後、クライアントが最初に送信できるメッセージです。 このメッセージは、サーバーが証明書を要求した場合のみ送信されます。適切な証明書がない場合、クライアントは証明書を含まない証明書メッセージを送信しなければならない(MUST)。 つまり、certificate_list構造体の長さは0である。クライアントがいかなる証明書も送信しない場合、サーバーはその裁量で、クライアント認証なしでハンドシェイクを継続するか、致命的なhandshake_failure警告で応答してもよい[MAY]。また、証明書チェーンのある側面が受け入れられなかった場合(例えば、既知で信頼できる CAによって署名されていなかった)、サーバーはその裁量でハンドシェイクを継続するか(クライア ントを未認証とみなす)、致命的な警告を送信してもよい[MAY]。

クライアント証明書は、セクション 7.4.2 に定義される証明書構造を用いて送信される。

このメッセージの意味

サーバはCertificateVerifyメッセージの検証時（クライアント認証が署名に基づいている場合）、またはプレマスターシークレットの計算時（非エフェメラルDiffie-Hellmanの場合）にこれを使用します。証明書は、ネゴシエートされた暗号スイートの鍵交換アルゴリズム、およびネゴシエートされたすべてのエクステンションに適したものでなければならない（MUST）。

特に。

- 証明書のタイプは、明示的にネゴシエートされない限り、X.509v3でなければならない(MUST) (例: [TLSPGP])。

- エンドエンティティ証明書の公開鍵（および関連する制限事項）は、CertificateRequest に記載された証明書タイプに適合していなければならない。

Client Cert.タイプ 証明書キータイプ

rsa_sign RSA公開鍵。証明書は、この鍵を、証明書検証メッセージで採用される署名方式とハッ シュアルゴリズムで署名するために使用することを許可しなければならない(MUST)。

dss_sign DSA公開鍵；証明書は、証明書検証メッセージで採用されるハッシュアルゴリズムで署名するために、この鍵を使用することを許可しなければならない。

ecdsa_sign ECDSA対応の公開鍵。証明書は、証明書検証メッセージで採用されるハッシュ アルゴリズムで署名するためにその鍵を使用することを許可しなければならな い[MUST]。

rsa_fixed_dh Diffie-Hellman公開鍵。サーバーの鍵と同じdss_fixed_dhパラメータを使用しなければならない(MUST)。

rsa_fixed_ecdh ECDH対応の公開鍵。サーバーの鍵と同じecdsa_fixed_ecdhカーブを使用しな ければならず(MUST)、サーバーがサポートするポイント形式を使用しなければな らない(MUST)。

- 証明書要求メッセージの certificate_authorities のリストに空白がない場合、証明書チェーン内の証明書の1つは、リストされた CA のいずれかによって発行されるべきである(SHOULD)。

- 証明書は、セクション7.4.4で述べられているように、許容できるハッシュ/ 署名アルゴリズムのペアを使用して署名されなければならない[MUST]。 これは、以前のバージョンのTLSで見られた証明書署名アルゴリズムに対する制約を緩和して いることに注意すること。

なお、サーバ証明書と同様に、現在TLSで使用できないアルゴリズム/アルゴリズムの組み合わせを使用した証明書があります。

7.4.7 クライアント鍵交換メッセージ
このメッセージはいつ送信されますか？

このメッセージは、常にクライアントから送信されます。そうでない場合は、ServerHelloDoneメッセージを受信した後にクライアントが送信する最初のメッセージでなければならない(MUST)。

このメッセージの意味

このメッセージで、RSA暗号化された秘密を直接送信するか、同じプレマスター秘密に合意するためのDiffie-Hellmanパラメータを送信することにより、プレマスター秘密が設定される。

クライアントがエフェメラルDH指数を使用している場合、このメッセージはクライアントの Diffie-Hellman公開値を含む。 クライアントが静的DH指数を含む証明書を送る場合(すなわち、fixed_dhクライアント 認証を行う場合)、このメッセージは送られなければならないが空でなければならない(MUST)。

このメッセージの構成

メッセージの選択は、どの鍵交換方式が選択されたかに依存する。 KeyExchangeAlgorithm の定義については、セクション 7.4.3 を参照のこと。

      構造体{
          select (KeyExchangeAlgorithm) {.
              ケースrsa。
                  EncryptedPreMasterSecretです。
              case dhe_dss:
              ケース dhe_rsa:
              case dh_dss:
              ケース dh_rsa:
              case dh_anon:
                  ClientDiffieHellmanPublicです。
          } exchange_keys;
      } ClientKeyExchange;
        
7.4.7.1. RSA 暗号化されたプレマスターシークレットメッセージ
このメッセージの意味

RSAが鍵合意および認証に使用されている場合、クライアントは48バイトの事前マスター秘密を生成し、サーバーの証明書の公開鍵を使用して暗号化し、その結果を暗号化した事前マスター秘密メッセージで送信する。 この構造はClientKeyExchangeメッセージの変形で、それ自体はメッセージではない(not a message in itself)。

このメッセージの構成

      構造体{
          ProtocolVersion client_version;
          opaque random[46]。
      } PreMasterSecret;
        
client_version クライアントがサポートする最新（最 新）バージョン。これは、バージョンロールバック攻撃を検出するために使用されます。

random 46 安全に生成されたランダムバイト。

      構造体{
          public-key-encrypted PreMasterSecret pre_master_secret;
      } EncryptedPreMasterSecret;
        
pre_master_secret このランダムな値はクライアントが生成し、セクション8.1で規定されているように、 マスターシークレットを生成するために使用される。

注意: PreMasterSecretに含まれるバージョン番号は、クライアントが ClientHello.client_versionで提示したバージョンであり、接続のためにネゴシエートされた バージョンではない。 この機能は、ロールバック攻撃を防ぐために設計されたものである。残念ながら、古い実装の中にはネゴシエーションされたバージョンを代わりに使用するものがあり、そのためバージョン番号をチェックすると、そのような不正なクライアント実装との相互運用に失敗する可能性があります。

クライアントの実装は、常に正しいバージョン番号をPreMasterSecretで送信しなければならない(MUST)。ClientHello.client_versionがTLS 1.1以上の場合、サーバー実装は、以下の注釈に従ってバージョン番号を確認しなければならない(MUST)。バージョン番号がTLS 1.0またはそれ以前の場合、サーバー実装はバージョン番号を チェックするべきである[SHOULD]が、チェックを無効にする設定オプションを持 っていてもよい[MAY]。チェックに失敗した場合、PreMasterSecretは以下に説明するようにランダム化 されるべきである(SHOULD)ことに注意。

注：Bleichenbacher [BLEI]とKlimaら[KPR03]が発見した攻撃は、特定のメッセージを復号したときに、それが適切にPKCS#1フォーマットされているか、有効なPreMasterSecret構造を含んでいるか、正しいバージョン番号を持っているかを明らかにするTLSサーバーへの攻撃に使用可能である。

Klima [KPR03]で説明されているように、これらの脆弱性は、正しくフォーマットされたRSAブロックと区別できない方法で、正しくフォーマットされたメッセージブロックや不一致のバージョン番号を処理することによって回避することができる。つまりは

1.46バイトのランダムな文字列Rを生成する。

2.メッセージを復号し、平文Mを復元する。

3.PKCS#1パディングが正しくない場合、またはメッセージMの長さが正確に48バイトでない場合： pre_master_secret = ClientHello.client_version || R else ClientHello.client_version <= TLS 1.0, かつバージョン番号チェックが明示的に無効の場合： pre_master_secret = M else: pre_master_secret = ClientHello.client_version || M[2.47].

ClientHello.client_versionを使用して明示的にpre_master_secretを構築すると、クライアントがオリジナルのpre_master_secretで間違ったバージョンを送信した場合、無効なmaster_secretが生成されることに注意してください。

別の方法として、バージョン番号の不一致をPKCS-1フォーマットエラーとして扱い、 プレマスターの秘密を完全にランダム化することもできます。

1.48バイトのランダムな文字列Rを生成する。

2.メッセージを復号し、平文Mを復元する。

3.PKCS#1パディングが正しくない、またはメッセージMの長さが正確に48バイトでない場合：premaster_secret = R else ClientHello.client_version <= TLS 1.0, and version number check is explicitly disabled: premaster secret = M else if M[0..1] != ClientHello.client_version: premaster secret = R else: premaster secret = M

この構成に対する実用的な攻撃は知られていないが、Klimaら[KPR03]はいくつかの理論的な攻撃を記述しているので、最初に記述した構成は推奨される(RECOMMENDED)．

いかなる場合でも、TLSサーバーは、RSA暗号化されたpremaster secretメッセージの処理が失敗するか、またはバージョン番号が期待通りでない場合、警告を生成してはならない[MUST NOT]。 その代わりに、ランダムに生成されたpremaster secretでハンドシェイクを継続しなければならない[MUST]。トラブルシューティングのために障害の真因を記録することは有用であるが、攻撃者に情報が漏れないように（タイミング、ログファイルなどを通じて）注意する必要がある。

PKCS1]で定義されているRSAES-OAEP暗号方式は、Bleichenbacher攻撃に対してより安全である。ただし、以前のバージョンのTLSとの互換性を最大にするため、この仕様ではRSAES-PKCS1-v1_5スキームを使用します。上記の推奨事項に従う限り、Bleichenbacher 攻撃の亜種は存在しないことが知られています。

実装上の注意：公開鍵暗号化データは不透明なベクトル <0..2^16-1> として表現される（セクション 4.7 参照）。 したがって、ClientKeyExchange の RSA 暗号化 PreMasterSecret には 2 バイトの長さが先行する。 EncryptedPreMasterSecret は ClientKeyExchange における唯一のデータなのでその長さは明確に決定できるので、RSA ではこれらのバイトは冗長となる。SSLv3 の仕様は公開鍵暗号化データのエンコーディングについて明確ではなかったため、 多くの SSLv3 の実装は長さのバイトを含んでいません -- 彼らは ClientKeyExchange メッセージに直接 RSA 暗号化データをエンコーディングしています。

この仕様では、Length バイトを含む EncryptedPreMasterSecret の正しいエンコーディングを要求します。 結果の PDU は多くの SSLv3 実装と互換性がありません。 SSLv3 からのアップグレード実装者は正しいエンコーディングを生成して 受け取るように実装を修正しなければなりません (訳注:この実装は SSLv3 の実装の一部です)。SSLv3とTLSの両方に対応したい実装者は、その実装の動作をプロトコルのバージョンに依存させるべきです。

実装上の注意：少なくともクライアントとサーバーが同じLAN上にある場合、TLSに対する遠隔タイミングベースの攻撃が可能であることが知られています。したがって、静的なRSA鍵を使用する実装は、[TIMING]で説明されているように、 RSA Blindingまたは他のアンチタイミング技術を使用しなければならない[MUST]。

7.4.7.2. クライアントDiffie-Hellman公開値
このメッセージの意味

この構造体は、クライアントのDiffie-Hellman公開値（Yc）がクライアントの証明書にまだ含まれていない場合、それを伝える。Yc に使用されるエンコーディングは、列挙された PublicValueEncoding によって決定される。この構造は、クライアント鍵交換メッセージの変形であり、それ自体はメッセージではない。

このメッセージの構成

      enum { implicit, explicit } PublicValueEncoding;
        
implicit クライアントが適切なDiffie-Hellman鍵を含む証明書を送った場合(fixed_dh クライアント認証の場合)、Ycはimplicitで、再度送る必要はない。 この場合、クライアント鍵交換メッセージは送られるが、それは空でなければ ならない[MUST]。

明示的にYcを送信する必要があります。

      構造体{
          select (PublicValueEncoding) {.
              case implicit: struct { };
              case explicit: opaque dh_Yc<1..2^16-1>;
          } dh_public;
      } ClientDiffieHellmanPublic;
        
dh_Yc クライアントの Diffie-Hellman 公開値 (Yc)である。

7.4.8. 証明書ベリファイ
このメッセージはいつ送信されますか？

このメッセージは、クライアント証明書の明示的な検証を行うために使用される。このメッセージは、署名機能を持つクライアント証明書（すなわち、固定のDiffie-Hellmanパラメータを含む証明書を除くすべての証明書）の後にのみ送信される。 送信された場合、それはクライアント鍵交換メッセージの直後に送信されなければならない（MUST）。

このメッセージの構成

      構造体{
           デジタル署名入り構造体 {
               opaque handshake_messages[handshake_messages_length];
           }
      } CertificateVerify;
        
ここでhandshake_messagesは、クライアントhelloから始まり、このメッセージを 含まないが、このメッセージまでに送信または受信したすべてのハンドシェイクメッセージ を指し、ハンドシェイクメッセージのタイプと長さのフィールドを含む。 これは、これまでに交換されたすべてのハンドシェイク構造(セクション 7.4 で定義)を連結したものである。この場合、両側でメッセージをバッファリングするか、CertificateVerifyの計算時までにすべての可能なハッシュアルゴリズムの実行ハッシュを計算する必要があることに注意してください。 サーバは、CertificateRequestメッセージでダイジェストアルゴリズムの限定セットを提供することによって、この計算コストを最小にすることができます。

署名に使用されるハッシュと署名のアルゴリズムは、CertificateRequest メッセージの supported_signature_algorithms フィールドに存在するものの一つでなければならない。 さらに、ハッシュと署名のアルゴリズムは、クライアントのエンドエンティティ証明書のキーと互換性がなければならな い。RSA鍵は、証明書に制約がある場合、許可されたあらゆるハッシュ・アルゴリズムとともに使用することができる（MAY）。

DSA署名は、ハッシュアルゴリズムの安全な表示を含まないため、複数のハッシュを任意の鍵で使用する場合、ハッシュの置換のリスクがある。現在、DSA[DSS]はSHA-1との組み合わせでのみ使用可能です。今後のDSSの改訂[DSS-3]では、DSAに他のダイジェストアルゴリズムを使用できるようにするとともに、各鍵サイズにどのダイジェストアルゴリズムを使用すべきかというガイダンスを示す予定である。さらに、[PKIX]の将来のリビジョンでは、どのダイジェストアルゴリズムがDSAとともに使用されるかを証明書が示すためのメカニズムが規定されるかもしれない。

7.4.9. 終了
このメッセージはいつ送信されますか？

Finishedメッセージは、鍵交換と認証処理が成功したことを確認するために、暗号仕様変更メッセージの直後に必ず送信される。他のハンドシェイクメッセージと Finished メッセージの間に、変更暗号仕様メッセージを受信することが不可欠である。

このメッセージの意味

Finishedメッセージは、ネゴシエートされたばかりのアルゴリズム、キー、シークレットで保護された最初のメッセージです。 Finishedメッセージの受信者は、内容が正しいことを検証しなければなりません(MUST)。 サイドがFinishedメッセージを送信し、相手からFinishedメッセージを受信して検証したら、接続を介してアプリケーションデータの送信と受信を開始することができ ます。

このメッセージの構成

      構造体{
          opaque verify_data[verify_data_length];
      } 終了しました。
        
      verify_data
         PRF(master_secret、finished_label、Hash(handshake_messages))
            [0...verify_data_length-1]である。
        
finished_label クライアントが送信した Finished メッセージの場合、"client finished" という文字列。サーバーから送信されたFinishedメッセージの場合、"server finished "という文字列。

Hashは、ハンドシェークメッセージのHashを示す。 セクション5で定義されたPRFの場合、HashはPRFの基礎として使用されるHashでなければならない(MUST)。 異なるPRFを定義する暗号スイートは、Finished計算で使用するHashも定義しなければならない(MUST)。

以前のバージョンのTLSでは、verify_dataは常に12オクテット長であった。現在のTLSのバージョンでは、暗号スイートに依存する。明示的に verify_data_length を指定していない暗号スイートは、 verify_data_length が 12 に等しい。 これには既存のすべての暗号スイートが含まれる。 この表現は以前のバージョンと同じエンコーディングであることに注意。 将来の暗号スイートは他の長さを指定してもよいが、その長さは少なくとも 12 バイトでなければならない。

handshake_messages このハンドシェイクのすべてのメッセージ(HelloRequestメッセージを含まない)から、このメッセージまでのすべてのデータ。 これはハンドシェイク層で見えるデータのみで、レコード層のヘッダーは含まれない。これは、これまでに交換された、セクション7.4で定義されたすべてのHandshake構造体の連結である。

ハンドシェイクの適切な時点で Finished メッセージの前に ChangeCipherSpec メッセージがない場合、致命的なエラーとなる。

この値には、ClientHelloからこのFinishedメッセージまでのすべてのハンドシェイクメッセージが含まれる。 これは、セクション7.4.8のhandshake_messagesと異なるかもしれない。なぜなら、(送信された場合) CertificateVerifyメッセージが含まれるからだ。 また、クライアントから送られるFinishedメッセージと、サーバから送られる Finishedメッセージでは、handshake_messagesは異なるだろう。なぜなら、二番目に送られるメッセージには前のメッセージも含まれる からである。

注：ChangeCipherSpecメッセージ、アラート、その他のレコードタイプはハンドシェイクメッセージではないので、ハッシュの計算に含まれません。 また、HelloRequestメッセージはハンドシェイクハッシュから省かれます。

8.暗号計算
接続保護を開始するために、TLS Record Protocolはアルゴリズム群、マスターシークレット、クライアントとサーバーのランダム値を指定する必要があります。認証、暗号化、MACアルゴリズムはサーバが選択したcipher_suiteによって決定され、ServerHelloメッセージで明らかにされる。 圧縮アルゴリズムはHelloメッセージで交渉され、乱数値はHelloメッセージで交換される。 残るはマスターシークレットの算出だけである。

8.1. マスターシークレットの計算
すべての鍵交換方式において、pre_master_secret を master_secret に変換するために同じアルゴリズムが使用される。pre_master_secret は master_secret が計算された後、メモリから削除される必要がある。

      master_secret = PRF(pre_master_secret, "master secret",
                          ClientHello.random＋ServerHello.random）。
                          [0..47];
        
マスターシークレットは常に正確に48バイトの長さである。プレマスターシークレットの長さは、鍵交換方式によって異なる。

8.1.1.
サーバ認証と鍵交換にRSAを使用する場合、48バイトのpre_master_secretをクライアントが生成し、サーバの公開鍵で暗号化してサーバに送信します。サーバは秘密鍵を用いて pre_master_secret を復号化する。その後、両者は上記のようにpre_master_secretをmaster_secretに変換する。

8.1.2. ディフィー・ヘルマン
従来のDiffie-Hellmanの計算が行われる。ネゴシエーションされた鍵（Z）は pre_master_secret として使用され、上記のように master_secret に変換される。Zの先頭バイトのうち、すべてのゼロビットを含むものは、pre_master_secretとして使用される前に取り除かれる。

注：Diffie-Hellmanパラメータは、サーバーによって指定され、エフェメラルまたはサーバーの証明書に含まれている可能性があります。

9.必須暗号スイート
アプリケーションプロファイルの規格に指定がない場合、TLS準拠のアプリケーション は、暗号スイートTLS_RSA_WITH_AES_128_CBC_SHAを実装しなければならない(MUST) (定義については付録A.5を参照のこと)。

10.アプリケーションデータプロトコル
アプリケーションデータのメッセージはレコード層によって運ばれ、現在の接続状態に応じて断片化、圧縮、暗号化されます。メッセージはレコード層にとって透過的なデータとして扱われる。

11.セキュリティに関する考慮事項
セキュリティの問題は、このメモ全体、特に付録D、E、Fで議論されています。

12.IANAに関する考察
この文書は、もともと[TLS1.1]で作成されたいくつかのレジストリを使用する。 IANAは、この文書を参照するためにこれらをアップデートした。 レジストリおよびそれらの割り当てポリシー([TLS1.1]から変更なし)は以下にリストされ ている。

- TLS ClientCertificateType Identifiers Registry: 0-63(10進数)の範囲の将来の値は、標準化活動 [RFC2434]によって割り当てられる。 64-223(10進数)の範囲の値は、仕様要求 [RFC2434]によって割り当てられる。 224-255(10進数)の値は私用として予約されている [RFC2434]．

- TLS 暗号スイートレジストリ：最初のバイトが 0-191（10 進法）の範囲にある将来の値は、標準化活動 [RFC2434] によって割り当てられます。 最初のバイトが 192-254（10 進法）の範囲は、仕様要求 [RFC2434] によって割り当てられます。 最初のバイトが 255（10 進法）は私用 [RFC2434] で予約されています。

- 本文書は、いくつかの新しいHMAC-SHA256ベースの暗号スイートを定義する。 その値(付録A.5)はTLS暗号スイートレジストリから割り当てられたもの である。

- TLS ContentType Registry: 今後の値は、Standards Action [RFC2434]を介して割り当てられる。

- TLSアラートレジストリ：将来の値はStandards Action [RFC2434]を介して割り当てられる。

- TLS HandshakeTypeレジストリ：将来の値は、Standards Action [RFC2434]を介して割り当てられる。

この文書では、もともと[RFC4366]で作成されたレジストリも使用しています。 IANAは、この文書を参照するためにそれを更新しました。 レジストリとその割り当て方針(RFC4366]から変更なし)を以下に列挙します。

- TLS ExtensionTypeレジストリ: 将来の値はIETF Consensus [RFC2434]を介して割り当てられる。 IANAはこのレジストリを更新し、signature_algorithms拡張とそれに対応する値を 含めた(セクション 7.4.1.4 参照)。

さらに、この文書では、IANAが維持する2つの新しいレジストリを定義している。

- TLS SignatureAlgorithmレジストリ：レジストリには、セクション7.4.1.4.1に記載されている値が初期設定されている。 将来の値として、0〜63 (10進数)の範囲は標準化活動[RFC2434]によって割り当てられる。 64〜223 (10進数)の範囲は要指定[RFC2434]によって割り当てられる。 224〜255 (10進数)は私用に予約されている [RFC2434]．

- TLS HashAlgorithmレジストリ：レジストリには、セクション7.4.1.4.1に記載されている値が最初に登録されています。 0〜63(10進数)の範囲の将来の値は、標準化活動[RFC2434]によって割り当てられます。 64〜223(10進数)の範囲の値は、要求仕様[RFC2434]によって割り当てられます。 224〜255(10進数)は私用として確保されています。[RFC2434]...。

このドキュメントでは、[RFC3749]で定義されているTLS Compression Method Identifiers Registryも使用します。 IANAは、「null」圧縮方式に値0を割り当てています。

付録A プロトコルのデータ構造と定数値
ここでは、プロトコルの型と定数について説明します。

A.1. レコードレイヤ
   構造体{
       uint8 メジャー。
       uint8 マイナー
   } ProtocolVersion;
        
   ProtocolVersion version = { 3, 3 }; /* TLS v1.2*/.
        
   enum {
       change_cipher_spec(20)、alert(21)、handshake(22) です。
       application_data(23), (255)
   } ContentType;
        
   構造体{
       ContentTypeの種類。
       ProtocolVersion バージョン。
       uint16の長さです。
       opaque fragment[TLSPlaintext.length]。
   } TLSPlaintext;
        
   構造体{
       ContentTypeの種類。
       ProtocolVersion バージョン。
       uint16の長さです。
       opaque fragment[TLSCompressed.length]。
   } TLSCompressed;
        
   構造体{
       ContentTypeの種類。
       ProtocolVersion バージョン。
       uint16の長さです。
       select (SecurityParameters.cipher_type) {.
           case stream: GenericStreamCipher;
           case block: GenericBlockCipher;
           case aead: GenericAEADCipher;
       } フラグメント
   } TLSCiphertext;
        
   ストリーム圧縮構造 {
       opaque content[TLSCompressed.length]。
       opaque MAC[SecurityParameters.mac_length]。
   } GenericStreamCipher;
        
   構造体{
       opaque IV[SecurityParameters.record_iv_length];
       ブロック暗号化構造
           opaque content[TLSCompressed.length]。
           opaque MAC[SecurityParameters.mac_length]。
           uint8 padding[GenericBlockCipher.padding_length];
           uint8 padding_length。
       };
   } GenericBlockCipher;
        
   構造体{
      opaque nonce_explicit[SecurityParameters.record_iv_length];
      aead-ciphered struct {
          opaque content[TLSCompressed.length]。
      };
   } GenericAEADCipher;
        
A.2. 暗号仕様の変更 メッセージ
   構造体{
       enum { change_cipher_spec(1), (255) } タイプ。
   } changeCipherSpec;
        
A.3. アラートメッセージ
   enum { warning(1), fatal(2), (255) } AlertLevel;
        
   enum {
       close_notify(0),
       unexpected_message(10),
       bad_record_mac(20),
       decryption_failed_RESERVED(21),
       record_overflow(22),
       decompression_failure(30),
       handshake_failure(40),
       no_certificate_RESERVED(41)です。
       bad_certificate(42),
       unsupported_certificate(43),
       certificate_revoked(44),
       certificate_expired(45)です。
       certificate_unknown(46),
       illegal_parameter(47),
       unknown_ca(48),
       access_denied(49),
       decode_error(50),
       decrypt_error(51),
       export_restriction_RESERVED(60)。
       protocol_version(70), insufficient_security(71),
       internal_error(80),
       user_canceled(90)です。
       no_renegotiation(100)です。
       unsupported_extension(110), /* new */
       (255)
   } AlertDescription;
        
   構造体{
       AlertLevelレベル。
       AlertDescription の説明。
   } アラート
        
A.4. ハンドシェイクプロトコル
   enum {
       hello_request(0), client_hello(1), server_hello(2),
       証明書(11)、server_key_exchange(12)。
       certificate_request(13), server_hello_done(14),
       certificate_verify(15)、client_key_exchange(16)。
       終了(20)
       (255)
   } HandshakeType;
        
   構造体{
       HandshakeType msg_type;
       uint24 長さ。
       select (HandshakeType) {.
           case hello_request: HelloRequest;
           case client_hello: ClientHello;
           case server_hello: ServerHello;
           ケース証明書： 証明書。
           case server_key_exchange: ServerKeyExchange;
           case certificate_request: CertificateRequest;
           case server_hello_done: ServerHelloDone;
           case certificate_verify: CertificateVerify;
           case client_key_exchange: ClientKeyExchange;
           case finished: 終了しました。
       } body;
   } ハンドシェイク
        
A.4.1. こんにちはメッセージ
   struct { } HelloRequest;
        
   構造体{
       uint32 gmt_unix_time です。
       opaque random_bytes[28]。
   } Random;
        
   opaque SessionID<0..32> です。
        
uint8 CipherSuite[2]。

   enum { null(0), (255) } CompressionMethod;
        
   構造体{
       ProtocolVersion client_version;
       ランダム
       セッションID session_id;
       CipherSuite cipher_suites<2..2^16-2>;
       CompressionMethod compression_methods<1..2^8-1>;
       select (extensions_present) {。
           case false とする。
               struct {}を使用します。
           の場合は真。
               拡張子extension<0..2^16-1>。
       };
   } ClientHello;
        
   構造体{
       ProtocolVersion server_version。
       ランダムランダム
       セッションID session_id;
       CipherSuite cipher_suite;
       CompressionMethod compression_method;
       select (extensions_present) {。
           case false とする。
               struct {}を使用します。
           の場合は真。
               拡張子extension<0..2^16-1>。
       };
   } ServerHello;
        
   構造体{
       ExtensionType extension_type;
       opaque extension_data<0..2^16-1>;
   } 拡張。
        
   enum {
       signature_algorithms(13), (65535)
   } ExtensionType;
        
   enum{
       none(0), md5(1), sha1(2), sha224(3), sha256(4), sha384(5),
       sha512(6)、(255)
   } HashAlgorithm;
   enum {
      匿名(0), RSA(1), DSA(2), ECDSA(3), (255)
   } SignatureAlgorithm;
        
   構造体{
         HashAlgorithm ハッシュ。
         SignatureAlgorithm 署名。
   } SignatureAndHashAlgorithm;
        
   SignatureAndHashAlgorithm（シグネチャーアンドハッシュアルゴリズム
    supported_signature_algorithms<2..2^16-1>です。
        
A.4.2. サーバー認証と鍵交換のメッセージ
   opaque ASN.1Cert<2^24-1>;
        
   構造体{
       ASN.1Cert certificate_list<0..2^24-1>;
   } 証明書
        
   enum { dhe_dss, dhe_rsa, dh_anon, rsa,dh_dss, dh_rsa
          /* ECDHなどの拡張が可能 -- [TLSECC]を参照 */
        } KeyExchangeAlgorithm;
        
   構造体{
       opaque dh_p<1..2^16-1>;
       opaque dh_g<1..2^16-1>;
       opaque dh_Ys<1..2^16-1>;
   } ServerDHParams; /* エフェメラルDHパラメータ */ struct { (構造体)
       select (KeyExchangeAlgorithm) {.
           case dh_anon:
               ServerDHParamsのparamsです。
           case dhe_dss:
           ケース dhe_rsa:
               ServerDHParamsのparamsです。
               デジタル署名入り構造体 {
                   opaque client_random[32]。
                   opaque server_random[32]。
                   ServerDHParamsのparamsです。
               } signed_params;
           ケースrsa。
           case dh_dss:
           ケース dh_rsa:
               struct {} ;
              /* rsa, dh_dss, dh_rsa ではメッセージは省略されます */
           /* ECDHなどの拡張が可能 -- [TLSECC]を参照 */
   } ServerKeyExchange;
        
   enum {
       RSA_SIGN(1), DSS_SIGN(2), RSA_FIXED_DH(3), DSS_FIXED_DH(4),
       rsa_ephemeral_dh_RESERVED(5)、dss_ephemeral_dh_RESERVED(6)のようになります。
       fortezza_dms_RESERVED(20),
       (255)
   } ClientCertificateType;
        
   opaque DistinguishedName<1..2^16-1>;
        
   構造体{
       ClientCertificateType certificate_types<1..2^8-1>;
       DistinguishedName certificate_authorities<0..2^16-1>;
   } CertificateRequest;
        
   struct { } ServerHelloDone;
        
A.4.3. クライアント認証と鍵交換メッセージ
   構造体{
       select (KeyExchangeAlgorithm) {.
           ケースrsa。
               EncryptedPreMasterSecretです。
           case dhe_dss:
           ケース dhe_rsa:
           case dh_dss:
           ケース dh_rsa:
           case dh_anon:
               ClientDiffieHellmanPublicです。
       } exchange_keys;
   } ClientKeyExchange;
        
   構造体{
       ProtocolVersion client_version;
       opaque random[46]。
   } PreMasterSecret;
        
   構造体{
       public-key-encrypted PreMasterSecret pre_master_secret;
   } EncryptedPreMasterSecret;
        
   enum { implicit, explicit } PublicValueEncoding;
        
   構造体{
       select (PublicValueEncoding) {.
           case implicit: struct {};
           case explicit: opaque DH_Yc<1..2^16-1>;
       } dh_public;
   } ClientDiffieHellmanPublic;
        
   構造体{
        デジタル署名入り構造体 {
            opaque handshake_messages[handshake_messages_length];
        }
   } CertificateVerify;
        
A.4.4. ハンドシェーク最終化メッセージ
   構造体{
       opaque verify_data[verify_data_length];
   } ファイナライズされました。
        
A.5. 暗号スイート
以下の値は、ClientHello および ServerHello メッセージで使用される暗号スイートコードを定義します。

暗号スイートは、TLS バージョン 1.2 でサポートされる暗号仕様を定義する。

TLS_NULL_WITH_NULL_NULL が指定され、そのチャンネルでの最初のハンドシェイク中の TLS 接続の初期状態であるが、安全でない接続以上の保護を提供しないため、ネゴシエートしてはならない(MUST NOT)。

      CipherSuite TLS_NULL_WITH_NULL_NULL = { 0x00,0x00 };
        
以下の CipherSuite 定義では、鍵交換に使用できる RSA 証明書をサーバーが提供することが必要です。サーバは、証明書要求メッセージにおいて、任意の署名可能な証明書を要求することができる。

      CipherSuite TLS_RSA_WITH_NULL_MD5 = { 0x00,0x01 };
      CipherSuite TLS_RSA_WITH_NULL_SHA = { 0x00,0x02 };
      CipherSuite TLS_RSA_WITH_NULL_SHA256 = { 0x00,0x3B };
      CipherSuite TLS_RSA_WITH_RC4_128_MD5 = { 0x00,0x04 };
      CipherSuite TLS_RSA_WITH_RC4_128_SHA = { 0x00,0x05 };
      CipherSuite TLS_RSA_WITH_3DES_EDE_CBC_SHA = { 0x00,0x0A };
      CipherSuite TLS_RSA_WITH_AES_128_CBC_SHA = { 0x00,0x2F };
      CipherSuite TLS_RSA_WITH_AES_256_CBC_SHA = { 0x00,0x35 };
      CipherSuite TLS_RSA_WITH_AES_128_CBC_SHA256 = { 0x00,0x3C };
      CipherSuite TLS_RSA_WITH_AES_256_CBC_SHA256 = { 0x00,0x3D };
        
サーバー認証型（およびオプションでクライアント認証型）のDiffie-Hellmanには、以下の暗号スイート定義が使用される。DH は、サーバーの証明書が認証局（CA）によって署名された Diffie-Hellman パラメータを含む暗号スイートを示す。 DHE は、Diffie-Hellman パラメータが CA によって署名された署名可能な証明書によって署名されているエフェメラル Diffie-Hellman を示す。サーバーが使用する署名アルゴリズムは、CipherSuite 名の DHE コンポーネントの後に指定します。サーバーは、クライアント認証のために、クライアントから任意の署名可能な証明書を要求することができ、また、Diffie-Hellman証明書を要求することもできる。クライアントが提供するDiffie-Hellman証明書は、サーバーが記述するパラメータ（グループとジェネレータ）を使用する必要があります。

      CipherSuite TLS_DH_DSS_WITH_3DES_EDE_CBC_SHA = { 0x00,0x0D };
      CipherSuite TLS_DH_RSA_WITH_3DES_EDE_CBC_SHA = { 0x00,0x10 };
      CipherSuite TLS_DHE_DSS_WITH_3DES_EDE_CBC_SHA = { 0x00,0x13 };
      CipherSuite TLS_DHE_RSA_WITH_3DES_EDE_CBC_SHA = { 0x00,0x16 };
      CipherSuite TLS_DH_DSS_WITH_AES_128_CBC_SHA = { 0x00,0x30 };
      CipherSuite TLS_DH_RSA_WITH_AES_128_CBC_SHA = { 0x00,0x31 };
      CipherSuite TLS_DHE_DSS_WITH_AES_128_CBC_SHA = { 0x00,0x32 };
      CipherSuite TLS_DHE_RSA_WITH_AES_128_CBC_SHA = { 0x00,0x33 };
      CipherSuite TLS_DH_DSS_WITH_AES_256_CBC_SHA = { 0x00,0x36 };
      CipherSuite TLS_DH_RSA_WITH_AES_256_CBC_SHA = { 0x00,0x37 };
      CipherSuite TLS_DHE_DSS_WITH_AES_256_CBC_SHA = { 0x00,0x38 };
      CipherSuite TLS_DHE_RSA_WITH_AES_256_CBC_SHA = { 0x00,0x39 };
      CipherSuite TLS_DH_DSS_WITH_AES_128_CBC_SHA256 = { 0x00,0x3E };
      CipherSuite TLS_DH_RSA_WITH_AES_128_CBC_SHA256 = { 0x00,0x3F };
      CipherSuite TLS_DHE_DSS_WITH_AES_128_CBC_SHA256 = { 0x00,0x40 } です。
      CipherSuite TLS_DHE_RSA_WITH_AES_128_CBC_SHA256 = { 0x00,0x67 };
      CipherSuite TLS_DH_DSS_WITH_AES_256_CBC_SHA256 = { 0x00,0x68 };
      CipherSuite TLS_DH_RSA_WITH_AES_256_CBC_SHA256 = { 0x00,0x69 };
      CipherSuite TLS_DHE_DSS_WITH_AES_256_CBC_SHA256 = { 0x00,0x6A };
      CipherSuite TLS_DHE_RSA_WITH_AES_256_CBC_SHA256 = { 0x00,0x6B } です。
        
以下の暗号スイートは、どちらの当事者も認証されない完全匿名Diffie-Hellman通信に使用されます。 このモードは、中間者攻撃に対して脆弱であることに注意してください。したがって、このモードの使用は限定的である。アプリケーション層が 匿名鍵交換を許可するように特に要求しない限り、これらの暗号スイートを TLS 1.2の実装で使用してはならない[MUST NOT]。 (匿名鍵交換は、例えば認証の設定が行われていないときや、認証を確保する 他の手段を持つより複雑なセキュリティプロトコルの一部としてTLSを使用するとき、日和見 的暗号化のサポートとして受け入れられることがある)。

      CipherSuite TLS_DH_anon_WITH_RC4_128_MD5 = { 0x00,0x18 };
      CipherSuite TLS_DH_anon_WITH_3DES_EDE_CBC_SHA = { 0x00,0x1B };
      CipherSuite TLS_DH_anon_WITH_AES_128_CBC_SHA = { 0x00,0x34 };
      CipherSuite TLS_DH_anon_WITH_AES_256_CBC_SHA = { 0x00,0x3A };
      CipherSuite TLS_DH_anon_WITH_AES_128_CBC_SHA256 = { 0x00,0x6C };
      CipherSuite TLS_DH_anon_WITH_AES_256_CBC_SHA256 = { 0x00,0x6D };
        
一般に、非匿名鍵交換は匿名鍵交換よりも高い計算・通信コストを伴うが、 アプリケーション層が匿名鍵交換を許可している場合には、非匿名鍵交換を 無効にしないことが相互運用性の観点から望ましい場合があることに注意する。

新しい暗号スイート値は、セクション12に記載されているように、IANAによって割り当てられました。

注：暗号スイート値{ 0x00, 0x1C }と{ 0x00, 0x1D }は、SSL 3におけるFortezzaベースの暗号スイートとの衝突を回避するために予約されています。

A.6. セキュリティパラメータ
これらのセキュリティパラメータは、TLS ハンドシェイクプロトコルによって決定され、接続状態を初期化するために TLS レコードレイヤにパラメータとして提供される。SecurityParametersに含まれる。

   enum { null(0), (255) } CompressionMethod;
        
   enum { server, client } ConnectionEnd;
        
   enum { tls_prf_sha256 } PRFAlgorithm;
        
   enum { null, rc4, 3des, aes } BulkCipherAlgorithm;
        
   enum { stream, block, aead } CipherType;
        
   enum { null, hmac_md5, hmac_sha1, hmac_sha256, hmac_sha384,
     hmac_sha512} MACAlgorithm;
        
   /* で指定されたアルゴリズムに、他の値を追加することができる。
   CompressionMethod、PRFAlgorithm、BulkCipherAlgorithm、および
   MACAlgorithm。*/
        
   構造体{
       ConnectionEndの実体。
       PRFAlgorithm prf_algorithmです。
       BulkCipherAlgorithm bulk_cipher_algorithm;
       CipherType cipher_type;
       uint8 enc_key_length。
       uint8 block_length。
       uint8 fixed_iv_length。
       uint8 record_iv_length。
       MACAlgorithm mac_algorithm;
       uint8 mac_length。
       uint8 mac_key_length。
       CompressionMethod compression_algorithm;
       opaque master_secret[48]。
       opaque client_random[32]。
       opaque server_random[32]。
   } SecurityParameters;
        
A.7 RFC4492の変更点
RFC 4492 [TLSECC]はTLSに楕円曲線暗号スイートを追加する。 このドキュメントは、そのドキュメントで使用されているいくつかの構造を変更する。 このセクションでは、RFC 4492とTLS 1.2の両方の実装者のために必要な変更を詳述する。 RFC 4492を実装しないTLS 1.2の実装者は、このセクションを読む必要はない。

本書では，署名の生成に使用される署名とダイジェストのアルゴリズムを特定するために，digital-signed 要素に "signature_algorithm" フィールドを追加した。この変更は、ECDSAを使用して形成されたデジタル署名にも適用される。したがって、ECDSA署名をSHA-1以外のダイジェストアルゴリズムで使用することができるが、その使用は証明書と[PKIX]の将来の改訂で課せられる制限に適合していることが条件である。

セクション7.4.2および7.4.6で述べたように、証明書への署名に使用されるアルゴリズムの制限は、暗号スイート（サーバーが使用する場合）またはClientCertificateType（クライアントが使用する場合）に結びつかない。 したがって、RFC4492のセクション2および3で規定された証明書への署名に使用するアルゴリズムの制限も緩和される。本文書と同様に、エンドエンティティ証明書の鍵に関する制限事項は残されている。

付録B 用語集
Advanced Encryption Standard (AES) AES [AES]は広く使われている対称型暗号化アルゴリズムである。AESは、128ビット、192ビット、256ビットの鍵、16バイトのブロックサイズを持つブロック暗号である。TLSは現在、128ビットと256ビットのキーサイズのみをサポートしています。

アプリケーションプロトコル アプリケーションプロトコルは、通常トランスポート層（TCP/IPなど）の上に直接重ねるプロトコルである。 例えば、HTTP、TELNET、FTP、SMTPなどが挙げられる。

非対称暗号 公開鍵暗号を参照。

AEAD（Authenticated Encryption with Additional Data） 機密性とメッセージの完全性を同時に提供する対称型暗号化アルゴリズム。

認証 認証とは、あるエンティティが他のエンティティのアイデンティティを決定する能力である。

ブロック暗号 ブロック暗号は、ブロックと呼ばれるビット単位で平文を操作するアルゴリズムである。

バルク暗号 大容量のデータを暗号化するために使用される対称型暗号化アルゴリズム。

CBC（cipher block chaining） CBCとは、ブロック暗号で暗号化された平文の各ブロックが、まず前の暗号文ブロック（または最初のブロックの場合は初期化ベクトル）と排他的論理和をとるモード。 復号の場合は、各ブロックがまず復号され、次に前の暗号文ブロック（またはIV）と排他的論理和をとるモードです。

証明書 X.509 プロトコル（別名 ISO 認証フレームワーク）の一部として、証明書は信頼できる認証局から割り当てられ、当事者の身元または他のいくつかの属性とその公開鍵との間の強力なバインドを提供します。

client サーバーとの TLS 接続を開始するアプリケーション・エンティティ。サーバとクライアントの間の主要な運用上の違いは、サーバは一般的に認証され、クライアントはオプションで認証されるだけであることである。

client write key クライアントが書き込むデータを暗号化するために使用するキー。

クライアント書き込みMACキー クライアントが書き込むデータを認証するための秘密データ。

コネクション コネクションは、適切な種類のサービスを提供するトランスポート（OSI レイヤリングモデルの定義において）である。TLSの場合、このような接続はピアツーピアの関係である。接続は一過性であり、すべての接続は1つのセッションに関連する。

データ暗号化規格 DES [DES] は、現在ではかなり弱いとされていますが、今でも非常に広く使われている対称型暗号化アルゴリズムです。 DESは、56ビットの鍵、8バイトのブロックサイズを持つブロック暗号化方式です。TLS では、鍵生成のために DES は 8 バイトの鍵長（64 ビット）として扱われますが、それでも 56 ビットの保護しか得られません（各鍵バイトの下位ビットは、その鍵バイトに奇数パリティを生成するように設定されると仮定されます）。 DES は、データブロックごとに 3 つの独立した鍵と 3 つの暗号化を使用するモード [3DES] で動作することも可能で、その場合は 168 ビット（TLS 鍵生成方法では 24 バイト）の鍵を使用して 112 ビット相当の安全性を提供します。

Digital Signature Standard (DSS) 米国商務省が2000年1月に発行したNIST FIPS PUB 186-2, "Digital Signature Standard" に定義されている、米国標準技術研究所が承認したデジタル署名アルゴリズムなどの規格 [DSS] 。 重要なアップデート [DSS-3] がドラフトされ2006年3月に発行された。

デジタル署名 デジタル署名は、公開鍵暗号と一方向ハッシュ関数を利用して、認証可能で、偽造や否認が困難なデータの署名を生成する。

ハンドシェイク クライアントとサーバーの間で行われる最初のネゴシエーションで、両者のトランザク ションのパラメータを確立する。

初期化ベクトル（IV） ブロック暗号を CBC モードで使用する場合、初期化ベクトルは暗号化前に最初の平文ブロックと排他的論理和をとる。

メッセージ認証コード（MAC） メッセージ認証コードは、メッセージといくつかの秘密データから計算される一方向ハッシュである。秘密データを知らずに偽造することは困難である。その目的は、メッセージが改ざんされていないかどうかを検出することである。

マスターシークレット 暗号鍵，MAC シークレット，IV の生成に使用されるセキュアな秘密データ。

MD5 MD5[MD5]は、任意の長さのデータストリームを固定サイズ（16バイト）のハッシュに変換するハッシュ関数です。 暗号解読の著しい進歩により、この文書の出版時点では、MD5はもはや「安全な」ハッシュ関数とは見なされなくなっています。

公開鍵暗号方式 二鍵暗号を用いた暗号技術の一種。公開鍵で暗号化されたメッセージは、関連する秘密鍵によってのみ復号化することができます。逆に、秘密鍵で署名されたメッセージは、公開鍵で検証することができる。

一方向性ハッシュ関数 任意の量のデータを固定長のハッシュに変換する一方向性変換。一方向ハッシュ関数の例として、MD5やSHAがある。

RC4 Ron Rivest氏によって考案されたストリーム暗号。互換性のある暗号は[SCH]で説明されています。

RSA 非常に広く使われている公開鍵アルゴリズムで、暗号化または電子署名のいずれにも使用できる。[RSA】。］

server サーバーは、クライアントからの接続要求に応答するアプリケーションエンティティである。 client」も参照。

セッション TLSセッションは、クライアントとサーバーの間の関連付けである。セッションは、複数の接続間で共有可能な暗号化セキュリティパラメータのセットを定義します。 セッションは、接続ごとに新しいセキュリティパラメータをネゴシエーションするという高価な作業を回避するために使用されます。

セッション識別子 セッション識別子は、特定のセッションを識別するためにサーバーが生成する値である。

server write key サーバーから書き込まれるデータを暗号化するために使用されるキー。

server write MAC key サーバーが書き込んだデータを認証するために使用する秘密データ。

SHA Secure Hash Algorithm [SHS]はFIPS PUB 180-2に定義されている。20バイトの出力が得られます。SHAへの言及はすべて（数字の接尾辞がない）実際には修正SHA-1アルゴリズムを使用していることに注意してください。

SHA-256 FIPS PUB 180-2 で定義されている 256bit の Secure Hash Algorithm。32バイトの出力が得られます。

SSL Netscape社のSecure Socket Layerプロトコル[SSL3]。 TLSはSSL Version 3.0をベースにしている。

ストリーム暗号 鍵を暗号的に強力なキーストリームに変換し、平文と排他的論理和をとる暗号化アルゴリズ ム。

symmetric cipher バルク暗号を参照。

Transport Layer Security (TLS) このプロトコル。また、IETF (Internet Engineering Task Force) の Transport Layer Security ワーキンググループ。 本書末尾の「ワーキンググループ情報」（99ページ参照）を参照ください。

付録 C. 暗号スイート定義
サイファースイート キー サイファー マック エクスチェンジ

                        キーIVブロック
暗号タイプ 素材サイズ
------------ ------ -------- ---- -----
NULLストリーム 0 0 N/A
RC4_128 ストリーム 16 0 N/A
3DES_EDE_CBC ブロック 24 8 8
AES_128_CBC ブロック 16 16 16 16
AES_256_CBCブロック 32 16 16
        
MAC Algorithm mac_length mac_key_length
-------- ----------- ---------- --------------
NULL N/A 0 0 0
md5 hmac-md5 16 16
sha hmac-sha1 20 20
sha256 hmac-sha256 32 32
        
Type CBC モードで動作するストリーム暗号とブロック暗号のどちらであるかを示す。

Key Material 書き込みキーの生成に使用される key_block のバイト数。

IV Size 初期化ベクトルを生成するために必要なデータ量。ストリーム暗号化方式では 0、ブロック暗号化方式ではブロックサイズに等しい（これは SecurityParameters.record_iv_length と等しい）。

ブロックサイズ ブロック暗号が1つのチャンクで暗号化するデータ量。CBC モードで動作するブロック暗号は、ブロックサイズの偶数倍しか暗号化できない。

付録D.実施上の注意事項
TLSプロトコルは、多くの一般的なセキュリティ上の欠陥を防ぐことができません。このセクションでは、実施者を支援するためにいくつかの提言を行います。

D.1. 乱数生成とシード
TLSは暗号的に安全な擬似乱数生成器（PRNG）を必要とする。 PRNGの設計とシードには注意が必要である。SHA-1に代表される安全なハッシュ演算に基づくPRNGも許容されるが、乱数生成器の状態サイズ以上の安全性を提供することはできない。

生成される種物質の量を見積もるには、各種バイトに含まれる予測不可能な情報のビット数を加算します。例えば、PC互換機の18.2Hzタイマーから取り出したキーストロークのタイミング値は、カウンタ値の合計が16ビット以上であっても、それぞれ1〜2ビットしか確保されない。128ビットPRNGの場合、約100個のタイマーが必要となる。

[RANDOM]はランダムな値を生成するためのガイダンスを提供します。

D.2. 証明書と認証
実装は、証明書の完全性を検証する責任があり、一般に証明書失効メッセージをサポートすべきである。 証明書は常に、信頼できる認証局（CA）による適切な署名を確認するために検証されるべきである。 信頼できる認証局の選択と追加は、非常に慎重に行われるべきである。ユーザーは、証明書とルートCAに関する情報を見ることができるはずです。

D.3. 暗号スイート
TLSは、全くあるいは最小限のセキュリティを提供するものも含め、さまざまな 鍵サイズとセキュリティレベルをサポートしている。 適切な実装では、おそらく多くの暗号スイートをサポートしない。 たとえば、匿名Diffie-Hellmanは中間者攻撃を防ぐことができないため、強く推奨されな い。また、アプリケーションは最小および最大の鍵サイズを強制する必要がある。例えば、512 ビットの RSA 鍵や署名を含む証明書チェーンは、高セキュリティのアプリケーションには適さない。

D.4. 導入時の落とし穴
実装の経験から、以前のTLS仕様のある部分は理解しにくく、相互運用性と セキュリティの問題の原因となっていた。 これらの部分の多くはこの文書で明確にされたが、この付録には、実装者が 特に注意を払う必要がある、最も重要なものの短いリストが含まれている。

TLSプロトコルの問題。

- 複数のTLSレコードにフラグメント化されたハンドシェイクメッセージを正しく処理しているか（6.2.1項参照）。ClientHelloが複数の小さなフラグメントに分割されるようなコーナーケースを含むか？ 最大フラグメントサイズを超えるハンドシェイクメッセージをフラグメント化するか？特に、証明書と証明書要求のハンドシェイクメッセージは、断片化を必要とするほど大きくなることがあります。

- ServerHello以前のすべてのTLSレコードのTLSレコード層バージョン番号を無視するか(付録E.1参照)。

- ClientHelloで、extensionsフィールドを完全に省略するなど、TLS拡張を正しく処理できていますか？

- 再ネゴシエーションは、クライアント主導とサーバー主導の両方でサポートされていますか？再ネゴシエーションはオプション機能ですが、サポートすることが強く推奨されます。

- サーバーがクライアント証明書を要求したが、適切な証明書がない場合、メッセージ全体を省略するのではなく、空のCertificateメッセージを正しく送信するか（7.4.6項参照）。

暗号の詳細

- RSA暗号化されたPremaster Secretにおいて、バージョン番号を正しく送信し、検証していますか？エラーが発生した場合、ブライヘンバッハ攻撃（7.4.7.1項参照）を避けるためにハンドシェイクを継続するか。

- RSA復号・署名操作に対するタイミング攻撃（7.4.7.1項参照）を防ぐために、どのような対策をしていますか？

- RSA署名を検証する際、NULLと欠損の両方のパラメータを受け入れるか(セクション4.7参照)。RSAパディングがハッシュ値の後に追加データを持たないことを検証していますか？[FI06】。］

- Diffie-Hellman鍵交換を使用する場合、ネゴシエーションされた鍵から先頭の0バイトを正しく削除していますか（8.1.2項参照）。

- あなたのTLSクライアントは、サーバーから送られたDiffie-Hellmanパラメータが許容できるかどうかをチェックしていますか(セクションF.1.1.3参照)。

- CBCモード暗号（セクション6.2.3.2参照）用の予測不可能なIVはどのように生成するのでしょうか？

- 長いCBCモードのパディングを受け入れるか（最大255バイトまで。）

- CBCモードのタイミング攻撃（6.2.3.2項）にはどのように対処するのでしょうか？

- プレマスター秘密鍵(RSA鍵交換用)、Diffie-Hellman秘密値、DSA「k」パラメータ、およびその他のセキュリティ上重要な値の生成に、強力で最も重要な、適切にシードされた乱数生成器(付録D.1参照)を使用しているか。

付録E 後方互換性
E.1. TLS 1.0/1.1およびSSL 3.0との互換性
TLS (1.0, 1.1, 1.2, そして将来のバージョン) と SSL (2.0 と 3.0) には様々なバージョンがあるので、 使用するプロトコルのバージョンをネゴシエートする手段が必要です。 TLS プロトコルはバージョン選択の複雑さで他のプロトコルコンポーネントを悩ませないために、 ビルトインのメカニズムとしてバージョンネゴシエーションを提供します。

TLSバージョン1.0、1.1、1.2とSSL3.0は非常によく似ており、互換性のあるClientHelloメッセージを使用するため、すべてのバージョンをサポートすることは比較的簡単です。同様に、サーバは、ClientHelloフォーマットに互換性があり、クライアントがサーバで利用可能な最も高いプロトコルバージョンをサポートする限り、TLSの将来のバージョンを使用しようとするクライアントを容易に扱うことができる。

このような古いサーバーとネゴシエートすることを望むTLS 1.2クライアントは、 ClientHello.client_version に { 3, 3 } (TLS 1.2) を含む通常のTLS 1.2 ClientHelloを送る。 このバージョンをサポートしないサーバーは、古いバージョン番号を含む ServerHelloで応答するだろう。クライアントがこのバージョンの使用に同意した場合、ネゴシエーションはネゴシエーションされたプロトコルに適した方法で進行します。

サーバーが選択したバージョンがクライアントでサポートされていない(または許容できない)場合、クライアントは「protocol_version」警告メッセージを送信し、接続を閉じなければならない(MUST)。

TLSサーバーが、サーバーがサポートする最も高いバージョンよりも大きな バージョン番号を含むClientHelloを受け取る場合、サーバーがサポートする最も 高いバージョンに従って返答しなければならない[MUST]。

TLSサーバは、サポートされる最高バージョンよりも小さいバージョン番号を含む ClientHelloを受け取ることもできる。 サーバが古いクライアントとネゴシエートしたい場合、サーバは、 ClientHello.client_versionよりも大きくない、サーバがサポートする最高バージョンの 処理を適切に行う。 例えば、サーバがTLS 1.0、1.1、および1.2をサポートしており、 client_version がTLS 1.0 の場合、サーバはTLS 1.0 ServerHelloを処理することになる。サーバーがclient_versionより大きいバージョンのみをサポートする(または使用する意思がある)場合、「protocol_version」警告メッセージを送信して接続を閉じなければならない(MUST)。

クライアントがサーバーに知られている最も高いプロトコルバージョンをすでに知っているときはいつでも(例えば、セッションを再開するとき)、そのネイティブプロトコルで接続を開始すべきである(SHOULD)。

注意: いくつかのサーバの実装は、バージョンネゴシエーションを正しく実装していないことが知られている。 たとえば、クライアントがTLS 1.0よりも新しいバージョンを提供すると、単に接続を閉じるバギーなTLS 1.0サーバもある。また、ClientHelloにTLS拡張が含まれていると、接続を拒否するサーバーがあることが知られています。このようなバギーサーバーとの相互運用性は、このドキュメントの範囲外の複雑なトピックであり、クライアントによる複数回の接続試行が必要になる場合があります。

TLS仕様の以前のバージョンは、ClientHelloを送るとき(すなわち、どのバージョンの プロトコルが採用されるかが判明する前)にレコードレイヤーのバージョン番号 (TLSPlaintext.version)が何を含むべきかについて完全に明確ではなかった。 したがって、この仕様に準拠したTLSサーバーは、任意の値 {03,XX} を ClientHello に対するレコードレイヤーバージョン番号として受け入 れなければならない[MUST]。

古いサーバーとネゴシエートしたいTLSクライアントは、レコードレイヤーの バージョン番号として、任意の値{03,XX}を送ってもよい(MAY)。典型的な値は {03,00} で、クライアントがサポートする最も低いバージョン番号と、 ClientHello.client_version の値です。一つの値ですべての古いサーバとの相互運用性を保証することはできませんが、これはこのドキュメントの範囲外の複雑なトピックです。

E.2. SSL 2.0との互換性
SSL 2.0サーバーをサポートしたいTLS 1.2クライアントは、[SSL2]で定義されている バージョン2.0のCLIENT-HELLOメッセージを送らなければならない(MUST)。 このメッセージは通常の ClientHelloと同じバージョン番号で、後述のCIPHER-SPECS-DATAフィールド でサポートするTLS cipher suitesをエンコーディングしなければならない(MUST)[MUST]。

警告: バージョン2.0のCLIENT-HELLOメッセージを送る機能は、 より新しいClientHelloフォーマットが、より新しいバージョンへの移行と 拡張のネゴシエーションのためのより良い仕組みを提供するので、急ぎ廃止される。 TLS 1.2クライアントはSSL 2.0をサポートするべきではない[SHOULD NOT]。

しかし、SSL2.0をサポートしていないTLSサーバーでも、バージョン2.0の CLIENT-HELLOメッセージを受け入れてもよい(MAY)。 メッセージはTLSサーバーの実装者のために十分詳細に以下に示される。真の定義はまだ[SSL2]と仮定される。

ネゴシエーションの目的のために、2.0 CLIENT-HELLOは、圧縮方法が「null」で拡張がない ClientHelloと同じように解釈される。 このメッセージはTLSレコードとしてラップせず、直接ワイヤ上で送信されなければならない (MUST)ことに注意。 FinishedおよびCertificateVerifyの計算のために、 msg_lengthフィールドはハンドシェークメッセージの部分とは見なされない。

      uint8 V2CipherSpec[3];
      構造体{
          uint16 msg_length。
          uint8 msg_type。
          バージョンバージョン。
          uint16 cipher_spec_length;
          uint16 session_id_length です。
          uint16 challenge_length;
          V2CipherSpec cipher_specs[V2ClientHello.cipher_spec_length];
          opaque session_id[V2ClientHello.session_id_length];
          opaque challenge[V2ClientHello.challenge_length;
      } V2ClientHello;
        
msg_length 最上位ビットは1でなければならず、残りのビットは次のデータの長さをバイト単位で含む。

msg_type このフィールドは、versionフィールドと一緒になって、バージョン2のClientHello メッセージを識別する。 この値は、1でなければならない。

version ClientHello.client_versionに等しい。

cipher_spec_length このフィールドは、フィールド cipher_specs の合計の長さである。ゼロにすることはできず、V2CipherSpec の長さ(3)の倍数でなければならない(MUST)。

session_id_length このフィールドは、TLS 1.2をサポートすると主張するクライアントに対してゼロの値 を持たなければならない[MUST]。

challenge_length クライアントが自身を認証するためにサーバに送るチャレンジの バイト長。 歴史的に、許される値は16から32バイトです。 SSLv2後方互換ハンドシェイクを使う場合、クライアントは32バイトの チャレンジを使うべきです(SHOULD)。

cipher_specs これは、クライアントが使用する意思があり、使用できる全ての CipherSpecsのリストです。 SSL2]で定義されている2.0暗号仕様に加えて、 ClientHello.cipher_suitesで通常送られるTLS暗号スイートを含み、 それぞれの暗号スイートにはゼロバイトが前に付きます。例えば、TLS暗号スイート{0x00,0x0A}は{0x00,0x00,0x0A}として送信されることになる。

session_id このフィールドは空でなければならない(MUST)。

challenge ClientHello.random に対応する。チャレンジの長さが32より短い場合、TLSサーバーはデータの先頭(注：末尾ではない)に0バイトを埋め込んで、32バイトの長さにする。

注：TLSセッションを再開するリクエストは、TLSクライアントハローを使用しな ければならない[MUST]。

E.3. 介入者によるバージョンアップの回避
TLSクライアントがバージョン2.0互換モードにフォールバックするときは、特別なPKCS#1ブロック フォーマットを使用しなければならない[MUST]。これは、TLSサーバーがTLS対応クライアントとのVersion 2.0セッションを拒否するようにするためである。

クライアントがSSL 2.0をネゴシエートし、TLSもサポートする場合、CLIENT-MASTER-KEYの ENCRYPTED-KEY-DATAフィールドをRSA暗号化するためのPKCSパディングの右側(最下位)のランダムな8バイト(パディングの終端ヌルは含まれない)を0x03に設定しなければならない(他のパディングバイトはランダムである)。

TLS 対応のサーバが SSL 2.0 をネゴシエートする際、 ENCRYPTED-KEY-DATA フィールドを復号した後、 これらの 8 つのパディングバイトが 0x03 であることを確認すべきです。 もしそうでなければ、サーバは SECRET-KEY-DATA にランダムな値を生成し、 ハンドシェイクを継続すべきです (キーが一致しないので、最終的には失敗するでしょうが)。クライアントにエラー状況を報告すると、[BLEI]で説明されている攻撃に対してサーバーが脆弱になる可能性があることに注意してください。

付録F セキュリティ分析
TLSプロトコルは、安全でないチャネルで通信するクライアントとサーバーの間に安全な接続を確立するために設計されています。本書では、攻撃者は相当な計算機資源を持ち、プロトコル外の情報源から秘密情報を得ることができないなど、いくつかの従来の仮定を置いている。 攻撃者は、通信路で送信されたメッセージを捕捉、変更、削除、再生、その他の改ざんを行う能力を持つと仮定している。この付録では、TLSがさまざまな攻撃に対抗するためにどのように設計されたかを概説する。

F.1. ハンドシェイクプロトコル
ハンドシェイクプロトコルは、暗号仕様の選択とマスターシークレットの生成を担当し、これらは共に安全なセッションに関連する主要な暗号パラメータを構成する。 ハンドシェイクプロトコルは、オプションとして信頼できる認証局によって署名された証明書を持つパーティを認証することもできる。

F.1.1. 認証と鍵交換
TLSは3つの認証モードをサポートしている。両者の認証、未認証のクライアントによるサーバー認証、そして完全匿名である。 サーバーが認証されている場合、チャンネルは中間者攻撃に対して安全であるが、完全匿名セッションは本質的にそのような攻撃に対して脆弱である。匿名サーバーはクライアントを認証できない。 サーバーが認証される場合、その証明書メッセージは、許容できる認証局につながる有効な証明書チェーンを提供しなければならない。 同様に、認証されたクライアントは、サーバーに許容できる証明書を提供する必要がある。各当事者は、相手方の証明書が有効であり、期限切れまたは失効していないことを確認する責任を負うものとします。

鍵交換プロセスの一般的な目標は、通信相手には知られ、攻撃者には知られない pre_master_secret を作成することである。pre_master_secret は master_secret の生成に使用される (8.1 節参照)。 master_secret は Finished メッセージ、暗号鍵、MAC 鍵の生成に必要である (7.4.9 節および 6.3 節参照)。正しいFinishedメッセージを送信することで、正しいpre_master_secretを知っていることを証明することができる。

F.1.1.1. 匿名鍵交換
鍵交換にDiffie-Hellmanを使用することで、完全匿名セッションを確立することができます。サーバの公開パラメータはサーバ鍵交換メッセージに含まれ、クライアントの公開パラメータはクライアント鍵交換メッセージに含まれる。 秘密値を知らない盗聴者は、Diffie-Hellmanの結果（すなわちpre_master_secret）を見つけることができないはずである。

警告：完全匿名接続は、受動的な盗聴に対する保護のみを提供します。 終了したメッセージが攻撃者によって置き換えられたものではないことを確認するために独立した改ざん防止チャネルを使用しない限り、アクティブな中間者攻撃が懸念される環境では、サーバー認証が必要です。

F.1.1.2. RSA 鍵交換と認証
RSAは、鍵交換とサーバー認証が一体化したもので、公開鍵はサーバーの証明書に含まれています。サーバーの静的なRSA鍵が漏洩すると、その静的な鍵で保護されているすべてのセッションの機密性が失われることに注意すること。TLSでPerfect Forward Secrecyを望む場合は、DHE暗号スイートを使うべきである。 秘密鍵の漏洩による被害は、秘密鍵（と証明書）を頻繁に変更することによって抑えることができる。

サーバの証明書を検証した後、クライアントはサーバの公開鍵でpre_master_secretを暗号化する。pre_master_secretの解読に成功し、正しいFinishedメッセージを生成することで、サーバはサーバ証明書に対応する秘密鍵を知っていることを証明することができる。

鍵交換に RSA を使用する場合、クライアントは証明書検証メッセージ (セクション 7.4.8 参照) を使用して認証される。 クライアントは、以前のすべてのハンドシェークメッセージから得られた値に署名する。 これらのハンドシェークメッセージには、署名とサーバーを結びつけるサーバー証明書と、署名と現在の ハンドシェークプロセスを結びつける ServerHello.random が含まれている。

F.1.1.3. 認証付きDiffie-Hellman鍵交換
Diffie-Hellman鍵交換を使用する場合、サーバーは固定Diffie-Hellmanパラメータを含む証明書を提供するか、サーバー鍵交換メッセージを使用して、DSAまたはRSA証明書で署名された一時的Diffie-Hellmanパラメータセットを送信することができます。一時的なパラメータは、攻撃者が古いパラメータを再生しないように、署名の前にhello.random値でハッシュ化されます。いずれの場合も、クライアントは証明書または署名を検証して、パラメータがサーバーに属することを確認することができます。

クライアントが固定Diffie-Hellmanパラメータを含む証明書を持っている場合、その証明書は鍵交換を完了するために必要な情報を含んでいる。この場合、クライアントとサーバーは通信するたびに同じDiffie-Hellmanの結果(すなわちpre_master_secret)を生成することに注意すること。pre_master_secretが必要以上に長くメモリに残るのを防ぐため、できるだけ早くmaster_secretに変換する。 鍵交換を行うためには、クライアントのDiffie-Hellmanパラメータがサーバーから提供されるものと互換性がなければならない。

クライアントが標準的なDSAまたはRSA証明書を持っているか、未認証の場合、クライアントはクライアント鍵交換メッセージでサーバに一時的なパラメータのセットを送信し、オプションで証明書検証メッセージを使用して自身を認証します。

クライアントまたはサーバーが固定のDHキーペアを含む証明書を持っているか、サーバーがDHキーを再利用しているために、同じDHキーペアを複数のハンドシェイクに使用する場合、小さなサブグループ攻撃を防ぐために注意を払う必要があります。実装は[SUBGROUP]にあるガイドラインに従うべきである(SHOULD)。

スモールサブグループ攻撃は、DHE暗号スイートの1つを使用し、ハンドシェイクごとに新しいDH秘密鍵（X）を生成することで最も簡単に回避することができます。適切な基底（例えば2）を選択すれば、g^X mod pは非常に高速に計算されるので、性能コストは最小になる。さらに、ハンドシェイクごとに新しい鍵を使用することで、Perfect Forward Secrecyを実現します。実装は、DHE暗号スイートを使用する場合、ハンドシェイクごとに新しいXを生成す るべきである(SHOULD)。

TLSではサーバーが任意のDHグループを提供することができるので、クライアントは DHグループがローカルポリシーで定義された適切なサイズであることを検証すべきである。 クライアントはDH公開指数が適切なサイズに見えることも検証すべきである（SHOULD）。[KEYSIZ】では、様々なグループサイズの強さの目安になります。サーバーは、[IKEALG]や[MODP]で定義されているような既知のグループを提供する ことによってクライアントを支援することを選択してもよい。 これらは単純な比較によって検証することが可能であ る。

F.1.2. バージョンロールバック攻撃
TLSはSSLバージョン2.0より大幅に改善されているため、攻撃者はTLS対応のクライアントやサーバーをバージョン2.0にフォールバックさせようとする可能性があります。この攻撃は、TLSに対応した2つのパーティがSSL 2.0のハンドシェイクを使用する場合（およびその場合に限る）に発生する可能性があります。

非ランダムな PKCS #1 ブロックタイプ 2 メッセージパディングを使用する解決策は、エレガントではありませんが、バージョン 3.0 サーバーが攻撃を検知するための合理的で安全な方法を提供します。この解決法は、アプリケーションで指定された待機時間が経過する前に、鍵をブルートフォースし、同じ鍵を含む新しいENCRYPTED-KEY-DATAメッセージ(ただし通常のパディング)を置き換えることができる攻撃者に対して安全ではない。 PKCSパディングの最も小さい8バイトを変更しても、入力ブロックサイズを8バイト増やすことと本質的に同等なので、このプロトコル内で使用する署名済みハッシュとRSA鍵長に対するセキュリティには影響がない。

F.1.3. ハンドシェイクプロトコルに対する攻撃の検出
攻撃者は、ハンドシェイクのやりとりに影響を与え、当事者が通常選択するのとは異なる暗号化アルゴリズムを選択させようとするかもしれません。

この攻撃では、攻撃者が1つ以上のハンドシェークメッセージを積極的に変更する必要があります。 この場合、クライアントとサーバーは、ハンドシェークメッセージのハッシュを異なる値で計算することになります。master_secretがないとFinishメッセージを修復できないため、攻撃がばれてしまう。

F.1.4. セッションの再開
セッションを再開して接続を確立する場合、新しい ClientHello.random と ServerHello.random の値は、セッションの master_secret でハッシュ化されます。master_secret が漏洩しておらず、暗号鍵と MAC 鍵を生成するための安全なハッシュ演算が安全である限り、接続は安全であり、以前の接続から事実上独立していなければならない。 攻撃者は安全なハッシュ演算を破らずに既知の暗号鍵や MAC 秘密を使って master_secret を漏洩させることはできない。

クライアントとサーバーの両方が合意しない限り、セッションを再開することはできません。どちらかの当事者が、セッションが侵害されたかもしれない、あるいは証明書が期限切れまたは失効した可能性があると疑った場合、完全なハンドシェイクを強制する必要があります。master_secret を取得した攻撃者は、対応するセッション ID が破棄されるまで、漏洩した相手になりすますことができるため、セッション ID の寿命の上限を 24 時間とすることを提案する。 比較的安全でない環境で実行する可能性のあるアプリケーションは、セッション ID を安定したストレージに書き込まない方がよいでしょう。

F.2. アプリケーションデータの保護
master_secret は ClientHello.random および ServerHello.random とハッシュ化され、各接続に固有のデータ暗号化キーと MAC シークレットが生成されます。

送信データは送信前にMACで保護され、メッセージのリプレイ攻撃や改ざん攻撃を防ぐため、MACはMACキー、シーケンス番号、メッセージ長、メッセージ内容、および2つの固定文字列から計算される。メッセージタイプフィールドは、あるTLSレコードレイヤークライアントに向けられたメッセージが別のものにリダイレクトされないことを保証するために必要である。シーケンス番号は64ビットであるため、オーバーフローすることはない。独立したMACキーを使用しているため、一方の当事者からのメッセージをもう一方の当事者の出力に挿入することはできない。同様に、サーバーの書き込みキーとクライアントの書き込みキーは独立しているので、ストリーム暗号キーは1度しか使用しない。

もし、攻撃者が暗号鍵を解読した場合、その暗号鍵で暗号化されたすべてのメッセージを読むことができます。同様に、MAC鍵の漏洩はメッセージ変更攻撃を可能にする。 MACも暗号化されているので、メッセージ変更攻撃には一般的にMACだけでなく暗号化アルゴリズムも破る必要がある。

注：MACキーは暗号化キーよりも大きい場合があるため、暗号化キーが破られた場合でもメッセージの耐タンパ性を維持することができる。

F.3. 明示的IV
[CBCATT]は、レコードのIVを知ることに依存する、TLSに対する選択平文攻撃を記述している。 TLSの以前のバージョン[TLS1.0]は、前のレコードのCBC残留物をIVとして使用していたので、この攻撃が可能であった。本バージョンでは、この攻撃から保護するために明示的なIVを使用しています。

F.4. 複合暗号モードの安全性
TLS は、ネゴシエーションされた暗号スイートで定義された対称的な暗号化および認証関数を使用して、送信されるアプリケーションデータを保護します。この目的を達成するためには、暗号化機能と認証機能をデータに適用する順番が重要であることが判明している[ENCAUTH]。

最も堅牢な方法はencrypt-then-authenticateと呼ばれ、まずデータに暗号をかけ、次に暗号文にMACをかける。 この方法は、前者が選択平文攻撃に対して安全で、MACが選択メッセージ攻撃に対して安全であれば、任意の暗号化関数とMAC関数の組で完全性と機密性の目標を確実に達成することができる。TLSでは、authenticate-then-encryptと呼ばれる別の方法を用いており、まず平文に対してMACを計算し、平文とMACの連結を暗号化する。 この方法は、暗号化関数とMAC関数の特定の組み合わせに対しては安全であると証明されているが、一般的に安全であるとは保証されない。

特に、完全に安全な暗号化関数（情報理論的な意味でも安全）が存在し、その暗号化関数と任意の安全なMAC関数を組み合わせても、アクティブ攻撃に対して機密性の目標を提供できないことが示されている。したがって、TLSに採用された新しい暗号スイートと操作モードは、authenticate-then-encrypt方式で分析し、それらが規定の完全性と機密性の目標を達成していることを確認する必要があります。

現在、authenticate-then-encrypt方式の安全性はいくつかの重要なケースで証明されている。 ひとつはストリーム暗号の場合で、メッセージ長とMACタグ長の計算不可能なパッドを疑似ランダム生成器で生成し、このパッドと平文とMACタグの連結を排他的論理和にするものである。もうひとつは、安全なブロック暗号を使ったCBCモードの場合です。この場合、平文とMACの連結にCBC暗号を1回適用し、平文とMACの新しいペアごとに新しい、独立した、予測不可能なIVを使用すれば、安全性を示すことができる。1.1より前のバージョンのTLSでは、CBCモードは適切に使用されていた。 ただし、直前の暗号文の最後のブロックという形で予測可能なIVを使用していた。 このため、TLSは選択平文攻撃に対してオープンになっていた。このバージョンのプロトコルは、それらの攻撃に対して免疫があります。安全性が証明された暗号化モードの正確な詳細については、[ENCAUTH]を参照してください。

F.5. サービス妨害（Denial of Service
TLSは、多くのDoS攻撃（Denial-of-Service: サービス妨害）の影響を受けやすい。しかし、TLSは一般的にTCP上で使用されるため、TCPスタックが適切なTCP SYNランダム化[SEQNUM]を使用していれば、攻撃者は自分の接続元を隠すことが困難である。

TLSはTCP上で動作するため、個々の接続に対する多くのDoS攻撃も受ける。 特に、攻撃者はRSTを偽造して接続を終了させたり、TLSレコードの一部を偽造して接続を停止させたりすることが可能である。これらの攻撃は、一般にTCPを使用するプロトコルでは防御できない。 このクラスの攻撃を懸念する実装者またはユーザーは、IPsecのAH[AH]またはESP[ESP]を使用するべきである。

F.6. ファイナルノート
TLSが安全な接続を提供できるためには、クライアントとサーバーのシステム、鍵、アプリケーションの両方が安全である必要があります。また、セキュリティエラーが発生しない実装であることが必要です。

システムは最も弱い鍵交換と認証アルゴリズムがサポートされている限り強く、信頼できる暗号機能のみを使用すべきである。 短い公開鍵や匿名サーバーは十分に注意して使用すべきである。 どの証明書と認証局が受け入れられるかを決めるとき、実装とユーザーは注意しなければならない。不正な認証局は甚大な損害を与える可能性があるのだ。

参考文献

[AES】米国標準技術研究所「Advanced Encryption Standard（AES）仕様」FIPS197。2001年11月26日

[3DES] National Institute of Standards and Technology, "Recommendation for Triple Data Encryption Algorithm (TDEA) Block Cipher", NIST Special Publication 800-67, May 2004.

[DSS] NIST FIPS PUB 186-2, "Digital Signature Standard", National Institute of Standards and Technology, U.S. Department of Commerce, 2000.

[HMAC] Krawczyk, H., Bellare, M., and R. Canetti, "HMAC: Keyed-Hashing for Message Authentication", RFC 2104, February 1997.

[MD5] Rivest, R., "The MD5 Message-Digest Algorithm", RFC 1321, April 1992.

[PKCS1] Jonsson, J. and B.Kaliski, "Public-Key Cryptography Standards (PKCS) #1: RSA Cryptography Specifications Version 2.1", RFC 3447, February 2003.

[PKIX] Housley, R., Polk, W., Ford, W., and D. Solo, "Internet X.509 Public Key Infrastructure Certificate and Certificate Revocation List (CRL) Profile", RFC 3280, April 2002.

[SCH] B．シュナイアー「Applied Cryptography: Protocols, Algorithms, and Source Code in C, 2nd ed.", Published by John Wiley & Sons, Inc.1996。

[SHS] NIST FIPS PUB 180-2, "Secure Hash Standard", National Institute of Standards and Technology, U.S. Department of Commerce, August 2002.

[REQ] Bradner, S., "Key words for use in RFC to Indicate Requirement Levels", BCP 14, RFC 2119, March 1997.

[RFC2434] Narten, T. and H. Alvestrand, "Guidelines for Writing an IANA Considerations Section in RFC", BCP 26, RFC 2434, October 1998.

[X680] ITU-T Recommendation X.680 (2002) | ISO/IEC 8824-1:2002, Information technology - Abstract Syntax Notation One (ASN.1): Specification of basic notation.X680 は、ITU-T 勧告 X.680 (2002)の一部である。

[X690] ITU-T Recommendation X.690 (2002) | ISO/IEC 8825-1:2002, Information technology - ASN.1 encoding Rules: Specification of Basic Encoding Rules (BER), Canonical Encoding Rules (CER) and Distinguished Encoding Rules (DER).ITU-T Recommendation X.690 (2002), ASN.1 エンコーディング規則, 基本エンコーディ ング規則。

参考文献

[AEAD] McGrew, D., "An Interface and Algorithms for Authenticated Encryption", RFC 5116, January 2008.

[AH] Kent, S., "IP Authentication Header", RFC 4302, December 2005.

[BLEI] Bleichenbacher D., "Chosen Ciphertext Attacks against Protocols Based on RSA Encryption Standard PKCS #1" in Advances in Cryptology -- CRYPTO'98, LNCS vol. 1462, pages: 1-12, 1998.

[CBCATT] Moeller, B., "Security of CBC Ciphersuites in SSL/TLS: Problems and Countermeasures", http://www.openssl.org/~bodo/tls-cbc.txt.

[CBCTIME] Canvel, B., Hiltgen, A., Vaudenay, S., and M. Vuagnoux, "Password Interception in the SSL/TLS Channel", Advances in Cryptology -- CRYPTO 2003, LNCS vol. 2729, 2003.

   [CCM】「NIST Special Publication 800-38C: The CCM Mode for the NIST
              認証と機密保持」。
              http://csrc.nist.gov/publications/nistpubs/800-38C/
              SP800-38C.pdf
        
[DES】米国標準技術研究所、「データ暗号化規格（DES）」、FIPS PUB 46-3、1999年10月。

[DSS-3] NIST FIPS PUB 186-3 Draft, "Digital Signature Standard", National Institute of Standards and Technology, U.S. Department of Commerce, 2006.

[ECDSA】米国規格協会、「金融サービス業界向け公開鍵暗号：楕円曲線デジタル署名アルゴリズム（ECDSA）」、ANS X9.62-2005、2005年11月。

[ENCAUTH] Krawczyk, H., "The Order of Encryption and Authentication for Protecting Communications (Or: How Secure is SSL?)", Crypto 2001.

[ESP] Kent, S., "IP Encapsulating Security Payload (ESP)", RFC 4303, December 2005.

[FI06] Hal Finney, "Bleichenbacher's RSA signature forgery based on implementation error", ietf-openpgp@imc.org mailing list, 27 August 2006, http://www.imc.org/ietf-openpgp/ mail-archive/msg14307.html.

[GCM] Dworkin, M., NIST Special Publication 800-38D, "Recommendation for Block Cipher Modes of Operation: Galois/Counter Mode (GCM) and GMAC", November 2007.

[IKEALG] Schiller, J., "Cryptographic Algorithms for Use in Internet Key Exchange Version 2 (IKEv2)", RFC 4307, December 2005.

[KEYSIZ] Orman, H. and P. Hoffman, "Determining Strengths For Public Keys Used For Exchanging Symmetric Keys", BCP 86, RFC 3766, April 2004.

[KPR03] Klima, V., Pokorny, O., Rosa, T., "Attacking RSA-based Sessions in SSL/TLS", http://eprint.iacr.org/2003/052/, March 2003.

[MODP] Kivinen, T. and M. Kojo, "More Modular Exponential (MODP) Diffie-Hellman groups for Internet Key Exchange (IKE)"、RFC 3526、2003年5月。

[PKCS6] RSA Laboratories, "PKCS #6: RSA Extended Certificate Syntax Standard", version 1.5, November 1993.

[PKCS7] RSA Laboratories, "PKCS #7: RSA Cryptographic Message Syntax Standard", version 1.5, November 1993.

[RANDOM] Eastlake, D., 3rd, Schiller, J., and S. Crocker, "Randomness Requirements for Security", BCP 106, RFC 4086, June 2005.

[RFC3749] Hollenbeck, S., "Transport Layer Security Protocol Compression Methods", RFC 3749, May 2004.

[RFC4366] Blake-Wilson, S., Nystrom, M., Hopwood, D., Mikkelsen, J., and T. Wright, "Transport Layer Security (TLS) Extensions", RFC 4366, April 2006.

[RSA】 R. Rivest, A. Shamir, and L. M. Adleman, "A Method for Obtaining Digital Signatures and Public-Key Cryptosystems", Communications of ACM, v. 21, n. 2, Feb 1978, pp.120-126.

[SEQNUM] Bellovin, S., "Defending Against Sequence Number Attacks", RFC 1948, May 1996.

[SSL2] Hickman, Kipp, "The SSL Protocol", Netscape Communications Corp, Feb 9, 1995.

[SSL3] A. Freier, P. Karlton, and P. Kocher, "The SSL 3.0 Protocol", Netscape Communications Corp.、Nov 18, 1996.

[SUBGROUP] Zuccherato, R., "Methods for Avoiding "Small-Subgroup" Attacks on Diffie-Hellman Key Agreement Method for S/MIME", RFC 2785, March 2000.

[TCP] Postel, J., "Transmission Control Protocol", STD 7, RFC 793, September 1981.

[TIMING] Boneh, D., Brumley, D., "Remote timing attacks are practical", USENIX Security Symposium 2003.

[TLSAES] Chown, P., "Advanced Encryption Standard (AES) Ciphersuites for Transport Layer Security (TLS)", RFC 3268, June 2002.

[TLSECC】ブレイク・ウィルソン、S、ボリアード、N、グプタ、V、ホーク、C、B．Moeller, "Elliptic Curve Cryptography (ECC) Cipher Suites for Transport Layer Security (TLS)", RFC 4492, May 2006.

[TLSEXT] Eastlake, D., 3rd, "Transport Layer Security (TLS) Extensions: Extension Definitions", Work in Progress, February 2008.

[TLSPGP] Mavrogiannopoulos, N., "Using OpenPGP Keys for Transport Layer Security (TLS) Authentication", RFC 5081, November 2007.

[TLSPSK] Eronen, P., Ed., and H. Tschofenig, Ed., "Pre-Shared Key Ciphersuites for Transport Layer Security (TLS)", RFC 4279, December 2005.

[TLS1.0] Dierks, T. and C. Allen, "The TLS Protocol Version 1.0", RFC 2246, January 1999.

[TLS1.1] Dierks, T. and E. Rescorla, "The Transport Layer Security (TLS) Protocol Version 1.1", RFC 4346, April 2006.

[X501] ITU-T Recommendation X.501: Information Technology - Open Systems Interconnection - The Directory: Models, 1993.

[XDR] Eisler, M., Ed., "XDR: External Data Representation Standard", STD 67, RFC 4506, May 2006.

ワーキンググループ情報

   IETFのTLSワーキンググループのディスカッションリストが
   電子メールアドレス<tls@ietf.org>.グループに関する情報や
   メーリングリストの登録方法は、以下の通りです。
   <https://www1.ietf.org/mailman/listinfo/tls>
        
   リストのアーカイブは、以下の場所で見ることができます。
   <http://www.ietf.org/mail-archive/web/tls/current/index.html>
        
投稿者

Christopher Allen (TLS 1.0 の共同編集者) Alacrity Ventures ChristopherA@AlacrityManagement.com

Martin Abadi カリフォルニア大学サンタクルーズ校 abadi@cs.ucsc.edu

Steven M. Bellovin コロンビア大学 smb@cs.columbia.edu

Simon Blake-Wilson BCI sblakewilson@bcisse.com Ran Canetti IBM canetti@watson.ibm.com

Pete Chown Skygate Technology Ltd pc@skygate.co.uk

Taher Elgamal taher@securify.com Securify

Passports Eronen pasi.eronen@nokia.com Nokia

Anil Gangolli anil@busybuddha.org

キップ・ヒックマン

アルフレッド・ホーネス

David Hopwood Independent Consultant david.hopwood@blueyonder.co.uk

フィル・カールトン（SSLv3の共著者）

Paul Kocher (SSLv3の共著者) Cryptography Research paul@cryptography.com

Hugo Krawczyk IBM hugo@ee.technion.ac.il

Jan Mikkelsen Transactionware janm@transactionware.com

Magnus Nystrom RSA セキュリティ magnus@rsasecurity.com

Robert Relyea Netscape Communications relyea@netscape.com Jim Roskind Netscape Communications jar@netscape.com

マイケル・セイビン

Dan Simon Microsoft, Inc. dansimon@microsoft.com

トム・ワインスタイン

Tim Wright Vodafone timothy.wright@vodafone.com

編集者アドレス

Tim Dierks 独立系電子メール：tim@dierks.org

Eric Rescorla RTFM, Inc. EMail: ekr@rtfm.com

著作権表示

Copyright (C) The IETF Trust (2008).

本書は、BCP78に含まれる権利、ライセンスおよび制限に従うものであり、そこに規定されたものを除き、著者はすべての権利を保持します。

この文書とここに含まれる情報は「現状有姿」で提供され、寄稿者、寄稿者が代表または後援する組織（存在する場合）、インターネット協会、IETFトラスト、インターネット技術タスクフォースはすべての保証を放棄する。本書の情報の使用がいかなる権利も侵害していないこと、または商品性もしくは特定目的への適合性に関する黙示の保証を含むがこれに限定されない、明示または黙示の保証を行うものです。

知的財産権

IETFは、本文書に記述された技術の実装または使用に関して主張される可能性のある 知的財産権または他の権利の有効性または範囲、あるいはそのような権利に基づく ライセンスが利用可能または不可能な範囲に関していかなる見解も持たない。 RFC文書の権利に関する手続きに関する情報は、BCP 78およびBCP 79に記載されてい る。

IETF事務局に対して行われたIPR開示のコピー、および利用可能になるライ センスの保証、またはこの仕様の実装者やユーザーによるそのような所有権の 使用のための一般ライセンスや許可を得ようとした結果は、IETFオンラインIPR リポジトリ( http://www.ietf.org/ipr )から入手することができる。

IETFは、この標準を実装するために必要とされる可能性のある技術をカバーする、著作権、特許または特許出願、あるいはその他の所有権に注意を向けるよう、あらゆる利害関係者に呼びかけます。宛先はIETF（ietf-ipr@ietf.org）でお願いします。