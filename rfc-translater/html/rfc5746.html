<!DOCTYPE html>

<html lang="ja">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>RFC 5746 - Transport Layer Security (TLS) Renegotiation Indication Extension 日本語訳</title>

      <link rel="shortcut icon" type="image/x-icon"
    href="https://tex2e.github.io/rfc-translater/favicon.ico" />

  <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous">

  <link rel="stylesheet" href="master.css">
  <script src="index.js"></script>

  <script>
    var host = window.location.hostname;
    if (host != "localhost") {
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
      ga('create', 'UA-75892425-1', 'auto');
      ga('send', 'pageview');
    }
  </script>

  </head>
  <body>
      <nav class="navbar navbar-expand navbar-light bg-light">
    <a class="navbar-brand" href="index.html">RFC Trans</a>
    <div class="collapse navbar-collapse" id="navbarText">
      <div class="navbar-nav mr-auto">
        <a class="nav-item nav-link" href="privacy-policy.html">Privacy Policy</a>
        <a class="nav-item nav-link" href="contact.html">Contact</a>
        <a class="nav-item nav-link" href="../figs/html/index.html">Figs</a>
      </div>
      <div class="navbar-nav ml-auto">
        <span class="navbar-text"><small>@tex2e</small></span>
      </div>
    </div>
  </nav>

    <span id="rfc_number" class="hidden">5746</span>
    <div style="height: 1ex;"></div>
    <div style="float: right; position: sticky; top: 0;">
      <button type="button" class="btn btn-light btn-sm">
        <a href="https://tools.ietf.org/html/rfc5746">Orig</a>
      </button>
    </div>
    <div class="container">
      <div class="row">
        <div class="col-sm-12 col-md-12">
          <div class="alert alert-info" role="alert">
            <h4 class="alert-heading">RFC 5746 - Transport Layer Security (TLS) Renegotiation Indication Extension 日本語訳</h4>
            <span class="URL"
              >URL :
              <a href="https://tools.ietf.org/html/rfc5746">
                https://tools.ietf.org/html/rfc5746
              </a> </span
            ><br />
            <span class="title_ja">
              タイトル : <strong>RFC 5746 - Transport Layer Security (TLS) Renegotiation Indication Extension</strong></span
            ><br />
            <span class="updated_by">翻訳編集 : 自動生成</span
            ><br />
          </div>
        </div>
      </div>
      <div class="row">
        <div class="col-sm-12 col-md-12">
          <pre class="text text-monospace">
Internet Engineering Task Force (IETF)                       E. Rescorla
Request for Comments: 5746                                    RTFM, Inc.
Updates: 5246, 4366, 4347, 4346, 2246                             M. Ray
Category: Standards Track                                    S. Dispensa
ISSN: 2070-1721                                              PhoneFactor
                                                                N. Oskov
                                                               Microsoft
                                                           February 2010
        </pre
          >
        </div>

      </div>
      <div class="row">
        <div class="col-sm-12 col-md-6">
          <p class="text indent-3">
            Transport Layer Security (TLS) Renegotiation Indication Extension
          </p>
        </div>        
      </div>
      <div class="row">
        <div class="col-sm-12 col-md-6">
          <p class="text indent-0">
            Abstract
          </p>
        </div>        
      </div>
      <div class="row">
        <div class="col-sm-12 col-md-6">
          <p class="text indent-3">
            Secure Socket Layer (SSL) and Transport Layer Security (TLS) renegotiation are vulnerable to an attack in which the attacker forms a TLS connection with the target server, injects content of his choice, and then splices in a new TLS connection from a client. The server treats the client&#39;s initial TLS handshake as a renegotiation and thus believes that the initial data transmitted by the attacker is from the same entity as the subsequent client data. This specification defines a TLS extension to cryptographically tie renegotiations to the TLS connections they are being performed over, thus preventing this attack.
          </p>
        </div>        
      </div>
      <div class="row">
        <div class="col-sm-12 col-md-6">
          <p class="text indent-0">
            Status of This Memo
          </p>
        </div>        
      </div>
      <div class="row">
        <div class="col-sm-12 col-md-6">
          <p class="text indent-3">
            This is an Internet Standards Track document.
          </p>
        </div>        
      </div>
      <div class="row">
        <div class="col-sm-12 col-md-6">
          <p class="text indent-3">
            This document is a product of the Internet Engineering Task Force (IETF). It represents the consensus of the IETF community. It has received public review and has been approved for publication by the Internet Engineering Steering Group (IESG). Further information on Internet Standards is available in Section 2 of RFC 5741.
          </p>
        </div>        
      </div>
      <div class="row">
        <div class="col-sm-12 col-md-6">
          <p class="text indent-3">
            Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at http://www.rfc-editor.org/info/rfc5746.
          </p>
        </div>        
      </div>
      <div class="row">
        <div class="col-sm-12 col-md-6">
          <p class="text indent-0">
            Copyright Notice
          </p>
        </div>        
      </div>
      <div class="row">
        <div class="col-sm-12 col-md-6">
          <p class="text indent-3">
            Copyright (c) 2010 IETF Trust and the persons identified as the document authors. All rights reserved.
          </p>
        </div>        
      </div>
      <div class="row">
        <div class="col-sm-12 col-md-6">
          <p class="text indent-3">
            This document is subject to BCP 78 and the IETF Trust&#39;s Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.
          </p>
        </div>        
      </div>
      <div class="row">
        <div class="col-sm-12 col-md-6">
          <p class="text indent-0">
            Table of Contents
          </p>
        </div>        
      </div>
      <div class="row">
        <div class="col-sm-12 col-md-12">
          <pre class="text text-monospace">
   1. Introduction ....................................................3
   2. Conventions Used in This Document ...............................4
   3. Secure Renegotiation Definition .................................4
      3.1. Additional Connection State ................................4
      3.2. Extension Definition .......................................5
      3.3. Renegotiation Protection Request Signaling Cipher
           Suite Value ................................................6
      3.4. Client Behavior: Initial Handshake .........................6
      3.5. Client Behavior: Secure Renegotiation ......................7
      3.6. Server Behavior: Initial Handshake .........................7
      3.7. Server Behavior: Secure Renegotiation ......................8
   4. Backward Compatibility ..........................................9
      4.1. Client Considerations ......................................9
      4.2. Client Behavior: Legacy (Insecure) Renegotiation ..........10
      4.3. Server Considerations .....................................10
      4.4. Server Behavior: Legacy (Insecure) Renegotiation ..........11
      4.5. SSLv3 .....................................................11
   5. Security Considerations ........................................12
   6. IANA Considerations ............................................13
   7. Acknowledgements ...............................................13
   8. References .....................................................13
      8.1. Normative References ......................................13
      8.2. Informative References ....................................13
        </pre
          >
        </div>

      </div>
      <div class="row">
        <div class="col-sm-12 col-md-6">
          <h5 class="text mt-2">
            1. Introduction
          </h5>
        </div>        
      </div>
      <div class="row">
        <div class="col-sm-12 col-md-6">
          <p class="text indent-3">
            TLS [RFC5246] allows either the client or the server to initiate renegotiation -- a new handshake that establishes new cryptographic parameters. Unfortunately, although the new handshake is carried out using the cryptographic parameters established by the original handshake, there is no cryptographic binding between the two. This creates the opportunity for an attack in which the attacker who can intercept a client&#39;s transport layer connection can inject traffic of his own as a prefix to the client&#39;s interaction with the server. One form of this attack [Ray09] proceeds as shown below:
          </p>
        </div>        
      </div>
      <div class="row">
        <div class="col-sm-12 col-md-12">
          <pre class="text text-monospace">
   Client                        Attacker                        Server
   ------                        -------                         ------
                                     &lt;----------- Handshake ----------&gt;
                                     &lt;======= Initial Traffic ========&gt;
   &lt;--------------------------  Handshake ============================&gt;
   &lt;======================== Client Traffic ==========================&gt;
        </pre
          >
        </div>

      </div>
      <div class="row">
        <div class="col-sm-12 col-md-6">
          <p class="text indent-3">
            To start the attack, the attacker forms a TLS connection to the server (perhaps in response to an initial intercepted connection from the client). He then sends any traffic of his choice to the server. This may involve multiple requests and responses at the application layer, or may simply be a partial application layer request intended to prefix the client&#39;s data. This traffic is shown with == to indicate it is encrypted. He then allows the client&#39;s TLS handshake to proceed with the server. The handshake is in the clear to the attacker but encrypted over the attacker&#39;s TLS connection to the server. Once the handshake has completed, the client communicates with the server over the newly established security parameters with the server. The attacker cannot read this traffic, but the server believes that the initial traffic to and from the attacker is the same as that to and from the client.
          </p>
        </div>        
      </div>
      <div class="row">
        <div class="col-sm-12 col-md-6">
          <p class="text indent-3">
            If certificate-based client authentication is used, the server will see a stream of bytes where the initial bytes are protected but unauthenticated by TLS and subsequent bytes are authenticated by TLS and bound to the client&#39;s certificate. In some protocols (notably HTTPS), no distinction is made between pre- and post-authentication stages and the bytes are handled uniformly, resulting in the server believing that the initial traffic corresponds to the authenticated client identity. Even without certificate-based authentication, a variety of attacks may be possible in which the attacker convinces the server to accept data from it as data from the client. For instance, if HTTPS [RFC2818] is in use with HTTP cookies [RFC2965], the attacker may be able to generate a request of his choice validated by the client&#39;s cookie.
          </p>
        </div>        
      </div>
      <div class="row">
        <div class="col-sm-12 col-md-6">
          <p class="text indent-3">
            Some protocols -- such as IMAP or SMTP -- have more explicit transitions between authenticated and unauthenticated phases and require that the protocol state machine be partly or fully reset at such transitions. If strictly followed, these rules may limit the effect of attacks. Unfortunately, there is no requirement for state machine resets at TLS renegotiation, and thus there is still a potential window of vulnerability, for instance, by prefixing a command that writes to an area visible by the attacker with a command by the client that includes his password, thus making the client&#39;s password visible to the attacker (note that this precise attack does not work with challenge-response authentication schemes, but other attacks may be possible). Similar attacks are available with SMTP, and in fact do not necessarily require the attacker to have an account on the target server.
          </p>
        </div>        
      </div>
      <div class="row">
        <div class="col-sm-12 col-md-6">
          <p class="text indent-3">
            It is important to note that in both cases these attacks are possible because the client sends unsolicited authentication information without requiring any specific data from the server over the TLS connection. Protocols that require a round trip to the server over TLS before the client sends sensitive information are likely to be less vulnerable.
          </p>
        </div>        
      </div>
      <div class="row">
        <div class="col-sm-12 col-md-6">
          <p class="text indent-3">
            These attacks can be prevented by cryptographically binding renegotiation handshakes to the enclosing TLS cryptographic parameters, thus allowing the server to differentiate renegotiation from initial negotiation, as well as preventing renegotiations from being spliced in between connections. An attempt by an attacker to inject himself as described above will result in a mismatch of the cryptographic binding and can thus be detected. The data used in the extension is similar to, but not the same as, the data used in the tls-unique and/or tls-unique-for-telnet channel bindings described in [TLS-CHANNEL-BINDINGS]; however, this extension is not a general-purpose RFC 5056 [RFC5056] channel binding facility.
          </p>
        </div>        
      </div>
      <div class="row">
        <div class="col-sm-12 col-md-6">
          <h5 class="text mt-2">
            2. Conventions Used in This Document
          </h5>
        </div>        
      </div>
      <div class="row">
        <div class="col-sm-12 col-md-6">
          <p class="text indent-3">
            The key words &#34;MUST&#34;, &#34;MUST NOT&#34;, &#34;REQUIRED&#34;, &#34;SHALL&#34;, &#34;SHALL NOT&#34;, &#34;SHOULD&#34;, &#34;SHOULD NOT&#34;, &#34;RECOMMENDED&#34;, &#34;MAY&#34;, and &#34;OPTIONAL&#34; in this document are to be interpreted as described in [RFC2119].
          </p>
        </div>        
      </div>
      <div class="row">
        <div class="col-sm-12 col-md-6">
          <h5 class="text mt-2">
            3. Secure Renegotiation Definition
          </h5>
        </div>        
      </div>
      <div class="row">
        <div class="col-sm-12 col-md-6">
          <h5 class="text mt-2">
            3.1. Additional Connection State
          </h5>
        </div>        
      </div>
      <div class="row">
        <div class="col-sm-12 col-md-6">
          <p class="text indent-3">
            Both client and server need to store three additional values for each TLS connection state (see RFC 5246, Section 6.1). Note that these values are specific to connection (not a TLS session cache entry).
          </p>
        </div>        
      </div>
      <div class="row">
        <div class="col-sm-12 col-md-6">
          <p class="text indent-3">
            o a &#34;secure_renegotiation&#34; flag, indicating whether secure renegotiation is in use for this connection.
          </p>
        </div>        
      </div>
      <div class="row">
        <div class="col-sm-12 col-md-6">
          <p class="text indent-3">
            o &#34;client_verify_data&#34;: the verify_data from the Finished message sent by the client on the immediately previous handshake. For currently defined TLS versions and cipher suites, this will be a 12-byte value; for SSLv3, this will be a 36-byte value.
          </p>
        </div>        
      </div>
      <div class="row">
        <div class="col-sm-12 col-md-6">
          <p class="text indent-3">
            o &#34;server_verify_data&#34;: the verify_data from the Finished message sent by the server on the immediately previous handshake.
          </p>
        </div>        
      </div>
      <div class="row">
        <div class="col-sm-12 col-md-6">
          <h5 class="text mt-2">
            3.2. Extension Definition
          </h5>
        </div>        
      </div>
      <div class="row">
        <div class="col-sm-12 col-md-6">
          <p class="text indent-3">
            This document defines a new TLS extension, &#34;renegotiation_info&#34; (with extension type 0xff01), which contains a cryptographic binding to the enclosing TLS connection (if any) for which the renegotiation is being performed. The &#34;extension data&#34; field of this extension contains a &#34;RenegotiationInfo&#34; structure:
          </p>
        </div>        
      </div>
      <div class="row">
        <div class="col-sm-12 col-md-12">
          <pre class="text text-monospace">
      struct {
          opaque renegotiated_connection&lt;0..255&gt;;
      } RenegotiationInfo;
        </pre
          >
        </div>

      </div>
      <div class="row">
        <div class="col-sm-12 col-md-6">
          <p class="text indent-3">
            The contents of this extension are specified as follows.
          </p>
        </div>        
      </div>
      <div class="row">
        <div class="col-sm-12 col-md-6">
          <p class="text indent-3">
            o If this is the initial handshake for a connection, then the &#34;renegotiated_connection&#34; field is of zero length in both the ClientHello and the ServerHello. Thus, the entire encoding of the extension is ff 01 00 01 00. The first two octets represent the extension type, the third and fourth octets the length of the extension itself, and the final octet the zero length byte for the &#34;renegotiated_connection&#34; field.
          </p>
        </div>        
      </div>
      <div class="row">
        <div class="col-sm-12 col-md-6">
          <p class="text indent-3">
            o For ClientHellos that are renegotiating, this field contains the &#34;client_verify_data&#34; specified in Section 3.1.
          </p>
        </div>        
      </div>
      <div class="row">
        <div class="col-sm-12 col-md-6">
          <p class="text indent-3">
            o For ServerHellos that are renegotiating, this field contains the concatenation of client_verify_data and server_verify_data. For current versions of TLS, this will be a 24-byte value (for SSLv3, it will be a 72-byte value).
          </p>
        </div>        
      </div>
      <div class="row">
        <div class="col-sm-12 col-md-6">
          <p class="text indent-3">
            This extension also can be used with Datagram TLS (DTLS) [RFC4347]. Although, for editorial simplicity, this document refers to TLS, all requirements in this document apply equally to DTLS.
          </p>
        </div>        
      </div>
      <div class="row">
        <div class="col-sm-12 col-md-6">
          <h5 class="text mt-2">
            3.3. Renegotiation Protection Request Signaling Cipher Suite Value
          </h5>
        </div>        
      </div>
      <div class="row">
        <div class="col-sm-12 col-md-6">
          <p class="text indent-3">
            Both the SSLv3 and TLS 1.0/TLS 1.1 specifications require implementations to ignore data following the ClientHello (i.e., extensions) if they do not understand it. However, some SSLv3 and TLS 1.0 implementations incorrectly fail the handshake in such a case. This means that clients that offer the &#34;renegotiation_info&#34; extension may encounter handshake failures. In order to enhance compatibility with such servers, this document defines a second signaling mechanism via a special Signaling Cipher Suite Value (SCSV) &#34;TLS_EMPTY_RENEGOTIATION_INFO_SCSV&#34;, with code point {0x00, 0xFF}. This SCSV is not a true cipher suite (it does not correspond to any valid set of algorithms) and cannot be negotiated. Instead, it has the same semantics as an empty &#34;renegotiation_info&#34; extension, as described in the following sections. Because SSLv3 and TLS implementations reliably ignore unknown cipher suites, the SCSV may be safely sent to any server. The SCSV can also be included in the SSLv2 backward compatible CLIENT-HELLO (see Appendix E.2 of [RFC5246]).
          </p>
        </div>        
      </div>
      <div class="row">
        <div class="col-sm-12 col-md-6">
          <p class="text indent-3">
            Note: a minimal client that does not support renegotiation at all can simply use the SCSV in all initial handshakes. The rules in the following sections will cause any compliant server to abort the handshake when it sees an apparent attempt at renegotiation by such a client.
          </p>
        </div>        
      </div>
      <div class="row">
        <div class="col-sm-12 col-md-6">
          <h5 class="text mt-2">
            3.4. Client Behavior: Initial Handshake
          </h5>
        </div>        
      </div>
      <div class="row">
        <div class="col-sm-12 col-md-6">
          <p class="text indent-3">
            Note that this section and Section 3.5 apply to both full handshakes and session resumption handshakes.
          </p>
        </div>        
      </div>
      <div class="row">
        <div class="col-sm-12 col-md-6">
          <p class="text indent-3">
            o The client MUST include either an empty &#34;renegotiation_info&#34; extension, or the TLS_EMPTY_RENEGOTIATION_INFO_SCSV signaling cipher suite value in the ClientHello. Including both is NOT RECOMMENDED.
          </p>
        </div>        
      </div>
      <div class="row">
        <div class="col-sm-12 col-md-6">
          <p class="text indent-3">
            o When a ServerHello is received, the client MUST check if it includes the &#34;renegotiation_info&#34; extension:
          </p>
        </div>        
      </div>
      <div class="row">
        <div class="col-sm-12 col-md-6">
          <p class="text indent-6">
            * If the extension is not present, the server does not support secure renegotiation; set secure_renegotiation flag to FALSE. In this case, some clients may want to terminate the handshake instead of continuing; see Section 4.1 for discussion.
          </p>
        </div>        
      </div>
      <div class="row">
        <div class="col-sm-12 col-md-6">
          <p class="text indent-6">
            * If the extension is present, set the secure_renegotiation flag to TRUE. The client MUST then verify that the length of the &#34;renegotiated_connection&#34; field is zero, and if it is not, MUST abort the handshake (by sending a fatal handshake_failure alert).
          </p>
        </div>        
      </div>
      <div class="row">
        <div class="col-sm-12 col-md-6">
          <p class="text indent-9">
            Note: later in Section 3, &#34;abort the handshake&#34; is used as shorthand for &#34;send a fatal handshake_failure alert and terminate the connection&#34;.
          </p>
        </div>        
      </div>
      <div class="row">
        <div class="col-sm-12 col-md-6">
          <p class="text indent-3">
            o When the handshake has completed, the client needs to save the client_verify_data and server_verify_data values for future use.
          </p>
        </div>        
      </div>
      <div class="row">
        <div class="col-sm-12 col-md-6">
          <h5 class="text mt-2">
            3.5. Client Behavior: Secure Renegotiation
          </h5>
        </div>        
      </div>
      <div class="row">
        <div class="col-sm-12 col-md-6">
          <p class="text indent-3">
            This text applies if the connection&#39;s &#34;secure_renegotiation&#34; flag is set to TRUE (if it is set to FALSE, see Section 4.2).
          </p>
        </div>        
      </div>
      <div class="row">
        <div class="col-sm-12 col-md-6">
          <p class="text indent-3">
            o The client MUST include the &#34;renegotiation_info&#34; extension in the ClientHello, containing the saved client_verify_data. The SCSV MUST NOT be included.
          </p>
        </div>        
      </div>
      <div class="row">
        <div class="col-sm-12 col-md-6">
          <p class="text indent-3">
            o When a ServerHello is received, the client MUST verify that the &#34;renegotiation_info&#34; extension is present; if it is not, the client MUST abort the handshake.
          </p>
        </div>        
      </div>
      <div class="row">
        <div class="col-sm-12 col-md-6">
          <p class="text indent-3">
            o The client MUST then verify that the first half of the &#34;renegotiated_connection&#34; field is equal to the saved client_verify_data value, and the second half is equal to the saved server_verify_data value. If they are not, the client MUST abort the handshake.
          </p>
        </div>        
      </div>
      <div class="row">
        <div class="col-sm-12 col-md-6">
          <p class="text indent-3">
            o When the handshake has completed, the client needs to save the new client_verify_data and server_verify_data values.
          </p>
        </div>        
      </div>
      <div class="row">
        <div class="col-sm-12 col-md-6">
          <h5 class="text mt-2">
            3.6. Server Behavior: Initial Handshake
          </h5>
        </div>        
      </div>
      <div class="row">
        <div class="col-sm-12 col-md-6">
          <p class="text indent-3">
            Note that this section and Section 3.7 apply to both full handshakes and session-resumption handshakes.
          </p>
        </div>        
      </div>
      <div class="row">
        <div class="col-sm-12 col-md-6">
          <p class="text indent-3">
            o When a ClientHello is received, the server MUST check if it includes the TLS_EMPTY_RENEGOTIATION_INFO_SCSV SCSV. If it does, set the secure_renegotiation flag to TRUE.
          </p>
        </div>        
      </div>
      <div class="row">
        <div class="col-sm-12 col-md-6">
          <p class="text indent-3">
            o The server MUST check if the &#34;renegotiation_info&#34; extension is included in the ClientHello. If the extension is present, set secure_renegotiation flag to TRUE. The server MUST then verify that the length of the &#34;renegotiated_connection&#34; field is zero, and if it is not, MUST abort the handshake.
          </p>
        </div>        
      </div>
      <div class="row">
        <div class="col-sm-12 col-md-6">
          <p class="text indent-3">
            o If neither the TLS_EMPTY_RENEGOTIATION_INFO_SCSV SCSV nor the &#34;renegotiation_info&#34; extension was included, set the secure_renegotiation flag to FALSE. In this case, some servers may want to terminate the handshake instead of continuing; see Section 4.3 for discussion.
          </p>
        </div>        
      </div>
      <div class="row">
        <div class="col-sm-12 col-md-6">
          <p class="text indent-3">
            o If the secure_renegotiation flag is set to TRUE, the server MUST include an empty &#34;renegotiation_info&#34; extension in the ServerHello message.
          </p>
        </div>        
      </div>
      <div class="row">
        <div class="col-sm-12 col-md-6">
          <p class="text indent-3">
            o When the handshake has completed, the server needs to save the client_verify_data and server_verify_data values for future use.
          </p>
        </div>        
      </div>
      <div class="row">
        <div class="col-sm-12 col-md-6">
          <p class="text indent-3">
            TLS servers implementing this specification MUST ignore any unknown extensions offered by the client and they MUST accept version numbers higher than their highest version number and negotiate the highest common version. These two requirements reiterate preexisting requirements in RFC 5246 and are merely stated here in the interest of forward compatibility.
          </p>
        </div>        
      </div>
      <div class="row">
        <div class="col-sm-12 col-md-6">
          <p class="text indent-3">
            Note that sending a &#34;renegotiation_info&#34; extension in response to a ClientHello containing only the SCSV is an explicit exception to the prohibition in RFC 5246, Section 7.4.1.4, on the server sending unsolicited extensions and is only allowed because the client is signaling its willingness to receive the extension via the TLS_EMPTY_RENEGOTIATION_INFO_SCSV SCSV. TLS implementations MUST continue to comply with Section 7.4.1.4 for all other extensions.
          </p>
        </div>        
      </div>
      <div class="row">
        <div class="col-sm-12 col-md-6">
          <h5 class="text mt-2">
            3.7. Server Behavior: Secure Renegotiation
          </h5>
        </div>        
      </div>
      <div class="row">
        <div class="col-sm-12 col-md-6">
          <p class="text indent-3">
            This text applies if the connection&#39;s &#34;secure_renegotiation&#34; flag is set to TRUE (if it is set to FALSE, see Section 4.4).
          </p>
        </div>        
      </div>
      <div class="row">
        <div class="col-sm-12 col-md-6">
          <p class="text indent-3">
            o When a ClientHello is received, the server MUST verify that it does not contain the TLS_EMPTY_RENEGOTIATION_INFO_SCSV SCSV. If the SCSV is present, the server MUST abort the handshake.
          </p>
        </div>        
      </div>
      <div class="row">
        <div class="col-sm-12 col-md-6">
          <p class="text indent-3">
            o The server MUST verify that the &#34;renegotiation_info&#34; extension is present; if it is not, the server MUST abort the handshake.
          </p>
        </div>        
      </div>
      <div class="row">
        <div class="col-sm-12 col-md-6">
          <p class="text indent-3">
            o The server MUST verify that the value of the &#34;renegotiated_connection&#34; field is equal to the saved client_verify_data value; if it is not, the server MUST abort the handshake.
          </p>
        </div>        
      </div>
      <div class="row">
        <div class="col-sm-12 col-md-6">
          <p class="text indent-3">
            o The server MUST include a &#34;renegotiation_info&#34; extension containing the saved client_verify_data and server_verify_data in the ServerHello.
          </p>
        </div>        
      </div>
      <div class="row">
        <div class="col-sm-12 col-md-6">
          <p class="text indent-3">
            o When the handshake has completed, the server needs to save the new client_verify_data and server_verify_data values.
          </p>
        </div>        
      </div>
      <div class="row">
        <div class="col-sm-12 col-md-6">
          <h5 class="text mt-2">
            4. Backward Compatibility
          </h5>
        </div>        
      </div>
      <div class="row">
        <div class="col-sm-12 col-md-6">
          <p class="text indent-3">
            Existing implementations that do not support this extension are widely deployed and, in general, must interoperate with newer implementations that do support it. This section describes considerations for backward compatible interoperation.
          </p>
        </div>        
      </div>
      <div class="row">
        <div class="col-sm-12 col-md-6">
          <h5 class="text mt-2">
            4.1. Client Considerations
          </h5>
        </div>        
      </div>
      <div class="row">
        <div class="col-sm-12 col-md-6">
          <p class="text indent-3">
            If a client offers the &#34;renegotiation_info&#34; extension or the TLS_EMPTY_RENEGOTIATION_INFO_SCSV SCSV and the server does not reply with &#34;renegotiation_info&#34; in the ServerHello, then this indicates that the server does not support secure renegotiation. Because some attacks (see Section 1) look like a single handshake to the client, the client cannot determine whether or not the connection is under attack. Note, however, that merely because the server does not acknowledge the extension does not mean that it is vulnerable; it might choose to reject all renegotiations and simply not signal it. However, it is not possible for the client to determine purely via TLS mechanisms whether or not this is the case.
          </p>
        </div>        
      </div>
      <div class="row">
        <div class="col-sm-12 col-md-6">
          <p class="text indent-3">
            If clients wish to ensure that such attacks are impossible, they need to terminate the connection immediately upon failure to receive the extension without completing the handshake. Such clients MUST generate a fatal &#34;handshake_failure&#34; alert prior to terminating the connection. However, it is expected that many TLS servers that do not support renegotiation (and thus are not vulnerable) will not support this extension either, so in general, clients that implement this behavior will encounter interoperability problems. There is no set of client behaviors that will guarantee security and achieve maximum interoperability during the transition period. Clients need to choose one or the other preference when dealing with potentially un-upgraded servers.
          </p>
        </div>        
      </div>
      <div class="row">
        <div class="col-sm-12 col-md-6">
          <h5 class="text mt-2">
            4.2. Client Behavior: Legacy (Insecure) Renegotiation
          </h5>
        </div>        
      </div>
      <div class="row">
        <div class="col-sm-12 col-md-6">
          <p class="text indent-3">
            This text applies if the connection&#39;s &#34;secure_renegotiation&#34; flag is set to FALSE.
          </p>
        </div>        
      </div>
      <div class="row">
        <div class="col-sm-12 col-md-6">
          <p class="text indent-3">
            It is possible that un-upgraded servers will request that the client renegotiate. It is RECOMMENDED that clients refuse this renegotiation request. Clients that do so MUST respond to such requests with a &#34;no_renegotiation&#34; alert (RFC 5246 requires this alert to be at the &#34;warning&#34; level). It is possible that the apparently un-upgraded server is in fact an attacker who is then allowing the client to renegotiate with a different, legitimate, upgraded server. If clients nevertheless choose to renegotiate, they MUST behave as described below.
          </p>
        </div>        
      </div>
      <div class="row">
        <div class="col-sm-12 col-md-6">
          <p class="text indent-3">
            Clients that choose to renegotiate MUST provide either the TLS_EMPTY_RENEGOTIATION_INFO_SCSV SCSV or &#34;renegotiation_info&#34; in their ClientHello. In a legitimate renegotiation with an un-upgraded server, that server should ignore both of these signals. However, if the server (incorrectly) fails to ignore extensions, sending the &#34;renegotiation_info&#34; extension may cause a handshake failure. Thus, it is permitted, though NOT RECOMMENDED, for the client to simply send the SCSV. This is the only situation in which clients are permitted to not send the &#34;renegotiation_info&#34; extension in a ClientHello that is used for renegotiation.
          </p>
        </div>        
      </div>
      <div class="row">
        <div class="col-sm-12 col-md-6">
          <p class="text indent-3">
            Note that in the case of a downgrade attack, if this is an initial handshake from the server&#39;s perspective, then use of the SCSV from the client precludes detection of this attack by the server (if this is a renegotiation from the server&#39;s perspective, then it will detect the attack). However, the attack will be detected by the client when the server sends an empty &#34;renegotiation_info&#34; extension and the client is expecting one containing the previous verify_data. By contrast, if the client sends the &#34;renegotiation_info&#34; extension, then the server will immediately detect the attack.
          </p>
        </div>        
      </div>
      <div class="row">
        <div class="col-sm-12 col-md-6">
          <p class="text indent-3">
            When the ServerHello is received, the client MUST verify that it does not contain the &#34;renegotiation_info&#34; extension. If it does, the client MUST abort the handshake. (Because the server has already indicated it does not support secure renegotiation, the only way that this can happen is if the server is broken or there is an attack.)
          </p>
        </div>        
      </div>
      <div class="row">
        <div class="col-sm-12 col-md-6">
          <h5 class="text mt-2">
            4.3. Server Considerations
          </h5>
        </div>        
      </div>
      <div class="row">
        <div class="col-sm-12 col-md-6">
          <p class="text indent-3">
            If the client does not offer the &#34;renegotiation_info&#34; extension or the TLS_EMPTY_RENEGOTIATION_INFO_SCSV SCSV, then this indicates that the client does not support secure renegotiation. Although the attack described in Section 1 looks like two handshakes to the
          </p>
        </div>        
      </div>
      <div class="row">
        <div class="col-sm-12 col-md-6">
          <p class="text indent-3">
            server, other attacks may be possible in which the renegotiation is seen only by the client. If servers wish to ensure that such attacks are impossible, they need to terminate the connection immediately upon failure to negotiate the use of secure renegotiation. Servers that do choose to allow connections from unpatched clients can still prevent the attack described in Section 1 by refusing to renegotiate over those connections.
          </p>
        </div>        
      </div>
      <div class="row">
        <div class="col-sm-12 col-md-6">
          <p class="text indent-3">
            In order to enable clients to probe, even servers that do not support renegotiation MUST implement the minimal version of the extension described in this document for initial handshakes, thus signaling that they have been upgraded.
          </p>
        </div>        
      </div>
      <div class="row">
        <div class="col-sm-12 col-md-6">
          <h5 class="text mt-2">
            4.4. Server Behavior: Legacy (Insecure) Renegotiation
          </h5>
        </div>        
      </div>
      <div class="row">
        <div class="col-sm-12 col-md-6">
          <p class="text indent-3">
            This text applies if the connection&#39;s &#34;secure_renegotiation&#34; flag is set to FALSE.
          </p>
        </div>        
      </div>
      <div class="row">
        <div class="col-sm-12 col-md-6">
          <p class="text indent-3">
            It is RECOMMENDED that servers not permit legacy renegotiation. If servers nevertheless do permit it, they MUST follow the requirements in this section.
          </p>
        </div>        
      </div>
      <div class="row">
        <div class="col-sm-12 col-md-6">
          <p class="text indent-3">
            o When a ClientHello is received, the server MUST verify that it does not contain the TLS_EMPTY_RENEGOTIATION_INFO_SCSV SCSV. If the SCSV is present, the server MUST abort the handshake.
          </p>
        </div>        
      </div>
      <div class="row">
        <div class="col-sm-12 col-md-6">
          <p class="text indent-3">
            o The server MUST verify that the &#34;renegotiation_info&#34; extension is not present; if it is, the server MUST abort the handshake.
          </p>
        </div>        
      </div>
      <div class="row">
        <div class="col-sm-12 col-md-6">
          <h5 class="text mt-2">
            4.5. SSLv3
          </h5>
        </div>        
      </div>
      <div class="row">
        <div class="col-sm-12 col-md-6">
          <p class="text indent-3">
            While SSLv3 is not a protocol under IETF change control (see [SSLv3]), it was the original basis for TLS and most TLS implementations also support SSLv3. The IETF encourages SSLv3 implementations to adopt the &#34;renegotiation_info&#34; extension and SCSV as defined in this document. The semantics of the SCSV and extension are identical to TLS stacks except for the size of the verify_data values, which are 36 bytes long each. Note that this will require adding at least minimal extension processing to such stacks. Clients that support SSLv3 and offer secure renegotiation (either via SCSV or &#34;renegotiation_info&#34;) MUST accept the &#34;renegotiation_info&#34; extension from the server, even if the server version is {0x03, 0x00}, and behave as described in this specification. TLS servers that support secure renegotiation and support SSLv3 MUST accept SCSV or the &#34;renegotiation_info&#34; extension and respond as described in this specification even if the offered client version is {0x03, 0x00}. SSLv3 does not define the &#34;no_renegotiation&#34; alert (and does not offer a way to indicate a refusal to renegotiate at a &#34;warning&#34; level). SSLv3 clients that refuse renegotiation SHOULD use a fatal handshake_failure alert.
          </p>
        </div>        
      </div>
      <div class="row">
        <div class="col-sm-12 col-md-6">
          <h5 class="text mt-2">
            5. Security Considerations
          </h5>
        </div>        
      </div>
      <div class="row">
        <div class="col-sm-12 col-md-6">
          <p class="text indent-3">
            The extension described in this document prevents an attack on TLS. If this extension is not used, TLS renegotiation is subject to an attack in which the attacker can inject their own conversation with the TLS server as a prefix to the client&#39;s conversation. This attack is invisible to the client and looks like an ordinary renegotiation to the server. The extension defined in this document allows renegotiation to be performed safely. Servers SHOULD NOT allow clients to renegotiate without using this extension. Many servers can mitigate this attack simply by refusing to renegotiate at all.
          </p>
        </div>        
      </div>
      <div class="row">
        <div class="col-sm-12 col-md-6">
          <p class="text indent-3">
            While this extension mitigates the man-in-the-middle attack described in the overview, it does not resolve all possible problems an application may face if it is unaware of renegotiation. For example, during renegotiation, either the client or the server can present a different certificate than was used earlier. This may come as a surprise to application developers (who might have expected, for example, that a &#34;getPeerCertificates()&#34; API call returns the same value if called twice), and might be handled in an insecure way.
          </p>
        </div>        
      </div>
      <div class="row">
        <div class="col-sm-12 col-md-6">
          <p class="text indent-3">
            TLS implementations SHOULD provide a mechanism to disable and enable renegotiation.
          </p>
        </div>        
      </div>
      <div class="row">
        <div class="col-sm-12 col-md-6">
          <p class="text indent-3">
            TLS implementers are encouraged to clearly document how renegotiation interacts with the APIs offered to applications (for example, which API calls might return different values on different calls, or which callbacks might get called multiple times).
          </p>
        </div>        
      </div>
      <div class="row">
        <div class="col-sm-12 col-md-6">
          <p class="text indent-3">
            To make life simpler for applications that use renegotiation but do not expect the certificate to change once it has been authenticated, TLS implementations may also wish to offer the applications the option to abort the renegotiation if the peer tries to authenticate with a different certificate and/or different server name (in the server_name extension) than was used earlier. TLS implementations may alternatively offer the option to disable renegotiation once the client certificate has been authenticated. However, enabling these options by default for all applications could break existing applications that depend on using renegotiation to change from one certificate to another. (For example, long-lived TLS connections could change to a renewed certificate; or renegotiation could select a different cipher suite that requires using a different certificate.) Finally, designers of applications that depend on renegotiation are reminded that many TLS APIs represent application data as a simple octet stream; applications may not be able to determine exactly which application data octets were received before, during, or after renegotiation. Especially if the peer presents a different certificate during renegotiation, care is needed when specifying how the application should handle the data.
          </p>
        </div>        
      </div>
      <div class="row">
        <div class="col-sm-12 col-md-6">
          <h5 class="text mt-2">
            6. IANA Considerations
          </h5>
        </div>        
      </div>
      <div class="row">
        <div class="col-sm-12 col-md-6">
          <p class="text indent-3">
            IANA has added the extension code point 65281 (0xff01), which has been used for prototype implementations, for the &#34;renegotiation_info&#34; extension to the TLS ExtensionType values registry.
          </p>
        </div>        
      </div>
      <div class="row">
        <div class="col-sm-12 col-md-6">
          <p class="text indent-3">
            IANA has added TLS cipher suite number 0x00,0xFF with name TLS_EMPTY_RENEGOTIATION_INFO_SCSV to the TLS Cipher Suite registry.
          </p>
        </div>        
      </div>
      <div class="row">
        <div class="col-sm-12 col-md-6">
          <h5 class="text mt-2">
            7. Acknowledgements
          </h5>
        </div>        
      </div>
      <div class="row">
        <div class="col-sm-12 col-md-6">
          <p class="text indent-3">
            This vulnerability was originally discovered by Marsh Ray and independently rediscovered by Martin Rex. The general concept behind the extension described here was independently invented by Steve Dispensa, Nasko Oskov, and Eric Rescorla with refinements from Nelson Bolyard, Pasi Eronen, Michael D&#39;Errico, Stephen Farrell, Michael Gray, David-Sarah Hopwood, Ben Laurie, David Makepeace, Bodo Moeller, Martin Rex, Peter Robinson, Jesse Walker, Nico Williams, and other members of the Project Mogul team and the TLS WG.
          </p>
        </div>        
      </div>
      <div class="row">
        <div class="col-sm-12 col-md-6">
          <h5 class="text mt-2">
            8. References
          </h5>
        </div>        
      </div>
      <div class="row">
        <div class="col-sm-12 col-md-6">
          <h5 class="text mt-2">
            8.1. Normative References
          </h5>
        </div>        
      </div>
      <div class="row">
        <div class="col-sm-12 col-md-6">
          <p class="text indent-3">
            [RFC2119] Bradner, S., &#34;Key words for use in RFCs to Indicate Requirement Levels&#34;, BCP 14, RFC 2119, March 1997.
          </p>
        </div>        
      </div>
      <div class="row">
        <div class="col-sm-12 col-md-6">
          <p class="text indent-3">
            [RFC5246] Dierks, T. and E. Rescorla, &#34;The Transport Layer Security (TLS) Protocol Version 1.2&#34;, RFC 5246, August 2008.
          </p>
        </div>        
      </div>
      <div class="row">
        <div class="col-sm-12 col-md-6">
          <h5 class="text mt-2">
            8.2. Informative References
          </h5>
        </div>        
      </div>
      <div class="row">
        <div class="col-sm-12 col-md-6">
          <p class="text indent-3">
            [RFC4347] Rescorla, E. and N. Modadugu, &#34;Datagram Transport Layer Security&#34;, RFC 4347, April 2006.
          </p>
        </div>        
      </div>
      <div class="row">
        <div class="col-sm-12 col-md-6">
          <p class="text indent-3">
            [RFC5056] Williams, N., &#34;On the Use of Channel Bindings to Secure Channels&#34;, RFC 5056, November 2007.
          </p>
        </div>        
      </div>
      <div class="row">
        <div class="col-sm-12 col-md-6">
          <p class="text indent-3">
            [TLS-CHANNEL-BINDINGS] Altman, J., Williams, N., and L. Zhu, &#34;Channel Bindings for TLS&#34;, Work in Progress, October 2009.
          </p>
        </div>        
      </div>
      <div class="row">
        <div class="col-sm-12 col-md-6">
          <p class="text indent-3">
            [RFC2818] Rescorla, E., &#34;HTTP Over TLS&#34;, RFC 2818, May 2000.
          </p>
        </div>        
      </div>
      <div class="row">
        <div class="col-sm-12 col-md-6">
          <p class="text indent-3">
            [RFC2965] Kristol, D. and L. Montulli, &#34;HTTP State Management Mechanism&#34;, RFC 2965, October 2000.
          </p>
        </div>        
      </div>
      <div class="row">
        <div class="col-sm-12 col-md-6">
          <p class="text indent-3">
            [Ray09] Ray, M., &#34;Authentication Gap in TLS Renegotiation&#34;, November 2009, &lt;http://extendedsubset.com/?p=8&gt;.
          </p>
        </div>        
      </div>
      <div class="row">
        <div class="col-sm-12 col-md-6">
          <p class="text indent-3">
            [SSLv3] Freier, A., Karlton, P., and P. Kocher, &#34;The SSL Protocol Version 3.0&#34;, Work in Progress, November 1996.
          </p>
        </div>        
      </div>
      <div class="row">
        <div class="col-sm-12 col-md-6">
          <p class="text indent-0">
            Authors&#39; Addresses
          </p>
        </div>        
      </div>
      <div class="row">
        <div class="col-sm-12 col-md-6">
          <p class="text indent-3">
            Eric Rescorla RTFM, Inc. 2064 Edgewood Drive Palo Alto, CA 94303 USA
          </p>
        </div>        
      </div>
      <div class="row">
        <div class="col-sm-12 col-md-6">
          <p class="text indent-3">
            EMail: ekr@rtfm.com
          </p>
        </div>        
      </div>
      <div class="row">
        <div class="col-sm-12 col-md-6">
          <p class="text indent-3">
            Marsh Ray PhoneFactor 7301 W 129th Street Overland Park, KS 66213 USA
          </p>
        </div>        
      </div>
      <div class="row">
        <div class="col-sm-12 col-md-6">
          <p class="text indent-3">
            EMail: marsh@extendedsubset.com
          </p>
        </div>        
      </div>
      <div class="row">
        <div class="col-sm-12 col-md-6">
          <p class="text indent-3">
            Steve Dispensa PhoneFactor 7301 W 129th Street Overland Park, KS 66213 USA
          </p>
        </div>        
      </div>
      <div class="row">
        <div class="col-sm-12 col-md-6">
          <p class="text indent-3">
            EMail: dispensa@phonefactor.com
          </p>
        </div>        
      </div>
      <div class="row">
        <div class="col-sm-12 col-md-6">
          <p class="text indent-3">
            Nasko Oskov Microsoft One Microsoft Way Redmond, WA 98052 USA
          </p>
        </div>        
      </div>
      <div class="row">
        <div class="col-sm-12 col-md-6">
          <p class="text indent-3">
            EMail: nasko.oskov@microsoft.com
          </p>
        </div>        
      </div>
    </div>
    <div id="rfc_footer"></div>
  </body>
</html>
