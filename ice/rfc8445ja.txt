RFC Trans
個人情報保護方針
連絡先
フィグス
テックスツーイー
8445
RFC 8445 - インタラクティブ・コネクティビティ・エスタブリッシュメント（ICE）。ネットワークアドレス変換器(NAT)トラバーサルのためのプロトコル 日本語訳
URL ：https://tools.ietf.org/html/rfc8445
タイトル :RFC 8445 - Interactive Connectivity Establishment (ICE):ネットワークアドレス変換器（NAT）トラバーサルのためのプロトコル
翻訳編集 : 自動生成
インターネット・エンジニアリング・タスク・フォース（IETF） A. Keranen Request for Comments:8445 C. Holmberg Obsoletes: 5245 Ericsson Category:スタンダードトラック J. Rosenberg ISSN: 2070-1721 jdrosen.net 2018年7月号        
インタラクティブ・コネクティビティ・エスタブリッシュメント(ICE)。ネットワークアドレス変換器（NAT）トラバーサルのためのプロトコル

アブストラクト

本書は、UDPベースの通信におけるネットワークアドレス変換器（NAT）トラバーサルのためのプロトコルを記述する。このプロトコルは、Interactive Connectivity Establishment (ICE)と呼ばれる。ICEは、Session Traversal Utilities for NAT（STUN）プロトコルとその拡張である Traversal Using Relay NAT（TURN）を利用する。

この文書は、RFC5245を廃止するものである。

本メモの位置づけ

これは、Internet Standards Trackの文書です。

この文書は、インターネット技術タスクフォース（IETF）の成果物である。IETFコミュニティのコンセンサスを代表するものである。パブリックレビューを受け、インターネットエンジニアリングステアリンググループ（IESG）により発行が承認されている。インターネット標準に関する詳しい情報は、RFC7841の第2章に記載されています。

この文書の現在の状況、正誤表、およびこの文書に対するフィードバックの提供方法に関する情報は、https://www.rfc-editor.org/info/rfc8445 で入手できます。

著作権について

Copyright (c) 2018 IETF Trust and the persons identified as the document authors.無断転載を禁じます。

この文書は、この文書の発行日に有効なBCP 78およびIETFトラストのIETF文書に関する法的規定(https://trustee.ietf.org/license-info)に従うものとします。これらの文書は、この文書に関するあなたの権利と制限を記述していますので、注意深く確認してください。この文書から抽出されたコードコンポーネントは、トラスト法的規定のセクション4.eに記載されているように、簡易BSDライセンステキストを含まなければならず、簡易BSDライセンスに記載されているように、保証なしで提供されます。

この文書には、2008年11月10日以前に発行された、または一般に公開されたIETF文書またはIETF貢献の資料が含まれている場合があります。この資料の著作権を管理する者は、IETF標準化プロセス外でこのような資料の改変を許可する権利をIETFトラストに付与していない場合があります。このような資料の著作権を管理する人物から適切なライセンスを取得しない限り、この文書はIETF標準化プロセスの外部で変更することはできず、RFCとして発行するためのフォーマットや英語以外の言語への翻訳を除いて、この文書の派生物をIETF標準化プロセスの外部で作成することはできません。

目次

   1.  Introduction  . . . . . . . . . . . . . . . . . . . . . . . .   5
   2.  Overview of ICE . . . . . . . . . . . . . . . . . . . . . . .   6
     2.1.  Gathering Candidates  . . . . . . . . . . . . . . . . . .   8
     2.2.  Connectivity Checks . . . . . . . . . . . . . . . . . . .  10
     2.3.  Nominating Candidate Pairs and Concluding ICE . . . . . .  12
     2.4.  ICE Restart . . . . . . . . . . . . . . . . . . . . . . .  13
     2.5.  Lite Implementations  . . . . . . . . . . . . . . . . . .  13
   3.  ICE Usage . . . . . . . . . . . . . . . . . . . . . . . . . .  13
   4.  Terminology . . . . . . . . . . . . . . . . . . . . . . . . .  13
   5.  ICE Candidate Gathering and Exchange  . . . . . . . . . . . .  17
     5.1.  Full Implementation . . . . . . . . . . . . . . . . . . .  17
       5.1.1.  Gathering Candidates  . . . . . . . . . . . . . . . .  18
         5.1.1.1.  Host Candidates . . . . . . . . . . . . . . . . .  18
         5.1.1.2.  Server-Reflexive and Relayed Candidates . . . . .  20
         5.1.1.3.  Computing Foundations . . . . . . . . . . . . . .  21
         5.1.1.4.  Keeping Candidates Alive  . . . . . . . . . . . .  21
       5.1.2.  Prioritizing Candidates . . . . . . . . . . . . . . .  22
         5.1.2.1.  Recommended Formula . . . . . . . . . . . . . . .  22
         5.1.2.2.  Guidelines for Choosing Type and Local
                   Preferences . . . . . . . . . . . . . . . . . . .  23
       5.1.3.  Eliminating Redundant Candidates  . . . . . . . . . .  23
     5.2.  Lite Implementation Procedures  . . . . . . . . . . . . .  23
     5.3.  Exchanging Candidate Information  . . . . . . . . . . . .  24
     5.4.  ICE Mismatch  . . . . . . . . . . . . . . . . . . . . . .  26
   6.  ICE Candidate Processing  . . . . . . . . . . . . . . . . . .  26
     6.1.  Procedures for Full Implementation  . . . . . . . . . . .  26
       6.1.1.  Determining Role  . . . . . . . . . . . . . . . . . .  26
       6.1.2.  Forming the Checklists  . . . . . . . . . . . . . . .  28
         6.1.2.1.  Checklist State . . . . . . . . . . . . . . . . .  28
         6.1.2.2.  Forming Candidate Pairs . . . . . . . . . . . . .  28
         6.1.2.3.  Computing Pair Priority and Ordering Pairs  . . .  31
         6.1.2.4.  Pruning the Pairs . . . . . . . . . . . . . . . .  31
         6.1.2.5.  Removing Lower-Priority Pairs . . . . . . . . . .  31
         6.1.2.6.  Computing Candidate Pair States . . . . . . . . .  32
       6.1.3.  ICE State . . . . . . . . . . . . . . . . . . . . . .  36
       6.1.4.  Scheduling Checks . . . . . . . . . . . . . . . . . .  36
         6.1.4.1.  Triggered-Check Queue . . . . . . . . . . . . . .  36
         6.1.4.2.  Performing Connectivity Checks  . . . . . . . . .  36
     6.2.  Lite Implementation Procedures  . . . . . . . . . . . . .  38
   7.  Performing Connectivity Checks  . . . . . . . . . . . . . . .  38
     7.1.  STUN Extensions . . . . . . . . . . . . . . . . . . . . .  38
       7.1.1.  PRIORITY  . . . . . . . . . . . . . . . . . . . . . .  38
       7.1.2.  USE-CANDIDATE . . . . . . . . . . . . . . . . . . . .  38
       7.1.3.  ICE-CONTROLLED and ICE-CONTROLLING  . . . . . . . . .  39
     7.2.  STUN Client Procedures  . . . . . . . . . . . . . . . . .  39
       7.2.1.  Creating Permissions for Relayed Candidates . . . . .  39
       7.2.2.  Forming Credentials . . . . . . . . . . . . . . . . .  39
       7.2.3.  Diffserv Treatment  . . . . . . . . . . . . . . . . .  40
       7.2.4.  Sending the Request . . . . . . . . . . . . . . . . .  40
       7.2.5.  Processing the Response . . . . . . . . . . . . . . .  40
         7.2.5.1.  Role Conflict . . . . . . . . . . . . . . . . . .  40
         7.2.5.2.  Failure . . . . . . . . . . . . . . . . . . . . .  41
           7.2.5.2.1.  Non-Symmetric Transport Addresses . . . . . .  41
           7.2.5.2.2.  ICMP Error  . . . . . . . . . . . . . . . . .  41
           7.2.5.2.3.  Timeout . . . . . . . . . . . . . . . . . . .  41
           7.2.5.2.4.  Unrecoverable STUN Response . . . . . . . . .  41
         7.2.5.3.  Success . . . . . . . . . . . . . . . . . . . . .  42
           7.2.5.3.1.  Discovering Peer-Reflexive Candidates . . . .  42
           7.2.5.3.2.  Constructing a Valid Pair . . . . . . . . . .  43
           7.2.5.3.3.  Updating Candidate Pair States  . . . . . . .  44
           7.2.5.3.4.  Updating the Nominated Flag . . . . . . . . .  44
         7.2.5.4.  Checklist State Updates . . . . . . . . . . . . .  44
     7.3.  STUN Server Procedures  . . . . . . . . . . . . . . . . .  45
       7.3.1.  Additional Procedures for Full Implementations  . . .  45
         7.3.1.1.  Detecting and Repairing Role Conflicts  . . . . .  46
         7.3.1.2.  Computing Mapped Addresses  . . . . . . . . . . .  47
         7.3.1.3.  Learning Peer-Reflexive Candidates  . . . . . . .  47
         7.3.1.4.  Triggered Checks  . . . . . . . . . . . . . . . .  47
         7.3.1.5.  Updating the Nominated Flag . . . . . . . . . . .  49
       7.3.2.  Additional Procedures for Lite Implementations  . . .  49
   8.  Concluding ICE Processing . . . . . . . . . . . . . . . . . .  50
     8.1.  Procedures for Full Implementations . . . . . . . . . . .  50
       8.1.1.  Nominating Pairs  . . . . . . . . . . . . . . . . . .  50
       8.1.2.  Updating Checklist and ICE States . . . . . . . . . .  51
     8.2.  Procedures for Lite Implementations . . . . . . . . . . .  52
     8.3.  Freeing Candidates  . . . . . . . . . . . . . . . . . . .  53
       8.3.1.  Full Implementation Procedures  . . . . . . . . . . .  53
       8.3.2.  Lite Implementation Procedures  . . . . . . . . . . .  53
   9.  ICE Restarts  . . . . . . . . . . . . . . . . . . . . . . . .  53
   10. ICE Option  . . . . . . . . . . . . . . . . . . . . . . . . .  54
   11. Keepalives  . . . . . . . . . . . . . . . . . . . . . . . . .  54
   12. Data Handling . . . . . . . . . . . . . . . . . . . . . . . .  55
     12.1.  Sending Data . . . . . . . . . . . . . . . . . . . . . .  55
       12.1.1.  Procedures for Lite Implementations  . . . . . . . .  56
     12.2.  Receiving Data . . . . . . . . . . . . . . . . . . . . .  56
   13. Extensibility Considerations  . . . . . . . . . . . . . . . .  57
   14. Setting Ta and RTO  . . . . . . . . . . . . . . . . . . . . .  57
     14.1.  General  . . . . . . . . . . . . . . . . . . . . . . . .  57
     14.2.  Ta . . . . . . . . . . . . . . . . . . . . . . . . . . .  58
     14.3.  RTO  . . . . . . . . . . . . . . . . . . . . . . . . . .  58
   15. Examples  . . . . . . . . . . . . . . . . . . . . . . . . . .  59
     15.1.  Example with IPv4 Addresses  . . . . . . . . . . . . . .  60
     15.2.  Example with IPv6 Addresses  . . . . . . . . . . . . . .  65
   16. STUN Extensions . . . . . . . . . . . . . . . . . . . . . . .  69
     16.1.  Attributes . . . . . . . . . . . . . . . . . . . . . . .  69
     16.2.  New Error-Response Codes . . . . . . . . . . . . . . . .  70
   17. Operational Considerations  . . . . . . . . . . . . . . . . .  70
     17.1.  NAT and Firewall Types . . . . . . . . . . . . . . . . .  70
     17.2.  Bandwidth Requirements . . . . . . . . . . . . . . . . .  70
       17.2.1.  STUN and TURN Server-Capacity Planning . . . . . . .  71
       17.2.2.  Gathering and Connectivity Checks  . . . . . . . . .  71
       17.2.3.  Keepalives . . . . . . . . . . . . . . . . . . . . .  72
     17.3.  ICE and ICE-Lite . . . . . . . . . . . . . . . . . . . .  72
     17.4.  Troubleshooting and Performance Management . . . . . . .  72
     17.5.  Endpoint Configuration . . . . . . . . . . . . . . . . .  73
   18. IAB Considerations  . . . . . . . . . . . . . . . . . . . . .  73
     18.1.  Problem Definition . . . . . . . . . . . . . . . . . . .  73
     18.2.  Exit Strategy  . . . . . . . . . . . . . . . . . . . . .  74
     18.3.  Brittleness Introduced by ICE  . . . . . . . . . . . . .  74
     18.4.  Requirements for a Long-Term Solution  . . . . . . . . .  75
     18.5.  Issues with Existing NAPT Boxes  . . . . . . . . . . . .  75
   19. Security Considerations . . . . . . . . . . . . . . . . . . .  76
     19.1.  IP Address Privacy . . . . . . . . . . . . . . . . . . .  76
     19.2.  Attacks on Connectivity Checks . . . . . . . . . . . . .  77
     19.3.  Attacks on Server-Reflexive Address Gathering  . . . . .  80
     19.4.  Attacks on Relayed Candidate Gathering . . . . . . . . .  80
     19.5.  Insider Attacks  . . . . . . . . . . . . . . . . . . . .  81
       19.5.1.  STUN Amplification Attack  . . . . . . . . . . . . .  81
   20. IANA Considerations . . . . . . . . . . . . . . . . . . . . .  82
     20.1.  STUN Attributes  . . . . . . . . . . . . . . . . . . . .  82
     20.2.  STUN Error Responses . . . . . . . . . . . . . . . . . .  82
     20.3.  ICE Options  . . . . . . . . . . . . . . . . . . . . . .  82
   21. Changes from RFC 5245 . . . . . . . . . . . . . . . . . . . .  83
   22. References  . . . . . . . . . . . . . . . . . . . . . . . . .  84
     22.1.  Normative References . . . . . . . . . . . . . . . . . .  84
     22.2.  Informative References . . . . . . . . . . . . . . . . .  85
   Appendix A.  Lite and Full Implementations  . . . . . . . . . . .  89
   Appendix B.  Design Motivations . . . . . . . . . . . . . . . . .  90
     B.1.  Pacing of STUN Transactions . . . . . . . . . . . . . . .  90
     B.2.  Candidates with Multiple Bases  . . . . . . . . . . . . .  92
     B.3.  Purpose of the Related-Address and Related-Port
           Attributes  . . . . . . . . . . . . . . . . . . . . . . .  94
     B.4.  Importance of the STUN Username . . . . . . . . . . . . .  95
     B.5.  The Candidate Pair Priority Formula . . . . . . . . . . .  96
     B.6.  Why Are Keepalives Needed?  . . . . . . . . . . . . . . .  96
     B.7.  Why Prefer Peer-Reflexive Candidates? . . . . . . . . . .  97
     B.8.  Why Are Binding Indications Used for Keepalives?  . . . .  97
     B.9.  Selecting Candidate Type Preference . . . . . . . . . . .  97
   Appendix C.  Connectivity-Check Bandwidth . . . . . . . . . . . .  99
   Acknowledgements  . . . . . . . . . . . . . . . . . . . . . . . . 100
   Authors' Addresses  . . . . . . . . . . . . . . . . . . . . . . . 100

1.はじめに
ピア間の通信セッションを確立するプロトコルは、通常、データソースとシンクのIPアドレスとポートを交換する。しかし、これはネットワークアドレス変換器（NAT）[RFC3235]を介して操作される場合に課題を提起するものである。また、これらのプロトコルは、参加者間で直接データフローを作成しようとするもので、参加者間にアプリケーション層の仲介がないようにする。これは、データの遅延を減らし、パケットロスを減らし、アプリケーションを展開するための運用コストを削減するために行われます。しかし、これはNATを通して実現するのは困難である。この理由の完全な扱いは、この仕様の範囲を超えている。

これらのプロトコルがNATを通して動作できるようにするための数多くのソリューションが定義されています。これには、アプリケーションレイヤーゲートウェイ (ALG)、ミドルボックス制御プロトコル [RFC3303]、オリジナルのSimple Traversal of UDP Through NAT (STUN) 仕様 [RFC3489] (RFC 3489はRFC 5389で廃止された)、レルム固有IP [RFC3102] [RFC3103] と、リアルタイム制御プロトコル (RTCP) [RFC3605] に対する セッション記述プロトコル (SDP) 属性 [RFC4566] など、これらの機能を実現するのに 必要となるセッション記述延長が挙げられる。残念ながら、これらの技術には長所と短所があり、あるネットワークトポロジでは最適だが、他のトポロジでは不適切な選択となる。その結果、管理者や実装者は、ソリューションが展開されるネットワークのトポロジーを想定することになります。これは、システムに複雑さと脆さをもたらす。

本仕様では、UDPベースのデータストリームに対するNATトラバーサルの技術として、Interactive Connectivity Establishment（ICE）を定義する（ただし、ICEはTCPなど他のトランスポートプロトコルを扱うために拡張されている[RFC6544]）。ICEは、複数のIPアドレスとポートを交換し、ピアツーピアの接続性チェックによって接続性をテストすることで動作します。IPアドレスとポートは、ICEの用途に特化したメカニズム（Offer/Answer交換など）を使用して交換され、接続性チェックはSTUN [RFC5389]を使用して実行されます。ICEはまた、STUNの拡張であるTraversal Using Relay around NAT（TURN）［RFC5766］を使用します。ICEは、各メディアストリームに対して複数のIPアドレスとポートを交換するため、マルチホームやデュアルスタックのホストのアドレス選択も可能です。このため、RFC 5245 [RFC5245]は、RFC 4091 [RFC4091]とRFC 4092 [RFC4092]で以前に定義されていたソリューションを非推奨としました。

付録Bでは、ICEをデザインする際に決定したデザインに関する背景や動機について説明しています。

2.ICEの概要
典型的なICEの展開では、通信を希望する2つのエンドポイント（ICEエージェント）が存在します。ICEは、シグナリングプロトコルのNATトラバーサルを目的としていないため、別のメカニズムで提供されることを想定しています。ICEは、エージェントが互いにシグナリング接続を確立できることを想定しています。

当初、エージェントは自身のトポロジーについて無知である。特に、エージェントはNAT（または複数層のNAT）の背後にいる場合もあれば、そうでない場合もある。ICEは、エージェントがデータセッションを確立できる1つまたは複数のパスを潜在的に見つけるために、そのトポロジーに関する十分な情報を発見することができます。

図1は、典型的なICEの配置を示したものです。エージェントはLとRとラベル付けされています。LとRはそれぞれNATの後ろにいますが、意識していないかもしれません。NATの種類とその特性も不明である。LとRは、LとRの間でデータセッションを設定することを目的とした候補交換プロセスに関与することができる。通常、この交換は、シグナリングサーバー（たとえば、SIPプロキシ）を介して行われる。

エージェント、シグナリングサーバー、NATに加えて、ICEは通常、ネットワーク内のSTUNまたはTURNサーバーと協調して使用されます。各エージェントは、独自のSTUNまたはTURNサーバーを持つことができ、またはそれらは同じであることができる。

                               +---------+
             +--------+        |Signaling|         +--------+
             | STUN   |        |Server   |         | STUN   |
             | Server |        +---------+         | Server |
             +--------+       /           \        +--------+
                             /             \
                            /               \
                           / <- Signaling -> \
                          /                   \
                   +--------+               +--------+
                   |  NAT   |               |  NAT   |
                   +--------+               +--------+
                      /                             \
                     /                               \
                 +-------+                       +-------+
                 | Agent |                       | Agent |
                 |   L   |                       |   R   |
                 +-------+                       +-------+

図1：ICE導入のシナリオ

ICEの基本的な考え方は以下の通りです。各エージェントは、他のエージェントと通信するために使用できる様々なトランスポートアドレス（特定のトランスポートプロトコルのIPアドレスとポートの組み合わせで、この仕様では常にUDPです）の候補があります。これらは以下のようなものです。

o 直接接続されたネットワークインターフェイスのトランスポートアドレス。

o NATのパブリック側で変換されたトランスポートアドレス（「server-reflexive」アドレス）。

o TURNサーバーから割り当てられたトランスポートアドレス（「中継アドレス」）。

潜在的には、Lの候補トランスポートアドレスのいずれかを使用して、Rの候補トランスポートアドレスのいずれかと通信することができる。しかし、実際には、多くの組み合わせがうまくいかない。例えば、LとRの両方がNATの後ろにある場合、直接接続されたインターフェースアドレスが直接通信できる可能性は低い（結局、これがICEが必要な理由です！）。ICEの目的は、どのアドレスのペアがうまくいくかを発見することです。ICEがこれを行う方法は、1つ以上動作するものを見つけるまで、すべての可能なペアを（注意深くソートされた順序で）系統的に試すことです。

2.1.Candidateを集める
ICEを実行するために、ICEエージェントは1つまたは複数のアドレス候補を特定し、収集する。候補は、トランスポートアドレス--特定のトランスポートプロトコル（ここではUDPのみ指定）用のIPアドレスとポートの組み合わせ--を持つ。候補にはさまざまな種類があり、物理的または論理的なネットワークインターフェースから得られるものもあれば、STUNやTURNで発見できるものもある。

最初のカテゴリーは、ローカルインターフェースから直接取得したトランスポートアドレスを持つ候補です。このような候補は、「ホスト候補」と呼ばれる。ローカルインターフェースは、イーサネットやWi-Fiであったり、VPN（Virtual Private Network）やMIP（Mobile IP）のようなトンネル機構を介して取得されるものであったりする可能性があります。どのような場合でも、このようなネットワーク・インターフェースは、ポート（したがって候補）を割り当てることができるローカル・インターフェースとしてエージェントに表示されます。

次に、エージェントはSTUNまたはTURNを使用して、追加の候補を取得します。NATのパブリックサイドにある変換されたアドレス（サーバー反射型候補）とTURNサーバーにあるアドレス（中継型候補）の2種類である。TURNサーバーを利用する場合、両方のタイプの候補がTURNサーバーから取得される。STUNサーバーのみを利用する場合は、サーバー反射型候補のみから取得する。これらの候補とホスト候補の関係を図2に示す。この図では、両方のタイプの候補がTURNを使用して発見されている。図中、X:xという表記は、IPアドレスXとUDPポートxを意味する。

                      To Internet

                          |
                          |
                          |  /------------  Relayed
                      Y:y | /               Address
                      +--------+
                      |        |
                      |  TURN  |
                      | Server |
                      |        |
                      +--------+
                          |
                          |
                          | /------------  Server
                   X1':x1'|/               Reflexive
                    +------------+         Address
                    |    NAT     |
                    +------------+
                          |
                          | /------------  Local
                      X:x |/               Address
                      +--------+
                      |        |
                      | Agent  |
                      |        |
                      +--------+
図2：Candidateの関係

エージェントがIPアドレスとポートX:xからTURN Allocateリクエストを送信すると、NAT（あると仮定）は、このサーバー反射候補をホスト候補X:xにマッピングする結合X1'：x1'を作成します。ホスト候補から送信される送信パケットは、NATによってサーバー反射候補に変換されます。サーバー反射候補に送られた着信パケットは、NATによってホスト候補に変換され、エージェントに転送される。あるサーバー反射候補に関連するホスト候補は「ベース」である。

注：「ベース」とは、エージェントが特定の候補のために送信するアドレスを指します。したがって、退化したケースとして、ホスト候補もベースを持つが、それはホスト候補と同じである。

エージェントとTURNサーバーの間に複数のNATがある場合、TURNリクエストは各NATにバインディングを作成しますが、一番外側のサーバー反射候補（TURNサーバーに最も近いもの）だけがエージェントによって発見されることになります。エージェントがNATの後ろにいない場合、ベース候補はサーバー反射候補と同じになり、サーバー反射候補は冗長であるため排除される。

その後、AllocateリクエストはTURNサーバーに到着する。TURNサーバーは、そのローカルIPアドレスYからポートyを割り当て、Allocate応答を生成し、この中継候補をエージェントに通知する。TURNサーバーはまた、AllocateリクエストのソーストランスポートアドレスをAllocateレスポンスにコピーすることで、サーバー反射型の候補、X1'：x1'をエージェントに通知する。Lにトラフィックを送るために、RはY:yのTURNサーバーにトラフィックを送り、TURNサーバーはそれをX1':x1'に転送し、NATを通過してX:xにマッピングされLに配信される、というようにTURNサーバーはパケットリレーとして機能しLとR間のトラフィック転送を行う。

STUNサーバーだけが利用されるとき、エージェントはSTUN Bindingリクエスト[RFC5389]をそのSTUNサーバーに送信する。STUNサーバは，BindingリクエストのソーストランスポートアドレスをBindingレスポンスにコピーすることによって，サーバ反射候補X1':x1'をエージェントに通知する。

2.2.接続性チェック
Lはすべての候補を集めたら、優先順位の高いものから低いものへと並べ、シグナリングチャネルでRに送信する。RはLから候補を受信すると、同じ収集プロセスを実行し、候補のリストを返信する。このプロセスの最後に、各ICEエージェントは、自分の候補と相手の候補の両方の完全なリストを持つ。そして、それらをペアリングし、候補ペアを作成する。どのペアがうまくいくかを確認するために、各エージェントは一連の接続性チェックをスケジュールします。各チェックは、ローカル候補からリモート候補にSTUNリクエストを送信することによって、クライアントが特定の候補ペアに対して実行するSTUNリクエスト/レスポンストランザクションです。

接続性チェックの基本原理はシンプルです。

1.候補ペアを優先順位順に並べる。

2.各候補ペアのチェックを優先的に送信する。

3.相手エージェントから受け取ったchecksを確認する。

両エージェントが候補ペアのチェックを行うことで、結果的に4ウェイハンドシェイクとなる。

                  L                        R
                  -                        -
                  STUN request ->             \  L's
                            <- STUN response  /  check

                             <- STUN request  \  R's
                  STUN response ->            /  check

図3：基本的な接続の確認

STUNリクエストは、データ(RTP、RTCP、または他のプロトコルなど)に使用され るのとまったく同じIPアドレスとポートに送受信されることに注意することが重要で ある。その結果、エージェントは、受信したポートではなく、パケットの内容を使用してSTUNとデータをデマルチプレックスする。

接続性チェックにSTUNバインディングリクエストが使用されるため、STUNバインディング応答は、エージェントとそのピア間のNATのパブリックサイドでエージェントの変換されたトランスポートアドレスを含むことになります。このトランスポートアドレスがエージェントがすでに学習した他の候補と異なる場合、それは新しい候補（ピアリフレクティブ候補）を表し、他の候補と同じようにICEによってテストされます。

上記のアルゴリズムでは、すべての候補ペアを検索するため、作業ペアが存在する場合、候補がどのような順序で試されても、最終的にはそれを見つけることができます。より速く（より良い）結果を得るために、候補は指定された順序でソートされます。ソートされた候補ペアのリストを「チェックリスト」と呼びます。

エージェントは、定期的にリスト上の次の候補ペアに対してSTUNリクエストを送信することで、チェックリストを通して作業する。これらは「通常チェック」と呼ばれる。STUNトランザクションが成功すると、1つ以上の候補ペアがいわゆる「有効ペア」となり、「有効リスト」と呼ばれる候補ペアリストに追加される。

最適化として、RはLのチェックメッセージを受け取るとすぐに、同じ候補ペアに関する接続性チェックメッセージをLに送信するようスケジュールする。これは「トリガーチェック」と呼ばれ、有効なペアを見つけるプロセスを加速させる。

このハンドシェイクが終わると、LとRの両方が、双方向でメッセージを端から端まで送る（受け取る）ことができることを知ります。

一般に、優先順位アルゴリズムは、類似したタイプの候補が類似した優先順位を得るように設計されており、より直接的なルート（つまり、データリレーやNATを持たないルート）が間接的なルート（データリレーやNATを持つルート）より優先されるようになっています。しかし、このガイドラインの範囲内で、エージェントはアルゴリズムの調整方法についてかなりの裁量を持つことができます。

データストリームは、複数のコンポーネント（独自の候補セットを必要とするデータストリームの断片、たとえばRTPとRTCP）で構成される場合があります。

2.3.候補ペアの指名とICEの終了
ICEは、ICEエージェントの一方を制御エージェントの役割に、もう一方を被制御エージェントの役割に割り当てる。データストリームの各コンポーネントについて、制御エージェントは、データに使用する有効なペア（有効なリストから）を指名する。指名の正確なタイミングは、ローカルポリシーに基づく。

指名する場合、制御エージェントは、データストリームの各コンポーネントについて少なくとも1つの有効なペアが見つかるまでチェックを続けさせ、次に有効なペアを選び、そのペアでSTUN要求を送信し、被制御ピアに指名されたことを示すために属性を使用する。これを図4に示す。

             L                        R
             -                        -
             STUN request ->             \  L's
                       <- STUN response  /  check

                        <- STUN request  \  R's
             STUN response ->            /  check

             STUN request + attribute -> \  L's
                       <- STUN response  /  check

                           Figure 4: Nomination
図4：ノミネーション

制御されるエージェントが属性を持つSTUN要求を受信すると、（チェックが既に行われていない限り）同じペアをチェックする。上記のトランザクションが成功した場合、エージェントはペアの指名フラグを設定し、データストリームのそのコンポーネントに対する将来のチェックをキャンセルする。エージェントがデータストリームの各コンポーネントに対して指名フラグを設定すると、そのペアは選択されたペアとなる。その後、選択されたペアのみが、そのデータストリームに関連するデータの送受信に使用されることになる。

2.4.ICEリスタート
ICEが終了すると、ICEエージェントのいずれかによって、1つまたはすべてのデータストリームに対していつでも再開することができる。これは、再開を示す更新された候補情報を送信することによって行われる。

2.5.Liteの実装
ある種のICEエージェントは、常にパブリックインターネットに接続され、任意の通信相手からパケットを受信できるパブリックIPアドレスを持っています。これらのデバイスがICEを簡単にサポートできるように、ICEは「ライト」と呼ばれる特別なタイプの実装を定義しています（通常のフル実装とは対照的です）。ライトエージェントはホスト候補のみを使用し、接続性チェックの生成やステートマシンの実行は行いませんが、接続性チェックに応答できるようにする必要があります。

3.ICE使用状況
本書は、ICEエージェント間でCandidate情報を交換する手段を提供するプロトコルでのICEの一般的な使用について規定する。ICEを使用するプロトコル（「使用プロトコル」と呼ぶ）ごとの具体的な詳細（Candidate情報の符号化方法と実際のCandidate交換処理）は、別の使用文書で説明される。

エージェントが候補情報を交換することを可能にする1つのメカニズムは、SIPプロトコル [RFC3261] [ICE-SIP-SDP] の一部として、オファー/アンサーセマンティクス（これは [RFC3264] に基づく）の利用です。

[RFC7825]は、Real-Time Streaming Protocol（RTSP）のICE用法を定義している。ただし、ICEの使用法はRFC5245に基づくものであることに注意すること。

4.用語解説
本文書のキーワード「MUST」「MUST NOT」「REQUIRED」「SHALL」「SHALL NOT」「SHOULD」「SHOULD NOT」「RECOMMENDED」「NOT RECOMMENDED」「MAY」「OPTIONAL」は、ここに示すようにすべて大文字で現れる場合に限り、BCP14 [RFC2119] [RFC8174] で説明されているように解釈することになっています。

読者は、[RFC5389]で定義された用語とUDPのNAT Behavioral要件[RFC4787]を熟知している必要があります。

本仕様では、以下の追加用語を使用する。

ICEセッション。ICEセッションは、候補の収集から始まり、候補がすべて解放されるかICE再起動が発動されるまでのICEエージェント間のやりとり（候補交換、接続性チェック、ノミネーション、キープアライブ）までのICE関連のすべてのアクションで構成される。

ICE エージェント、エージェント。ICEエージェント（単に「エージェント」と呼ばれることもある）は、ICE Candidate交換に関わるプロトコル実装である。典型的なCandidate交換には、2つのエージェントが関与する。

Initiating Peer、Initiating Agent、Initiator。initiating agentとは、ICE候補交換プロセスを開始するICEエージェントのことである。

Responding Peer、Responding Agent、Responder。responding agentは、initiating agentによって開始された候補交換プロセスを受信して応答するICEエージェントである。

ICE Candidate Exchange、Candidate Exchange。ICEエージェントが、ICEを実行するために必要な情報（候補やパスワードなど）を交換する処理。SDPエンコーディングによるOffer/Answer[RFC3264]は、Candidate情報の交換に使用できるプロトコルの一例である。

ピア（Peer）。セッションのICEエージェントの1つから見て、そのピアは他のエージェントである。具体的には、initiating agentの観点からは、ピアはresponding agentである。応答するエージェントの観点からは、ピアはinitiating agentである。

トランスポートアドレス。IPアドレスとトランスポートプロトコル（UDPやTCPなど）のポートを組み合わせたものです。

データ、データストリーム、データセッション。ICEがデータセッションを設定するために使用される場合、データは何らかのプロトコルを使用して転送される。メディアは通常、RTPで転送され、RTPパケットのストリームで構成されます。データセッションとは、ICEで作成されテストされたパス上のピア間で交換されるデータパケットを指します。

Candidate、Candidate情報。データ受信のための潜在的な接点となるトランスポートアドレス。候補はまた、タイプ（サーバー反射型、中継型、ホスト型）、優先度、基礎、ベースなどの特性を持つ。

コンポーネント（Component）。コンポーネントとは、データストリームの一部分のことです。データストリームには複数のコンポーネントが必要な場合があり、各コンポーネントは、 データストリーム全体が機能するために動作する必要がある。RTP/RTCPデータストリームの場合、RTPとRTCPが同じポートで多重化されてい ない限り、データストリームごとに2つのコンポーネントが存在する（RTP用とRTCP 用）。コンポーネントには候補となるペアがあり、他のコンポーネントが使用することはできない。

ホスト候補：ホスト上のIPアドレスから特定のポートにバインドすることで得られる候補のこと。物理的なインターフェイス上のIPアドレスや、VPNで取得したような論理的なIPアドレスも含まれる。

Server-Reflexive Candidate：ICEエージェントがNATを経由してSTUNサーバーなどのサーバーにパケットを送信した後、IPアドレスとポートがNATによって割り当てられたバインディングである候補のこと。

Peer-Reflexive Candidate：ICEエージェントがNATを経由してピアにパケットを送信した後、そのIPアドレスとポートがNATによって割り当てられたバインディングである候補のこと。

中継候補：TURNサーバーなどの中継サーバーから取得した候補のことです。

ベース。ICEエージェントが特定の候補のために送信するトランスポートアドレス。ホスト候補、サーバー反射候補、ピア反射候補の場合、ベースはホスト候補と同じである。中継候補の場合、ベースは中継候補と同じである（すなわち、TURNサーバーが送信元として使用するトランスポートアドレスである）。

Related Addressとポート。候補に関連するトランスポートアドレスで、診断などに有用なもの。候補がサーバまたはピアリフレクティブの場合、Related Addressとポートはそのサーバまたはピアリフレクティブの候補のベースと同じです。候補が中継される場合、Related Addressとポートは、クライアントにその中継される候補を提供したAllocate応答におけるマップされたアドレスと等しい。候補がホスト候補である場合、Related Addressとポートはホスト候補と同じである。

Foundation。凍結アルゴリズムにおいて、類似の候補をグループ化するために使用される任意の文字列です。タイプ、ベースIPアドレス、プロトコル（UDP、TCPなど）、STUNまたはTURNサーバーが同じである2つの候補で同じになります。これらのいずれかが異なる場合、基盤が異なることになる。

ローカル候補：ICEエージェントが取得した候補で、ピアに送信する可能性があるもの。

リモート候補：ICEエージェントがピアから受信した候補。

デフォルトの宛先/候補：データストリームのコンポーネントのデフォルトの宛先は、ICEを認識していないICEエージェントが使用するトランスポートアドレスである。あるコンポーネントのデフォルト候補とは、トランスポートアドレスがそのコンポーネントのデフォルトデスティネーションと一致するものである。

Candidate Pair（Candidateペア）。ローカル候補とリモート候補を含むペア。

チェック、コネクティビティチェック、STUN チェック。接続性を確認するためのSTUN Binding要求。チェックは、候補ペアのローカル候補の基地からリモート候補に送信される。

チェックリスト。ICEエージェントがチェックを生成するために使用する、候補となるペアの順序付けられたセット。

通常のチェック。ICEエージェントが定期的に起動するタイマーの結果として生成される接続性チェックで、チェックを送信するように指示する。

Triggered Check（トリガーチェック）。ピアからコネクティビティチェックを受け取った結果として生成されるコネクティビティチェック。

有効なペア。有効なペア：ローカル候補が成功した接続性チェック応答のマップされたアドレスに等しく、リモート候補が接続性チェック要求が送信された宛先アドレスに等しい候補ペア。

Valid List（有効リスト）。STUNトランザクションの成功によって検証された、データストリームの候補ペアの順序付きセット。

チェックリスト・セット。すべてのチェックリストの順序付きリストです。順番は各ICEの使用状況に応じて決定されます。

Full Implementation（完全な実装）。本仕様で定義された機能一式を実行するICE実装。

ライト実装。特定の機能を省略したICE実装で、Lite実装でないピアがICEの利点を得るために必要なものだけを実装します。ライト実装は、ステートマシンを維持せず、接続性チェックを生成しない。

コントロール・エージェント（Controlling Agent）。候補ペアを指名するICEエージェント。どのセッションでも、常に1人のコントロールエージェントと1人のコントロールエージェントが存在する。

コントロール・エージェント制御エージェントが候補ペアを指名するのを待つICEエージェント。

ノミネーション。ICEエージェントがデータの送受信に使用する候補ペアを、制御エージェントが被制御エージェントに指示する処理。本仕様で定義されるノミネーションプロセスは、RFC5245で「regular nomination」と呼ばれていた。RFC 5245で "aggressive nomination "と呼ばれていたノミネーションプロセスは、本仕様では非推奨である。

ノミネーション、ノミネーションフラグ候補ペアの指名が成功すると、その候補ペアは指名されたことになり、その指名フラグの値が真に設定される。

Selected Pair、選択された候補ペア。データストリームの構成要素のデータ送受信に使用される候補ペアは、「選択ペア」と称される。データストリームのために選択されたペアが生成される前は、データストリームのコンポーネントに関連する任意の有効なペアを、そのコンポーネントのためのデータの送受信のために使用することができる。データストリームの各コンポーネントについて候補となるペアが存在すると、候補となるペアは、データストリームの選択されたペアとなる。選択されたペアに関連する候補は、「選択された候補」と呼ばれる。

プロトコル、ICEを使用する。NAT トラバーサルのために ICE を使用するプロトコル。利用規定では、ここで定義された手順をそのプロトコルに適用する方法について、プロトコル固有の詳細を定義する。

タイマーのTa。新しいSTUNまたはTURNトランザクションを生成するためのタイマです。

タイマーRTO（Retransmission Timeout）。STUNまたはTURNトランザクションの再送タイマ。

5.ICE Candidateの収集と交換
ICE処理の一環として、initiating agentとresponding agentの両方が候補を収集し、優先順位をつけて冗長な候補を排除し、使用プロトコルによって定義された候補情報を相手と交換する（ICE使用）。候補のエンコード機構や候補情報交換のセマンティクスの詳細は、本仕様の範囲外である。

5.1.フル実装
5.1.1.Candidateを集める
ICEエージェントは、通信が間近に迫っていると判断した場合に候補を収集する。initiating agentは、ユーザーインターフェイスの合図や、セッションを開始するための明示的な要求に基づいてこれを行うことができます。すべての候補はトランスポートアドレスを持っている。また、タイプおよびベースも持っている。ホスト候補、サーバー反射型候補、ピア反射型候補、および中継型候補の 4つのタイプが、この仕様で定義され、収集される。サーバー反射型候補はSTUNまたはTURNを用いて集められ、中継型候補はTURNを用いて取得される。ピアリフレックス候補は、ICEの後のフェーズで、接続性チェックの結果として得られる。

responding agentで候補を集めるためのプロセスは、initiating agentのプロセスと同じである。responding agentは、ICEセッションに関連するアプリケーションのユーザーに警告する前に、Candidate情報を受信したら直ちにこのプロセスを開始することが推奨される（RECOMMENDED）。

5.1.1.1.ホスト候補
ホスト候補は、ホスト上のインターフェイス（物理または仮想、VPNインターフェイスを含む）に接続されたIPアドレスのポートにバインドして取得します。

ICEエージェントが使用したい各データストリームの各コンポーネントについて、 エージェントは、以下に示す例外を除いて、ホストが持つ各IPアドレス上で候補を 取得するべきである[SHOULD]。エージェントは、特定のIPアドレス上のUDPポートにバインドすることで、各候補を取得する。ホストの候補(そして実際にすべての候補)は、常に候補である特定のコンポーネントと関連付けられている。

各コンポーネントには、「コンポーネントID」と呼ばれるIDが割り当てられている。RTP/RTCPデータストリームの場合、RTPとRTCPの両方が同じUDPポートに多重化されている場合（RTP/RTCP多重化）以外は、RTP自身はコンポーネントIDが1、RTCPはコンポーネントIDが2である。

候補を取得するとき、エージェントがRTP/RTCP多重化を使用することを確実に 知っている場合(つまり、他のエージェントもRTP/RTCP多重化をサポートし、 使用する意思があることを知っている場合)、またはエージェントがRTP/RTCP多重化 しかサポートしていない場合を除いて、エージェントはRTCP用に別の候補を取得しなけれ ばならない[MUST]。エージェントがRTCPの候補を取得し、RTP/RTCP多重化を使用することになった場合、エージェントはRTCP候補の接続性チェックを実行する必要はない。このようなコンポーネントID 2の不在は、RTCP/RTP多重化の使用を意味するものではない。

エージェントがRTPとRTCPで別々の候補を使用する場合、エージェントにK個のIPアドレスがあれば、結局2*K個のホスト候補を持つことになります。

responding agentは、候補を取得する際に、相手エージェントがRTP/RTCP多重化 をサポートしているかどうかを通常知っており、その場合、RTCP用の別の候補を 取得する必要はないことに注意する。しかし、コンポーネントID 2が存在しないことは、RTCP/RTP多重化を使用していないことを意味しない。

RTP/RTCPストリーム以外では、ICE処理の複雑さを増すため、複数のコンポーネントを使用することは推奨されない。複数のコンポーネントが必要な場合、コンポーネントIDは1から始まり、各コンポーネ ントごとに1ずつ増えるべきである[SHOULD]。

各ホスト候補のベースは、Candidate本人に設定されます。

ホスト候補は、以下の例外を除き、すべてのIPアドレスから収集されます。

o ループバックインタフェースからのアドレスは、候補アドレスに含めてはならない（MUST NOT）。

o 非推奨のIPv4互換IPv6アドレス[RFC4291]とIPv6サイトローカルユニキャストアドレス[RFC3879]は、アドレス候補に含めてはならない（MUST NOT）。

o ICEを使用するアプリケーションがIPv4をサポートしない（すなわち、IPv6専用アプリケーション [RFC4038]）場合を除き、IPv4マッピングされたIPv6アドレスをアドレス候補に含めるべきではありません（SHOULD NOT）。

o 位置追跡を防ぐ仕組み[RFC7721]を用いて生成されたIPv6アドレスに対応する1つ以上のホスト候補を集める場合、位置追跡を許可するIPv6アドレスに対応し、同じインタフェースに設定され、同じネットワークプレフィックスに含まれるホスト候補を集めてはならない（MUST NOT）。同様に、位置追跡を防ぐメカニズムを使用して生成されたIPv6アドレスに対応するホスト候補を集める場合、IPv6リンクローカルアドレス[RFC4291]に対応するホスト候補を集めてはならない[MUST NOT]。

IPv6デフォルトアドレス選択仕様[RFC6724]では、一時アドレス[RFC4941]が永久アドレスよりも優先されることが規定されている。

5.1.1.2.サーバー反射型と中継型Candidate
ICEエージェントは、サーバー反射型と中継型の候補を収集すべきである(SHOULD)。しかし、STUNとTURNサーバーの使用はネットワークによっては不要であり、TURNサーバーの使用は高価であるため、一部のデプロイメントでは、それらを使用しないことを選択するかもしれない。エージェントがサーバー反射型または中継型の候補を収集しない場合、その機能を実装し、設定により無効にすることが推奨されます。

エージェントは、各ホスト候補を、それが設定されているか、何らかの手段で発見したSTUNサーバーまたはTURNサーバーとペアリングする。ドメイン名を設定し、STUNサーバーを発見するために[RFC5389]のDNS手順（"stun "サービスでSRVレコードを使用）を使用し、TURNサーバーを発見するために[RFC5766]のDNS手順（"turn "でSRVレコードを使用）することが推奨（recommended）されています。

複数のSTUNまたはTURNサーバーが利用可能な場合(またはDNSレコードを通じて学習し、複数の結果が返された場合)、エージェントはそれらすべての候補を集めてもよく、少なくとも1つの候補を集めるべきである(STUNサーバーとTURNサーバーを1つずつ)。それは、ホスト候補とSTUNサーバーまたはTURNサーバーをペアリングし、各ペアについて、エージェントはホスト候補からサーバーにBindingまたはAllocateリクエストを送信することによって行う。STUNサーバーへのバインディングリクエストは認証されず、応答中のALTERNATE-SERVER属性はすべて無視される。エージェントは[RFC5389]で定義されているBindingリクエストの後方互換モードをサポートしなければならない(MUST)。Allocateリクエストは、クライアントが他の手段で取得した長期的なクレデンシャルを使用して認証されるべきです(SHOULD)。

ギャザリングプロセスはタイマーTaを使って制御される。Taが満了するたびに、エージェントは別の新しいSTUNまたはTURNトランザクションを生成できる。このトランザクションは、回復可能なエラー（認証失敗など）で失敗した以前のトランザクションの再試行か、新しいホスト候補とSTUNまたはTURNサーバーのペアのためのトランザクションのどちらかであることができる。エージェントは、各TAの有効期限ごとに1回より頻繁にトランザクションを生成すべきではない(SHOULD NOT)。TaとSTUN再送タイマーRTOの設定方法に関するガイダンスについては、セクション14を参照。

エージェントは、BindingまたはAllocate応答を受け取る。Allocate応答が成功すると，エージェントは，XOR-RELAYED-ADDRESS属性で，（マップされたアドレスから得られる）サーバ-reflexive候補と中継される候補を提供する。サーバーがそれを満たすためのリソースを欠いているためにAllocateリクエストが拒否された場合、エージェントは代わりにサーバー反射候補を得るためにBindingリクエストを送るべきである（SHOULD）。Binding応答は，エージェントに対して，（マップされたアドレスから得られる）サーバー反射候補だけを提供する。サーバー反射候補のベースは、AllocateまたはBinding要求が送信されたホスト候補である。中継候補のベースは、その候補自身である。中継された候補がホスト候補と同一である場合(まれに起こりうる)、その中継された候補は破棄されなければならない(MUST)。

IPv6専用エージェントがNAT64[RFC6146]およびDNS64[RFC6147]技術を利用するネットワーク内にある場合、IPv4専用STUNまたはTURNサーバーからIPv4サーバー反射型および/または中継型の候補も収集できるだろう。IPv6専用エージェントはまた、NAT64が使用するIPv6プレフィックスを発見するためにIPv6プレフィックス発見[RFC7050]を利用し、（もしあれば）それに応じて各IPv6専用インターフェースのサーバー反射候補を生成するべきである（SHOULD）。NAT64のサーバー反射候補は、IPv4のサーバー反射候補と同様に優先順位を付けられる。

5.1.1.3.コンピューティングの基礎
ICEエージェントは、各Candidateにfoundationを割り当てます。次のすべてが当てはまる場合、2人のCandidateは同じ土台を持つ。

o 同じタイプ（ホスト、リレー、サーバリフレクティブ、ピアリフレクティブ）であること。

o 両者のベースは同じIPアドレスを持つ（ポートは異なってもよい）。

o 反射型候補と中継型候補については、取得に使用されるSTUNまたはTURNサーバーが同じIPアドレス（エージェントがSTUNまたはTURNサーバーに連絡するために使用するIPアドレス）を有すること。

o 同じトランスポートプロトコル（TCP、UDP）を用いて取得されたものである。

同様に、2つの候補は、そのタイプが異なる場合、拠点が異なるIPアドレスを持つ場合、取得に使用するSTUNまたはTURNサーバーが異なるIPアドレス（エージェントがSTUNまたはTURNサーバーに連絡するために使用するIPアドレス）、またはその輸送プロトコルが異なる場合、異なる基盤を持ちます。

5.1.1.4.Keeping Candidates Alive
サーバー反射型候補と中継型候補が割り当てられると、セクション8.3に記載されて いるように、ICE処理が完了するまでそれらを存続させなければならない[MUST]。Bindingリクエストで学習したサーバー反射候補の場合、サーバーへの追加のBindingリクエストによって、バインディングを存続させなければならない[MUST]。アロケーションのリフレッシュは、[RFC5766]で述べられているように、 Refreshトランザクションを使用して行われる。Refreshリクエストは、サーバー反射的な候補もリフレッシュする。

ホスト候補はタイムアウトしないが、候補アドレスは多くの理由で変更または消滅する可能性がある。ICEエージェントは、使用しているインターフェースを監視し、ベースが消滅した候補を無効化し、新しいIPアドレス（新しいインターフェースまたは現在使用しているインターフェース）が出現したときに、必要に応じて新しい候補を取得すべきです（SHOULD）。

5.1.2.Candidateの優先順位付け
優先順位付けプロセスの結果、各候補に優先順位が割り当てられる。データストリームの各候補は、1から(2**31 - 1)までの正の整数である固有の優先度を持たなければならない(MUST)。この優先順位は、ICEが接続性チェックの順序と候補の相対的な優先順位を決定するために使用されます。優先度の高い値は、低い値よりも優先されます。

ICEエージェントは、セクション5.1.2.1の式を使用して優先度を計算し、セクション5.1.2.2 のガイドラインを使用してパラメータを選択するべきである[SHOULD]。エージェントが異なる計算式を使用することを選択した場合、エージェントのチェックが調整されないため、ICEは収束に時間がかかるかもしれない。

候補の優先順位付けのプロセスは、開始側と応答側で共通である。

5.1.2.1.推奨フォーミュラ
推奨式は、候補の種類（server reflexive、peer reflexive、relayed、host）の優先順位、候補を取得したIPアドレスの優先順位、コンポーネントIDを以下の式で組み合わせている。

   priority = (2^24)*(type preference) +
              (2^8)*(local preference) +
              (2^0)*(256 - component ID)

タイププリファレンスは0(最も低いプリファレンス)から126(最も高いプリファレンス)までの整数でなければならず(MUST)、同じタイプのすべての候補に対して同じでなければならず(MUST)、異なるタイプの候補に対して異なっていなければならない(MUST)。ピアリフレクティブ候補のタイププリファレンスは、サーバリフレクティブ候補のそれよりも高くなければならない(MUST)。値を0に設定すると、このタイプの候補は最後の手段としてのみ使用されることを意味する。セクション5.1.1の手順に基づいて収集された候補は、ピアリフレクティブ候補になることはないことに注意してください。

ローカルプリファレンスは、0(最低プリファレンス)から65535(最高プリファレンス)までの整数でなければならない(MUST)。IPアドレスが1つしかない場合、この値は65535に設定されるべきである(SHOULD)。特定のデータストリームの特定のコンポーネントに対して、同じタイプを持つ複数の候補がある場合、ローカルプリファレンスは、それぞれについてユニークでなければならない（MUST）。ICEエージェントがデュアルスタックの場合、ローカルプリファレンスは[RFC8421]に記載されている現在のベストプラクティスに従って設定されるべきである(SHOULD)。

コンポーネントIDは、1以上256以下の整数でなければならない（MUST）。

5.1.2.2.タイプ選びのガイドラインとローカルな嗜好
タイププリファレンスの推奨値（RECOMMENDED）は、ホスト候補が126、ピアリフレクティブ候補が110、サーバリフレクティブ候補が100、リレー候補が0です。

ICEエージェントがマルチホームで複数のIPアドレスを持つ場合、[RFC8421]の推奨に従うべきであ る（SHOULD）。複数のTURNサーバーが使用される場合、TURNサーバーから取得した候補のローカル優先順位は、マルチホームのローカル候補と同様の方法で選択される。ローカル優先順位値は、異なるサーバー間の優先度を示すために使用されるが、優先順位は各サーバーに対してユニークでなければならない[MUST]。

タイププリファレンスを選択する際、エージェントは、遅延、パケットロス、コスト、ネットワークトポロジー、セキュリティ、プライバシーなどの要素を考慮することができる。

5.1.3.冗長な候補を排除する
次に、ICEエージェント（開始側と応答側）は、冗長な候補を排除する。2つの候補は、同じトランスポートアドレスでありながら、異なるベースを持つことができ、これらは冗長とはみなされない。エージェントがNATの後ろにいない場合、サーバー反射候補とホスト候補が冗長であることがよくあります。候補は、そのトランスポートアドレスとベースが他の候補のものと等しい場合にのみ、冗長である。エージェントは、優先度の低い冗長な候補を排除すべきです（SHOULD）。

5.2.Liteの導入手順
Liteの実装では、ホスト候補のみを利用する。IPアドレスファミリーに依存しない各IPアドレスに対して、0個または1個の候補が存在しなければならない（MUST）。ライト実装では、ICEは候補の中から動的に選択するために使用することはできない。したがって、特定のIPアドレスファミリから複数の候補を含めることは推奨されません（RECOMMENDED）。代わりに、複数のパブリックIPアドレスを持つエージェントは、そのアドレスの最適な使用を保証するために、完全なICE実装を実行することが推奨されます。

各コンポーネントには、「コンポーネントID」と呼ばれるIDが割り当てられている。RTP/RTCPデータストリームの場合、RTPと同じポートでRTCPが多重化されてい ない限り、RTP自体はコンポーネントID 1を持ち、RTCPはコンポーネントID 2を持つ。エージェントが多重化なしでRTCPを使用している場合、その候補を取得しな ければならない[MUST]。ただし、このようにコンポーネントID 2がないことは、RTCP/RTPの多重化を使用していないことを意味するものではない。

各候補には、基盤が割り当てられる。基盤は、異なるIPアドレスから割り当てられた2つの候補について、異ならなければならない(MUST)が、そうでない場合は同じでなければならない(MUST)。そうでなければ同じでなければならない。各IPアドレスに対して増加する単純な整数で十分である。さらに、各候補は、同じデータストリームの全候補の中で一意の優先度を割り当てなければならない (MUST)。セクション5.1.2.1の計算式で優先度を計算する場合、タイププリファレンス値は126に設定されるべきです(SHOULD)。ホストがIPv4のみの場合、ローカルプリファレンス値は65535に設定されるべきです（SHOULD）。ホストがIPv6またはデュアルスタックの場合、ローカルプリファレンス値はRFC6724[RFC6724]で記述されているIPアドレスの優先順位値に設定されるべきです(SHOULD)。

次に、エージェントは各データストリームの各コンポーネントのデフォルト候補を選択する。ホストがIPv4のみの場合、各データストリームの各コンポーネントの候補は1つだけであるため、その候補がデフォルトとなる。ホストがIPv6のみの場合、デフォルトの候補は通常、グローバルにスコープされたIPv6アドレスであろう。デュアルスタックホストは、デフォルトの候補にIPv4とIPv6のどちらを使用するかの設定を可能にすべきであり、その設定は、管理者が現在のネットワーク環境において成功する確率が高いと考える方に基づく必要がある。

このセクションの手順は、開始側と応答側のエージェントに共通するものです。

5.3.Candidate情報の交換
ICEエージェント（開始側と応答側）は、交換する候補について以下の情報を必要とする。各ICE使用法は、使用するプロトコルとどのように情報を交換するかを定義しなければならない（MUST）。このセクションでは、交換される必要がある情報について説明する。

Candidate: 1人または複数のCandidate。各Candidateについて。

  アドレス: 候補のIPアドレスとトランスポートプロトコルポートです。

  トランスポート: 候補のトランスポートプロトコル。使用するプロトコルが単一のトランスポートプロトコル上でしか動作しない場合、これは省略してもよい（MAY）。

  foundation: 最大32文字までの配列です。

  コンポーネントID: 候補のコンポーネントID。使用するプロトコルがコンポーネントの概念を使用しない場合は、省略してもよい（MAY）。

  優先順位: 候補の32ビット優先度。

  タイプ: Candidateのタイプです。

  関連アドレスとポート：Candidateの関連IPアドレスとポート。エージェントがプライバシー上の理由などで明らかにしたくない場合、これらは省略してもよいし、無効な値を設定してもよい。

  拡張性パラメータ: 使用するプロトコルは、将来的にCandidateごとの新しいICEパラメータを追加するための手段を定義するかもしれない。

Lite or Full: エージェントがライトエージェントかフルエージェントか。

コネクティビティ・チェック・ペーシング値: エージェントが使用したい接続性チェックのペーシング値。エージェントが定義されたデフォルト値の使用を希望する場合、これは省略してもよい（MAY）。

ユーザー名フラグメントとパスワード：接続性チェックに使用される値。パスワードの生成には少なくとも128ビットの乱数生成器の出力が使われ、ユーザー名フラグメントの生成には少なくとも24ビットの出力が使われるなど、推測不可能な値でなければならない（MUST）。

Extensions: 新しいメディアストリームまたはセッションレベルの属性（ICEオプション）。

使用するプロトコルがICEの不一致に脆弱であり、それを検出できる場合(セクション5.4)、検出するエージェントがそのピアにこの情報を伝える方法が必要である。これはブーリアンフラグである。

使用プロトコルは、ICEをサポートしない古い実装との後方互換性に対処する必要がある（またはない）かもしれない。非ICEへのフォールバックメカニズムがサポートされ、使用されている場合、おそらくusingプロトコルは、ICEパラメータに加えてデフォルト候補（そのIPアドレスとポート）を伝達する方法を提供する。

エージェントが候補情報を送信したら、エージェントは各候補でSTUNとデータパケットの両方を受信する準備をしなければならない(MUST)。セクション12.1で議論したように、データ用デフォルトデスティネーションとして候補が現れる前に、データパケットを候補に送ることができる。

5.4.ICEの不一致
ALGなどの特定のミドルボックスは、ICEを破壊する方法でシグナリング情報を 変更することができる(たとえば、SDPでIPアドレスを書き換えるなど)。これは、「ICE mismatch」と呼ばれる。使用するプロトコルがICEミスマッチに脆弱な場合、responding agentはそれを検出し、ICEミスマッチについて相手ICEエージェントに通知する必要がある。

各使用プロトコルは、ICE不一致に対する脆弱性の有無、ICE不一致の検出方法、ICE不一致が検出された場合の特定のアクションの必要性を定義する必要がある。

6.ICE Candidate処理
ICEエージェントは、候補を集め、ピアと候補を交換した後（セクション5）、自身の役割を決定することになる。また、完全な実装では、チェックリストを形成し、ピアとの接続性チェックを開始する。

6.1.完全実施に向けた手続き
6.1.1.役割の決定
各セッションにおいて、ICEエージェント（開始側と応答側）はそれぞれ役割を担います。役割には、制御と被制御の2つがある。制御するエージェントは、通信に使用する最終候補ペアの選択に責任を持つ。以下のセクションでは、制御側エージェントと被制御側エージェントが実際に行う手順について詳しく説明する。

役割と行動への影響を判断するためのルールは以下の通りです。

両エージェントとも満席です。ICE処理を開始したイニシエーションエージェントは制御の役割を果たさなければならず(MUST)、もう一方のエージェントは制御される役割を果たさなければならない(MUST)。両エージェントは、チェックリストを形成し、ICEステートマシンを実行し、 接続性チェックを生成する。制御エージェントは、セクション8.1のロジックを実行し、(指名に関連するコネクティビティチェックが成功した場合)選択されたペアとなるペアを指名し、その後両エージェントはセクション8.1.2に記載されているようにICEを終了する。

フルエージェントが1人、ライトエージェントが1人。フルエージェントは制御する役割を、ライトエージェントは制御される役割を担わなければならない（MUST）。フルエージェントはチェックリストを作成し、ICEステートマシンを実行し、接続性チェッ クを生成する。そのエージェントは、セクション8.1のロジックを実行し、(指名に関連するコネクティビティチェックが成功すれば)選択されたペアとなるペアを指名し、セクション8.1.2のロジックを使用してICEを終了させる。ライト実装では、接続性チェックをリッスンし、それを受信して応答し、8.2節で説明するようにICEを終了させるだけである。lite実装では、各データストリームのICE処理の状態はRunning、ICE全体の状態はRunningとみなされる。

ともにライト。ICE処理を開始したイニシエーションエージェントは、制御の役割を果たさなければならず(MUST)、他方は制御される役割を果たさなければならない(MUST)。この場合、接続性チェックが送信されることはない。むしろ、候補が交換されると、各エージェントは接続性チェッ クなしでセクション8で説明されている処理を実行する。両エージェントが、自分がコントロールされている、あるいはコントロールしていると思い込む可能性がある。後者の場合、候補の交換を可能にするシグナリングプロトコルのグレア検出機能によって、競合が解決される。各データストリームのICE処理の状態はRunningであり、ICE全体の状態はRunningであると考えられる。

セッションに対して役割が決定されると、その役割はセッションの有効期間中存続する。役割はICEリスタート（セクション9）の一部として再決定することができるが、ICEエージェントは、以下の基準のうち1つ以上が満たされない限り、ICEリスタートの一部として役割を再決定してはならない（MUST NOT）。

Full becomes lite：コントロールエージェントがフルで、ライトに切り替えた場合、ピアエージェントもフルであれば、役割を再決定しなければならない（MUST）。

役割の衝突：ICE再起動により役割の衝突が発生した場合、7.3.1.1項の役割の衝突の手順により、役割を再決定することができる。

注：ICEの再起動が役割の衝突を引き起こす可能性がある、特定のサードパーティ呼制御（3PCC）［RFC3725］のシナリオがある。

注：エージェントは、役割が決定される前に、フルかライトかを互いに通知する必要がある。そのためのメカニズムは、シグナリングプロトコルに特有のものであり、この文書の範囲外である。

エージェントは，相手が役割の再決定を開始した場合，そのための基準が満たされていなくても，受け入れなければならない(MUST)。これはピアがRFC5245に準拠している場合に起こりうる。

6.1.2.チェックリストの形成
各データストリームに対して1つのチェックリストが存在する。チェックリストを形成するために、開始側と応答側のICEエージェントは、候補ペアの形成、ペアの優先度の計算、優先度によるペアの順序付け、ペアの刈り込み、優先度の低いペアの削除、チェックリストの状態設定を行います。候補がチェックリストに追加された場合（例えば、ピアリフレクティブ候補の検出による）、エージェントは更新されたチェックリストに対してこれらのステップを再実行することになる。

6.1.2.1.チェックリストの状態
各チェックリストには状態があり、そのチェックリストに関連するデータストリームのICEチェックの状態を把握することができます。状態は以下の通りです。

実行中です。チェックリストは、まだCompletedでもFailedでもありません。チェックリストは、初期状態で「実行中」に設定されています。

完了した。チェックリストには、データストリームの各コンポーネントについて、指名されたペアが含まれている。

Failed（失敗）。チェックリストには、データストリームの各コンポーネントに対して有効なペアがなく、チェックリストの候補ペアのすべてがFailedまたはSucceededのいずれかの状態になっています。つまり、チェックリストの少なくとも1つのコンポーネントは、候補ペアがすべてFailed状態であり、そのコンポーネントは失敗し、チェックリストは失敗したことを意味する。

6.1.2.2.候補ペアの形成
ICEエージェントは、同じデータストリームの同じコンポーネントの同じIPアドレスファミリーの各ローカル候補と各リモート候補をペアリングします。ローカル候補の一部がリモート候補とペアにならず、リモート候補の一部がローカル候補とペアにならないこともあり得ます。これは、1つのエージェントがデータストリームのすべてのコンポーネントの候補を含んでいない場合に起こり得ます。この場合、そのデータストリームのコンポーネント数は実質的に減少し、データストリームのすべてのコンポーネントにわたって各エージェントが提供する最大コンポーネントIDの両エージェントにわたる最小値に等しいとみなされる。

RTPの場合、一方のエージェントがRTCPの候補を提供し、もう一方が提供し ない場合に発生する。別の例として、initiating agentは、同じポートでRTPとRTCPを多重化する ことができる[RFC5761]。しかし、initiating agentは、ピアエージェントがそのような多重化 を実行できるかどうか知らないため、RTPとRTCPの候補を別々のポートに含める。ピアエージェントがこのような多重化を実行できる場合、各候補のコンポーネント (RTP/RTCP muxを組み合わせたもの)を1つだけ含めることになる。ICEは、この候補に単一のコンポーネントがあるかのように動作することになります。

IPv6では、各インタフェースに対して複数のホスト候補が存在することが一般的である。このような候補ペアの量を適切に保つため、また、動作する可能性が極めて低い候補ペアを避けるため、IPv6のリンクローカルアドレスはリンクローカルアドレス以外とペアリングしてはならない（MUST NOT）。

ローカル候補とリモート候補の両方が特定のコンポーネントのデフォルト候補である候補ペアは、そのコンポーネントの「デフォルト候補ペア」と呼ばれます。これは、両エージェントがICEを意識していなかった場合に、データ伝送に使用されるペアである。

図5は、トランスポートアドレス、Candidate、Candidateペア、チェックリストの性質と関係を示したものである。

              +--------------------------------------------+
              |                                            |
              | +---------------------+                    |
              | |+----+ +----+ +----+ |   +Type            |
              | || IP | |Port| |Tran| |   +Priority        |
              | ||Addr| |    | |    | |   +Foundation      |
              | |+----+ +----+ +----+ |   +Component ID    |
              | |      Transport      |   +Related Address |
              | |        Addr         |                    |
              | +---------------------+   +Base            |
              |             Candidate                      |
              +--------------------------------------------+
              *                                         *
              *    *************************************
              *    *
            +-------------------------------+
            |                               |
            | Local     Remote              |
            | +----+    +----+   +default?  |
            | |Cand|    |Cand|   +valid?    |
            | +----+    +----+   +nominated?|
            |                    +State     |
            |                               |
            |                               |
            |          Candidate Pair       |
            +-------------------------------+
            *                              *
            *                  ************
            *                  *
            +------------------+
            |  Candidate Pair  |
            +------------------+
            +------------------+
            |  Candidate Pair  |
            +------------------+
            +------------------+
            |  Candidate Pair  |
            +------------------+

                 Checklist

図5：チェックリストの概念図

6.1.2.3.ペアの優先順位の計算とペアの順序付け
ICEエージェントは、各候補のペアの優先順位を計算する。制御側エージェントが提供する候補の優先順位をGとする。被制御エージェントが提供する候補の優先順位をDとする。ペアの優先順位は以下のように計算される。

      ペア優先度 = 2^32*MIN(G,D) + 2*MAX(G,D) + (G>D?1:0)        
エージェントは、各チェックリストを候補ペアの優先順位の降順に並べ替える。2つのペアが同じ優先度を持つ場合、それらの間の順序は任意である。

6.1.2.4.ペアの刈り込み
この候補ペアのソートされたリストは、実行される接続性チェックの順序を決定するために使用される。各チェックでは、ローカル候補からリモート候補にリクエストを送信する。ICEエージェントは、反射型候補（サーバー反射型またはピア反射型）から直接リクエストを送信できず、ベースからしか送信できないため、エージェントは次に、候補ペアのソートされたリストを確認する。ローカル候補が反射的である各ペアについて、候補はそのベースに置き換えられなけれ ばならない[MUST]。

エージェントは、各チェックリストを整理する。これは、候補ペアが同じチェックリスト内の優先順位の高い候補ペアと冗長である場合に、候補ペアを削除することによって行われる。2つの候補ペアは、ローカル候補が同じベースを持っていて、リモート候補が同じであれば冗長である。その結果、候補ペアの順序が決まり、そのデータストリームの「チェックリスト」と呼ばれます。

6.1.2.5.下位優先度ペアの削除
セクション19.5.1に記載されている攻撃を制限するために、ICEエージェントは、 チェックリストセット内のすべてのチェックリストに対してエージェントが実行する 接続性チェックの総数を制限しなければならない[MUST]。これは、チェックリストセット内の候補ペアの総数を制限することによって行われる。チェックリストセットの候補ペアのデフォルトの制限は100であるが、この値は設定可能でなければならない（MUST）。この制限は、各チェックリスト内で、チェックリストセット内の候補ペアの総数が制限値より小さくなるまで、優先順位の低い候補ペアを破棄することによって強制される。各チェックリストの候補ペアの数が同じだけ減るように、破棄は均等に行われるべきである（SHOULD）。

可能な限りデフォルト値よりも低い制限値を選択し、実際の展開構成で作成される可能性のある候補ペアの最大数に設定することが推奨されます（RECOMMENDED）。設定に関する要件は、配備後にこの値に問題があることが判明した場合に、現場で修正するためのツールを提供することを意図しています。

6.1.2.6.ペア候補の状態を計算する
チェックリストの各候補ペアは、基礎（ペアのローカル候補とリモート候補の基礎の組み合わせ）と以下のいずれかの状態を持つ。

待機中です。このペアに対してチェックは送信されていませんが、ペアはFrozenではありません。

進行中です。このペアに対してチェックが送信されましたが、トランザクションは進行中です。

成功しました。このペアに対してチェックが送信され、成功した。

失敗した。このペアに対してチェックが送信されましたが、失敗しました（チェックに対する応答が受信されなかったか、失敗の応答が受信された）。

凍結されている。このペアのチェックは送信されておらず、ペアの凍結が解除されWaiting状態に移行するまで送信できない。

図6に示すように、ペアは状態間を移動する。

      +-----------+
      |           |
      |           |
      |  Frozen   |
      |           |
      |           |
      +-----------+
            |
            |unfreeze
            |
            V
      +-----------+         +-----------+
      |           |         |           |
      |           | perform |           |
      |  Waiting  |-------->|In-Progress|
      |           |         |           |
      |           |         |           |
      +-----------+         +-----------+
                                  / |
                                //  |
                              //    |
                            //      |
                           /        |
                         //         |
               failure //           |success
                     //             |
                    /               |
                  //                |
                //                  |
              //                    |
             V                      V
      +-----------+         +-----------+
      |           |         |           |
      |           |         |           |
      |   Failed  |         | Succeeded |
      |           |         |           |
      |           |         |           |
      +-----------+         +-----------+
図6：ペアステート有限状態機械(FSM)

チェックリストの各ペアの初期状態は、以下の一連のステップを実行することで計算される。

1.チェックリストは、「チェックリストセット」と呼ばれる順序の決まったリスト（順序は各ICEの使用状況により決定されます）に入れられます。

2.ICEエージェントは、最初にすべての候補ペアをFrozen状態にする。

3.エージェントは、チェックリストセット内の全てのチェックリストをRunning状態にする。

4.各基盤について、エージェントは、ちょうど1つの候補ペアの状態をWaiting状態に設定する（凍結を解除する）。凍結解除する候補ペアは、その基盤を持つ最初のチェックリスト（利用者が定義したチェックリストのセット順序に従う）において、最初の候補ペア（コンポーネントIDが低い順に並び、コンポーネントIDが等しい場合は優先度が高い）を見つけることによって選択される。

注：上記の手順は、最初のチェックリストの候補ペアだけが最初にWaiting状態に置かれたRFC5245とは異なります。現在は、チェックリストセットの最初のチェックリストでなくても、その基盤を持つ最初のチェックリスト内の候補ペアに適用される。

下表はその一例を示しています。

表の凡例。

各行（m1、m2、...）は、データストリームに関連するチェックリストを表し、m1は、チェックリストセット内の最初のチェックリストを表す。

各列（f1,f2,...）はfoundationを表す。ある列内のすべての候補ペアは、同じ基盤を共有している。

f-cpはFrozen状態での候補ペアを表す。

w-cpはWaiting状態の候補ペアを表す。

1.エージェントは、チェックリストセットの全てのペアを凍結状態にする。

         f1 f2 f3 f4 f5
       -----------------------------
   m1 | f-cp f-cp f-cp
      |
   m2 | f-cp f-cp f-cp f-cp
      |
   m3 | f-cp f-cp

2.各基礎について、同じ基礎に関連するCandidateペアがチェックリストセット内の他の検査済みチェックリストの1つで既に待機状態に置かれていない限り、コンポーネントIDが最も低いCandidateペアが待機状態に置かれる。

         f1 f2 f3 f4 f5
       -----------------------------
   m1 | w-cp w-cp w-cp
      |
   m2 | f-cp f-cp f-cp w-cp
      |
   m3 | f-cp w-cp
        
表1：ペアの状態例

最初のチェックリスト（m1）では、各基盤の候補ペアは、同じ基盤のペアがまだWaiting状態に置かれていないため、Waiting状態に置かれます。

第2チェックリスト（m2）において、基礎f4の候補ペアは待機状態に置かれる。基礎f1、f2、f3の候補ペアは、既に（チェックリストm1内で）待機状態に置かれているため、凍結状態に保たれる。

第3チェックリスト（m3）において、基盤f5の候補ペアがWaiting状態になる。foundationf1の候補ペアは、既に待機状態（チェックリストm1内）になっているため、凍結状態にしておく。

各チェックリストが処理されると、チェックリストの各foundationに対して1組の候補が待機状態になります。

6.1.3.ICEステート
ICEエージェントは、チェックリストの状態によって決まる状態を持つ。状態は、すべてのチェックリストがCompletedの場合はCompleted、すべてのチェックリストがFailedの場合はFailed、それ以外はRunningである。

6.1.4.スケジューリングチェック
6.1.4.1.トリガーチェック・キュー（Triggered-Check Queue
ICEエージェントは、セクション6.1.2で説明したように、チェックリストを計算し、 チェックリストセットを作成すると、接続性チェック（通常およびトリガー）の実行を開始す る。トリガー接続性チェックのために、エージェントは、「トリガーチェック・キュー」と呼ばれる、各チェックリストのためのFIFOキューを維持し、次の利用可能な機会にチェックが送信されるべき候補ペアを含む。トリガーチェック・キューは、最初は空である。

6.1.4.2.接続性チェックの実行
通常接続チェック及びトリガー接続チェックの生成は、タイマーTaによって支配される。チェックリストセット内の候補ペアの初期状態が設定されるとすぐに、セクション7の手順に従って、実行状態にある最初のチェックリスト内の候補ペアに対してチェックが実行される。その後、Taが発生するたびに、チェックリスト集合の次の実行状態のチェックリストが選ばれ、そのチェックリスト内の候補についてチェックが行われる。チェックリストセット内の実行状態の最後のチェックリストが処理された後、最初のチェックリストが再び選択される、など。

Taが発火するたびに、ICEエージェントは、以下のステップを実行することによって摘出されたチェックリスト内の候補ペアのチェックを実行する。

1.チェックリストに関連するトリガーチェック・キューに1つ以上の候補ペアが含まれている場合、エージェントはキューから一番上のペアを取り除き、そのペアに対して接続性チェックを行い、候補ペアの状態を進行中にし、その後のステップを中止する。

2.Waiting状態の候補ペアがなく、Frozen状態のペアが1つ以上ある場合、エージェントは、Frozen状態の各ペアに関連する基盤をチェックする。与えられた基礎について、（チェックリスト集合のどのチェックリストにも）Waiting状態又はIn-Progress状態のペアがない場合、エージェントは候補ペア状態をWaitingにし、次のステップに進む。

3.Waiting状態の候補ペアが1つ以上ある場合、エージェントはWaiting状態の中で最も優先度の高い候補ペア（同じ優先度のペアが複数ある場合は、コンポーネントIDが最も低いペアを選ぶ）を選び、そのペアに対して接続性チェックを行い、候補ペアの状態をIn-Progressにして、以降のステップを中止します。

4.このステップに到達した場合、ピックしたチェックリストについて、チェックを行うことができなかった。そこで、タイマーTaの再延長を待たずに、Running状態の次のチェックリストを選択し、ステップ#1に戻る。もし、実行中のチェックリストが1つもない場合、つまり接続性チェックを行う候補ペアが残っていない場合は、このステップを中止してください。

エージェントが接続性チェックを行う候補ペアを選んだら、エージェントはチェックを開始し、7.2.4節で説明したように、ペアのローカル候補に関連する基地からペアのリモート候補にバインド要求を送信する。

ローカルポリシーに基づき、エージェントは、チェックリストセット内の1つまたは複数のチェックリストの接続性チェックの実行をいつでも終了することを選択してもよい（MAY）。ただし、ICEを終了させることができるのは、制御エージェントのみである（セクション8）。

チェックのためのメッセージの完全性を計算するために、エージェントは、ピアから得た候補情報から学んだリモートのユーザ名フラグメントとパスワードを使用します。ローカルユーザ名の断片は、エージェントが自分のCandidateについて直接知っているものである。

6.2.Liteの導入手順
Liteの実装では、ピアのICEサポートの確認とICE処理における役割の決定を除き、セクション6のステップのほとんどをスキップすることができます。

ライト実装が制御エージェントである場合（ピアICEエージェントもライト実装である場合のみ）、候補交換にあるものに基づいて候補ペアを選択し（IPv4では1ペアのみ）、必要に応じてその選択を反映した新しい候補情報をピアに更新します（IPv4のみのホストでは決して必要ありません）。

7.接続性チェックの実行
ここでは、接続性チェックの方法について説明します。

ICEエージェントは、[RFC5389]に準拠しなければならない（MUST）。フル実装はSTUNクライアントとSTUNサーバーの両方として動作し、ライト実装はSTUNサーバーとしてのみ動作する（接続性チェックを生成しないため）。

7.1.STUNエクステンション
ICEはSTUNを属性で拡張しています。PRIORITY、USE-CANDIDATE、ICE-CONTROLLED、およびICE-CONTROLLING。これらの属性は、セクション16.1で正式に定義される。このセクションでは、属性の使用法について説明する。

属性はICEの接続チェックにのみ適用されます。

7.1.1.優先順位（PRIORITY
PRIORITY属性はBindingリクエストに含まれ、ローカル候補のためにセクション5.1.2のアルゴリズムで計算された値に設定されなければならないが、ピアリフレクティブ候補の候補タイプの優先順位がある。

7.1.2.USE-CANDIDATE
制御エージェントは、候補ペアを指名するためにUSE-CANDIDATE属性を含まなければならない (セクション8.1.1)。被制御エージェントは、BindingリクエストにUSE-CANDIDATE属性を含めてはならない(MUST NOT)。

7.1.3.ICE-CONTROLLEDおよびICE-CONTROLLINGについて
制御エージェントは、BindingリクエストにICE-CONTROLLING属性を含めなければならない(MUST)。被制御エージェントは、BindingリクエストにICE-CONTROLLED属性を含めなければならない(MUST)。

ICEの役割の競合が発生した場合、いずれかの属性の内容がタイブレーク値として使用される（7.3.1.1項）。

7.2.STUNクライアント手順
7.2.1.中継Candidateのパーミッションの作成
接続性チェックが中継されたローカル候補を使用して送信される場合、クライアントは、以前に許可を作成していない場合は、最初に許可を作成しなければならない(MUST)。TURNサーバーに、リモート候補のIPアドレスに向けて、指定された中継候補の許可を作成するように指示した場合、ICEエージェントは以前に許可を作成したことになる。許可を作成するために、ICEエージェントは[RFC5766]に定義されている手順に従います。許可は、リモート候補のIPアドレスに向けて作成されなければならない(MUST)。エージェントは、ICEが完了するまでTURNチャネルの作成を延期することが推奨される (RECOMMENDED)。この場合、接続性チェックのための許可は、通常CreatePermissionリクエストを使用して作成される。いったん確立されると、エージェントはICEが終了するまで、その許可を有効にしておかなければならない(MUST)。

7.2.2.クレデンシャルの形成
接続性チェックのバインディングリクエストは、STUN短期クレデンシャルメカニズムを利用しなければならない（MUST）。

クレデンシャルのユーザー名は、ピアから提供されたユーザー名フラグメントと、リクエストを送信するICEエージェントのユーザー名フラグメントをコロン（"："）で区切って連結することで形成されます。

パスワードは、ピアから提供されたパスワードと同じです。

例えば、ICEエージェントLがinitiating agentで、ICEエージェントRがresponding agentである場合を考えてみよう。エージェントLは、Candidateのユーザー名としてLFRAGを、パスワードとしてLPASSを含む。エージェントRは、RFRAGというユーザー名の断片とRPASSというパスワードを提供した。LからRへの接続チェックは、ユーザ名RFRAG:LFRAGとパスワードRPASSを利用する。RからLへの接続チェックは、ユーザー名LFRAG:RFRAGとパスワードLPASSを使用する。レスポンスはリクエストと同じユーザー名とパスワードを利用する（レスポンスにはUSERNAME属性が存在しないことに注意）。

7.2.3.ディフサーブ処理
エージェントが送信するデータパケットにDSCP(Differentiated Services Code Point)マーキング[RFC2475]を使用している場合、エージェントは送信するBindingリクエストと応答に同じマーキングを適用するべきである[SHOULD]。

データパケットに複数のDSCPマーキングが使用されている場合、エージェントは接続性チェックで使用するためにそのうちの一つを選択するべきである（SHOULD）。

7.2.4.リクエストの送信
接続性チェックは、ローカル候補に関連するベースからリモート候補にBindingリクエストを送信することで生成される。[RFC5389]は、Bindingリクエストがどのように構築され生成されるかを記述している。

RFC 3489との後方互換性のサポートは、接続性チェックの実行時に仮定してはならない（MUST NOT）。接続性チェックには、FINGERPRINT機構を使用しなければならない（MUST）。

7.2.5.レスポンスの処理
本節では、ICE接続チェックに特化したBindingレスポンスの処理手順を追加定義する。

Binding応答を受信すると、トランザクションID[RFC5389]を用いて対応するBinding要求と関連付けられ、Binding要求が送信された候補ペアと応答が関連付けされる。その後、以下の手順により、役割の衝突、失敗、成功の手順で応答が処理される。

7.2.5.1.役割の相反
Bindingリクエストが487(Role Conflict)エラー応答(セクション7.3.1.1)を生成し、ICEエージェントがリクエストに ICE-CONTROLLED属性を含んでいた場合、エージェントは制御する役割に移行しなけれ ばならない[MUST]。ICEエージェントがリクエストにICE-CONTROLLING属性を含んでいた場合、エージェントは制御される役割に切り替わらなければならない(MUST)。

エージェントがその役割を切り替えたら、エージェントは、そのチェックが487エラー応答を生成した候補ペアを、そのペアが属するチェックリストに関連付けられたトリガーチェックのキューに追加し、候補ペアのステートを「待機中」に設定しなければならない[MUST]。後にトリガーされた接続性チェックが実行されるとき、BindingリクエストのICE-CONTROLLING/ICE-CONTROLLED属性は、エージェントの新しい役割を示すだろう。エージェントはタイブレーカー値を変更しなければならない(MUST)。

注：ロールスイッチは、優先度の値がロールに依存するため、エージェントがペアの優先度を再計算する必要があります（セクション6.1.2.3）。

注：役割の切り替えは、エージェントが候補ペアの指名に責任を持つかどうか、ICEが終了した後、エージェントがピアとの更新された候補情報の交換を開始する責任を持つかどうかにも影響します。

7.2.5.2.失敗の場合
ここでは、候補ペアの状態がFailedに設定されている場合について説明する。

注：ICEエージェントが接続性チェックエラーの結果、候補ペアの状態を「失敗」に設定した場合、エージェントは同じ土台を持つ他の候補ペアの状態を変更しません。

7.2.5.2.1.非対称型トランスポートアドレス
ICEエージェントは、Bindingリクエストと応答のソースとデスティネーション トランスポートアドレスが対称であることを確認しなければならない[MUST]。つまり、応答のソースIPアドレスとポートは、Bindingリクエストが送信されたデス ティネーションIPアドレスとポートに等しくなければならず(MUST)、応答のデスティ ネーションIPアドレスとポートは、Bindingリクエストが送信されたソースIPアドレス とポートに等しくなければならない(MUST)。アドレスが対称でない場合、エージェントは候補ペアステートをFailedに設定しなければならない(MUST)。

7.2.5.2.2.ICMPエラー
ICEエージェントは、接続性チェックのためのICMPエラーの処理をサポートしてもよい(MAY)。エージェントがICMPエラーの処理をサポートし、BindingリクエストがハードICMPエラーを生成する場合、エージェントは候補ペアのステートをFailedに設定するべきである(SHOULD)。実装者は，ICMPエラーを処理する方法と方法を決定する際に，ICMPエラーがサービス拒否 (DoS) 攻撃の方法として使用できることを認識する必要がある。

7.2.5.2.3.タイムアウト
Bindingリクエストトランザクションがタイムアウトした場合、ICEエージェントは候補ペアのステートをFailedに設定しなければならない(MUST)。

7.2.5.2.4.回復不能なSTUNレスポンス
Bindingリクエストが回復不可能なSTUNエラー応答を生成した場合[RFC5389]、ICEエージェントは候補ペアのステートをFailedに設定すべきである（SHOULD）。

7.2.5.3.サクセス
接続性チェックは、以下の各条件が真である場合に成功とみなされます。

o Binding リクエストが成功応答を生成したこと。

o Bindingリクエストとレスポンスにおけるソースとデスティネーションのトランスポートアドレスは対称である。

チェックが成功とみなされた場合、ICEエージェントは以下のセクションで説明するアクションを（順番に）実行します。

7.2.5.3.1.ピアリフレックス候補の発見
ICEエージェントは、STUN応答からマップされたアドレスを確認しなければならない (MUST)。トランスポートアドレスが、エージェントが知っているローカル候補のいずれとも一致しない場合、マップされたアドレスは、新しい候補であるピアリフレクティブ候補を表す。他の候補と同様に、ピアリフレクティブ候補は、タイプ、ベース、プライオリティ、およびファウンデーションを持つ。これらは以下のように計算される。

o タイプはピアリフレクティブです。

o ベースとは、バインディング要求の送信元である候補ペアのローカル候補のことです。

o 優先度は、BindingリクエストのPRIORITY属性の値である。

o foundationについては、5.1.1.3節に記載されています。

その後、ピアリフレクティブ候補は、そのデータストリームのローカル候補のリストに追加されます。ユーザー名の断片とパスワードは、そのデータストリームの他のすべてのローカル候補と同じである。

セクション7.2.5.3.2の手順により、有効なペアが作成されるため、ICEエージェントはピ アレフ候補をリモート候補とペアリングする必要はない。エージェントがピアリフレクティブ候補を、生成される有効なペアの候補以外のリモート候補とペアリングしたい場合、エージェントは、ピアリフレクティブ候補を含むピアに更新された候補情報を提供してもよい（MAY）。これにより、ピアリフレクティブ候補は、他のすべてのリモート候補とペアリングされる。

7.2.5.3.2.有効なペアを構成する
ICEエージェントは、ローカル候補が応答のマップされたアドレスに等しく、リモート候補が リクエストの送信先アドレスに等しい候補ペアを構築する。これを "有効なペア "と呼ぶ。

有効なペアは、接続性チェックを発生させたペア、チェックリスト内の別のペア、または現在チェックリストにないペアと同じかもしれません。

エージェントは、「有効リスト」と呼ばれる別のリストを保持する。チェックリストセットの各チェックリストに対して、有効なリストがある。有効リストは、有効なペアを含むことになる。初期状態では、各有効リストは空である。

有効リスト内の各有効ペアは、「指名フラグ」と呼ばれるフラグを持つ。有効なペアが有効なリストに追加されると、フラグの値は'false'に設定される。

有効なペアは、以下のように有効なリストに追加されます。

1.有効なペアがチェックを生成したペアと等しい場合、そのペアは、そのペアが属するチェックリストに関連する有効なリストに追加されます。

2.有効なペアがチェックリスト内の他のペアと等しい場合、そのペアはそのペアのチェックリストに関連付けられた有効なリストに追加される。チェックが発生したペアは、有効なリストに追加されない。

3.有効なペアがどのチェックリストにもない場合、エージェントはセクション6.1.2のアルゴリズムを使用して、各候補の優先度に基づいてペアの優先度を計算する。ローカル候補の優先順位は、そのタイプに依存する。タイプがピアリフレクティブでない限り、優先度はCandidate交換でそのCandidateにシグナルされた優先度と同じである。タイプがpeer reflexiveである場合，それは，エージェントがちょうど完了したBindingリクエストに置いたPRIORITY属性と等しい。リモート候補の優先度は，ピアの候補情報から取得される。もしそこに候補が表示されない場合、そのチェックは新しいリモート候補へのトリガーチェックであったことになる。その場合、優先順位は、ちょうど完了したチェックをトリガーしたバインディングリクエストのPRIORITY属性の値として取られる。そして、そのペアは有効リストに追加される。

注：有効なペアがどのチェックリストにもないことはよくあることであろう。チェックリストには、ローカル候補がreflexiveでないペアがあることを想起 してほしい。それらのペアは、ローカル候補をreflexive候補のベースに変換し、 冗長であれば削除された。バインド要求に対する応答が到着したとき、2つの間にNATがあれば、マップされたアドレスはリフレクティブになる。その場合、有効なペアは、チェックリストのどのペアとも一致しないローカル候補を持つことになる。

7.2.5.3.3.ペア候補の状態更新
ICEエージェントは、チェックが発生した候補ペアと構築された有効ペア（異なる場合がある）の両方の状態をSucceededに設定する。

エージェントは、同じ土台を持つすべてのチェックリストの他のすべてのFrozen候補ペアの状態をWaitingに設定しなければならない(MUST)。

注：あるチェックリストの中で、同じファウンデーションを持つ候補ペアは、通常、異なるコンポーネントID値を持ちます。

7.2.5.3.4.指名フラグを更新する
制御エージェントがUSE-CANDIDATE属性を設定したBindingリクエストを送信し、ICEエージェントがリクエストに対する成功応答を受信した場合、エージェントはペアの指名フラグを真に設定する。リクエストが失敗した場合(セクション7.2.5.2)、エージェントは候補ペアを有効リストから削除し、候補ペアステートをFailedに設定し、チェックリストステートをFailedに設定しなければならない (MUST)。

被制御エージェントが送信したBindingリクエストに対する成功応答を受信し、そのBindingリクエストがUSE-CANDIDATE属性が設定された受信Bindingリクエストによってトリガーされた場合(セクション7.3.1.4)、エージェントはそのペアの指名フラッグを真にセットする。トリガーされたリクエストが失敗した場合、エージェントは候補ペアを有効リストから削除し、候補ペアのステートをFailedに設定し、チェックリストのステートをFailedに設定しなければならない (MUST)。

データストリームのあるコンポーネントに指名フラグが設定されると、そのコンポーネントの ICE 処理を終了する（8 章）。

7.2.5.4.チェックリストの状態更新
接続性チェックが成功したか失敗したかにかかわらず、チェックの完了に伴い、チェックリストの状態の更新が必要となる場合がある。チェックリスト集合の各チェックリストについて、候補ペアのすべてが失敗または成功のいずれかの状態にあり、チェックリストに関連するデータストリームの各コンポーネントについて有効なペアが有効リストに存在しない場合、チェックリストの状態は失敗とされる。有効リスト内の各コンポーネントに対して有効なペアがある場合、チェックリストの状態はSucceededに設定される。

7.3.STUNサーバーの手順
ICEエージェント（liteまたはfull）は、直近のCandidate交換に含まれる各CandidateをベースとしたBindingリクエストを受け取る準備をしなければならない（MUST）。

エージェントは、リクエストを認証し、メッセージの完全性チェックを実行するた めに、短期クレデンシャルメカニズム(すなわち、MESSAGE-INTEGRITY属性)を使用しな ければならない(MUST)。同様に、レスポンスにも短期クレデンシャルメカニズムを使用しなければならない(MUST)。エージェントは、ユーザー名がコロンで区切られた2つの値からなり、最初の値が進行中の セッションの候補交換でエージェントが生成したユーザー名の断片と等しい場合、 有効であるとみなさなければならない(MUST)。initiating agentが、ピアから候補を受け取る前にBindingリクエストを受け取ることは可能である(実際には非常に可能性が高い)。これが起こった場合、エージェントは直ちに応答を生成しなければならない (セクション7.3.1.2で述べられているように、マップされたアドレスの計算を含む)。エージェントはこの時点で、応答を生成するのに十分な情報を持っている; ピアからのパスワードは必要ない。すなわち、完全な実装についてはセクション7.3.1.3、7.3.1.4、および7.3.1.5を参照のこと）、必要な残りのステップを進めなければならない（MUST）。複数のSTUN要求が回答の前に受信される場合、これはトリガーチェックのキューに複数のペアがキューイングされる原因となるかもしれない。

エージェントはALTERNATE-SERVER機構を利用してはならず(MUST NOT)、RFC 5389で定義された後方互換機構(RFC 3489のプロトコルとの連携のため)をサポートしていない(MUST NOT)。エージェントはFINGERPRINT機構を利用しなければならない(MUST)。

エージェントがデータパケットにDSCPマーキング[RFC2475]を使用している場合、それはBindingレスポンスに同じマーキングを適用すべきです(SHOULD)。同じことが、エンドポイントがデータパケットに適用する可能性のあるあらゆるレイヤー2マーキングにも適用される。

7.3.1.フル実装のための追加手続き
このサブセクションでは、完全な実装がBinding要求を受け入れるときに、完全な実装に適用される追加のサーバ手順を定義する。

7.3.1.1.役割の衝突の検出と修復
ICEの特定の使用法（3PCCなど）では、両方のICEエージェントが同じ役割を選択することになり、役割の衝突が発生することがある。このセクションでは、役割の衝突を検出し修復するためのメカニズムについて説明する。このメカニズムが必要かどうかは、使用文書で指定しなければならない(MUST)。

エージェントは、ICE-CONTROLLINGまたはICE-CONTROLLED属性のいずれかについて、Bindingリクエスト を検査しなければならない(MUST)。それは以下の手順に従わなければならない(MUST)。

o エージェントが制御の役割にあり、ICE-CONTROLLING属性がリクエストに存在する場合。

* エージェントのタイブレーク値がICE-CONTROLLING属性の内容より大きいか等しい場合、エージェントはBindingエラー応答を生成し、値487（Role Conflict）のERROR-CODE属性を含むが、その役割は保持される。

エージェントのタイブレーク値がICE-CONTROLLING属性の内容より小さい場合、エージェントは制御された役割に切り替わります*。

o エージェントが管理された役割にあり、ICE-CONTROLLED属性がリクエストに存在する場合。

エージェントのタイブレーク値がICE-CONTROLLED属性の内容より大きいか等しい場合、エージェントは制御する役割に切り替わります*。

* エージェントのタイブレーク値がICE-CONTROLLED属性の内容より小さい場合、エージェントはBindingエラー応答を生成し、値487（Role Conflict）のERROR-CODE属性を含むが、その役割は保持される。

o エージェントが管理される役割で、ICE-CONTROLLING属性がリクエストに存在した場合、またはエージェントが管理する役割で、ICE-CONTROLLED属性がリクエストに存在した場合、競合はないです。

役割の変更は、優先順位が役割の関数であるため、エージェントはペアの優先順位を再計算する必要がある（セクション6.1.2.3）。役割の変更は、エージェントが指名されたペアを選択し、ICEの終了時に更新された候補情報との交換を開始する責任を負うかどうかにも影響する。

セクション7.3.1の残りのサブセクションは、エージェントが役割を変えたとしても、エージェントがバインディング要求に対して成功した応答を生成した場合に従います。

7.3.1.2.マッピングされたアドレスの計算
中継候補で受け取ったリクエストの場合、STUN処理(すなわち、XOR-MAPPED- ADDRESS属性の生成)に使用されるソーストランスポートアドレスは、TURNサーバーが見るトランスポートアドレスである。そのソーストランスポートアドレスは、BindingリクエストがData Indicationを通じて配信された場合、Data IndicationメッセージのXOR-PEER-ADDRESS属性に存在することになる。BindingリクエストがChannelDataメッセージを通して配信された場合、ソーストランスポートアドレスは、チャネルにバインドされたものである。

7.3.1.3.ピアリフレ候補の学習
リクエストのソーストランスポートアドレスが既存のリモート候補にマッチしない 場合、それは新しいピアリフレクティブリモート候補を表す。この候補は次のように構築される。

o タイプはピアリフレクティブです。

o 優先度は、BindingリクエストのPRIORITY属性の値である。

o 基盤は任意の値であり、他のすべてのリモート候補の基盤とは異なる。後続の候補交換にこのピアリフレックス候補が含まれていれば、その候補の実際の基盤を知らせることになる。

o コンポーネントIDは、リクエストの送信先であるローカル候補のコンポーネントIDである。

この候補は、リモート候補のリストに追加される。しかし、ICEエージェントはこのCandidateをローカルCandidateとペアリングすることはない。

7.3.1.4.トリガーチェック
次に、エージェントは、ローカル候補が、STUNリクエストを受信したトランス ポートアドレス(エージェントによって見られる)と、リクエストが来たソース トランスポートアドレスに等しいリモート候補(これは、ちょうど学習したピア リフレクティブリモート候補であるかもしれない)を持つペアを構築する。ローカル候補は、ホスト候補(リクエストがリレーを通して受け取られなかった場合)またはリレー候補(リレーを通して受け取られた場合)のいずれかになる。ローカル候補は、決してサーバー反射的な候補にはなり得ない。両方の候補がエージェントに知られているので、エージェントはそれらの優先順位を取得し、候補ペアの優先順位を計算することができる。そして、このペアはチェックリストで検索される。いくつかの結果のうちの1つがあり得る。

o ペアがすでにチェックリストに入っている場合。

* そのペアの状態がSucceededである場合、それ以上のことは何もしない。

* そのペアの状態がIn-Progressである場合、エージェントはIn-Progressトランザクションをキャンセルする。キャンセルは、エージェントが接続性チェックトランザクションに関連するBindingリクエストを再送せず、応答の欠如を失敗として扱わず、応答のためにトランザクションタイムアウトの期間を待つことを意味する。さらに、エージェントは、ペアの新しい接続性チェックをトリガーするために、 チェックリストに関連付けられたトリガーされたチェックリストにペアをエンキューし、 ペアのステートをWaitingに設定しなければならない[MUST]。新しい接続性チェックを作成することで、元の接続性チェックトランザクションに関連するBindingリクエストの再送を待つことなく、できるだけ早くIn-Progressペアを検証することができる。

* ペアの状態がWaiting、Frozen、またはFailedの場合、エージェントは、ペアの新しい接続性チェックをトリガーするために、チェックリストに関連付けられたトリガーされたチェックリストにペアをエンキューし（まだ存在しない場合）、ペアの状態をWaitingに設定しなければならない（MUST）。FailedからWaitingへのペアの状態変化は、関連するチェックリストの状態変化も引き起こすかもしれないことに注意。

これらの手順は、両エージェントがNATの後ろにいるときに、ICEを迅速に完了させるために行われるものです。

o ペアがチェックリストにまだ載っていない場合。

* ペアの優先順位に基づき、チェックリストに挿入されます。

* 状態は「待機中」となっています。

* ペアはトリガーチェックキューにエンキューされます。

トリガーされたチェックが送信される場合、それはセクション7.2.4で説明されるように構築され処理される。これらの手続きは、エージェントが相手のトランスポートアドレス、ユーザ名フラグメント、パスワードを知っていることを要求する。リモート候補のユーザー名フラグメントは、ちょうど受け取ったバインディングリクエストのUSERNAMEのコロン以降の部分と同じである。そのユーザ名フラグメントを使って、エージェントはピアから受け取った候補をチェックし（フォークの場合は複数あるかもしれません）、このユーザ名フラグメントを見つけることができます。そして、対応するパスワードが選ばれます。

7.3.1.5.指名フラグを更新する
被制御エージェントがUSE-CANDIDATE属性を設定したBinding要求を受信し、ICEエージェントがその要求を受け入れた場合、セクション7.3.1.4で計算されたペアの状態に基づいて以下のアクションを行う。

o このペアの状態がSucceededである場合、このペアによって以前に送信されたチェックが成功した応答を生成し、有効なペアを生成したことを意味する（7.2.5.3.2項）。エージェントは、有効なペアの指名フラグ値を真に設定する。

o 受信したバインディングリクエストがトリガーされ、トリガーチェックキュー(セクション7.3.1.4)にエンキューされる新しいチェックを引き起こした場合、チェックが送信され、それが成功応答を生成し、有効ペアを生成すれば、エージェントはそのペアの指名フラッグを真に設定する。リクエストが失敗した場合(セクション7.2.5.2)、エージェントは候補ペアを有効リストから削除し、候補ペアステートをFailedに設定し、チェックリストステートをFailedに設定しなければならない (MUST)。

被制御エージェントがコントロールエージェントからの要求を受け入れない場合、被制御エージェントは適切なエラーコード応答(例えば400)[RFC5389]でノミネーション要求を拒否しなければならない(MUST)。

データストリームのあるコンポーネントに対して指名フラグが設定されると、そのコンポーネントの ICE 処理を終了する。セクション8を参照。

7.3.2.Lite 実装のための追加手順
被制御エージェントは、USE-CANDIDATE属性が設定されたBindingリクエストを受信し、 ICEエージェントがそのリクエストを受け入れる場合、ローカル候補がリクエストを受信した トランスポートアドレスを持ち、リモート候補が受信したリクエストのソーストランスポート アドレスと等しい候補ペアを構築する。この候補ペアは、任意の優先度を割り当てられ、関連するチェックリストの有効リストに配置される。エージェントは、そのペアの指名フラグを真に設定する。

データストリームのあるコンポーネントに対して指名フラグが設定されると、そのコンポーネントの ICE 処理を終了する。セクション8を参照。

8.ICE処理を終了する
ICE エージェントが ICE を完了させる方法について説明します。

8.1.フル実装のための手続き
ICEの終了には、制御エージェントによるペアの指名と、ステートマシンの更新が必要です。

8.1.1.ペアを指名する
ノミネートの前に、制御エージェントは、ある停止基準が満たされるまで、接続性チェックを継続させる。その後、評価基準に基づいて、制御エージェントは、指名のために、有効なリスト内の有効なペアの中からペアを選択する。

制御エージェントが指名のために有効なペアを選ぶと、この有効なペアを生成した接続性チェックを（チェックを生成したペアをtriggered-checkキューに入れることによって）、今度はUSE-CANDIDATE属性（セクション7.2.5.3.4）で繰り返し行う。被制御エージェントの手続きは、7.3.1.5節に記述されている。

最終的に、指名が成功すれば、制御エージェントと被制御エージェントの両方が、データストリームの各コンポーネントの有効リストに1つの指名ペアを持つことになる。ICEエージェントがチェックリストの状態をCompletedに設定すると（データストリームの各コンポーネントに指名ペアがある場合）、そのペアはそのエージェントの選択ペアとなり、データストリームのそのコンポーネントに対するデータの送受信に使用される。

エージェントがデータストリームの各コンポーネントに対して選択されたペアを生成できない場合、エージェントは、例えばストリームを削除するなど、他のエージェントに通知するための適切なアクションを取らなければならない（MUST）。正確なアクションは、この仕様の範囲外である。

接続性チェックを停止する基準や、推薦するペアを選ぶ基準は、この仕様の範囲外である。それらは局所最適化の問題である。唯一の要件は、エージェントが最終的に1つの候補ペアを選び、USE-CANDIDATE属性セットでそのペアに対するチェックを生成しなければならない(MUST)ということである。

制御エージェントが候補ペアの指名に成功したら(セクション7.2.5.3.4)、エージェントはICEセッション内でデータストリームの同じコンポーネントに別のペアを指名してはならない (MUST NOT)。そうすると、ICEの再起動が必要となる。

本仕様をサポートしていない（すなわち、RFC5245に従って実装されている）制御エージェントは、複数の候補ペアを指名する可能性がある。これはRFC5245では "aggressive nomination "と呼ばれていた。複数の候補ペアが制御エージェントによって指名され、制御エージェントが複数の指名要求を受け入れる場合、エージェントは選択されたペアを生成し、最も高い優先順位を持つペアを使用しなければならない（MUST）。

本仕様をサポートするエンドポイントによるICEオプション「ice2」（第10項）の使用は、RFC5245に従って実装されたコントロールエージェントが攻撃的な指名を使用することを防ぐと考えられる。

注：RFC5245では、"aggressive nomination "の使用により、ペアが最終的に選択される前に、ペアのデータ送信を許可するために、エージェントが継続的にペアを指名することができた。本仕様では、指名をしなくても、有効なペアであれば常にデータを送信することができる。したがって、積極的な指名の必要性はもはやない。

8.1.2.チェックリストとICEステートを更新する
制御側、被制御側ともに、あるデータストリームの構成要素の候補ペアが指名されると、そのデータストリームに関連するチェックリストの他のペアに影響を与える可能性がある。また、チェックリストの状態にも影響を与える可能性がある。

o データストリームのコンポーネントの候補ペアが指名され、データストリームに関連する チェックリストの状態が実行中である場合、ICEエージェントは、同じコンポーネントの すべての候補ペアをチェックリストおよびトリガーチェック待ち行列から削除しなければ ならない[MUST]。ペアの状態がIn-Progressである場合、エージェントはIn-Progressトランザクションをキャンセ ルする。キャンセルは、エージェントが接続性チェックトランザクションに関連するBindingリクエストを再送せず、応答の欠如を失敗として扱わず、応答のためにトランザクションタイムアウトの期間を待つことを意味する。

o データストリームの各コンポーネントの候補ペアが指名され、データストリームに関連する チェックリストの状態が「実行中」になると、ICEエージェントは、チェックリストの状態を「完了」 に設定する。

o データストリームのコンポーネントの候補ペアが指名されると、エージェントは、指名されたペアと、データストリームに関連するチェックリストの残りの候補ペアのために、まだ受け取るかもしれないBindingリクエストに応答し続けなければならない (MUST)。セクション7.3.1.4で定義されているように、ペアの状態がSucceededであるとき、エージェントはそのペアに対するBinding要求を受信したときに、もはやトリガーされたチェックを生成しない。

チェックリストセットの各チェックリストの状態がCompletedになると、エージェントはICEセッションの状態をCompletedに設定する。

チェックリストの状態が「Failed」の場合、ICEはチェックリストに関連するデータストリームの処理を正常に完了することができませんでした。正しい動作は、チェックリストセット内のチェックリストの状態によって異なります。制御するエージェントが、失敗したチェックリストに関連するデータストリームなしでセッションを継続したい場合、および実行中または完了モードのチェックリストがまだ1つ以上ある場合、エージェントはICEの処理を継続させることができます。エージェントは、失敗したデータストリームを削除するための適切なアクションを取らなければならない（MUST）。制御するエージェントがセッションの継続を望まず、セッションを終了しなければならない場合、ICEセッションの状態はFailedに設定される。

チェックリストセットの各チェックリストの状態がFailedである場合、ICEセッションの状 態はFailedに設定される。制御エージェントは、データストリームなしでセッションを継続することを望まない限り、セッションを終了しなければならない(MUST)。

8.2.Lite実装のための手順
ICEが終了すると、8.3節で説明したように、lite ICEエージェントはICEで使用されなかったホスト候補を解放することができます。

ピアがフルエージェントである場合、ライトエージェントが候補ペアの指名要求を受け付けると、ライトエージェントはそのペアが指名されたとみなす。データストリームの各コンポーネントに対して指名されたペアが存在すると、そのペアはデータストリームのコンポーネントのための選択されたペアになる。ライトエージェントがすべてのデータストリームのすべてのコンポーネントに対して選択されたペアを生成すると、ICEセッションの状態がCompletedに設定される。

ピアがライトエージェントの場合、エージェントはローカル候補と、同じデータストリームの、同じコンポーネント、トランスポートプロトコル、IPアドレスファミリーを持つリモート候補をペアリングする。各データストリームの各コンポーネントについて、候補ペアが1つしかない場合、そのペアが有効リストに追加される。複数のペアがある場合、エージェントはRFC6724[RFC6724]の手順に従ってペアを選択し、有効なリストに追加することが推奨される(RECOMMENDED)。

すべてのデータストリームのすべてのコンポーネントが1つのペアを持っていた場合、ICE処理の状態はCompletedとなる。そうでない場合、制御エージェントは、異なる候補ペアを選択する異なるエージェントを調整するために、更新された候補リストを送信しなければならない(MUST)。ICE 処理は、更新された候補の交換が完了した後、そしてその後にのみ完了する。

8.3.Candidateを解放する
8.3.1.完全実施手順
このセクションのルールは、エージェントが選択候補にならなかった（つまり、選択されたペアと関連していない）Candidateのチェックの送受信を停止しても安全な場合、およびCandidateを解放する場合について説明します。

チェックリストがCompleted状態になったら、エージェントはさらに3秒待つべきで、その後、選択された候補になった候補以外のすべてのローカル候補のチェックへの応答またはトリガーされたチェックの生成を停止することができます。すべてのICEセッションが特定のローカル候補を使用しなくなったら（候補は、フォークシナリオなどで複数のICEセッションによって使用されることがあります）、エージェントはその候補を解放することができます。3秒の遅延は、積極的な指名が行われた場合に対応するもので、ICEが完了した後に選択されたペアがすぐに変更されることがあります。

サーバ反射候補の解放は明示的に行われることはなく、キープアライブの欠如によって行われる。

8.3.2.Lite導入手順
Lite実装では、ICE処理が、その候補を使用するすべてのICEセッションのCompleted状態に達した時点で、選択候補にならなかった候補を解放できる。

9.ICEリスタート
ICEエージェントは、既存のデータストリームに対してICEを再起動してもよい(MAY)。ICEの再起動によって、エージェントの役割を除くデータストリームの以前の状態がすべてフラッシュされる。ICEの再起動と全く新しいデータセッションの唯一の違いは、再起動中に既存のデータセッションを使用してデータを送信し続けることができることであり、新しいデータセッションは常にロールを決定することを必要とする。

以下のアクションは、ICE再起動を使用することによってのみ達成することができます（エージェントはそのためにICE再起動を使用しなければなりません）。

o データストリームの送信先を変更する。

o ライトな実装からフルな実装に変更する。

o フル実装からライト実装への変更。

ICEを再起動するために、エージェントは、再起動されるデータストリームのパスワードとユーザー名フラグメントの両方を変更しなければなりません（MUST）。

ICEが再起動されると、新しいICEセッションの候補セットには、現在のICEセッションで使用された候補の一部、ゼロ、またはすべてが含まれるかもしれません。

セクション6.1.1に記載されているように、エージェントは、役割を再決定する必要がある特定の基準が満たされない限り、ICEリスタートの一部として役割を再決定してはならない（MUST NOT）。

10.ICEオプション
本節では、新しいICEオプションである「ice2」を定義する。ICEエージェントが候補交換に「ice2」を含める場合、ICEオプションは本仕様に準拠することを示す。例えば、エージェントはRFC5245で定義されている攻撃的な指名手順を使用しない。また、RFC5245に準拠するピアは、未知のICEオプションを受信するピアに対してRFC5245のセクション14で要求されるように、攻撃的な指名を使用しないことを保証することになる。

この仕様に準拠したエージェントは，'ice2'オプションを使用して，準拠についてピアに通知しなければならない（MUST）。

注: 'ice2'オプションのエンコーディングと、それをピアに伝えるために使用されるメッセ ージは、プロトコル固有である。SDP[RFC4566]のエンコーディングは、[ICE-SIP-SDP]で定義されている。

11.キープアライブ
すべてのエンドポイントは、各データセッションに対してキープアライブを送信しなければならない(MUST)。これらのキープアライブは、データセッションのためにNATバインディングを維持する目的で使用される。キープアライブは、ピアでサポートされているフォーマットを使用して送信されるべきです (SHOULD)。ICEエンドポイントは、UDPストリームに対してSTUNベースのキープアライブを許可している。そのため、ICEエージェントが完全なICE実装で、ICEをサポートするピア(liteまたはfull)と通信する場合、STUNキープアライブを使用しなければならない (MUST)。

エージェントは、データ送信に使用される各候補ペアで、過去Tr秒間にそのペアでパケットが送信されていない場合、キープアライブを送信しなければなりません(MUST)。エージェントは15秒のTr値を使うべきである(SHOULD)。エージェントはもっと大きな値を使ってもよいが、15秒より小さい値を使うべきではない(MUST NOT)。

データストリームのために選択されたペアが生成されると、キープアライブはそれらのペアにのみ送信されます。

エージェントは、データストリームが削除された場合、データストリームのキープアライブ送信を停止しなければならない(MUST)。ICEセッションが終了した場合、エージェントはすべてのデータストリームのキープアライブの送信を停止しなければならない(MUST)。

エージェントは、設定やネットワーク/NATの特性などに基づいて、Trに別の値 を使用してもよい[MAY]。例えば、エージェントが間にあるNATのバインディング寿命を発見する動的な方法を持つ場合、Trを決定するためにその値を使用することができる。より制御されたネットワーク環境でICEを展開する管理者は、その環境で可能な限り長い期間をTrに設定するべきである[SHOULD]。

STUNがキープアライブに使用される場合、STUN Binding Indicationが使用される [RFC5389]。この表示は、いかなる認証メカニズムも利用してはならない[MUST NOT]。それは、デマルチプレクスを助けるためにFINGERPRINT属性を含むべきで あるが、他の属性を含むべきでない(SHOULD NOT)。それは、NATバインディングを維持するためだけに使用される。Binding Indicationは、データ用に使用されているのと同じローカル候補とリモート候補を使用して送信されます。バインディングインジケーションはキープアライブのために使用されるが、エージェントは 接続性チェックも受信できるように準備しなければならない(MUST)。接続性チェックを受信した場合、[RFC5389]で議論されているように応答が生成されるが、それ以外のICE処理には何の影響もない。

エージェントは、デフォルトでSTUNキープアライブを使用しなければならない(MUST)。個々のICE使用法とICE拡張は、使用法/拡張固有のキープアライブを指定してもよい（MAY）。

12.データの取り扱い
12.1.データの送信
ICEエージェントは、データストリームのために選択されたペアが生成される前に、任意の有効なペアでデータを送信してもよい（MAY）。

データストリームのために選択されたペアが生成されたら、エージェントはそれらのペアのデータのみを送信しなければならない（MUST）。

エージェントは、ローカル候補の基地からリモート候補にデータを送信する。ローカル中継候補の場合、[RFC5766]で定義された手順で、（TURNサーバにある）ベースを通してデータが転送される。

ローカル候補が中継候補である場合、エージェントはTURNサーバー上でリモート候補に向けたチャンネルを作成することが推奨される(RECOMMENDED)。これは、[RFC5766]のセクション11で定義されているチャネル作成の手順を使用して行われる。

データストリームの構成要素に対して選択されたペアは、以下の通りです。

o そのデータストリームのチェックリストの状態が「実行中」であり、ICEの再起動によりそのコンポーネントに対して以前に選択されたペアがない場合は空白となる。

o データストリームのコンポーネントのチェックリストの状態が「実行中」であり、ICEの再起動によりそのコンポーネントに以前の選択されたペアが存在する場合、そのペアに等しいこと。

エージェントがデータストリームに関連する各コンポーネントの選択されたペアを生成することができない限り、エージェントはそのデータストリームに関連するどのコンポーネントについてもデータの送信を継続してはならない（MUST NOT）。

12.1.1.Lite実装のための手順
lite実装は、そのデータストリームの各コンポーネントの候補ペアを含む有効なリストができ るまで、データを送信してはならない(MUST NOT)。それが実現したら、ICEエージェントはデータパケットの送信を開始してもよい(MAY)。そのためには、ペアのリモート候補にデータを送信し(パケットの宛先アドレスとポートをそのリモート候補に等しく設定する)、データ送信に使用した候補ペアに関連するベースからデータを送信することになる。中継候補の場合、データはエージェントから送信され、[RFC5766]で定義された手順で、（TURNサーバにある）ベースを通して転送される。

12.2.データの受信
ICEエージェントは、有効な候補ペアを使用してデータを送信することだけが許されている（そして、選択されたペアが生成されると、選択されたペアにのみ）にもかかわらず、ICEの実装は、デフォルトで、ピアとの最新の候補交換で提供された任意の候補でデータを受け取る準備をすべきです（SHOULD）」。例えば、データストリームで選択されたペアが生成されるまでデータを送信しないと定義するなど、ICEの使用法はこれと異なるルールを定義してもよい（MAY）。

エージェントが特定のRTP/RTCPデータストリームの新しいソースまたはデスティネーションIPアドレスを持つRTPパケットを受信した場合、エージェントはそのジッターバッファを再調整することが推奨されます（RECOMMENDED）。

RFC3550[RFC3550]のセクション8.2は、同期ソース（SSRC）の衝突とループを検出するためのアルゴリズムを記述しています。これらのアルゴリズムは、部分的には、同じSSRCを持つ異なるソーストランスポートアドレスを見ることに基づいている。しかし、ICEが使用される場合、データストリームが候補間で切り替わるため、そのような変化が時々発生する。エージェントは、メディアデータ伝送を進めるSTUN交換の結果として、データストリームが同じピアからのものであると判断することができるだろう。したがって、送信元トランスポートアドレスに変更があっても、メディアデータパ ケットが同じピアエージェントから来た場合、これはSSRC衝突として扱ってはならない (MUST NOT)。

13.拡張性についての考慮事項
この仕様では、セッション内の両方のICEエージェントが、データのために選択される候補ペアのセットに到達するためにどのように調整するかについて、非常に具体的な選択を行っています。将来の仕様では、タイマーの微調整のような単純な変更であれ、優先順位アルゴリズムの改良のような大きな変更であれ、これらのアルゴリズムを変更したいと思うことが予想される。このような変更が行われた場合、セッション内の2つのエージェント間で相互運用性を提供することが重要です。

まず、ICEはICEオプションの概念を提供しています。ICEの各拡張または変更には、ICEオプションが関連付けられている。エージェントがそのような拡張や変更をサポートする場合、候補交換の一部として、ICEオプションを相手エージェントに提供する。

相互運用性を実現するための複雑さの一つは、ICEが、合意された候補ペアのセットに収束するために、両方のエージェント上で動作する分散アルゴリズムに依存していることです。2つのエージェントが異なるアルゴリズムを実行している場合、同じ候補ペアへの収束を保証することは困難である。セクション8で説明する指名手続きは、選択アルゴリズムを完全に制御エージェントに委ねることで、緊密な調整の必要性をある程度排除し、ICEは、両エージェントが異なるペア優先順位付けアルゴリズムを使用しても、完全に収束する。このような収束の鍵の一つは、推薦されたペアが両方のエージェントによって検証されることを保証するトリガーチェックである。

ICEは、RTP以外のデータストリームや、UDP以外のトランスポートプロトコルにも拡張可能である。RTP以外のデータストリームのためのICEの拡張は、利用するコンポーネン トの数を指定し、最も重要なコンポーネントIDを1として、コンポーネントに 割り当てる必要がある。新しいトランスポートプロトコルの仕様では、ICE処理のさまざまなステップが UDPと異なる場合、その方法を定義しなければならない[MUST]。

14.TaとRTOを設定する
14.1.一般的な
ICE収集フェーズ（セクション5.1.1）およびICEが接続性チェック（セクション7）を実行している間、ICEエージェントはSTUNおよびTURNトランザクションをトリガーします。これらのトランザクションはTaで示されるレートでペースが設定され、各トランザクションの再送間隔はSTUNトランザクションの再送タイマー（RTO）［RFC5389］に基づき計算される。

このセクションでは、ICEの収集段階とICEが接続性チェックを実行している間に、TaとRTOの値がどのように計算されるかを説明します。

注：以前、RFC 5245では、ICEがリアルタイムデータストリーム（RTPなど）に使用されるかどうかに応じて、TaとRTOを計算するための異なる計算式が定義されていた。

以下の式は、エージェントが再送を実行する前に、接続性チェックのたびに最初のパケットを送信する動作になります。これは、RTO（再送間隔を表す）の計算式で見ることができます。これらの式は、実行されるチェックの数であるNによって変化します。この結果、ICEはきれいに一定のレートを維持しますが、パケットロスには敏感になります。接続性チェックの最初の1パケットが失われると、そのペアの検証には長い時間がかかり、代わりに優先度の低いチェック（ただしパケット損失がないもの）が先に完了する可能性が高くなります。その結果、ICEは、優先順位の高いペアよりも低いペアを選択し、最適でない動作をすることになります。

14.2.Ta
ICEエージェントは、デフォルトのTa値である50msを使用すべきであるが、関連するデータの特性に基づき、別の値を使用してもよい（MAY）。

エージェントがデフォルト値以外のTa値を使用したい場合、エージェントはICEセッションの確立中に提案値をピアに示さなければならない(MUST)。両エージェントは、提案された値のうち高い方の値を使用しなければならない（MUST）。エージェントが値を提案しない場合、どちらの値が高いかを比較するときは、そのエージェントのデフォルト値が使用される。

各エージェントに選択されたTa値にかかわらず、すべてのエージェントからのすべてのトランザクションの組み合わせは、（ある実装が複数のエージェントを同時に実行する場合）5msに1回より頻繁に送信してはならない（あたかもすべてのエージェントのペースのための1つのグローバルTa値が存在するように）。ICEで5msという値を使用する背景については、付録B.1を参照。

注：付録Cは、異なるTa値を使用した場合の必要帯域幅の例です。

14.3.RTO
ICE収集フェーズにおいて、ICEエージェントは、以下の式を用いてRTO値を計算するべきである（SHOULD）。

     RTO = MAX (500ms、Ta * (Num-Of-Cands))        
Num-Of-Cands：サーバー・リフレックス・リレー候補の数

接続性チェックの場合、エージェントは、以下の式を用いてRTO値を計算すべきである（SHOULD）。

     RTO = MAX (500ms, Ta * N * (待ち受け数 + 進行中数))        
N：実行するコネクティビティチェックの総数。

Num-Waiting：Waiting状態に設定されたチェックリストのチェックの数です。

Num-In-Progress：In-Progress状態にあるチェックリストセットのチェックの数です。

なお、Waiting状態やIn-Progress状態のチェックの数が変わると、RTOはトランザクションごとに異なることに注意してください。

エージェントは、上記以外のメカニズムを使用してRTO値を計算してもよい(MAY)。エージェントは500msより小さいRTO値を使用してはならない(MUST NOT)。

15.例
ここでは、IPv4アドレスを使用したICEと、IPv6アドレスを使用したICEの2つの例を紹介します。

理解を容易にするため、トランスポートアドレスは、ニーモニック名を持つ変数を使用して一覧表示される。名前の形式は、entity-type-seqnoである。「entity」は、トランスポートアドレスが載っている IPアドレスのエンティティを指し、「L」、「R」、「STUN」、「NAT」のいずれ かである。タイプは、パブリックなトランスポートアドレスの場合は「PUB」、プライベー トなトランスポートアドレスの場合は「PRIV」のいずれかである[RFC1918]。最後に

seq-noは、特定のエンティティ上の同じタイプのトランスポートアドレスごとに異なるシーケンス番号である。各変数はIPアドレスとポートを持ち、それぞれvarname.IPとvarname.PORTで示され、varnameは変数名である。

コールフロー自体では、STUNメッセージはいくつかの属性で注釈される。S=」属性は、メッセージのソーストランスポートアドレスを示す。D=」属性は、メッセージのデスティネーション・トランスポート・アドレスを示す。MA=」属性は、STUNバインディング応答メッセージで使用され、マッピングされたアドレスを参照する。"USE-CAND "属性は、USE-CANDIDATE属性の存在を意味する。

コールフロー例では、STUN認証操作を省略し、2つの完全な実装間の単一のデータストリームに焦点を当てます。

15.1.IPv4アドレスでの例
以下の例では、図7に示すトポロジーを使用しています。


                                  +-------+
                                  |STUN   |
                                  |Server |
                                  +-------+
                                      |
                           +---------------------+
                           |                     |
                           |      Internet       |
                           |                     |
                           +---------------------+
                             |                |
                             |                |
                      +---------+             |
                      |   NAT   |             |
                      +---------+             |
                           |                  |
                           |                  |
                        +-----+            +-----+
                        |  L  |            |  R  |
                        +-----+            +-----+

図7：トポロジーの例

この例では、ICEエージェントLとRは、完全なICE実装です。両エージェントは1つのIPv4アドレスを持ち、どちらも同じSTUNサーバーで構成されています。NATは、エンドポイントに依存しないマッピングプロパティとアドレスに依存するフィルタリングプロパティを持ちます。ICEエージェント、STUNサーバー、およびNATのIPアドレスを以下に示す。

  ENTITY                   IP Address  Mnemonic name
   --------------------------------------------------
   ICE Agent L:             10.0.1.1    L-PRIV-1
   ICE Agent R:             192.0.2.1   R-PUB-1
   STUN Server:             192.0.2.2   STUN-PUB-1
   NAT (Public):            192.0.2.3   NAT-PUB-1


             L             NAT           STUN             R
             |STUN alloc.   |              |              |
             |(1) STUN Req  |              |              |
             |S=$L-PRIV-1   |              |              |
             |D=$STUN-PUB-1 |              |              |
             |------------->|              |              |
             |              |(2) STUN Req  |              |
             |              |S=$NAT-PUB-1  |              |
             |              |D=$STUN-PUB-1 |              |
             |              |------------->|              |
             |              |(3) STUN Res  |              |
             |              |S=$STUN-PUB-1 |              |
             |              |D=$NAT-PUB-1  |              |
             |              |MA=$NAT-PUB-1 |              |
             |              |<-------------|              |
             |(4) STUN Res  |              |              |
             |S=$STUN-PUB-1 |              |              |
             |D=$L-PRIV-1   |              |              |
             |MA=$NAT-PUB-1 |              |              |
             |<-------------|              |              |
             |(5) L's Candidate Information|              |
             |------------------------------------------->|
             |              |              |              | STUN
             |              |              |              | alloc.
             |              |              |(6) STUN Req  |
             |              |              |S=$R-PUB-1    |
             |              |              |D=$STUN-PUB-1 |
             |              |              |<-------------|
             |              |              |(7) STUN Res  |
             |              |              |S=$STUN-PUB-1 |
             |              |              |D=$R-PUB-1    |
             |              |              |MA=$R-PUB-1   |
             |              |              |------------->|



Keranen, et al.              Standards Track                   [Page 61]

RFC 8445                           ICE                         July 2018


             |(8) R's Candidate Information|              |
             |<-------------------------------------------|
             |              |         (9) Bind Req        |Begin
             |              |         S=$R-PUB-1          |Connectivity
             |              |         D=$L-PRIV-1         |Checks
             |              |         <-------------------|
             |              |         Dropped             |
             |(10) Bind Req |              |              |
             |S=$L-PRIV-1   |              |              |
             |D=$R-PUB-1    |              |              |
             |------------->|              |              |
             |              |(11) Bind Req |              |
             |              |S=$NAT-PUB-1  |              |
             |              |D=$R-PUB-1    |              |
             |              |---------------------------->|
             |              |(12) Bind Res |              |
             |              |S=$R-PUB-1    |              |
             |              |D=$NAT-PUB-1  |              |
             |              |MA=$NAT-PUB-1 |              |
             |              |<----------------------------|
             |(13) Bind Res |              |              |
             |S=$R-PUB-1    |              |              |
             |D=$L-PRIV-1   |              |              |
             |MA=$NAT-PUB-1 |              |              |
             |<-------------|              |              |
             |Data          |              |              |
             |===========================================>|
             |              |              |              |
             |              |(14) Bind Req |              |
             |              |S=$R-PUB-1    |              |
             |              |D=$NAT-PUB-1  |              |
             |              |<----------------------------|
             |(15) Bind Req |              |              |
             |S=$R-PUB-1    |              |              |
             |D=$L-PRIV-1   |              |              |
             |<-------------|              |              |
             |(16) Bind Res |              |              |
             |S=$L-PRIV-1   |              |              |
             |D=$R-PUB-1    |              |              |
             |MA=$R-PUB-1   |              |              |
             |------------->|              |              |
             |              |(17) Bind Res |              |
             |              |S=$NAT-PUB-1  |              |
             |              |D=$R-PUB-1    |              |
             |              |MA=$R-PUB-1   |              |
             |              |---------------------------->|
             |Data          |              |              |
             |<===========================================|
             |              |              |              |
                                .......
             |              |              |              |
             |(18) Bind Req |              |              |
             |S=$L-PRIV-1   |              |              |
             |D=$R-PUB-1    |              |              |
             |USE-CAND      |              |              |
             |------------->|              |              |
             |              |(19) Bind Req |              |
             |              |S=$NAT-PUB-1  |              |
             |              |D=$R-PUB-1    |              |
             |              |USE-CAND      |              |
             |              |---------------------------->|
             |              |(20) Bind Res |              |
             |              |S=$R-PUB-1    |              |
             |              |D=$NAT-PUB-1  |              |
             |              |MA=$NAT-PUB-1 |              |
             |              |<----------------------------|
             |(21) Bind Res |              |              |
             |S=$R-PUB-1    |              |              |
             |D=$L-PRIV-1   |              |              |
             |MA=$NAT-PUB-1 |              |              |
             |<-------------|              |              |
             |              |              |              |

        
図8：フロー例

メッセージ1～4エージェントLは、ローカルIPアドレスからホスト候補を収集し、そこからSTUNサーバにSTUN Bindingリクエストを送信する。このリクエストにより、NATバインディングが作成される。バインディングのNATパブリックIPアドレスがエージェントLのサーバリフレクティブ候補となる。

メッセージ 5．エージェントLは、ICE利用に関連するシグナリングプロトコルを使用して、エージェントRにローカル候補情報を送信する。

メッセージ6-7：エージェントRは、そのローカルIPアドレスからホスト候補を収集し、そこからSTUNサーバにSTUNバインディング要求を送信します。エージェントRはNATの後ろにいないので、Rのサーバ反射候補はホスト候補と同じになる。

メッセージ 8．エージェントRは、ICEの使用法に関連するシグナリングプロトコルを使用して、エージェントLにローカル候補情報を送信する。

両エージェントはICEの完全な実装であるため、initiating agent（エージェントL）が制御エージェントになる。

エージェントLとRは、ともにCandidateをペアリングする。両エージェントとも、最初は2つのペアを持つ。しかし、エージェントLは、そのサーバー反射候補を含むペアを刈り込み、1つだけ(L1)にします。エージェントLでは、このペアはローカル候補$L_PRIV_1とリモート候補$R_PUB_1を持つ。エージェントRでは、2つのペアが存在する。最優先のペア（R1）は、ローカル候補が$R_PUB_1、リモート候補が$L_PRIV_1であり、2番目のペア（R2）は、ローカル候補が$R_PUB_1、リモート候補が$NAT_PUB_1とする。そのペアを以下に示す（ペア番号は参考値です）。

                            Pairs
   ENTITY                   Local         Remote     Pair #     Valid
   ------------------------------------------------------------------
   ICE Agent L:             L_PRIV_1      R_PUB_1       L1

   ICE Agent R:             R_PUB_1       L_PRIV_1      R1
                            R_PUB_1       NAT_PUB_1     R2

メッセージ9エージェントRは、ペア#2の接続性チェックを開始した。このペアのリモート候補はエージェントLのプライベートアドレスであるため、RからLへリクエストをルーティングすることができず、チェックは成功せず、ネットワークによってドロップされる。

メッセージ 10-13エージェント L は、ペア L1 の接続性チェックを開始した。チェックは成功し、Lは新しいペア(L2)を作成する。新しいペアのローカル候補は$NAT_PUB_1であり、リモート候補は$R_PUB_1である。エージェントLは、希望すればペア(L2)上でデータの送受信ができるようになった。

                            Pairs
   ENTITY                   Local         Remote     Pair #     Valid
   ------------------------------------------------------------------
   ICE Agent L:             L_PRIV_1      R_PUB_1       L1
                            NAT_PUB_1     R_PUB_1       L2        X

   ICE Agent R:             R_PUB_1       L_PRIV_1      R1
                            R_PUB_1       NAT_PUB_1     R2

メッセージ14～17エージェントRがエージェントLからバインディング要求（メッセージ11）を受け取ると、トリガーによる接続性チェックを開始する。ペアは、エージェントRの既存のペア(R2)の1つと一致する。チェックは成功し、ペア(R2)はエージェントRの有効リストに追加される。エージェントRは、希望すればペア(R2)でデータを送受信できるようになった。

                            Pairs
   ENTITY                   Local         Remote     Pair #     Valid
   ------------------------------------------------------------------
   ICE Agent L:             L_PRIV_1      R_PUB_1       L1
                            NAT_PUB_1     R_PUB_1       L2        X

   ICE Agent R:             R_PUB_1       L_PRIV_1      R1
                            R_PUB_1       NAT_PUB_1     R2        X
メッセージ18～21ある時点で、制御エージェント(エージェントL)は、有効リストにあるペア(L2)を指名することを決定する。ペア(L2)の接続性チェックを行い、バインディングリクエストにUSE-CANDIDATE属性を含む。チェックが成功すると、エージェントLはペア(L2)の指名フラグ値を「真」に設定し、エージェントRはマッチするペア(R2)の指名フラグ値を「真」に設定する。このストリームに関連するコンポーネントがなくなったため、指名されたペアが選択されたペアとなる。その結果、このストリームの処理はCompleted状態に移行する。また、ICE処理もCompleted状態に移行する。

15.2.IPv6アドレスを使用した例
以下の例では、図9に示すトポロジーを使用しています。

                                +-------+
                                |STUN   |
                                |Server |
                                +-------+
                                    |
                         +---------------------+
                         |                     |
                         |      Internet       |
                         |                     |
                         +---------------------+
                            |                |
                            |                |
                            |                |
                            |                |
                            |                |
                            |                |
                            |                |
                         +-----+          +-----+
                         |  L  |          |  R  |
                         +-----+          +-----+
図9：トポロジーの例

この例では、ICEエージェントLとRは、完全なICE実装です。両エージェントは1つのIPv6アドレスを持ち、どちらも同じSTUNサーバーで構成されています。ICEエージェントとSTUNサーバーのIPアドレスは以下の通りです。

   ENTITY                   IP Address  mnemonic name
   --------------------------------------------------
   ICE Agent L:             2001:db8::3   L-PUB-1
   ICE Agent R:             2001:db8::5   R-PUB-1
   STUN Server:             2001:db8::9   STUN-PUB-1


             L                           STUN             R
             |STUN alloc.                  |              |
             |(1) STUN Req                 |              |
             |S=$L-PUB-1                   |              |
             |D=$STUN-PUB-1                |              |
             |---------------------------->|              |
             |(2) STUN Res                 |              |
             | S=$STUN-PUB-1               |              |
             | D=$L-PUB-1                  |              |
             | MA=$L-PUB-1                 |              |
             |<----------------------------|              |
             |(3) L's Candidate Information|              |
             |------------------------------------------->|
             |                             |              | STUN
             |                             |              | alloc.
             |                             |(4) STUN Req  |
             |                             |S=$R-PUB-1    |
             |                             |D=$STUN-PUB-1 |
             |                             |<-------------|
             |                             |(5) STUN Res  |
             |                             |S=$STUN-PUB-1 |
             |                             |D=$R-PUB-1    |
             |                             |MA=$R-PUB-1   |
             |                             |------------->|
             |(6) R's Candidate Information|              |
             |<-------------------------------------------|
             |(7) Bind Req                 |              |
             |S=$L-PUB-1                   |              |
             |D=$R-PUB-1                   |              |
             |------------------------------------------->|
             |(8) Bind Res                 |              |
             |S=$R-PUB-1                   |              |
             |D=$L-PUB-1                   |              |
             |MA=$L-PUB-1                  |              |
             |<-------------------------------------------|
             |Data                         |              |
             |===========================================>|
             |                             |              |
             |(9) Bind Req                 |              |
             |S=$R-PUB-1                   |              |
             |D=$L-PUB-1                   |              |
             |<-------------------------------------------|
             |(10) Bind Res                |              |
             |S=$L-PUB-1                   |              |
             |D=$R-PUB-1                   |              |
             |MA=$R-PUB-1                  |              |
             |------------------------------------------->|
             |Data                         |              |
             |<===========================================|
             |                             |              |
                                .......
             |                             |              |
             |(11) Bind Req                |              |
             |S=$L-PUB-1                   |              |
             |D=$R-PUB-1                   |              |
             |USE-CAND                     |              |
             |------------------------------------------->|
             |(12) Bind Res                |              |
             |S=$R-PUB-1                   |              |
             |D=$L-PUB-1                   |              |
             |MA=$L-PUB-1                  |              |
             |<-------------------------------------------|
             |              |              |              |

図10：フロー例

メッセージ1-2エージェントLは、そのローカルIPアドレスからホスト候補を集め、そこからSTUNサーバにSTUN Bindingリクエストを送信する。エージェントLはNATの後ろにいないので、Lのサーバ反射候補はホスト候補と同じになる。

メッセージ3：エージェントLは、ICE利用に関連するシグナリングプロトコルを使用して、エージェントRにローカル候補情報を送信する。

メッセージ4-5：エージェントRは、そのローカルIPアドレスからホスト候補を収集し、そこからSTUNサーバにSTUNバインディング要求を送信する。エージェントRはNATの後ろにいないので、Rのサーバ反射候補はホスト候補と同じになる。

メッセージ 6．エージェントRは、ICE利用に関連するシグナリングプロトコルを使用して、エージェントLにローカル候補情報を送信する。

両エージェントはICEの完全な実装であるため、initiating agent（エージェントL）が制御エージェントになる。

エージェントLとRは、ともにCandidateをペアリングする。両エージェントとも、最初はそれぞれ1組ずつ持っている。エージェントLでは、ペア(L1)は、ローカル候補が$L_PUB_1、リモート候補が$R_PUB_1である。エージェントRでは、ペア(R1)は、ローカル候補が$R_PUB_1、リモート候補が$L_PUB_1である。ペアを以下に示す（ペア番号は参照用）。

                            ペア ENTITY ローカル リモート ペア # 有効 ------------------------------------------------------------- ICE Agent L: L_PUB_1 R_PUB_1 L1  
ICEエージェントR：R_PUB_1 L_PUB_1 R1

メッセージ7-8：エージェントLは、ペアL1の接続性チェックを開始する。チェックは成功し、ペア(L1)はエージェントLの有効リストに追加される。エージェントLは、望むならペア(L1)でデータを送受信できるようになった。

                            ペア ENTITY ローカル リモート ペア # 有効 ------------------------------------------------------------- ICE Agent L: L_PUB_1 R_PUB_1 L1 X 
ICEエージェントR：R_PUB_1 L_PUB_1 R1

メッセージ9～10エージェントRがエージェントLからバインディング要求（メッセージ7）を受信すると、トリガーによる接続性チェックを開始する。ペアは、エージェントRの既存のペア(R1)と一致する。チェックは成功し、ペア(R1)はエージェントRの有効リストに追加される。エージェントRは、希望すればペア(R1)でデータを送受信できるようになった。

                            ペア ENTITY ローカル リモート ペア # 有効 ------------------------------------------------------------- ICE Agent L: L_PUB_1 R_PUB_1 L1 X 
ICEエージェントR：R_PUB_1 L_PUB_1 R1 X

メッセージ11～12ある時点で、制御エージェント(エージェントL)は、有効リストにあるペア(L1)を指名することを決定する。ペア(L1)の接続性チェックを行い、バインディングリクエストにUSE-CANDIDATE属性を含める。チェックが成功すると、エージェントLはペア(L1)の指名フラグ値を「真」に設定し、エージェントRはマッチするペア(R1)の指名フラグ値を「真」に設定する。

ストリームに関連するコンポーネントがなくなったため、指名されたペアが選択されたペアとなる。その結果、このストリームの処理はCompleted状態に移行する。また、ICE処理もCompleted状態に移行する。

16.STUNエクステンション
16.1.属性（Attributes
本仕様では、4つのSTUN属性を定義する。PRIORITY、USE-CANDIDATE、ICE-CONTROLLED、ICE-CONTROLLING。

PRIORITY属性は、このチェックでピアリフレクティブ候補が発見された場合に、関連付けられる優先度を示します。32ビットの符号なし整数で、属性値は0x0024である。

USE-CANDIDATE属性は、このチェックの結果得られた候補ペアがデータ送信に使用されることを示す。この属性には内容がなく（属性の長さフィールドは0）、フラグとして機能する。属性値は 0x0025 である。

ICE-CONTROLLED属性は、Bindingリクエストの中に存在する。この属性は、クライアントが現在制御された役割にあると信じていることを示す。属性の内容は，ネットワークバイトオーダーの64ビット符号なし整数であり，乱数を含む。この数値は "タイブレーカー値 "と呼ばれ、役割の競合を解決するために使用される。ICEエージェントは、487応答を受信しない限り、ICEセッション内のすべてのストリー ムのすべてのBindingリクエストに同じ番号を使用しなければならない[MUST]が、その 場合は番号を変更しなければならない[MUST](セクション7.2.5.1)。エージェントは、ICEの再起動が発生したときに、番号を変更してもよい (MAY)。

ICE-CONTROLLING属性は、Bindingリクエストの中に存在する。この属性は，クライアントが現在制御の役割にあると信じていることを示す。属性の内容は、ネットワークバイトオーダーの64ビット符号なし整数で、乱数を含む。ICE-CONTROLLED属性と同様に、この番号は役割の競合を解決するために使用される。エージェントは、487応答を受け取らない限り、ICEセッション内のすべてのストリー ムのすべてのバインディングリクエストに同じ番号を使用しなければならない[MUST]が、 その場合、番号を変更しなければならない(セクション7.2.5.1)。エージェントは、ICEの再起動が発生したときに、番号を変更してもよい (MAY)。

16.2.新しいエラー・レスポンス・コード
本仕様では、1つのエラー応答コードを定義する。

487(役割の競合)。BindingリクエストにICE-CONTROLLINGまたはICE-CONTROLLED属性が含まれており、サーバーと競合するICEロールがあることを示しました。リモートサーバーは、クライアントとサーバーのタイブレーク値を比較し、クライアントが役割を切り替える必要があると判断しました。

17.運用上の留意点
本項では、ICEがエンドポイントに利用されるネットワークを運用する事業者に関連する事項を説明する。

17.1.NATとファイアウォールの種類
ICEは、既存のNATやファイアウォール機器と連携して動作するように設計されています。そのため、ICEの導入を容易にするために、既存のファイアウォールやNAT機器を交換したり、再設定したりする必要はない。実際、ICEは、Voice over IP（VoIP）事業者がファイアウォールやNATを含むIPネットワークインフラを制御できない環境で展開するために開発されました。

つまり、ICEは、NATデバイスが[RFC4787]と[RFC5382]で定義されている推奨事項を満たす「behave」準拠の環境で最もよく機能します。behaveに準拠したNATを持つネットワークでは、ICEはTURNサーバーを必要とせずに動作するため、音声品質の向上、通話設定時間の短縮、ネットワークオペレータの帯域幅需要の低減を実現します。

17.2.帯域幅の要件
ICEの導入は、利用可能なネットワーク容量といくつかの相互作用があり、オペレータはそれを考慮する必要がある。

17.2.1.STUNおよびTURNサーバー-容量計画
まず第一に、ICEはTURNとSTUNサーバーを利用します。これらは通常、データセンターに設置されます。STUNサーバーは、比較的小さな帯域幅を必要とする。各データストリームの各コンポーネントについて、各クライアントからSTUNサーバーへのSTUNトランザクションが1つ以上存在することになる。基本的な音声のみのIPv4 VoIPの展開では、1つの呼につき4つのトランザクションがある（発呼側と着呼側の両方について、RTPとRTCPのために1つずつある）。各トランザクションは1つのリクエストと1つのレスポンスで、前者は20バ イト長、後者は28バイト長である。

その結果、あるシステムにN人のユーザーがいて、それぞれが忙しい時間帯に4回電話をかけるとすると、N*1.7bpsが必要になります。100万人のユーザーであれば、これは1.7Mbpsであり、非常に小さな数字です（相対的には）。

TURNトラフィックはより充実しています。TURNサーバーは、実際のデータのトラフィックに加えて、STUNのトラフィック量と同等のトラフィック量を見ることになる（実際、TURNサーバーが配備されている場合、別のSTUNサーバーは必要ない）。データ中継のためにTURNを必要とするコールの量は、ネットワークのトポロジーに大きく依存し、時間の経過とともに変化する可能性があります。100％behave準拠のNATを持つネットワークでは、それはまさにゼロです。

上記の計画上の考慮事項は、マルチメディアシナリオ（例：オーディオおよびビデオ会議）やセッションの参加者数が増加した場合に、より重要になります。

17.2.2.ギャザリングと接続性チェック
候補を集め、接続性チェックを行うプロセスは、帯域幅を消費する可能性があります。ICEは、この2つのプロセスのペースを上げるように設計されています。候補の収集と接続性チェックの段階では、ICEのプロセスが終了した後に消費されるデータトラフィックとほぼ同じ帯域幅のトラフィックを生成するように設計されています。これは、ネットワークがある種の通信トラフィック（音声、ビデオ、テキスト）をサポートするように設計されている場合、そのデータのICEチェックをサポートするのに十分な容量があることを保証するために行われました。ICEが終了すると、その後のICEキープアライブによって、総帯域幅使用量がわずかに増加しますが、これは通常、極めて小さな増加量にとどまります。

ペーシングを利用しない導入では、収集とチェックのフェーズによる輻輳が問題となることが証明されています。一般的に、エンドポイントが送信できる速度でチェックをネットワークに流し込むため、アクセスリンクが輻輳しました。そのため、ネットワークオペレータは、ICEの実装がペーシング機能をサポートしていることを確認する必要があります。このペーシング機能により、コールセットアップ時間が長くなりますが、ICEはネットワークに優しく、導入が容易になります。

17.2.3.キープアライブ
STUNキープアライブ（STUN Binding Indicationsの形式）は、データセッションの途中で送信される。しかし、これらは実際のデータトラフィックがない場合にのみ送信される。連続メディアを使用し、音声活動検出（VAD）を使用しない場合、またはVADが短い間隔（最大1秒）の快適なノイズと一緒に使用される場合、キープアライブは使用されず、帯域幅使用量が増加することはないです。VADが快適なノイズなしで使用されている場合、キープアライブは無音時間帯に送信されます。これは15～20秒に1回のパケット送信となり、音声があるときに送信される20～30msごとのパケットに比べてはるかに少ない。したがって、キープアライブはキャパシティプランニングに実質的な影響を与えません。

17.3.ICEとICE-Lite
ICEとICE-liteを混在して使用する展開は、互いに相互運用が可能です。そのように明示的に設計されています。

しかし、ICE-liteは限られたユースケースにしか導入できない。これらのケースとその際の注意点については、付録Aに記載されています。

17.4.トラブルシューティングとパフォーマンス管理
ICEは、エンドツーエンドの接続チェックを利用し、処理の多くをエンドポイントに配置します。このため、ネットワーク事業者は、ICE導入のトラブルシューティングをどのように行うか、ICEのパフォーマンスをどのように把握するかといった課題を抱えています。ICEがどのように機能しているのか、どのように知ることができるのか？

ICEには、これらの問題に対処するための機能が組み込まれています。通常、ネットワークオペレータのデータセンターに配備されているシグナリングサーバは、ICEのパラメータを伝える候補交換の内容を見ることができます。このパラメータには、各候補のタイプ（ホスト、サーバー反射型、中継型）、およびRelated Addressが含まれます。ICE処理が完了すると、選択されたアドレス（およびそのタイプ）をシグナリングする、更新された候補の交換が行われます。この更新されたシグナリングは、まさにネットワーク機器（シグナリングに接続された診断ツールなど）にICE処理の結果を知らせる目的で実行されます。

その結果、シグナリングサーバーが生成するログを通じて、ネットワークオペレータは、各コールでどのような種類の候補が使用されているか、ICEによってどのアドレスが選択されたかを観察することができます。これは、ICEがどのように機能しているかを評価するのに役立つ主要な情報です。

17.5.エンドポイント設定
ICEは、エンドポイントに設定されたいくつかのデータに依存しています。この設定データには、タイマー、TURNサーバーの認証情報、STUNとTURNサーバーのホスト名などが含まれます。ICE自身は、この設定のためのメカニズムを提供していません。代わりに、この情報は、エンドポイントの他のすべてのパラメータを構成するために使用されるメカニズムに添付されていると仮定されます。SIPフォンの場合、コンフィギュレーションフレームワーク[RFC6080]のような標準的なソリューションが定義されている。

18.IABの検討事項
IABは、"Unilateral Self-Address Fixing"（UNSAF）の問題を研究しました。これは、ICEエージェントが、NATの反対側にある別の領域で、協調的なプロトコル反映メカニズムによってアドレスを決定しようとする一般的なプロセスです [RFC3424]。ICEは、この種の機能を実行するプロトコルの一例である。興味深いことに、ICEのプロセスは片務的ではなく、両務的であり、この違いはIABが提起した問題に大きな影響を与える。実際、ICEはUNSAFプロトコルではなく、B-SAF（Bilateral Self-Address Fixing）プロトコルと考えることができる。しかし、IABは、この目的のために開発されたプロトコルは、特定の考慮事項のセットを文書化することを義務付けています。このセクションは、これらの要件を満たすものです。

18.1.問題の定義
RFC 3424から、UNSAFの提案は、提供する必要がある。

UNSAFの提案で解決しようとする、具体的で限定された範囲の問題を正確に定義すること。短期的な解決策を他の問題の解決に一般化すべきではない。そのような一般化は、その短期的な解決策への依存と使用を長期化させることになり、もはや「短期的」と呼ぶには正確でないことを意味する。

ICEが解決しようとしている具体的な問題は、以下の通りです。

2つのピアが通信に使用できるトランスポートアドレスのセットを決定するための手段を提供すること。

エージェントが通信を希望する他のピアから到達可能なアドレスを決定するための手段を提供すること。

18.2.出口戦略
RFC 3424から、UNSAFの提案は、提供する必要がある。

出口戦略/移行計画の記述。短期的な対策として優れているのは、適切な技術が導入されるにつれて、自然と使用頻度が減っていくようなものである。

ICE自体は簡単に廃止されることはない。しかし、グローバルに接続されたインターネットでも、ルーターの故障で一時的に接続が途絶えたかどうかを検出する手段などとして有効です。また、ICEは、NATとは無関係なある種のセキュリティ攻撃の防止にも役立ちます。しかし、ICEが行うのは、他のUNSAFメカニズムの段階的な廃止を支援することです。ICEは、これらのメカニズムの中から、より良いものを優先し、より悪いものを非優先とすることで、効果的に選択します。IPv6の導入に伴いNATが減少し始めると、サーバー反射型候補と中継型候補（どちらもUNSAFアドレスの一種）は、ネイティブホスト候補へのより高い優先度の接続が存在するため、単に使用されなくなる。そのため、サーバーの使用量はどんどん減っていき、最終的には使用量がゼロになった時点で撤去することができる。

実際、ICEはIPv4からIPv6への移行を支援することができます。2つのデュアルスタックホストがSIPで通信する際に、IPv6とIPv4のどちらを使用するかを決定するために使用することができます（IPv6が使用されます）。また、6to4とネイティブv6の両方の接続性を持つネットワークが、ピアと通信する際にどちらのアドレスを使用するかを決定することができます。

18.3.ICEで導入された脆さ
RFC 3424から、UNSAFの提案は、提供する必要がある。

システムをより「もろい」ものにする可能性のある特定の問題についての議論。例えば、複数のネットワーク層でデータを使用するアプローチでは、依存関係が増え、デバッグの課題が増え、移行が難しくなる。

ICEは実際に、既存のUNSAFメカニズムから脆さを取り除いている。特に、古典的なSTUN（RFC 3489 [RFC3489]で説明されている）には、脆さのポイントがいくつかある。そのうちの1つは、ICEエージェントが背後にあるNATの種類を分類しようとすることを要求する発見プロセスである。このプロセスは、エラーが発生しやすい。ICEでは、その発見プロセスは単に使用されない。アドレスの有効性を一方的に評価するのではなく、ピアへの接続性を測定することによって、その有効性を動的に決定します。接続性を判断するプロセスは、非常に堅牢です。

古典的なSTUNや他のユニラテラルメカニズムのもろさのもう一つのポイントは、追加のサーバーに絶対的に依存することです。ICEはユニラテラルアドレスを割り当てるためにサーバーを利用するが、可能であればエージェントが直接接続することを許可する。したがって、STUNサーバーが故障しても、ICEを使用すれば通話を進行させることができるケースもある。

クラシックSTUNのもう一つの脆さのポイントは、STUNサーバーがパブリックインターネット上にあると仮定していることです。興味深いことに、ICEではその必要はない。様々なアドレス領域に多数のSTUNサーバーが存在する可能性があります。ICEは、使用可能なアドレスを提供したものを発見する。

古典的なSTUNのもろさの最も厄介な点は、すべてのネットワークトポロジで動作しないことである。各エージェントとSTUNサーバーの間に共有NATがあるような場合、従来のSTUNは動作しないことがあります。ICEでは、その制約がなくなります。

また、Classic STUNは、いくつかのセキュリティ上の考慮事項を導入しています。幸いなことに、それらのセキュリティ上の考慮点もICEによって緩和されます。

その結果、ICEは古典的なSTUNで導入された脆さを修復する役割を果たし、システムに新たな脆さを導入することはない。

これらの改良のペナルティとして、ICEはセッション確立時間を増加させます。

18.4.長期的なソリューションのための要件
RFC 3424より、UNSAFプロポーザルは以下のものを提供する必要がある。

長期的かつ健全な技術的ソリューションの要件を特定し、適切な長期的ソリューションを見出すプロセスに貢献する。

RFC 3489の結論に変更はありません。しかし、ICEは長期的な解決策の一部になり得ると考えているため、実際に役立つと感じます。

18.5.既存のNAPTボックスの問題点
RFC 3424から、UNSAFの提案は、提供する必要がある。

既存のNA[P]Tsと経験報告で指摘された実用的な問題の影響について議論する。

現在、「汎用」ALG機能を提供しようとする多くのNATボックスが市場に展開されている。これらの汎用ALGは、パケット内のテキストまたはバイナリ形式でIPアドレスを探し、バインディングに一致する場合はそれらを書き換えます。これは、古典的なSTUNを妨害する。しかし、STUNのアップデート[RFC5389]は、汎用ALGからこれらのバイナリアドレスを隠すエンコーディングを使用しています。

既存のNAPTボックスでは、UDPベースのバインディングの有効期限が非決定的であり、通常短い。このため、実装はバインディングを維持するために定期的にキープアライブを送信する必要があります。ICEは、デフォルトで15秒を使用していますが、これは非常に保守的な見積もりです。最終的には、NATボックスがbehave [RFC4787]に準拠するようになるにつれて、この最小キープアライブは決定論的なものになります。

ICEタイマーを調整することができます。最小のキープアライブ間隔を発見し、制御する方法を持つことは、さらに良いことです。

19.セキュリティに関する考慮事項
19.1.IPアドレスのプライバシー
候補を探す過程では、ネットワーク上でリスニングしている攻撃者にクライアントとそのピアのソースアドレスを公開し、候補を交換する過程では、ネゴシエーションを見ることができる攻撃者にアドレスを公開する。また、候補を交換する過程では、ネゴシエーションを見ることができる攻撃者にアドレスが公開される。VPN ユーザーのローカルインターフェースから収集されたサーバーリフレクティブアドレスなど、一部のアドレスは機密情報である可能性がある。これらの潜在的な攻撃を軽減できない場合、 ICE の用途では、どのアドレスがネゴシエーションやプロービングプロセスに公開されるかを制御するためのメカニズムを定義することができる。また、個々の実装は、どのアドレスが公開されるかを制御するための実装固有のルールを持つことができる。例えば、[WebRTC-IP-HANDLING]は、WebRTCアプリケーションのためにICEを介してIPアドレスを公開することのプライバシー側面に関する追加情報を提供します。このような問題が発生する可能性があるICEの実装では、候補を生成するためにどのネットワークインターフェースを使用するかを制御するプログラムまたはユーザーインターフェースを提供することが推奨されます（RECOMMENDED）。

ピアから提供された候補の種類と、それらの候補に対して実行された接続性テストの結果に基づいて、ピアは、ローカルネットワークの特性、例えば、異なるタイミングがピアに明白である場合などを決定することができるかもしれない。制限の範囲内で、ピアはローカルネットワークを調査することができるかもしれない。

ICEシステムでは、いくつかのタイプの攻撃が可能である。以下では、これらの攻撃とその対策について考察する。

19.2.接続性チェックへの攻撃
攻撃者は、STUN接続性チェックを妨害しようとするかもしれない。最終的に、これらの攻撃はすべて、ICEエージェントを騙して、接続性チェックの結果について何か間違ったことを考えさせるものです。攻撃の種類によって、攻撃者は異なる能力を持つ必要があります。ある場合には、攻撃者は接続性チェックの経路上にいる必要があります。また、STUN接続性チェックを生成することができれば、攻撃者が経路上にいる必要はない場合もある。接続性チェックに対する攻撃は通常ネットワークエンティティによって実行されるが、攻撃者がエンドポイントを制御できる場合、接続性チェックの攻撃を引き起こすことができるかもしれない。攻撃者が試み、引き起こすことができる可能性のある誤った結論は以下の通りです。偽の無効。攻撃者は、候補ペアが無効であるにもかかわらず、無効であると考えるようにエージェントのペアを欺くことができます。これは、エージェントに別の候補（攻撃者が注入したものなど）を選ばせたり、すべての候補を失敗させることで通話を中断させたりするために使用されることがあります。

False Valid（偽の有効）。攻撃者は、候補ペアが有効でないにもかかわらず、有効であると思わせるようにエージェントのペアを欺くことができる。これにより、エージェントはセッションを進めることができますが、その後、データを受信することができません。

偽のピアリフレクティブ候補：攻撃者は、エージェントが予期していないときに新しいピアリフレクティブ候補を発見させることができます。これは、データストリームをDoSターゲットまたは攻撃者にリダイレクトし、盗聴やその他の目的で使用することができます。

偽の候補で偽の有効：攻撃者は、あるエージェントに対して、実際にはそのエージェントにルートしていないアドレスを持つ候補が存在することを既に確信している（例えば、偽のピアリフレクティブ候補や偽のサーバリフレクティブ候補を注入することによって）。そして攻撃者は、この候補が有効であるとエージェントに信じ込ませる攻撃を開始する。

攻撃者が偽のpeer-reflexive候補や偽の候補での偽の有効を引き起こすことができれば、[RFC5389]で説明されている攻撃のいずれかを開始することができます。

偽の無効結果を出させるために、攻撃者はエージェントの1つから接続性チェックが送信されるのを待つ必要があります。送信されたら、攻撃者は回復不可能なエラー応答(400など)を持つ偽の応答を注入するか、応答がエージェントに到達しないように応答をドロップする必要がある。しかし、候補は実際には有効であるため、元のリクエストはピアエージェントに到達し、成功レスポンスとなる可能性がある。攻撃者は、DoS攻撃、レイヤー2ネットワークの妨害、または他の技術によって、このパケットまたはその応答を強制的にドロップする必要があります。そうしなければ、成功レスポンスは発信元にも届き、攻撃の可能性を警告することになります。攻撃者が偽の応答を生成する能力は、STUN短期クレデンシャル機構によって緩和される。この応答が処理されるために、攻撃者はパスワードを必要とする。候補交換信号が安全であれば、攻撃者はパスワードを持たず、その応答は破棄される。

偽の無効な結果を作成するために、なりすましICMPハードエラー（タイプ3、コード2～4）を使用することもできる。ICEエージェントがこれらのICMPエラーに対する応答を実装している場合、攻撃者は接続性チェックを送信するエージェントに配信されるICMPメッセージを生成することが可能です。エージェントによる ICMP エラーメッセージの検証は、その唯一の防御策である。Type 3 の code=4 では、接続性チェックが DF=0 で送信されない限り、外側の IP ヘッダは何の検証も行わない。 ホストが発信する code 2 または 3 では、アドレスはリモートエージェントのホスト、リフレクティブ、リレーの候補 IP アドレスのいずれかになると予想される。ICMPメッセージは、エラーを引き起こすメッセージのIPヘッダーとUDPヘッダーを含む。これらのフィールドも検証される必要がある。IP宛先とUDP宛先ポートは、ターゲットとなるCandidateのアドレスとポート、またはCandidateのベースアドレスのいずれかに一致する必要があります。送信元IPアドレスとポートは、接続性チェックを送信するエージェントの同じベースアドレスの任意の候補にすることができます。したがって、Candidateの交換にアクセスできる攻撃者であれば、必要な情報を入手することができる。したがって、検証は弱い防御であり、送信元アドレス検証のないネットワーク内のノードからオフパスの攻撃者がなりすましICMP攻撃を送信することも可能である。

偽の有効な結果を強制することも、同様の方法で動作します。攻撃者は、各エージェントからのBindingリクエストを待ち、偽の成功応答を注入する必要があります。ここでもSTUNの短期クレデンシャル機構により、攻撃者が有効な成功応答を注入するためには、攻撃者はパスワードが必要である。あるいは、攻撃者は、通常ネットワークによってドロップまたは拒否される有効な成功応答を、（例えばトンネリングメカニズムを使用して）エージェントにルーティングすることができます。

偽のpeer-reflexive候補の結果を強制するには、偽のリクエストや応答、またはリプレイのいずれかを使用することができます。まず、偽のリクエストとレスポンスのケースを考える。これは、攻撃者が、偽の候補のソースIPアドレスとポートを持つ1つのエージェントにバインドリクエストを送信することを必要とします。さらに、攻撃者は他のエージェントからのBindingリクエストを待ち、偽の候補を含むXOR-MAPPED-ADDRESS属性の偽の応答を生成する必要があります。ここで説明した他の攻撃と同様に、この攻撃はSTUNメッセージの完全性メカニズムと安全なCandidate交換によって軽減される。

パケットリプレイで偽のpeer-reflexive候補の結果を強制するのは、それとは異なります。攻撃者は、エージェントの1つがチェックを送信するまで待ちます。このリクエストを傍受し、偽のソースIPアドレスで他のエージェントに向けてリプレイする。また、DoS攻撃でパケットをドロップさせるか、レイヤ2メカニズムを使用して強制的にドロップさせることで、元のリクエストがリモートエージェントに到達するのを防ぐ必要がある。再生されたパケットは、他のエージェントで受信され、完全性チェックが通っ ているので、受け入れられる(完全性チェックは、ソースIPアドレスとポートをカバー することはできないし、しない)。その後、応答される。この応答は、偽候補とのXOR-MAPPED-ADDRESSを含み、その偽候補に送信される。攻撃者はこれを受信し、送信元に向けて中継する必要があります。

その後、他のエージェントは、その偽候補に向けた接続性チェックを開始します。この検証は成功する必要があります。これは、攻撃者が偽の候補に偽の有効性を強制することを必要とする。この目的を達成するために偽のリクエストや応答を注入することは、STUNとCandidate交換の完全性メカニズムを使用して防止される。したがって、この攻撃はリプレイを通してのみ実行可能である。そのためには、攻撃者はこの偽の候補に向けたチェックを傍受し、それを他のエージェントに向けて再生する必要がある。次に、応答を傍受し、同様にそれをリプレイする必要があります。

この攻撃は、攻撃者が偽のCandidateによって特定されない限り、非常に困難である。これは、攻撃者が2つの異なるホストから送信されたパケットを傍受して再生する必要があるためです。両エージェントが異なるネットワーク上（例えば、公衆インターネット上）にいる場合、この攻撃はネットワークの異なる部分にある2つのエンドポイントに対して同時に発生する必要があるため、調整が困難な場合があります。

攻撃者自身が偽の候補によって識別される場合、攻撃は調整しやすくなる。ただし、データパスが保護されている場合（SRTP (Secure Real-time Transport Protocol) [RFC3711]を使用するなど）、攻撃者はデータパケットを処理できず、破棄することしかできな いので、データストリームを効果的に無効化できる。ただし、この攻撃では、接続性チェックがターゲットに到達するのをブロックするために、エージェントがパケットを破壊する必要がある。その場合、データストリームの破壊が目的であれば、ICEを攻撃するよりも、同じ仕組みで破壊するだけの方がずっと簡単です。

19.3.サーバリフレクティブアドレス収集に対する攻撃
ICEエンドポイントは、STUNサーバーからサーバー反射候補を収集するためにSTUN Bindingリクエストを使用する。これらのリクエストは、いかなる方法でも認証されません。その結果、攻撃者がクライアントに偽のサーバー反射候補を提供するために採用できる多くのテクニックが存在する。

o 攻撃者はDNSを侵害し、DNSクエリが不正なSTUNサーバーアドレスを返すようにすることができます。そのサーバーは、クライアントに偽のサーバー反射候補を提供することができます。この攻撃はDNSセキュリティによって軽減されるが、DNSSECはこれに対処するために必要ではない。

o STUNメッセージを観察できる攻撃者（Wi-Fiなどの共有ネットワークセグメント上の攻撃者）は、有効でクライアントに受け入れられる偽のレスポンスを注入することができます。

o 攻撃者は、STUNサーバーを侵害し、不正なマッピングされたアドレスで応答を送信させることができます。

これらの攻撃によって学習された偽のマッピングされたアドレスは、ICEセッションの確立において、サーバーの反射的な候補として使用される。この候補が実際にデータに使用されるためには、攻撃者は接続性チェックを攻撃し、特に、偽の候補に偽の有効性を強制する必要がある。この攻撃は、セッション内の各ICEエージェントが生成するチェックを 攻撃する必要があり、攻撃者自身を特定するとSRTPによって阻止されるため、 偽のアドレスが第4のパーティ(イニシエータ、Responder、攻撃者のいずれも) を特定する場合は、非常に困難である。

攻撃者が接続性チェックを攻撃しないことを選択した場合、攻撃者ができる最悪のことは、サーバー反射型候補が使用されるのを阻止することである。しかし、攻撃を受けているエージェントから到達可能なピアエージェントの候補が少なくとも1つあれば、STUN接続性チェック自体が、データ交換に使用できるピアリフレクティブな候補を提供する。ピアリフレクティブ候補は、一般的にサーバリフレクティブ候補よりも優先される。そのため、STUNアドレスの収集のみに対する攻撃は、通常、セッションに全く影響を及ぼさない。

19.4.中継Candidate集めへの攻撃
攻撃者は、中継候補の収集を妨害し、クライアントに偽の中継候補があると思わせることを試みるかもしれない。TURNサーバーとの交換は、長期間のクレデンシャルを使用して認証される。その結果、偽の応答やリクエストを注入しても、うまくいかない。さらに、Bindingリクエストとは異なり、Allocateリクエストは、ソースIPアドレスとポートがクライアントに中継候補を提供するために利用されないので、ソースIPアドレスとポートを変更したリプレイ攻撃には影響されない。

攻撃者がクライアントに偽の中継候補を信じ込ませたとしても、接続性チェックが成功した場合のみ、その候補が使用される。したがって、攻撃者は、上記のように、偽の候補に対して偽の有効性を打ち出す必要があり、これは、調整するのが非常に難しい攻撃である。

19.5.インサイダー攻撃
ICEでは、攻撃者が第三者で偽のCandidate情報やSTUNメッセージを挿入しようとする攻撃に加えて、攻撃者がICE取引所の認証された有効な参加者である場合に可能な攻撃が存在する。

19.5.1.STUNアンプリファイヤーアタック
STUN増幅攻撃は、攻撃者が他のエージェントに音声パケットを攻撃対象に向けさせる「ボイスハンマー」攻撃と似ています。しかし、音声パケットがターゲットに向けられる代わりに、STUN接続性チェックがターゲットに向けられる。攻撃者は50個など大量の候補を送信する。応答するエージェントは候補情報を受信してチェックを開始しますが、そのチェックはターゲットに向けられるため、結果として応答が発生することはありません。WebRTCの場合、ユーザーが取得した悪意のあるJavaScriptコードによってバックグラウンドで発動される可能性があるため、ユーザーはこの攻撃が進行していることにすら気づかないかもしれません。回答者は、Ta ms（例えばTa=50ms）ごとに新しい接続性チェックを開始する。しかし、候補が多いため再送タイマは大きく設定される。その結果、パケットはTaミリ秒ごとに1つずつ、その後は間隔を空けて送信されることになる。したがって、STUNは、データが送信されるよりも速い速度でパケットを送信することはなく、STUNパケットは、ICEがセッションのために失敗するまで、わずかな時間だけ持続する。それにもかかわらず、これは増幅機構である。

増幅をなくすことは不可能だが、さまざまなヒューリスティックな方法で量を減らすことができる。ICEエージェントは、実行する接続性チェックの総数を100に制限すべきである（SHOULD）。さらに、エージェントは受け入れるCandidateの数を制限してもよい（MAY）。

このような攻撃を回避したいプロトコルは、次のメッセージを送信する前に、イニシエータが応答を待つことを強制することがよくある。しかし、ICEの場合、これは不可能である。以下の2つのケースを区別することはできない。

o 応答がないのは、イニシエータが応答しない無防備なターゲットに対してDoS攻撃を仕掛けるために使用されているためです。

o IPアドレスとポートがイニシエータによって到達可能でないため、応答がありませんでした。

後者の場合は、次の機会に再度チェックを送りますが、前者の場合は、それ以降のチェックを送りません。

20.IANAに関する考察
オリジナルのICE仕様では、4つのSTUN属性と1つの新しいSTUNエラー応答が登録されていた。STUN属性とエラー応答は、ここに再現される。また、本仕様では新たにICEオプションが登録されている。

20.1.STUN 属性
IANAでは、4つのSTUN属性を登録しています。

0x0024 PRIORITY 0x0025 USE-CANDIDATE 0x8029 ICE-CONTROLLED 0x802A ICE-CONTROLLING

20.2.STUNエラーレスポンス
IANAは、次のSTUNエラー応答コードを登録した。

487 役割の競合。クライアントは、サーバーの役割と競合するICEの役割（制御またはコントロール）を主張した。

20.3.ICEオプション
IANAは、[RFC6336]で定義された手順に従って、以下のICEオプションを「Interactive Connectivity Establishment（ICE）」レジストリの「ICE Options」サブレジストリに登録しました。

ICE オプション名：ice2

連絡先名前IESG Email: iesg@ietf.org

チェンジコントローラー：IESG

説明ICEオプションは、ICEオプションを使用するICEエージェントがRFC8445に従って実装されていることを示す。

参照RFC 8445

21.RFC 5245からの変更点
このICE仕様の更新の目的は、以下の通りです。

o RFC5245の手順を明確にする。

o RFC5245の欠陥の発見や、RFC5245に基づくICEアプリケーションを実装・展開したコミュニティからのフィードバックにより、技術的な変更を行う。

o SIPとSDPの手順を削除することで、手順をシグナリングプロトコルから独立させる。シグナリングプロトコルに固有の手続きは、別の用法文書で定義される。[ICE-SIP-SDP]は、SIPとSDPを使用したICEの使用法を定義する。

以下の技術的な変更を行いました。

o アグレッシブノミネーションを削除しました。

o ペア候補の状態計算と接続性チェックのスケジューリングの手順を変更した。

o TaおよびRTOの計算手順を変更した。

o アクティブチェックリストとフローズンチェックリストの定義が削除されました。

o 'ice2' ICEオプションが追加されました。

o IPv6に関する考察を修正しました。

o keepalives の no-op による使用法、および非 ICE ピアとの keepalives が削除されました。

22.参考資料
22.1.規範となる参考文献
[RFC2119] Bradner, S., "Key words for use in RFC to Indicate Requirement Levels", BCP 14, RFC 2119, DOI 10.17487/RFC2119, March 1997, <https://www.rfc-editor.org/info/rfc2119>.

[RFC4941] Narten, T., Draves, R., and S. Krishnan, "Privacy Extensions for Stateless Address Autoconfiguration in IPv6", RFC 4941, DOI 10.17487/RFC4941, September 2007, <https://www.rfc-editor.org/info/rfc4941>.

[RFC5389] Rosenberg, J., Mahy, R., Matthews, P., and D. Wing, "Session Traversal Utilities for NAT (STUN)", RFC 5389, DOI 10.17487/RFC5389, October 2008, <https://www.rfc-editor.org/info/rfc5389>.

[RFC5766] Mahy, R., Matthews, P., and J. Rosenberg, "Traversal Using Relays around NAT (TURN):Session Traversal Utilities for NAT (STUN) へのリレー拡張", RFC 5766, DOI 10.17487/RFC5766, April 2010, <https://www.rfc-editor.org/info/rfc5766>.

[RFC6336] Westerlund, M. and C. Perkins, "IANA Registry for Interactive Connectivity Establishment (ICE) Options", RFC 6336, DOI 10.17487/RFC6336, July 2011, <https://www.rfc-editor.org/info/rfc6336>.

[RFC6724] Thaler, D., Ed., Draves, R., Matsumoto, A., and T. Chown, "Default Address Selection for Internet Protocol Version 6 (IPv6)", RFC 6724, DOI 10.17487/RFC6724, September 2012, <https://www.rfc-editor.org/info/rfc6724>.

[RFC8174] Leiba, B., "Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words", BCP 14, RFC 8174, DOI 10.17487/RFC8174, May 2017, <https://www.rfc-editor.org/info/rfc8174>.

22.2.参考文献
[ICE-SIP-SDP] Petit-Huguenin, M., Nandakumar, S., and A. Keranen, "Session Description Protocol (SDP) Offer/Answer procedures for Interactive Connectivity Establishment (ICE)", Work in Progress, draft-ietf-mmusic-ice-sip-sdp-21, June 2018.

[RFC1918] Rekhter, Y., Moskowitz, B., Karrenberg, D., de Groot, G., and E. Lear, "Address Allocation for Private Internets", BCP 5, RFC 1918, DOI 10.17487/RFC1918, February 1996, <https://www.rfc-editor.org/info/rfc1918>.

[RFC2475] Blake, S., Black, D., Carlson, M., Davies, E., Wang, Z., and W. Weiss, "An Architecture for Differentiated Services", RFC 2475, DOI 10.17487/RFC2475, December 1998, <https://www.rfc-editor.org/info/rfc2475>.

[RFC3102] Borella, M., Lo, J., Grabelsky, D., and G. Montenegro, "Realm Specific IP: Framework", RFC 3102, DOI 10.17487/RFC3102, October 2001, <https://www.rfc-editor.org/info/rfc3102>.

[RFC3103] Borella, M., Grabelsky, D., Lo, J., and K. Taniguchi, "Realm Specific IP: Protocol Specification", RFC 3103, DOI 10.17487/RFC3103, October 2001, <https://www.rfc-editor.org/info/rfc3103>.

[RFC3235] Senie, D., "Network Address Translator (NAT)-Friendly Application Design Guidelines", RFC 3235, DOI 10.17487/RFC3235, January 2002, <https://www.rfc-editor.org/info/rfc3235>.

[RFC3261] Rosenberg, J., Schulzrinne, H., Camarillo, G., Johnston, A., Peterson, J., Sparks, R., Handley, M., and E. Schooler, "SIP: Session Initiation Protocol", RFC 3261, DOI 10.17487/RFC3261, June 2002, <https://www.rfc-editor.org/info/rfc3261>.

[RFC3264] Rosenberg, J. and H. Schulzrinne, "An Offer/Answer Model with Session Description Protocol (SDP)", RFC 3264, DOI 10.17487/RFC3264, June 2002, <https://www.rfc-editor.org/info/rfc3264>.

[RFC3303] Srisuresh, P., Kuthan, J., Rosenberg, J., Molitor, A., and A. Rayhan, "Middlebox communication architecture and framework", RFC 3303, DOI 10.17487/RFC3303, August 2002, <https://www.rfc-editor.org/info/rfc3303>.

[RFC3424] Daigle, L., Ed. and IAB, "IAB Considerations for UNilateral Self-Address Fixing (UNSAF) Across Network Address Translation", RFC 3424, DOI 10.17487/RFC3424, November 2002, <https://www.rfc-editor.org/info/rfc3424>.

[RFC3489] Rosenberg, J., Weinberger, J., Huitema, C., and R. Mahy, "STUN - Simple Traversal of User Datagram Protocol (UDP) Through Network Address Translators (NATs)", RFC 3489, DOI 10.17487/RFC3489, March 2003, <https://www.rfc-editor.org/info/rfc3489>.

[RFC3550] Schulzrinne, H., Casner, S., Frederick, R., and V. Jacobson, "RTP: A Transport Protocol for Real-Time Applications", STD 64, RFC 3550, DOI 10.17487/RFC3550, July 2003, <https://www.rfc-editor.org/info/rfc3550>.

[RFC3605] Huitema, C., "Real Time Control Protocol (RTCP) attribute in Session Description Protocol (SDP)", RFC 3605, DOI 10.17487/RFC3605, October 2003, <https://www.rfc-editor.org/info/rfc3605>.

[RFC3711] Baugher, M., McGrew, D., Naslund, M., Carrara, E., and K. Norrman, "The Secure Real-time Transport Protocol (SRTP)", RFC 3711, DOI 10.17487/RFC3711, March 2004, <https://www.rfc-editor.org/info/rfc3711>.

[RFC3725] Rosenberg, J., Peterson, J., Schulzrinne, H., and G. Camarillo, "Best Current Practices for Third Party Call Control (3pcc) in Session Initiation Protocol (SIP)", BCP 85, RFC 3725, DOI 10.17487/RFC3725, April 2004, <https://www.rfc-editor.org/info/rfc3725>.

[RFC3879] Huitema, C. and B. Carpenter, "Deprecating Site Local Addresses", RFC 3879, DOI 10.17487/RFC3879, September 2004, <https://www.rfc-editor.org/info/rfc3879>.

[RFC4038] Shin, M-K., Ed., Hong, Y-G., Hagino, J., Savola, P., and E. Castro, "Application Aspects of IPv6 Transition", RFC 4038, DOI 10.17487/RFC4038, March 2005, <https://www.rfc-editor.org/info/rfc4038>.

[RFC4091] Camarillo, G. and J. Rosenberg, "The Alternative Network Address Types (ANAT) Semantics for Session Description Protocol (SDP) Grouping Framework", RFC 4091, DOI 10.17487/RFC4091, June 2005, <https://www.rfc-editor.org/info/rfc4091>.

[RFC4092] Camarillo, G. and J. Rosenberg, "Usage of Session Description Protocol (SDP) Alternative Network Address Types (ANAT) Semantics in Session Initiation Protocol (SIP)", RFC 4092, DOI 10.17487/RFC4092, June 2005, <https://www.rfc-editor.org/info/rfc4092>.

[RFC4103] Hellstrom, G. and P. Jones, "RTP Payload for Text Conversation", RFC 4103, DOI 10.17487/RFC4103, June 2005, <https://www.rfc-editor.org/info/rfc4103>.

[RFC4291] Hinden, R. and S. Deering, "IP Version 6 Addressing Architecture", RFC 4291, DOI 10.17487/RFC4291, February 2006, <https://www.rfc-editor.org/info/rfc4291>.

[RFC4566] Handley, M., Jacobson, V., and C. Perkins, "SDP:Session Description Protocol", RFC 4566, DOI 10.17487/RFC4566, July 2006, <https://www.rfc-editor.org/info/rfc4566>.

[RFC4787] Audet, F., Ed. and C. Jennings, "Network Address Translation (NAT) Behavioral Requirements for Unicast UDP", BCP 127, RFC 4787, DOI 10.17487/RFC4787, January 2007, <https://www.rfc-editor.org/info/rfc4787>.

[RFC5245] Rosenberg, J., "Interactive Connectivity Establishment (ICE):A Protocol for Network Address Translator (NAT) Traversal for Offer/Answer Protocols", RFC 5245, DOI 10.17487/RFC5245, April 2010, <https://www.rfc-editor.org/info/rfc5245>.

[RFC5382] Guha, S, Ed., Biswas, K., Ford, B., Sivakumar, S., and P. Srisuresh, "NAT Behavioral Requirements for TCP", BCP 142, RFC 5382, DOI 10.17487/RFC5382, October 2008, <https://www.rfc-editor.org/info/rfc5382>.

[RFC5761] Perkins, C. and M. Westerlund, "Multiplexing RTP Data and Control Packets on Single Port", RFC 5761, DOI 10.17487/RFC5761, April 2010, <https://www.rfc-editor.org/info/rfc5761>.

[RFC6080] Petrie, D. and S. Channabasappa, Ed., "A Framework for Session Initiation Protocol User Agent Profile Delivery", RFC 6080, DOI 10.17487/RFC6080, March 2011, <https://www.rfc-editor.org/info/rfc6080>.

[RFC6146] Bagnulo, M., Matthews, P., and I. van Beijnum, "Stateful NAT64:Network Address and Protocol Translation from IPv6 Clients to IPv4 Servers", RFC 6146, DOI 10.17487/RFC6146, April 2011, <https://www.rfc-editor.org/info/rfc6146>.

[RFC6147] Bagnulo, M., Sullivan, A., Matthews, P., and I. van Beijnum, "DNS64: DNS Extensions for Network Address Translation from IPv6 Clients to IPv4 Servers", RFC 6147, DOI 10.17487/RFC6147, April 2011, <https://www.rfc-editor.org/info/rfc6147>.

[RFC6298] Paxson, V., Allman, M., Chu, J., and M. Sargent, "Computing TCP's Retransmission Timer", RFC 6298, DOI 10.17487/RFC6298, June 2011, <https://www.rfc-editor.org/info/rfc6298>.

[RFC6544] Rosenberg, J., Keranen, A., Lowekamp, B., and A. Roach, "TCP Candidates with Interactive Connectivity Establishment (ICE)", RFC 6544, DOI 10.17487/RFC6544, March 2012, <https://www.rfc-editor.org/info/rfc6544>.

[RFC6928] Chu, J., Dukkipati, N., Cheng, Y., and M. Mathis, "Increasing TCP's Initial Window", RFC 6928, DOI 10.17487/RFC6928, April 2013, <https://www.rfc-editor.org/info/rfc6928>.

[RFC7050] Savolainen, T., Korhonen, J., and D. Wing, "Discovery of IPv6 Prefix Used for IPv6 Address Synthesis", RFC 7050, DOI 10.17487/RFC7050, November 2013, <https://www.rfc-editor.org/info/rfc7050>.

[RFC7721] Cooper, A., Gont, F., and D. Thaler, "Security and Privacy Considerations for IPv6 Address Generation Mechanisms", RFC 7721, DOI 10.17487/RFC7721, March 2016, <https://www.rfc-editor.org/info/rfc7721>.

[RFC7825] Goldberg, J., Westerlund, M., and T. Zeng, "A Network Address Translator (NAT) Traversal Mechanism for Media Controlled by Real-Time Streaming Protocol (RTSP)", RFC 7825, DOI 10.17487/RFC7825, December 2016, <https://www.rfc-editor.org/info/rfc7825>.

[RFC8421] Martinsen, P., Reddy, T., and P. Patil, "Interactive Connectivity Establishment (ICE) Multihomed and IPv4/IPv6 Dual-Stack Guidelines", RFC 8421, DOI 10.17487/RFC8421, July 2018, <https://www.rfc-editor.org/info/rfc8421>.

[WebRTC-IP-HANDLING] Uberti, J. and G. Shieh, "WebRTC IP Address Handling Requirements", Work in Progress, draft-ietf-rtcweb-ip-handling-09, June 2018.

付録A．LiteとFullの実装
ICEは、2種類の実装を許可しています。フル実装は、セッションにおける制御役と被制御役をサポートし、アドレス収集も実行できる。これに対して、ライト実装は、STUNチェックに応答すること以外はほとんど行わない最小限の実装であり、セッションにおける制御される役割のみをサポートする。

ICEがどちらかのエンドポイントに利益をもたらすためには、両方のエンドポイントがそれをサポートする必要があるため、ネットワークにおけるICEの段階的な導入はより複雑なものとなります。多くのセッションは、それ自体、NATの背後になく、NATトラバーサルを気にしないエンドポイントを含んでいます。非常によくあるケースは、NATトラバーサルを必要とするエンドポイント（VoIPハードフォンやソフトフォンなど）が、これらのデバイスの1つに電話をかけることです。電話がICEのフル実装をサポートしていても、もう一方のデバイスがそれをサポートしていなければ、ICEはまったく使用されません。Lite実装は、これらのデバイスに低コストで参入できるようにするものです。Lite実装をサポートすれば、フル実装のデバイスに接続し、ICEの完全なメリットを得ることができます。

したがって、Lite実装は、常にパブリックインターネットに接続され、どのような相手からもパケットを受信できるパブリックIPアドレスを持っているデバイスにのみ適しています。ICEは、Lite実装がNATの後ろに置かれた場合、機能しません。

ICEでは、ライト実装で1つのIPv4ホスト候補と複数のIPv6アドレスを持つことができる。その場合、本仕様で推奨するRFC6724のような静的なアルゴリズムを用いて、制御エージェントが候補ペアを選択する。しかし、アドレス選択のための静的メカニズムは、実際のトポロジーを反映したり、接続性の実際の保証を提供することができないため、常にエラーが発生しやすいものである。それらは常に発見的である。したがって、ICEエージェントがIPv4アドレスとIPv6アドレスを選択するためだけにICEを実装し、そのIPアドレスのどれもがNATの後ろにない場合、最も堅牢なアドレス選択を提供するために、フルICEの使用は推奨されます（RECOMMENDED）。

本仕様では、ライト実装はフル実装への足がかりとして追加されたものであることに留意する必要がある。IPv4アドレス1つでパブリックインターネットに常時接続する機器であっても、実現可能であれば完全な実装が望ましい。また、完全な実装は、NATトラバーサルとは無関係なICEのセキュリティ上の利点も得ることができる。最後に、今日パブリックアドレスを持っているデバイスが、明日にはNATの背後にあるネットワークに置かれるということはよくあることである。デバイスや製品の寿命が尽きるまで、それが常にパブリックインターネット上で使用されるかどうかを決定的に知ることは困難である。完全な実装は、通信が常に機能することを保証するものです。

付録B.デザインの動機
ICEには、それ自体は単純であっても、複雑で明白でない考え方や使用例から派生して、さらに議論する価値のある規範的な動作が数多く含まれています。これらの設計動機は、実装のために理解する必要はないため、ここで説明する。この付録は非規範的なものである。

B.1.STUNトランザクションのペーシング
候補を収集し、接続性を確認するために使用されるSTUNトランザクションは、Taミリ秒ごとに1つの新しいトランザクションというおおよその割合でペースアウトする。各トランザクションには、同様にTaの関数である再送タイマRTOがあります。なぜこのようなトランザクションのペースが設定され、なぜこのような計算式が使われるのでしょうか？

これらのSTUNリクエストの送信は、クライアントとSTUNサーバーの間のNATデバイスにバインディングを作成する効果があることが多い。経験上、多くのNATデバイスは、新しいバインディングを作成する速度に上限があることが示されている。この仕様の作業中にIETF ICE WGで行われた議論では、5ミリ秒に1回が十分にサポートされているという結論に達しました。これが、Taが5msという下限を持つ理由である。さらに、これらのパケットのネットワーク上での送信は、帯域幅を使用するため、ICE エージェントによってレート制限される必要がある。RFC5245]の以前のドラフトバージョンに基づく展開では、ネットワークに悪影響を与えるだけでなく、レート制限のあるアクセスリンクに過負荷がかかり、全体的にパフォーマンスが低下する傾向がありました。その結果、ペーシングにより、NATデバイスが過負荷にならず、トラフィックが適切なレートに保たれるようになります。

妥当な」レートの定義は、データが流れ始めると、STUNはRTP自体が使用する帯域幅 よりも多くの帯域幅を使用してはならない、というものである。Taの計算式は、STUNパケットをTa秒ごとに送信した場合、すべてのデータスト リームを合計すると、RTPパケットと同じ量の帯域幅を消費するように設計されて いる。もちろん、STUNには再送信があり、これもペース配分することが望まれます。このため、RTOは、最初のトランザクションの最初の再送が、最後のトランザク ションの最初のSTUNリクエストの発生と同時に発生するように設定される。図解。

ファーストパケット再送信

                    | |
                    | |
             ------- + ------ ------- + ------
            / \ / \
           / \ / \
        
           +-+ +-+ +-+ +-+ +-+ +-+
           | A1 | | B1 | | C1 | | A2 | | B2 | | C2 |
           +-+ +-+ +-+ +-+ +-+ +-+
        
        --- + ------- + ------- + ------- + ------- + ------- + ------ ------時間
           0 Ta 2Ta 3Ta 4Ta 5Ta

この図では、送信されるトランザクションが3つある（たとえば、Candidate収集の場合、ホスト候補とSTUNサーバーのペアは3つある）。これらはトランザクションA、B、Cであり、最初のトランザクション（パケットA2）の最初の再送が時刻3Taに送信されるように再送タイマが設定されている。

STUNは再送に指数関数的なバックオフを使用するため、最初の再送の後の再送は、Taミリ秒間隔よりもさらに少ない頻度で発生します。

このグローバルな最小ペーシング間隔5msというメカニズムは、トランスポートプロトコルには一般的に適用できないが、以下の理由によってICEには適用できる。

o トランスポートプロトコルに一般的に適用されるであろう、以下のルールから始める。

1.MaxBytesを、[RFC6928]のセクション2で定義されているように、起動時にネットワークで未処理であることが許される最大バイト数（14600であるべき）とします。

2.HTOをトランザクションタイムアウトとする。これはRTTが既知の場合は2*RTT、それ以外は500msであるべきである。これは、[RFC5389]のSTUNメッセージのRTOと、[RFC6298]のTCP初期RTO(1秒)に基づいてい る。

3.トランザクション間の最小ペーシング間隔をMinPacingとすると、5msである（上記参照）。

o エージェントは通常、ICEトランザクション（特に接続性チェック）のRTTを知らないので、HTOはほとんど常に500ミリ秒になることを観察する。

o MinPacingが5ms、HTOが500msの場合、最大100パケット/HTOとなり、120バイト未満の典型的なICEチェックの場合、ネットワーク上の未処理バイトは最大12000バイトとなり、ルール1で示される最大値よりも少ないことを観察する。

o このように、ICEの場合、ルールセットはMinPacingルールだけになり、グローバルなTa値を持つことと同じになります。

B.2.複数のベースを持つCandidate
5.1.3項では、トランスポートアドレスとベースが同じ候補を排除することについて述べている。しかし、同じトランスポートアドレスでベースが異なる候補は、冗長ではない。ICEエージェントが、同じIPアドレスとポートを持つがベースが異なる2つの候補を持つことができるのは、どのような場合か。図11のトポロジーを考えてみましょう。

          + ---------- +
          | STUN Srvr |
          + ---------- +
               |
               |
             -----
           // \\
          | |
         | B：net10 |
          | |
           \\ //
             -----
               |
               |
          + ---------- +
          | NAT |
          + ---------- +
               |
               |
             -----
           // \\
          | A |
         | 192.168 / 16 |
          | |
           \\ //
             -----
               |
               |
               | 192.168.1.100 -----
          + ---------- + // \\ + ---------- +
          | | | | | |
          | イニシエーター| --------- | C：net10 | ----------- | Responderー|
          | | 10.0.1.100 | | 10.0.1.101 | |
          + ---------- + \\ // + ---------- +
                                   -----
図11：ベースが異なる同一候補の場合

この場合、initiating agentはマルチホームである。ネット10のプライベートネットワークであるネットワークCに、10.0.1.100という1つのIPアドレスを持っています。responding agentは、この同じネットワーク上にいます。initiating agentは、192.168/16のネットワークAにも接続されており、192.168.1.100のIPアドレスを持っています。このネットワークにはNATがあり、別のネット10プライベートネットワークであるネットワークBにNATしていますが、ネットワークCには接続されていません。

initiating agentは、ネットワークCのIPアドレスのホスト候補（10.0.1.100:2498）とネットワークAのIPアドレスのホスト候補（192.168.1.100:3344）を取得します。192.168.1.100:3344から設定されているSTUNサーバーにSTUNクエリーを実行する。このクエリはNATを通過し、たまたまバインディング10.0.1.100:2498を割り当てました。STUNサーバーはこれをSTUN Bindingレスポンスに反映させます。さて、initiating agentは、ホスト候補(10.0.1.100:2498)と同じトランスポートアドレスを持つサーバーリフレクティブ候補を取得した。ただし、サーバー反射候補のベースは192.168.1.100:3344であり、ホスト候補のベースは10.0.1.100:2498である。

B.3.Related-Address 属性及び Related-Port 属性の目的
candidate属性には、ICE自身では全く使用されない2つの値（related addressとrelated port）が含まれています。なぜこのような値があるのでしょうか？

その搭載の動機は2つあります。1つ目は、診断的なものです。異なるタイプの候補の間の関係を知ることは非常に有用である。これを含めることで、ICEエージェントは、どの中継候補がどの反射候補に関連付けられ、その反射候補が特定のホスト候補に関連付けされているかを知ることができる。ある候補のチェックは成功するが、他の候補のチェックは成功しない場合、これはネットワークで何が起こっているのかについて有用な診断を提供します。

2つ目の理由は、オフパスのQoS（Quality-of-Service）メカニズムに関係している。ICEがPacketCable 2.0のような環境で使用される場合、プロキシは通常のSIPオペレーションに加えて、SIPメッセージのSDPを検査し、データトラフィックのIPアドレスとポートを抽出します。そして、ポリシーサーバを介してネットワーク上のアクセスルータと対話し、データフローに対して保証されたQoSを確立することができます。このQoSは、RTPトラフィックを5タプルに基づき分類し、保証されたレートを提供したり、DSCPを適切にマークすることで提供されます。住宅用NATが存在し、中継候補がデータ用に選択された場合、この中継候補は、実際のTURNサーバー上のトランスポートアドレスになる。このアドレスは、QoS処理のためにパケットを分類するために使用されるであろうアクセスルーター内の実際のトランスポートアドレスについては何も語らない。むしろ、TURNサーバーに向けたサーバー反射的な候補が必要である。SDPで変換を運ぶことで、プロキシは、アクセスルータにQoSを要求するた めに、そのトランスポートアドレスを使用できる。

B.4.STUN Usernameの重要性
ICEは、短期クレデンシャル機能を使用したSTUNによるメッセージインテグリティの使用を要求する。実際の短期クレデンシャルは、候補交換でユーザー名の断片を交換することで形成される。このメカニズムの必要性は、単なるセキュリティにとどまらず、そもそもICEを正しく運用するために必要なものである。

LとRは、10.0.0.0/8を使用する私企業1に所属しています。Zは、同じく10.0.0.0/8を使用している私企業2内にいる。結局，RとZはともにIPアドレス10.0.1.1を持っている。LはZに候補を送り、Zはそのホスト候補をLに返信する。この場合、その候補は10.0.1.1:8866と10.0.1.1:8877である。結論から言うと、Rは同時刻にセッション中であり、10.0.1.1:8866 と 10.0.1.1:8877 をホスト候補として使用しています。つまり、RもZと同じように、これらのポートでSTUNメッセージを受け入れる用意があるのです。Lは10.0.1.1:8866と10.0.1.1:8877にSTUNリクエストを送信することになります。しかし、これらは予想通りZには行きません。代わりに、Rに行くのです!Rがそれらに返信した場合、LはZに接続していると考えるが、実際にはまったく別のユーザーであるRに接続している。これを解決するために、STUN短期クレデンシャル機構が使用される。ユーザー名の断片は十分にランダムであるため、RがZと同じ値を使用している可能性は極めて低い。要するに、STUNユーザー名断片は、候補交換の一部として確立された特定のセッションにバインドされた、一時的なホスト識別子の形式を提供する。

IPアドレスの非一意性の残念な結果は、上記の例では、RがICEエージェントでない可能性があることです。それは任意のホストであり、STUNパケットが向けられるポートは、そのホスト上の任意のエフェメラルポートである可能性があります。このソケットでパケットをリッスンしているアプリケーションがあり、そのアプリケーションが、使用されているプロトコルの不正なパケットを処理する準備ができていない場合、そのアプリケーションの動作に影響を与える可能性があります。幸い、交換されるポートは刹那的で、通常は動的または登録された範囲から選択されるため、そのポートはホストR上のサーバーを実行するために使用されているのではなく、何らかのプロトコルのエージェント側である可能性が高い。このため、この範囲のポート使用は一過性であるため、割り当てられたポートにヒットする確率は低下する。しかし、問題が発生する可能性は存在するため、ネットワーク導入者はそれに備える必要がある。これはICEに限った問題ではなく、どのようなプロトコルでも、特にパブリックインターネット上では、いつでも迷子のパケットがポートに到達する可能性があることに注意してください。そのため、この要件は、インターネットアプリケーションの一般的な設計ガイドラインを再掲しているに過ぎない--どのポートでも未知のパケットに備えられるように。

B.5.候補ペアの優先順位式
候補ペアの優先順位は、奇妙な形をしています。それは

      ペア優先度 = 2^32*MIN(G,D) + 2*MAX(G,D) + (G>D?1:0)        
これはなぜか？候補となるペアをこの値に基づいてソートすると、結果としてMAX/MINの特性を持つソートになります。つまり、ペアはまず2つの優先順位のうち最小値の減少に基づきソートされます。優先順位の最小値が同じペアについては、優先順位の最大値でソートされます。最大と最小の優先順位が同じであれば、制御エージェントの優先順位が式の最後の部分でタイブレーカーとして使用されます。1つの候補の優先順位は常に2*32より小さいので、2*32の係数が使用され、その結果、ペアの優先順位は2つの構成要素の優先順位の「連結」となる。これにより、MAX/MINソートが作成されます。MAX/MINは、特定のICEエージェントに対して、優先度の高い候補がすべて試されるまで、優先度の低い候補が使われることがないようにします。

B.6.なぜキープアライブが必要なのか？
候補ペア上でデータの流れが始まると、セッションの期間中、中間NATでバインディ ングを維持する必要がある。通常、データストリームパケット自体(たとえば、RTP)がこの目的に適う。ただし、いくつかのケースについては、さらに検討する必要がある。まず、SIPなどの一部のRTP使用では、データストリームを「保留」にすること ができる。これは、RFC 3264 [RFC3264]で定義されているように、SDPの「sendonly」または「inactive」属性 を使用することで実現できる。RFC 3264は、このような場合、データの送信を停止するよう実装に指示し ている。ただし、これを実行すると、NATバインディングがタイムアウトになり、 データが保留から外れる可能性がある。

第二に、テキスト会話用のペイロードフォーマット[RFC4103]など、一部のRTPペイロードフォーマットは、間隔がNATバインディングのタイムアウトを超えるほど頻繁にパケットを送信することがあります。

第三に、無音化機能を使用した場合、無音時間が長いと、NATバインディングがタイムアウトするほどデータ転送が停止することがあります。

これらの理由から、データパケットそのものに依存することはできない。ICEは、STUN Binding Indicationsを利用したシンプルな定期的キープアライブを定義しています。これにより、ICEの帯域幅要件は非常に予測しやすくなり、QoS予約に対応できるようになります。

B.7.なぜピアリフレ候補を優先するのか？
5.1.2節では、候補のタイプおよびローカルプリファレンスに基づいて候補の優先度を計算する手順について説明します。その節では、ピアリフレクティブ候補のタイププリファレンスは常にサーバリフレクティブより高くすることを要求しています。それはなぜか？その理由は、セクション19のセキュリティに関する考察と関係があります。攻撃者がICEエージェントに偽のサーバーリフレクティブ候補を使用させるのは、偽のピアリフレクティブ候補よりもはるかに簡単です。その結果、Bindingリクエストによるアドレス収集に対する攻撃は、 ICEがpeer-reflexive候補を優先することによって阻止される。

B.8.なぜキープアライブにバインディング・インジケータが使われるのか？
データキープアライブはセクション11で説明される。これらのキープアライブは、両方のエンドポイントがICE可能な場合、STUNを使用する。しかし、Bindingリクエストトランザクション(これは応答を生成する)を使用するのでは なく、keepalivesはIndicationを使用する。それはなぜか？

その主な理由は、ネットワークのQoSメカニズムに関係しています。データが流れ始めると、ネットワーク要素は、データストリームがかなり規則的な構造を持ち、一定の間隔で周期的なパケットを使用し、ジッターが発生する可能性があると仮定します。ICEエージェントがデータパケットを送信しているときにBindingリクエストを受信した場合、データパケットと一緒に応答パケットを生成する必要があります。これにより、データパケットを運ぶ5タプルの実際の帯域幅要件が増加し、これらのパケットの配信にジッターが発生します。分析によると、これはデータ用にかなり厳しいパケットスケジューラを使用している特定のレイヤー2アクセスネットワークで懸念されることが示されている。

さらに、バインディングインジケーションを使用することで、整合性を無効にすることができ、より良いパフォーマンスを得ることができます。これは、公衆交換電話網（PSTN）ゲートウェイやセッションボーダーコントローラー（SBC）など、大規模なエンドポイントに有効です。

B.9.Candidateタイプの優先順位を選択する
タイプやローカルプリファレンス値を選択する基準の1つは、TURNサーバー、VPNサーバーなどのトンネルサービス、NATなどのデータ仲介の使用である。データ仲介を利用すると、データがその候補に送信された場合、受信する前にまずデータ仲介を通過することになる。データ仲介を伴う候補の1つに、中継候補があります。もう一つのタイプは、VPNインターフェースから得られるホスト候補である。データがデータ仲介者を経由する場合、送信と受信の間の待ち時間にプラスまたはマイナスの影響を与えることがあります。ルーターのホップ数が増えるため、パケットロスが増えることもあれば、増えないこともある。プロバイダーが運営するデータ中継施設にデータが転送され、そこから戻ってくるため、サービス提供のコストが増加する可能性があります。これらの懸念が重要である場合、中継候補のタイプの優先順位を慎重に選択する必要がある。

プリファレンスを選択するもう一つの基準は、IPアドレスファミリーです。ICEはIPv4とIPv6の両方で動作する。ICEはデュアルスタックホストがIPv6での接続を好むが、v6ネットワークが切断された場合にIPv4にフォールバックすることを可能にする移行メカニズムを提供します。実装は[RFC8421]のガイドラインに従うべきで、壊れたパスが存在する場合に接続性チェックフェーズの過剰な遅延を回避する。

もう一つの選択基準は、トポロジーを意識することです。これは、仲介者を利用する候補に有益である。このような場合、ICEエージェントが、仲介者のトポロジカルな近さに関する知識を事前に設定または動的に発見していれば、それを利用して、より近い仲介者から得られた候補に高いローカルな優先度を割り当てることができる。

プリファレンスを選択するもう一つの基準は、セキュリティやプライバシーかもしれません。あるユーザーが在宅勤務者であり、企業ネットワークとローカルのホームネットワークに接続している場合、ユーザーは、企業内で通信するときは企業ネットワーク上に音声トラフィックを維持し、企業外のユーザーと通信するときはローカルネットワークを使用するために、VPNまたは同様のトンネルを介してルーティングされることを好むかもしれません。このような場合、VPNアドレスは、他のどのアドレスよりも高いローカルプリファレンスを持つことになります。

付録C．接続性-帯域幅の確認
以下の表は、IPv4とIPv6について、異なるTa値（ms単位）と異なるufragサイズ（byte単位）を使用して、接続性チェックを実行するために必要な帯域幅を示したものです。

この結果は、2016年4月11日にJusin Uberti（Google）より提供されました。

                     IPバージョン：IPv4
                     パケット長（バイト）：108 + ufrag
                          |
                       ms | 4 8 12 16
                     ----- | ------------------------
                      500 | 1.86k 1.98k 2.11k 2.24k
                      200 | 4.64k 4.96k 5.28k 5.6k
                      100 | 9.28k 9.92k 10.6k 11.2k
                       50 | 18.6k 19.8k 21.1k 22.4k
                       20 | 46.4k 49.6k 52.8k 56.0k
                       10 | 92.8k 99.2k 105k 112k
                        5 | 185k 198k 211k 224k
                        2 | 464k 496k 528k 560k
                        1 | 928k 992k 1.06M 1.12M
        
                     IPバージョン：IPv6
                     パケット長（バイト）：128 + ufrag
                          |
                       ms | 4 8 12 16
                     ----- | ------------------------
                      500 | 2.18k 2.3k 2.43k 2.56k
                      200 | 5.44k 5.76k 6.08k 6.4k
                      100 | 10.9k 11.5k 12.2k 12.8k
                       50 | 21.8k 23.0k 24.3k 25.6k
                       20 | 54.4k 57.6k 60.8k 64.0k
                       10 | 108k 115k 121k 128k
                        5 | 217k 230k 243k 256k
                        2 | 544k 576k 608k 640k
                        1 | 1.09M 1.15M 1.22M 1.28M  
図12：接続性-帯域幅の確認

謝辞

この文書のテキストのほとんどは、オリジナルのICE仕様であるRFC 5245に由来しています。著者は、その文書に貢献したすべての人に感謝したい。この仕様の改訂への追加的な貢献として、Emil Ivov、Paul Kyzivat、Pal-Erik Martinsen、Simon Perrault、Eric Rescorla、Thomas Stach、Peter Thatcher、Martin Thomson、Justin Uberti、Suhas Nandakumar、 Taylor Brandsteter、 Peter Saint-Andre、 Harald Alvestrand、および Roman Shpountに感謝したい。Ben CampbellはADレビューを担当した。Stephen Farrellがsec-dirのレビューを担当しました。Stewart BryantがGen-artレビューを担当した。Qin WeがOps-Dirのレビューを行った。Magnus Westerlundがtsv-artのレビューを行いました。

著者の住所

Ari Keranen Ericsson Hirsalantie 11 02420 Jorvas フィンランド

   メール： ari.keranen@ericsson.com        
Christer Holmberg Ericsson Hirsalantie 11 02420 Jorvas フィンランド

   メール： christer.holmberg@ericsson.com        
Jonathan Rosenberg jdrosen.net Monmouth, NJ United States of America.

   メール：jdrosen@jdrosen.net URI：http://www.jdrosen.net        